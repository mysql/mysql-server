#
# The intent of this test is to verify if the validations that were
# created within the Group Replication plugin in the runtime process
# are fully functional.
#
# It will test the invalid scenarios:
# - Table with no primary key
# - Table with no transactional engine
# - Table without both
#
# It will cycle all cases in which the runtime validation is verified.
#
# Afterwards the plugin will be stopped and one of the cases will be tested in
# order to assess that the verification is no longer accomplished.
#
# One will test in a valid table that dynamic variables that can change in
# runtime will also cause a failure in validation if they have incorrect values.
#

--source include/have_group_replication_plugin.inc

--let $group_replication_group_name= 36236980-4307-11e4-916c-0800200c9a67
--source include/start_group_replication.inc

#Lets create several tables. They will all breach 1 or more rules

#Wrong table without Primary Key
CREATE TABLE t1 (c1 char(50)) ENGINE=InnoDB;

#Wrong table without Transactional engine
CREATE TABLE t2 (c1 char(50) NOT NULL PRIMARY KEY) ENGINE=MyISAM;

#Wrong table with both criteria
CREATE TABLE t3 (c1 char(50)) ENGINE=MyISAM;

#Auxiliary test table
CREATE TABLE tn (cn char(50) NOT NULL PRIMARY KEY) ENGINE=InnoDB;

#
# The tests begin here.
#
# The use cases to test are the following:
# - SQLCOM_UPDATE
# - SQLCOM_INSERT
# - SQLCOM_INSERT_SELECT
# - SQLCOM_DELETE
# - SQLCOM_LOAD
# - SQLCOM_REPLACE
# - SQLCOM_REPLACE_SELECT
# - SQLCOM_DELETE_MULTI
# - SQLCOM_UPDATE_MULTI
#

--echo #
--echo # Testing all tables that will fail.
--echo #

--let $wrong_tables_count=3
while ($wrong_tables_count)
{
   #Test the INSERT instruction
   --error ER_BEFORE_DML_VALIDATION_ERROR
   --eval INSERT INTO t$wrong_tables_count VALUES('a')

  #Test the UPDATE instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval UPDATE t$wrong_tables_count SET c1 = 'a'

  #Test the INSERT...SELECT instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval INSERT INTO t$wrong_tables_count (c1) SELECT tn.cn FROM tn

  #Test the DELETE instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval DELETE FROM t$wrong_tables_count

  #Test the load instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval LOAD DATA INFILE '../../std_data/words.dat' INTO TABLE t$wrong_tables_count

  #Test the REPLACE instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval REPLACE INTO t$wrong_tables_count(c1) VALUES('a')

  #Test the REPLACE...SELECT instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval REPLACE INTO t$wrong_tables_count (c1) SELECT tn.cn FROM tn

  #Test the DELETE_MULTI instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval DELETE t$wrong_tables_count, tn FROM t$wrong_tables_count, tn

  #Test the UPDATE_MULTI instruction
  --error ER_BEFORE_DML_VALIDATION_ERROR
  --eval UPDATE t$wrong_tables_count, tn SET c1 = 'a'

  #clean up this table
  --eval DROP TABLE t$wrong_tables_count

  --dec $wrong_tables_count
}

--echo #
--echo # Lets test the global variables that might change in
--echo # runtime and which values are not allowed.
--echo #

#Test the value of binlog checksum.

--let $binlog_checksum_backup= `SELECT @@GLOBAL.binlog_checksum;`
SET GLOBAL binlog_checksum= CRC32;

--error ER_BEFORE_DML_VALIDATION_ERROR
INSERT INTO tn VALUES ('a');

--eval SET GLOBAL binlog_checksum= $binlog_checksum_backup

#Test the value of binlog format.

--let $binlog_format_backup= `SELECT @@GLOBAL.binlog_format`

SET SESSION binlog_format= STATEMENT;

--error ER_BEFORE_DML_VALIDATION_ERROR
INSERT INTO tn VALUES ('a');

--eval SET SESSION binlog_format= $binlog_format_backup

#Test the value of transaction_write_set_extraction.

--let $transaction_write_set_extraction_backup= `SELECT @@GLOBAL.transaction_write_set_extraction`

SET SESSION transaction_write_set_extraction=OFF;

--error ER_BEFORE_DML_VALIDATION_ERROR
INSERT INTO tn VALUES ('a');

--eval SET SESSION transaction_write_set_extraction= $transaction_write_set_extraction_backup

--echo #
--echo # Now, lets repeat all the tests with group replication stopped.
--echo # They all must succeed or fail with other errors that not the
--echo # ones from validation.
--echo #
--echo # It will be a single table simpler test just to assess that the
--echo # hook is not longer active.
--echo #
STOP GROUP_REPLICATION;

#Wrong table without Primary Key
CREATE TABLE t1 (c1 char(50)) ENGINE=InnoDB;

#Test the UPDATE instruction
--eval UPDATE t1 SET c1 = 'a'

#Test the INSERT instruction
--eval INSERT INTO t1 VALUES('a')

#Test the INSERT...SELECT instruction
--eval INSERT INTO t1 (c1) SELECT tn.cn FROM tn

#Test the DELETE instruction
--eval DELETE FROM t1

#Test the load instruction
--eval LOAD DATA INFILE '../../std_data/words2.dat' INTO TABLE t1

#Test the REPLACE instruction
--eval REPLACE INTO t1(c1) VALUES('a')

#Test the REPLACE...SELECT instruction
--eval REPLACE INTO t1 (c1) SELECT tn.cn FROM tn

#Test the DELETE_MULTI instruction
--eval DELETE t1, tn FROM t1, tn

#Test the UPDATE_MULTI instruction
--eval UPDATE t1, tn SET c1 = 'a'

#clean up
DROP TABLE t1, tn;

call mtr.add_suppression("Table.*is not transactional. This is not compatible with Group Replication");
call mtr.add_suppression("Table.*does not have any PRIMARY KEY. This is not compatible with Group Replication");
call mtr.add_suppression("Binlog checksum should be OFF for Group Replication");
call mtr.add_suppression("Binlog format should be ROW for Group Replication");
call mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT");
call mtr.add_suppression("transaction_write_set_extraction should be MURMUR32 for Group Replication");
