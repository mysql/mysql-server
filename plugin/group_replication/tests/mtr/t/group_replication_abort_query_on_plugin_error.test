# This test proves that no query can be executed when the plugin is active but
# in an error state.
# The test induces such a state by causing a recovery failure on server 2.
# Not being able to recover due to an invalid recovery user, the server stays in
# an error state where no transactions can be executed.
# For the test about recovery connection errors go to:
#   group_replication_recovery_connection_options.test
################################################################################

--source include/have_group_replication_plugin.inc
--let $group_replication_group_name= a1e87f30-b156-11e4-ab27-0800200c9a66
--let $rpl_skip_group_replication_start= 1
--source include/master-slave.inc

--echo #######################
--echo # Start a 2 server group

--connection server1
--echo server1
--source include/start_group_replication.inc

CREATE TABLE t1 (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY , b INT);

--connection server2
--echo server2
--source include/start_group_replication.inc


--echo
--echo #####################################################################
--echo # Restart group replication on server 2 inducing a failure on recovery

--source include/stop_group_replication.inc

set session sql_log_bin=0;
call mtr.add_suppression("There was an error when connecting to the donor*");
call mtr.add_suppression("Maximum number of retries when*");
call mtr.add_suppression("Fatal error during the Recovery process of Group Replication.*");
call mtr.add_suppression("Transaction cannot be executed while Group Replication is OFFLINE.*");
call mtr.add_suppression("Run function 'before_commit' in plugin 'group_replication' failed");
set session sql_log_bin=1;

SET @configured_rec_user= @@GLOBAL.group_replication_recovery_user;
SET GLOBAL group_replication_recovery_user= "dummy_user";

--eval SET GLOBAL group_replication_group_name= "$group_replication_group_name"
START GROUP_REPLICATION;

--echo
--echo ##########################################################
--echo # Recovery should fail and the server should become OFFLINE

--let $group_replication_member_state= OFFLINE
--source ../inc/group_replication_wait_for_member_state.inc


--echo
--echo ###################################################################
--echo # When we try to execute a transaction on the server, it should fail

--error ER_RUN_HOOK_ERROR
INSERT INTO test.t1 (b) VALUES (1);

--echo
--echo ##########################################
--echo # Solve the issue and re-execute the query

--source include/stop_group_replication.inc

SET @@GLOBAL.group_replication_recovery_user= @configured_rec_user;

--source include/start_group_replication.inc

INSERT INTO test.t1 (b) VALUES (1);

--source include/rpl_sync.inc

--echo
--echo #######################################################################
--echo # Assert that server1 and server2 have the same data and GTID_EXECUTED.

--connection server1
--echo server1
--let $assert_text= 'There is a value 1 in table t1 on server1'
--let $assert_cond= [SELECT COUNT(*) AS count FROM t1, count, 1] = 1
--source include/assert.inc

--connection server2
--echo server2
--let $assert_text= 'There is a value 1 in table t1 on server2'
--let $assert_cond= [SELECT COUNT(*) AS count FROM t1, count, 1] = 1
--source include/assert.inc

--connection server1
--echo server1
--let $server1_gtid_executed= `SELECT @@GLOBAL.GTID_EXECUTED`
--connection server2
--echo server2
--let $server2_gtid_executed= `SELECT @@GLOBAL.GTID_EXECUTED`
--let $assert_text= 'server1 and server2 GTID_EXECUTED must be equal'
--let $assert_cond= "$server1_gtid_executed" = "$server2_gtid_executed"
--source include/assert.inc

--echo
--echo #########
--echo # Cleanup

DROP TABLE test.t1;

--source include/rpl_end.inc

