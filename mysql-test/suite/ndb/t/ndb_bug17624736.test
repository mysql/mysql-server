--source include/have_ndb.inc
--source suite/ndb/include/backup_restore_setup.inc

#
# NOTE! This test restarts the data nodes with the special parameter
# __at_restart_skip_indexes which causes indexes to be skipped during restart.
#

# Ignore the warning generated by ndbcluster's binlog thread
# when cluster is restarted
--disable_query_log
call mtr.add_suppression("cluster disconnect An incident event has been written");
# These failures occurs when NDB is restarted without indexes
call mtr.add_suppression("Failed to setup PRIMARY index of ndb_sql_metadata");
call mtr.add_suppression("stored grants: not initialized.");
call mtr.add_suppression("stored grants: failed to apply stored grants.");
--enable_query_log

# Ignore the warning generated by ndbcluster's binlog thread
# when cluster is restarted - also on the second mysqld
connect(mysqld2,127.0.0.1,root,,test,$MASTER_MYPORT1);
connection mysqld2;
--disable_query_log
call mtr.add_suppression("cluster disconnect An incident event has been written");
# These failures occurs when NDB is restarted without indexes
call mtr.add_suppression("Failed to setup PRIMARY index of ndb_sql_metadata");
call mtr.add_suppression("stored grants: not initialized.");
call mtr.add_suppression("stored grants: failed to apply stored grants.");
--enable_query_log

connection default;

# Create view which displays all NDB objects type and name.
--disable_query_log ONCE
CREATE VIEW ndb_objects AS
  SELECT
    t.type_name as type,
    /* Return everything after last slash as name */
    SUBSTRING_INDEX(i.fq_name, "/", -1) AS name
  FROM ndbinfo.dict_obj_info AS i
  JOIN ndbinfo.dict_obj_types AS t ON i.type = t.type_id;

let $qry =
select type,name from ndb_objects
where (type like '%Index%' or type like '%Foreign key def%')
and (name like '%t1%' or name like '%t2%')
order by name;

let $cre1 =
create table t1 (
  a int not null,
  b int not null,
  unique key t1x1 (b) using hash,
  primary key using hash (a)
) engine=ndb;

let $cre2 =
create table t2 (
  a int not null,
  b int not null,
  key t2x1 (b),
  primary key using hash (a),
  constraint t2fk1 foreign key (b) references t1 (b)
) engine=ndb;

--eval $cre1
--eval $cre2

--echo Expect fk and indexes to exist
--disable_query_log ONCE
--eval $qry

insert into t1 values (1,10),(2,20),(3,30),(4,40),(5,50);
insert into t2 values (1,10),(2,10),(3,30),(4,50),(5,50);

select * from t1 where b = 10 order by a;
select * from t2 where b = 10 order by a;

--echo # run restart skip indexes

--exec $NDB_MGM -e "all restart -n" >> $NDB_TOOLS_OUTPUT
--exec $NDB_WAITER --not-started >> $NDB_TOOLS_OUTPUT
--exec $NDB_MGM -e "all start" >> $NDB_TOOLS_OUTPUT
--exec $NDB_WAITER >> $NDB_TOOLS_OUTPUT

# Wait for MySQL Server reconnect after cluster restart
--source include/ndb_not_readonly.inc

--echo Expect neither fk or indexes since restart was without indexes
--disable_query_log ONCE
--eval $qry

# FRM is wrong so SQL level fails (drop works)
# verify that SQL level can be fixed via BACKUP

--echo # run backup
--source include/ndb_backup.inc

--echo # create empty schema
drop table t2, t1;
--eval $cre1
--eval $cre2

--echo Expect fk and indexes to exist again
--disable_query_log ONCE
--eval $qry

--echo # run restore
--exec $NDB_RESTORE -b $the_backup_id -n 1 -r $NDB_BACKUPS-$the_backup_id >> $NDB_TOOLS_OUTPUT
--exec $NDB_RESTORE -b $the_backup_id -n 2 -r $NDB_BACKUPS-$the_backup_id >> $NDB_TOOLS_OUTPUT

select * from t1 where b = 10 order by a;
select * from t2 where b = 10 order by a;

drop table t2, t1;
--source suite/ndb/include/backup_restore_cleanup.inc
--remove_file $NDB_TOOLS_OUTPUT

--disable_query_log ONCE
DROP VIEW ndb_objects;
