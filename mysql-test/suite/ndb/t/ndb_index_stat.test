-- source include/have_ndb.inc

# Notes on index stats in *.test.
#
# Most tables here have few table rows.  Index stats are not very
# useful in such cases but the optimizer seems to use them anyway.
# One reason may be that nested joins is only join method.
#
# In real production index stats are computed daily or weekly.
# But tests here must compute them at once if "explain" is used.
# Thus: insert (or other dml) - analyze table - explain.
#
# Index stats are approximate since only one replica was scanned
# and values are interpolated from samples.  MTR however should be
# deterministic.  If not use --replace column 9 # (rows).

--disable_warnings
DROP TABLE IF EXISTS t1, t2;
--enable_warnings

set @is_enable_default = @@global.ndb_index_stat_enable;

set @is_enable = 1;
source ndb_index_stat_enable.inc;

# test changing suboptions
show global variables like 'ndb_index_stat_option';
set @save_option = @@global.ndb_index_stat_option;
# some options
set @@global.ndb_index_stat_option = 'loop_idle=3333,cache_limit=44M';
set @@global.ndb_index_stat_option = 'cache_lowpct=85,evict_delay=55';
set @@global.ndb_index_stat_option = 'check_delay=234s';
show global variables like 'ndb_index_stat_option';
set @@global.ndb_index_stat_option = @save_option;
show global variables like 'ndb_index_stat_option';

# TEST: main
create table t1 (
  a1 int unsigned not null,
  b1 int unsigned not null,
  c1 int unsigned not null,
  primary key (a1),
  index b1x (b1),
  index c1x (c1)
) engine=ndb;

create table t2 (
  a2 int unsigned not null,
  b2 int unsigned not null,
  c2 int unsigned not null,
  primary key (a2),
  index b2x (b2),
  index c2x (c2)
) engine=ndb;

# enough rows to make index stats more approximate

--disable_query_log
let $i = 1000;
while ($i)
{
  dec $i;
  eval insert into t1 values ($i, $i % 100, $i % 10);
}
let $i = 1000;
while ($i)
{
  dec $i;
  eval insert into t2 values ($i, $i % 10, $i % 100);
}
--enable_query_log
analyze table t1, t2;

# TEST: key equal constant

--echo # must use b1x
--replace_column 9 #
explain select * from t1
  where b1 = 5 and c1 = 5;

--echo # must use c2x
--replace_column 9 #
explain select * from t2
  where b2 = 5 and c2 = 5;

# TEST: keys equal constant in join

--echo # must use b1x, c2x
--replace_column 9 #
explain select * from t1, t2
  where c1 = c2 and b1 = 5 and b2 = 5;

--echo # must use c2x, b1x
--replace_column 9 #
explain select * from t1, t2
  where b1 = b2 and c1 = 5 and c2 = 5;

# TEST: join via keys of different selectivity

--echo # must use t1, c2x
--replace_column 9 #
explain select * from t1, t2
  where c1 = c2;
--echo # must use t2, b1x
--replace_column 9 #
explain select * from t1, t2
  where b1 = b2;

# TEST: bug#44760 quick distinct
# QUICK_GROUP_MIN_MAX_SELECT says "Using index for group-by".
# Should happen only for low cardinality index.
# wl4124_todo: result is wrong until HA_KEYREAD_ONLY is set

--echo # should NOT say: Using index for group-by
--replace_column 9 #
explain select distinct (a1) from t1;

--echo # must say: Using index for group by
--replace_column 9 #
explain select distinct (b1) from t1;

--echo # must say: Using index for group by
--replace_column 9 #
explain select distinct (c1) from t1;

# TEST: end
drop table t1, t2;

# turn index stats OFF in client (falls back on other methods)
# code snippet moved from ndb_index_ordered.test

create table t1 (a int, b int, c varchar(10) not null,
  primary key using hash (a), index(b,c)) engine=ndb;
insert into t1 values
  (1,10,'aaa'),(2,10,'bbb'),(3,10,'ccc'),
  (4,20,'aaa'),(5,20,'bbb'),(6,20,'ccc'),
  (7,30,'aaa'),(8,30,'bbb'),(9,30,'ccc');
analyze table t1;
let $is_loop = 4;
while ($is_loop)
{
  # 4-OFF 3-ON 2-OFF 1-ON
  let $is_enable = `select ($is_loop=3 or $is_loop=1)`;
  dec $is_loop;
  eval set @@local.ndb_index_stat_enable = $is_enable;

select count(*) from t1 where b < 10;
select count(*) from t1 where b >= 10 and c >= 'bbb';
select count(*) from t1 where b > 10;
select count(*) from t1 where b <= 20 and c < 'ccc';
select count(*) from t1 where b = 20 and c = 'ccc';
select count(*) from t1 where b > 20;
select count(*) from t1 where b = 30 and c > 'aaa';
select count(*) from t1 where b <= 20;
select count(*) from t1 where b >= 20 and c > 'aaa';
}
drop table t1;

# bug#XXXXX
# autocreate=false,enable=1 is now acceptable
# following hangs for error_delay (60s) if "no stats" is counted as error
create table t1 (a int, b int, primary key using hash (a), index x1 (b))
engine=ndb;
insert into t1 values (1,11),(2,22),(3,33);
# make_join_statistics() -> info() -> ndb_index_stat_set_rpk()
select * from t1 order by a;
# index stat entry would now wait 60s on error list
analyze table t1;
drop table t1;

set @is_enable = @is_enable_default;
source ndb_index_stat_enable.inc;
