--source include/have_ndb.inc
--source suite/ndb/include/ndb_find_import_tool.inc

--echo # manual ndb_import tests

--let $is_windows= `select convert(@@version_compile_os using latin1) in ('Win32', 'Win64', 'Windows')`

--echo # database argument is required
--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     >> $NDB_TOOLS_OUTPUT 2>&1;

--echo # no args is ok
--error 0
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     test >> $NDB_TOOLS_OUTPUT 2>&1;

--echo # table does not exist
--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     test '/foo/data/t1.csv' >> $NDB_TOOLS_OUTPUT 2>&1;

create table t1 (
  a int primary key,
  b int
) engine=ndb;

--echo # csv file does not exist
--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     test '/foo/data/t1.csv' >> $NDB_TOOLS_OUTPUT 2>&1;

perl;
use strict;
use Symbol;
my $vardir = $ENV{MYSQLTEST_VARDIR}
  or die "need MYSQLTEST_VARDIR";
my $file = "$vardir/tmp/t1.csv";
my $fh = gensym();
open($fh, ">:raw", $file)
  or die "$file: open for write failed: $!";
for my $i (0..999) {
  print $fh $i, "\t", $i*10, "\n";
}
close($fh)
  or die "$file: close after write failed: $!";
exit(0)
EOF

--echo # bad state dir
--error 1
exec $NDB_IMPORT --state-dir=/foo/state --keep-state --verbose=1
     test $MYSQLTEST_VARDIR/tmp/t1.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--echo # normal import
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     --input-type=csv --output-type=ndb
     test $MYSQLTEST_VARDIR/tmp/t1.csv >> $NDB_TOOLS_OUTPUT 2>&1;
select count(*) from t1;

--echo # invalid --input-type
--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     --input-type=xxx --output-type=ndb
     test $MYSQLTEST_VARDIR/tmp/t1.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--echo # invalid --output-type
--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     --input-type=csv --output-type=xxx
     test $MYSQLTEST_VARDIR/tmp/t1.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--echo # simple utf8 test

perl;
use strict;
use Symbol;
my $vardir = $ENV{MYSQLTEST_VARDIR}
  or die "need MYSQLTEST_VARDIR";
my $file = "$vardir/tmp/t2.csv";
my $fh = gensym();
open($fh, ">:raw:utf8", $file)
  or die "$file: open for write failed: $!";
my $c1 = chr(0x00e4);
my $c2 = chr(0x263a);
my $c3 = chr(0x2665);
print $fh 0, "\t", '\N', "\n";
print $fh 1, "\t", $c1, "\n";
print $fh 2, "\t", $c1, $c2, "\n";
print $fh 3, "\t", $c1, $c2, $c3, "\n";
close($fh)
  or die "$file: close after write failed: $!";
exit(0);
EOF

create table t2 (
  a int primary key,
  b char(3)
) charset utf8
  engine=ndb;

create table t2ver (
  a int primary key,
  b char(3)
) charset utf8
  engine=ndb;

exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     test $MYSQLTEST_VARDIR/tmp/t2.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--disable_query_log
eval load data infile '$MYSQLTEST_VARDIR/tmp/t2.csv'
into table t2ver
character set utf8;
--enable_query_log

select count(*) from t2 x, t2ver y
where x.a = y.a
and (x.b = y.b or (x.b is null and y.b is null));

# to check result diff
--disable_query_log
eval select * from t2 order by a
  into outfile '$MYSQLTEST_VARDIR/tmp/t2.out'
  charset utf8;
eval select * from t2ver order by a
  into outfile '$MYSQLTEST_VARDIR/tmp/t2ver.out'
  charset utf8;
--enable_query_log

--echo # simple hidden-pk test

perl;
use strict;
use Symbol;
my $vardir = $ENV{MYSQLTEST_VARDIR}
  or die "need MYSQLTEST_VARDIR";
my $file = "$vardir/tmp/t3.csv";
my $fh = gensym();
open($fh, ">:raw", $file)
  or die "$file: open for write failed: $!";
for my $i (1..1000) {
  print $fh 10*$i, "\n";
}
close($fh)
  or die "$file: close after write failed: $!";
exit(0);
EOF

create table t3 (
  b int not null,
  # unique key would turn into pk
  key bx (b)
) engine=ndb;

create table t3ver like t3;

exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --keep-state --verbose=1
     test $MYSQLTEST_VARDIR/tmp/t3.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--disable_query_log
eval load data infile '$MYSQLTEST_VARDIR/tmp/t3.csv'
into table t3ver;
--enable_query_log

select count(*) from t3;
select count(*) from t3ver;

select count(*) from t3 x, t3ver y
where x.b = y.b;

--echo # test with rejects and no --keep-state

perl;
use strict;
use Symbol;
my $vardir = $ENV{MYSQLTEST_VARDIR}
  or die "need MYSQLTEST_VARDIR";
my $file = "$vardir/tmp/t4.csv";
my $fh = gensym();
open($fh, ">:raw", $file)
  or die "$file: open for write failed: $!";
for my $i (0..999) {
  if ($i == 333) {
    print $fh $i, "\t", $i*10, "\t", 333, "\n";
  } elsif ($i == 666) {
    print $fh 111, "\t", $i*10, "\n";
  } elsif ($i == 999) {
    print $fh $i, "\t", "abcde", "\n";
  } else {
    print $fh $i, "\t", $i*10, "\n";
  }
}
close($fh)
  or die "$file: close after write failed: $!";
exit(0)
EOF

create table t4 (
  a int primary key,
  b int not null
) engine=ndb;

exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --rejects=3
     test $MYSQLTEST_VARDIR/tmp/t4.csv >> $NDB_TOOLS_OUTPUT 2>&1;
select count(*) from t4;

--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/t4.res
--error 0
--file_exists $MYSQLTEST_VARDIR/tmp/t4.rej
--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/t4.map
--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/t4.stt

--echo # test with rejects and --stats

delete from t4;

exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --rejects=3 --stats
     test $MYSQLTEST_VARDIR/tmp/t4.csv >> $NDB_TOOLS_OUTPUT 2>&1;
select count(*) from t4;

--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/t4.res
--error 0
--file_exists $MYSQLTEST_VARDIR/tmp/t4.rej
--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/t4.map
--error 0
--file_exists $MYSQLTEST_VARDIR/tmp/t4.stt

--echo # test --continue option with missing table

create table t5a (a int primary key) engine=ndb;
create table t5c like t5a;

write_file $MYSQLTEST_VARDIR/tmp/t5a.csv;
111
222
EOF

write_file $MYSQLTEST_VARDIR/tmp/t5b.csv;
111
111
EOF

write_file $MYSQLTEST_VARDIR/tmp/t5c.csv;
111
222
EOF

--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --continue
     test
     $MYSQLTEST_VARDIR/tmp/t5a.csv
     $MYSQLTEST_VARDIR/tmp/t5b.csv
     $MYSQLTEST_VARDIR/tmp/t5c.csv >> $NDB_TOOLS_OUTPUT 2>&1;
select count(*) from t5a;
select count(*) from t5c;

--echo # test --continue option with rejects

delete from t5a;
delete from t5c;
create table t5b like t5a;

--error 1
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --continue
     test
     $MYSQLTEST_VARDIR/tmp/t5a.csv
     $MYSQLTEST_VARDIR/tmp/t5b.csv
     $MYSQLTEST_VARDIR/tmp/t5c.csv >> $NDB_TOOLS_OUTPUT 2>&1;
select count(*) from t5a;
select count(*) from t5b;
select count(*) from t5c;

--echo # test quoting and escapes

create table t6 (
  a int primary key,
  b char(5) not null
) engine=ndb;

create table t6ver like t6;

write_file $MYSQLTEST_VARDIR/tmp/t6.csv;
1,abc
2,"abc"
3,"a""bc"
4,\\\"\\
5,"\\\"\\"
6,\0\b\r\n\t
7,"\0\b\r\n\t"
EOF

--error 0
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --csvopt=cq
     test $MYSQLTEST_VARDIR/tmp/t6.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--disable_query_log
eval load data infile '$MYSQLTEST_VARDIR/tmp/t6.csv'
into table t6ver
fields terminated by ',' enclosed by '"' escaped by '\\\\'
lines terminated by '\n';
--enable_query_log

select count(*) from t6 x, t6ver y
where x.a = y.a and x.b = y.b;

select a from t6
where b like '%"%'
order by a;

--echo # test CR-LF line terminator

perl;
use strict;
use Symbol;
my $vardir = $ENV{MYSQLTEST_VARDIR}
  or die "need MYSQLTEST_VARDIR";
my $file = "$vardir/tmp/t7.csv";
my $fh = gensym();
open($fh, ">:raw", $file)
  or die "$file: open for write failed: $!";
for my $i (1..1000) {
  my $s;
  if (int(rand(5)) == 0) {
    $s = "\\N";
  } else {
    my $n = 1 + int(rand(20));
    for (1..$n) {
      my $c;
      my $k = int(rand(256));
      if ($k == 0) {
        # NUL byte not handled currently
        $c = "\\0";
      } elsif ($k == 0x09) {
        # TAB is field separator
        $c = "\\t";
      } elsif ($k == 0x5c) {
        # backslash is escape
        $c = "\\\\";
      } elsif ($k == 0x0d) {
        # CR would be assumed to start CR-LF currently
        $c = "\\r";
      } else {
        $c = chr($k);
      }
      $s .= $c;
    }
  }
  print $fh $i, "\t", $s, "\r", "\n";
}
close($fh)
  or die "$file: close after write failed: $!";
exit(0);
EOF

create table t7 (
  a int primary key,
  b varbinary(20)
) engine=ndb;

create table t7ver like t7;

exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp --verbose=1
     --csvopt=r --keep-state
     test $MYSQLTEST_VARDIR/tmp/t7.csv >> $NDB_TOOLS_OUTPUT 2>&1;

--disable_query_log
eval load data infile '$MYSQLTEST_VARDIR/tmp/t7.csv'
into table t7ver
lines terminated by '\r\n';
--enable_query_log

select count(*) from t7 x, t7ver y
where x.a = y.a
and (x.b = y.b or (x.b is null and y.b is null));

--echo # test windows directory separator

# on windows mysqltest converts "/" to "\" in recognized paths
# on windows file i/o functions also convert "/" to "\"

--mkdir $MYSQLTEST_VARDIR/tmp/imp0
--copy_file $MYSQLTEST_VARDIR/tmp/t7.csv $MYSQLTEST_VARDIR/tmp/imp0/t7.csv

delete from t7;

if (!$is_windows)
{
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR/tmp/imp0 --verbose=1
     --csvopt=r --keep-state
     test $MYSQLTEST_VARDIR/tmp/imp0/t7.csv >> $NDB_TOOLS_OUTPUT 2>&1;
}

if ($is_windows)
{
exec $NDB_IMPORT --state-dir=$MYSQLTEST_VARDIR\tmp\imp0 --verbose=1
     --csvopt=r --keep-state
     test $MYSQLTEST_VARDIR\tmp\imp0\t7.csv >> $NDB_TOOLS_OUTPUT 2>&1;
}

select count(*) from t7;

--list_files $MYSQLTEST_VARDIR/tmp/imp0

drop table t1, t2, t2ver, t3, t3ver, t4, t5a, t5b, t5c,
           t6, t6ver, t7, t7ver;
