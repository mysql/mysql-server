CREATE TABLE S (
pk int NOT NULL,
col_int int NOT NULL,
PRIMARY KEY (`pk`)
) ENGINE=ndbcluster;
INSERT INTO S VALUES
(19, 4),                             
(12, 36),                            
(5, 47),                             
(7, 23),                            
(3, 7),                              
(9, 16),                             
(21, 48),                            
(22, 10),                            
(10, 27),                            
(14, 17),                            
(11, 4),                             
(18, 6),                             
(20, 39),                            
(1, 32),                             
(15, 49),                            
(13, 18),                            
(25, 21),                            
(6, 6),                              
(23, 3),                             
(2, 16),                             
(17, 13),                            
(16, 0),                             
(4, 2),                              
(24, 23),                            
(8, 7);
EXPLAIN SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7	ALL	NULL	NULL	NULL	NULL	25	100.00	NULL
1	SIMPLE	t2	p0,p1,p2,p3,p4,p5,p6,p7	ALL	NULL	NULL	NULL	NULL	25	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	t3	p0,p1,p2,p3,p4,p5,p6,p7	ALL	NULL	NULL	NULL	NULL	25	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	t4	p0,p1,p2,p3,p4,p5,p6,p7	ALL	NULL	NULL	NULL	NULL	25	100.00	Parent of 2 pushed join@1; Using join buffer (Block Nested Loop)
1	SIMPLE	t5	p0,p1,p2,p3,p4,p5,p6,p7	eq_ref	PRIMARY	PRIMARY	4	test.t4.col_int	1	100.00	Child of 't4' in pushed join@1
Warnings:
Note	1003	Can't push table 't2' as child, 'type' must be a 'ref' access
Note	1003	Can't push table 't3' as child, 'type' must be a 'ref' access
Note	1003	Can't push table 't4' as child, 'type' must be a 'ref' access
Note	1003	Cannot push table 't5' as child of table 't1'. Doing so would prevent using join buffer for table 't4'.
Note	1003	Cannot push table 't5' as child of table 't2'. Doing so would prevent using join buffer for table 't4'.
Note	1003	Cannot push table 't5' as child of table 't3'. Doing so would prevent using join buffer for table 't4'.
Note	1003	/* select#1 */ select straight_join count(0) AS `count(*)` from `test`.`S` `t1` join `test`.`S` `t2` join `test`.`S` `t3` join `test`.`S` `t4` join `test`.`S` `t5` where (`test`.`t5`.`pk` = `test`.`t4`.`col_int`)
EXPLAIN FORMAT=TREE SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
EXPLAIN
-> Aggregate: count(0)
    -> Nested loop inner join  (cost=104758.75 rows=390625)
        -> Inner hash join  (cost=65690.00 rows=390625)
            -> Table scan on t4, activating pushed join of 2 tables  (cost=0.40 rows=25)
            -> Hash
                -> Inner hash join  (cost=20377.50 rows=15625)
                    -> Table scan on t3  (cost=10.00 rows=25)
                    -> Hash
                        -> Inner hash join  (cost=12565.00 rows=625)
                            -> Table scan on t2  (cost=250.10 rows=25)
                            -> Hash
                                -> Table scan on t1  (cost=6252.50 rows=25)
        -> Index lookup on t5 using PRIMARY (pk=t4.col_int), child of t4 in pushed join  (cost=0.00 rows=1)

Warnings:
Note	1003	Can't push table 't2' as child, 'type' must be a 'ref' access
Note	1003	Can't push table 't3' as child, 'type' must be a 'ref' access
Note	1003	Can't push table 't4' as child, 'type' must be a 'ref' access
Note	1003	Cannot push table 't5' as child of table 't1'. Doing so would prevent using join buffer for table 't4'.
Note	1003	Cannot push table 't5' as child of table 't2'. Doing so would prevent using join buffer for table 't4'.
Note	1003	Cannot push table 't5' as child of table 't3'. Doing so would prevent using join buffer for table 't4'.
set join_buffer_size = 128;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 1024;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 2048;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 4096;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 16000;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 64000;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 256000;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = 1024000;
SELECT
STRAIGHT_JOIN count(*)
FROM 
S AS t1, S AS t2, S as t3, S as t4
JOIN S as t5 ON t5.pk = t4.col_int
;
count(*)
265625
set join_buffer_size = default;
DROP TABLE S;
