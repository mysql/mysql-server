#############################################################
# Test behaviout of the binlog injector during restart of itself.
# A restart should be triggered when the mysqld disconnects from
# the datanodes.
#
#############################################################

-- source include/have_binlog_format_mixed_or_row.inc
-- source include/have_multi_ndb.inc

# Ignore the warning generated by ndbcluster's binlog thread
# when mysqld is disconnected from cluster
--disable_query_log ONCE
call mtr.add_suppression("cluster disconnect An incident event has been written");

##################################################
# Check whether we have a debug compiled binary:
# @@global.debug can't be referred without this.
# However, instead of skipping entire test without debug,
# we run it without setting the specific debug flags.
###################################################
--let $have_debug= `select (version() like '%debug%')`

connection server1;
# Find NodeId of the mysqld we are connected to:
--let $node_id= `SHOW STATUS LIKE 'Ndb_cluster_node_id'`
--let $node_id= `SELECT SUBSTRING('$node_id', 20)+0`

connection server2;
# Find NodeId2 of 'server2' we are connected to:
--let $node_id2= `SHOW STATUS LIKE 'Ndb_cluster_node_id'`
--let $node_id2= `SELECT SUBSTRING('$node_id2', 20)+0`

# Ignore the warning generated by ndbcluster's binlog thread
# when mysqld is disconnected from cluster also on second Server
--disable_query_log ONCE
call mtr.add_suppression("cluster disconnect An incident event has been written");

connection server1;
reset master;

#############################################################
# A TE_FAILURE event will be received by the binlog thread 
# due to the DUMP disconnecting mysqld from datanodes.
# When binlog handles the FAILURE event, mysqld is put into
# readonly mode. A restart of the Binlog thread is required
# to bring it out of RO-mode.
#############################################################
--echo Disconnect mysqld from all datanodes
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id" > $NDB_TOOLS_OUTPUT

#############################################################
# The disconnect will create a GAP event in the binlog.
# To avoid 'disconnect failures' while probing for 'not_readonly',
# we use the binlog GAP as an indicator that disconnect has
# already completed.
#############################################################
--echo Wait for binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

#############################################################
# Until the binlog injector has completed the restart all tables
# will temporarily be in a read-only mode.
# (As the binlog will not be able to log any updates)
#############################################################
--echo Wait to get out of read-only mode
--source include/ndb_not_readonly.inc

#############################################################
# During the restart a 'Gap event' should be written to the
# binlog and the log rotated to 'binlog.000002'.
#############################################################
--echo
--echo Check that the binlog was rotated:
--echo There should be a 'LOST EVENT', then 'Rotate ... binlog.000002'
--source include/show_binlog_events.inc


#############################################################
# Bug#22204186: NDB REPLICATION : READ ONLY TABLES AND NO BINLOGGING
#
# Tables could get stuck in read only mode due to slow handling 
# of cluster failure in the binlog.
#
# Testcase is identical to the one above, except that
# we use debug inserts to force the binlog injector to take
# a break when handling failures. When not using debug compiled
# binaries, there will be no such breaks inserted, but the
# test should still succeed.
#
# This previously caused a race condition where the Util-thread
# managed to recreate the schema distr. tables before
# the binlog thread had completed the failure handling. Thus,
# the binlog never reached its restart condition of all
# eventOps have been dropped.
#############################################################

--echo
--echo Testing for Bug#22204186: Stuck in Readonly if slow failure handling
--echo ====================================================================

disable_query_log;
if ($have_debug)
{
  set @save_debug= @@global.debug;
  set global debug='+d,ndb_binlog_slow_failure_handling';
}
enable_query_log;

reset master;

--echo Disconnect mysqld from all datanodes
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id" > $NDB_TOOLS_OUTPUT

--echo Wait for binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

--echo Wait to get out of read-only mode
--source include/ndb_not_readonly.inc

--echo
--echo Check that the binlog was rotated:
--echo There should be a 'LOST EVENT', then 'Rotate ... binlog.000002'
--source include/show_binlog_events.inc

disable_query_log;
if ($have_debug)
{
  set global debug= @save_debug;
}
enable_query_log;

#############################################################
# Bug#22494024
#  SQL NODE FAILS TO RECONNECT AFTER NETWORK OUTAGE; BLOCKS OTHER NODES
#
# If a mysqld completes ndb_binlog_setup() before the others,
# and executes a schema change operation which has to be distributed,
# it can grab the MDL lock, which is also required by the other
# mysqlds to complete ndb_binlog_setup(). Thus we effectively
# deadlocks on the MDL.
#
# This could happen if one of the mysqlds opens the special table
# 'ndb_schema' *without* also completing the ndb_binlog_setup()
# in the same 'atomic' (MDL locked) operation. Opening of this table
# will cause a SUBSCRIBE-event to be sent to all other mysqlds,
# which is the signal used to enroll this node into the 
# schema distribution. However, as it is not yet 'setup', it
# will not yet act on schema distr. events, thus blocking other
# mysqlds waiting on its response.
#
#############################################################

--echo
--echo Testcase1 for Bug#22494024 Slow binlog-setup -> MDL deadlock (Meta Data Lock)
--echo    ndb_binlog_setup() fails to fully complete and does not clean up
--echo    its partial setup binlog subscriptions on exit
--echo =============================================================================

--echo Prepare mysqld 'server2' to not entirely complete binlog_setup
disable_query_log;
if ($have_debug)
{
  connection server2;
  set @save_debug= @@global.debug;
  set global debug='+d,ndb_binlog_setup_incomplete';
  connection server1;
}
enable_query_log;

--echo Disconnect both mysqld servers from all datanodes -> binlog restarts
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id"  > $NDB_TOOLS_OUTPUT
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id2" > $NDB_TOOLS_OUTPUT

connection server1;
--echo Wait for 'server1' binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

connection server2;
--echo Wait for 'server2' binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

connection server1;
--echo Wait for 'server1' to complete setup and get out of read-only mode
--source include/ndb_not_readonly.inc

--echo Give 'server2' some time to start, and fail, a binlog_setup
sleep 2;

connection server1;
--echo Create table operation on 'server1' grab MDL lock while waiting for
--echo   schema change distribution to all subscribing mysqld.
create table t1 (a int primary key) engine=ndb;
drop table t1;

disable_query_log;
if ($have_debug)
{
  connection server2;
  set global debug= @save_debug;
  connection server1;
}
enable_query_log;

connection server2;
--echo Wait for 'server2' to complete setup and get out of read-only mode
--source include/ndb_not_readonly.inc


--echo
--echo Testcase2 for Bug#22494024 Slow binlog-setup -> MDL deadlock (Meta Data Lock)
--echo   Table 'ndb_schema' is accessed from a SQL query. Causing it to be opened
--echo   and a SUBSCRIBE-event sent to other mysqld.
--echo =============================================================================

--echo Prepare mysqld 'server2' to do slow binlog_setup upon restart
disable_query_log;
if ($have_debug)
{
  connection server2;
  set @save_debug= @@global.debug;
  set global debug='+d,ndb_binlog_setup_slow';
  connection server1;
}
enable_query_log;

--echo Disconnect both mysqld servers from all datanodes -> binlog restarts
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id"  > $NDB_TOOLS_OUTPUT
--exec $NDB_MGM --no-defaults -e "ALL DUMP 900 $node_id2" > $NDB_TOOLS_OUTPUT

connection server1;
--echo Wait for 'server1' binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

connection server2;
--echo Wait for 'server2' binlog rotate to indicate disconnect
--let $wait_binlog_event= binlog.000002
--source include/wait_for_binlog_event.inc

connection server1;
--echo Wait for (fast) 'server1' to complete setup and get out of read-only mode
--source include/ndb_not_readonly.inc

connection server2;
--echo Reading 'mysql.ndb_schema' on 'server2' announce schema distr. participation as a side effect.
disable_result_log;
--error 0,ER_NO_SUCH_TABLE,ER_OPEN_AS_READONLY,ER_GET_ERRMSG,ER_TABLE_DEF_CHANGED,ER_NOT_FORM_FILE,ER_KEY_NOT_FOUND
select * from mysql.ndb_schema where db="" and name="";
enable_result_log;

connection server1;
--echo Create table operation on 'server1' grab MDL lock while waiting for
--echo schema distribution to all subscribing mysqld -> stuck on 'server2'
create table t1 (a int primary key) engine=ndb;
drop table t1;

disable_query_log;
if ($have_debug)
{
  connection server2;
  set global debug= @save_debug;
  connection server1;
}
enable_query_log;

connection server2;
--echo Wait for 'server2' to complete setup and get out of read-only mode
--source include/ndb_not_readonly.inc
