# DEBUG_SYNC must be compiled in.
--source include/have_debug_sync.inc

# We need to test the use case:
#    a. Create a transaction T1 that will be promoted to RW.
#    b. Create a transaction T2 that will be promoted to RW.
#    a. Create a RO transaction T3
#    d. T3 does a select - creates a read view that doesn't include T1 and T2
#    e. T1 & T2 do some updates - this promotes T1 & T2 to RW transactions
#    f. T1 & T2 Commit
#    g. T3 Does a select - it should not see the changes of T1 & T2

--source include/have_innodb.inc

CREATE TABLE t1 (c1 INT , c2 CHAR(10), PRIMARY KEY (c1)) ENGINE = InnoDB;
INSERT INTO t1 VALUES(0, "0");
INSERT INTO t1 VALUES(1, "1");
INSERT INTO t1 VALUES(2, "2");
INSERT INTO t1 VALUES(3, "3");

CREATE TABLE t2 (c1 INT , c2 CHAR(10), PRIMARY KEY (c1)) ENGINE = InnoDB;
INSERT INTO t2 VALUES(0, "a");
INSERT INTO t2 VALUES(1, "b");
INSERT INTO t2 VALUES(2, "c");
INSERT INTO t2 VALUES(3, "d");

--connect (con1,localhost,root,,)
--connect (con2,localhost,root,,)

connection con1;
--echo 'T1'
SET AUTOCOMMIT=0;
BEGIN;
SELECT * FROM t2;

connection default;
--echo 'T2'
SET AUTOCOMMIT=0;
BEGIN;
SELECT * FROM t1;

connection con2;
--echo 'T3'
SET AUTOCOMMIT=0;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT * FROM t1;
SELECT * FROM t2;

connection default;
--echo 'T1'
UPDATE t2 SET c1 = c1 + 100;
SELECT * FROM t2;
COMMIT;

connection default;
--echo 'T2'
UPDATE t1 SET c1 = c1 + 100;
SELECT * FROM t1;
COMMIT;

connection con2;
--echo 'T3'
SET DEBUG_SYNC='row_select_wait WAIT_FOR waiting1';
--send SELECT * FROM t1;

connection default;
--echo 'T2'
SET DEBUG_SYNC='now SIGNAL waiting1';
--echo 'Signalled T3'

connection con2;
--echo 'T3'
reap;

connection con2;
--echo 'T3'
SET DEBUG_SYNC='row_select_wait WAIT_FOR waiting1';
--send SELECT * FROM t2;

connection default;
--echo 'T2'
SET DEBUG_SYNC='now SIGNAL waiting1';
--echo 'Signalled T3'

connection con2;
--echo 'T3'
reap;

connection default;
disconnect con1;
disconnect con2;

# We need to test the use case:
#    a. Create a transaction T1 that will be promoted to RW.
#    b. Create a transaction T2 that will be promoted to RW.
#    c. T2 does some updates - this promotes T2 to RW transactions
#    d. T2 Commits
#    e. Create a RO transaction T3
#    f. T3 does a select - creates a read view that doesn't include T1
#    g. T1 does some updates - this promotes T1 to RW transactions
#    h. T1 Commits
#    i. T3 Does a select - it should not see the changes made by T1 but should
#       see the changes by T2

--connect (con1,localhost,root,,)
--connect (con2,localhost,root,,)

connection con1;
--echo 'T1'
SET AUTOCOMMIT=0;
BEGIN;
SELECT * FROM t1;

connection default;
--echo 'T2'
SET AUTOCOMMIT=0;
BEGIN;
SELECT * FROM t2;
UPDATE t2 SET c1 = c1 + 100;
SELECT * FROM t2;
COMMIT;

connection con2;
--echo 'T3'
SET AUTOCOMMIT=0;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT * FROM t1;
SELECT * FROM t2;

connection con1;
--echo 'T1'
UPDATE t1 SET c1 = c1 + 100;
SELECT * FROM t1;
COMMIT;

connection con2;
--echo 'T3'
SET DEBUG_SYNC='row_select_wait WAIT_FOR waiting1';
--send SELECT * FROM t1;

connection con1;
--echo 'T2'
SET DEBUG_SYNC='now SIGNAL waiting1';
--echo 'Signalled T3'

connection con2;
--echo 'T3'
reap;

connection con2;
--echo 'T3'
SET DEBUG_SYNC='row_select_wait WAIT_FOR waiting1';
--send SELECT * FROM t2;

connection default;
--echo 'T2'
SET DEBUG_SYNC='now SIGNAL waiting1';
--echo 'Signalled T3'

connection con2;
--echo 'T3'
reap;

connection default;
disconnect con1;
disconnect con2;

DROP TABLE t1;
DROP TABLE t2;

# Clean up resources used in this test case.
--disable_warnings
SET DEBUG_SYNC= 'RESET';
--enable_warnings
