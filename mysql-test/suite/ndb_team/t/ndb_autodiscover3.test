-- source include/have_multi_ndb.inc

-- disable_query_log
call mtr.add_suppression("NDB_SHARE: .* already exists use_count=[0-9]*. Moving away for safety, but possible memleak.");
-- enable_query_log

# see bug#21563
-- source include/have_binlog_format_mixed_or_row.inc

--connection server1
# Ignore the warning generated by ndbcluster's binlog thread
# when cluster is restarted
--disable_query_log ONCE
call mtr.add_suppression("cluster disconnect An incident event has been written");

--connection server2
# Ignore the warning generated by ndbcluster's binlog thread
# when cluster is restarted - also on the second mysqld
--disable_query_log ONCE
call mtr.add_suppression("cluster disconnect An incident event has been written");

--disable_warnings
drop table if exists t1, t2;
--disable_query_log
set ndb_table_temporary=0;
--enable_query_log
--enable_warnings

connect (con1,127.0.0.1,root,,test,$MASTER_MYPORT,);
connect (con2,127.0.0.1,root,,test,$MASTER_MYPORT1,);

# Workaround for Bug#27644
# ndb: connecting api node/mysqld may "steal" node_id from running mysqld
# - let ndb_waiter use a fixed node id so "steal" cannot happen
--let connect_str = "nodeid=255;$NDB_CONNECTSTRING"

#
# Transaction ongoing while cluster is restarted
#
--connection server1
create table t1 (a int key) engine=ndbcluster;

begin;
insert into t1 values (1);

--exec $NDB_MGM --no-defaults -e "all restart" >> $NDB_TOOLS_OUTPUT
--exec $NDB_WAITER --no-defaults -c $connect_str >> $NDB_TOOLS_OUTPUT

# Wait for mysqld to reconnect and exit from readonly mode
--connection con1
--source include/ndb_not_readonly.inc
# wait for server1 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection con2
--source include/ndb_not_readonly.inc
# wait for server2 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection server1
--error 1297
insert into t1 values (2);
rollback;

drop table t1;

#
# Stale cache after restart -i
#
--connection server1
create table t2 (a int, b int, primary key(a,b)) engine=ndbcluster;
insert into t2 values (1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1);
select * from t2 order by a limit 3;

--disable_query_log
--source include/ndb_backup_id.inc
--enable_query_log
--exec $NDB_MGM --no-defaults -e "all restart -i" >> $NDB_TOOLS_OUTPUT
--exec $NDB_WAITER --no-defaults -c $connect_str >> $NDB_TOOLS_OUTPUT
# now make a backup with explicit id to restore the backup id after initial start
--inc $the_backup_id
--exec $NDB_MGM --no-defaults -e "start backup $the_backup_id" >> $NDB_TOOLS_OUTPUT
# to ensure mysqld has connected again, and recreated system tables

--connection con1
--source include/ndb_not_readonly.inc
# wait for server1 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection con2
--source include/ndb_not_readonly.inc
# wait for server2 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection server2
--error ER_NO_SUCH_TABLE
select * from t2;
show tables like 't2';
reset master;
create table t2 (a int key) engine=ndbcluster;
insert into t2 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
select * from t2 order by a limit 3;

# server 1 should have a stale cache, and in this case wrong frm, transaction must be retried
--connection server1
select * from t2 order by a limit 3;
reset master;

--disable_query_log
--source include/ndb_backup_id.inc
--enable_query_log
--exec $NDB_MGM --no-defaults -e "all restart -i" >> $NDB_TOOLS_OUTPUT
--exec $NDB_WAITER --no-defaults -c $connect_str >> $NDB_TOOLS_OUTPUT
# now make a backup with explicit id to restore the backup id after initial start
--inc $the_backup_id
--exec $NDB_MGM --no-defaults -e "start backup $the_backup_id" >> $NDB_TOOLS_OUTPUT
# to ensure mysqld has connected again, and recreated system tables

--connection con1
--source include/ndb_not_readonly.inc
# wait for server1 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection con2
--source include/ndb_not_readonly.inc
# wait for server2 stats thread to re-initialize
--source include/ndb_index_stat_wait.inc

--connection server1
--error ER_NO_SUCH_TABLE
select * from t2;
show tables like 't2';
reset master;
create table t2 (a int key) engine=ndbcluster;
insert into t2 values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
select * from t2 order by a limit 3;

# server 2 should have a stale cache, but with right frm, transaction need not be retried
--connection server2
select * from t2 order by a limit 3;
reset master;

drop table t2;
# End of 4.1 tests
