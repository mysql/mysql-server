# Some functional checks for the content of the performance_schema table
# socket_summary_by_instance.
#
# Created: mleich 2011-07-01
#
# Rough description of "What is when tested"
# 1. Impact of successful connect
#    A new row with EVENT_NAME "client_connection" shows up
#    is tested in 0 and 4.5.
# 2. Impact of disconnect
#    A row with EVENT_NAME "client_connection" disappears
#    is tested in 0. and 2.
# 3. Disabling the instrumentation for some thread causes that the
#    counter for this thread become static is tested in 4.3.
#    Nearby the beginning of this test and somewhere in the middle.
# 4. TRUNCATE table resets the counters is tested in 5.
# 5. Consistency within a row like MIN_* <= AVG_* <= MAX_*
#    -> include/socket_summary_check.inc which is called at
#       various places
# 6. Consistency of the instances mentioned in socket_summary_by_event
#    and socket_summary_by_instance is checked per call of
#    include/socket_summary_check.inc
# 7. Check if changes in counters of instances caused by actions
#    are reasonable is tested for
#    - Connects+SQL statements    in 4.1 and 4.2
#    - SQL statements             in 4.4
#    - Connects                   in 4.5
#

# Embedded server does not supprt the performance_schema.
--source include/not_embedded.inc
--source include/not_windows.inc
--source include/have_perfschema.inc

# The values in the performance_schema tables depend on how much communication
# happens per SQL statement within our MTR tests. And there is a significant
# difference between standard statement execution and execution via
# prepared statement.
--source ../include/no_protocol.inc


#===================================
# Set IP address defaults with respect to IPV6 support
#
# Set this to enable debugging output
let $my_socket_debug= 0;
#
# Determine if IPV6 supported
#
let $check_ipv6_just_check= 1;
--source include/check_ipv6.inc
#
# Determine if IPV4 mapped to IPV6 supported
#
let $check_ipv4_mapped_just_check= 1;
--source include/check_ipv4_mapped.inc
#
# Set the localhost IP default to use when establishing connections
let $my_localhost=127.0.0.1;
if($check_ipv6_supported)
{
  let $my_localhost=::1;
}
if($check_ipv4_mapped_supported)
{
  let $my_localhost=::ffff:127.0.0.1;
}
#
let $my_socket_debug= 0;
if($my_socket_debug)
{
  --echo IPV6=$check_ipv6_supported, IPV4_MAPPED = $check_ipv4_mapped_supported, LOCALHOST = $my_localhost
}
#===================================

--echo # The logging of commands and result sets is mostly disabled.
--echo # There are some messages which help to observe the progress of the test.
--echo # In case some check fails
--echo # - a message about this will be printed
--echo # - some SQL commands which show the unexpected state will be executed
--echo #   (logging enabled)
--echo # - the test might abort
--echo #

--disable_query_log

--echo # 0. Check, build or set prequisites
#==========================================
# Set $print_details to 1 in case you want that the exact diffs caused
# by the execution of a statement get printed.
# Disadvantage of printing details:
#    Even minor legimitate changes of the client - server communication can
#    cause that the test needs maintenance.
# Advantage:
#    More thorough checks.
# If any of the checks detects some suspicious/unexpected state than
# $print_details will be automatically switched to 1.
#
let $print_details= 0;

#
# Number of attempts within the test checking the stability of counter changes.
#
let $loop_rounds= 10;

# This test of PERFORMANCE_SCHEMA functionality is very vulnerable.
# Ensure that we have in the moment exact one
# - connection
# - instance with EVENT_NAME LIKE '%client_connection'
# - instance with EVENT_NAME LIKE '%server_tcpip_socket'
# - instance with EVENT_NAME LIKE '%server_unix_socket'
#=======================================================
let $my_rules= COUNT(*) = 1;
let $part=
FROM performance_schema.threads
WHERE NAME LIKE '%one_connection';
let $wait_condition=
SELECT $my_rules $part;
let $wait_timeout= 5;
--source include/wait_condition.inc
--enable_query_log
if(!$success)
{
   --echo # ERROR: There must be only one user connection
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%client_connection';
let $wait_condition=
SELECT $my_rules $part;
let $wait_timeout= 5;
--source include/wait_condition.inc
if(!$success)
{
   --echo # ERROR: There must be only one instance with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%server_unix_socket';
let $wait_condition=
SELECT $my_rules $part;
let $wait_timeout= 5;
--source include/wait_condition.inc
if(!$success)
{
   --echo # ERROR: There must be only one instance with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%server_tcpip_socket';
let $wait_condition=
SELECT $my_rules $part;
let $wait_timeout= 5;
--source include/wait_condition.inc
if(!$success)
{
   --echo # ERROR: There must be only one instance with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}

--disable_query_log

#
# Lower the resolution of the wait timer from the default 'CYCLE'
# to 'NANOSECOND'.
# Hint: The timer columns contains values in picoseconds independent
#       of the timer resolution.
#       The timer resolution has an impact on the precision of the value.
# This should prevent the failures seen on some suspicious PB boxes where
# - calculations exceeded the BIGINT UNSIGNED (data type of the counter columns)
#   value range.
# - we have reached from whatever reason 20 digit values 
# The consequence for the current test is the following:
#    The common sense rule
#       In case COUNT_<A> increases than SUM_TIMER_<A> must also increase
#    is no more valid because some action might need less time than the
#    timer resolution.
#
let $wait_timer= `SELECT TIMER_NAME FROM performance_schema.setup_timers
                  WHERE NAME = 'wait'`;
UPDATE performance_schema.setup_timers
SET TIMER_NAME = 'NANOSECOND'
WHERE NAME = 'wait';

#
# Additional SCHEMA used for
# - detection of our "worker" session within the PROCESSLIST.
#   No other connection should use this schema as default schema.
# - easy cleanup because auxiliary objects are stored there
#
CREATE SCHEMA mysqltest;
CREATE SCHEMA mysqlsupertest;

#
# Clear summary tables of previous entries
#
TRUNCATE performance_schema.socket_summary_by_instance;
TRUNCATE performance_schema.socket_summary_by_event_name;
# Disable instrumenting of the current default session.
# Required for check 1.1
UPDATE performance_schema.threads
SET INSTRUMENTED='NO' WHERE PROCESSLIST_ID = CONNECTION_ID();

#
# Auxiliary tables for storing current values at certain points of time.
# We store states of performance_schema.socket_summary_by_instance here
# in order
# - to have initial values from before some action
# - to minimize the impact of statements used for the checks on results.
# CREATE TEMPORARY TABLE my_socket_summary_by_instance AS
# would be nice but some statements are not supported for temporary tables.
#
# DECIMAL(60,0) is used instead of BIGINT UNSIGNED. The goal is to prevent
# errors during calculations
#   Example:
#   -    A and B UNSIGNED BIGINT
#   -    A < B
#   -    A - B ---> Error
# though the columns in all queries are orderd to avoid this too.
#
CREATE TABLE mysqltest.my_socket_summary_by_instance (
  EVENT_NAME varchar(128) NOT NULL,
  OBJECT_INSTANCE_BEGIN bigint(20) unsigned NOT NULL,
  COUNT_STAR                DECIMAL(60,0) NOT NULL,
  SUM_TIMER_WAIT            DECIMAL(60,0) NOT NULL,
  MIN_TIMER_WAIT            DECIMAL(60,0) NOT NULL,
  AVG_TIMER_WAIT            DECIMAL(60,0) NOT NULL,
  MAX_TIMER_WAIT            DECIMAL(60,0) NOT NULL,
  COUNT_READ                DECIMAL(60,0) NOT NULL,
  SUM_TIMER_READ            DECIMAL(60,0) NOT NULL,
  MIN_TIMER_READ            DECIMAL(60,0) NOT NULL,
  AVG_TIMER_READ            DECIMAL(60,0) NOT NULL,
  MAX_TIMER_READ            DECIMAL(60,0) NOT NULL,
  SUM_NUMBER_OF_BYTES_READ  DECIMAL(60,0) NOT NULL,
  COUNT_WRITE               DECIMAL(60,0) NOT NULL,
  SUM_TIMER_WRITE           DECIMAL(60,0) NOT NULL,
  MIN_TIMER_WRITE           DECIMAL(60,0) NOT NULL,
  AVG_TIMER_WRITE           DECIMAL(60,0) NOT NULL,
  MAX_TIMER_WRITE           DECIMAL(60,0) NOT NULL,
  SUM_NUMBER_OF_BYTES_WRITE DECIMAL(60,0) NOT NULL,
  COUNT_MISC                DECIMAL(60,0) NOT NULL,
  SUM_TIMER_MISC            DECIMAL(60,0) NOT NULL,
  MIN_TIMER_MISC            DECIMAL(60,0) NOT NULL,
  AVG_TIMER_MISC            DECIMAL(60,0) NOT NULL,
  MAX_TIMER_MISC            DECIMAL(60,0) NOT NULL,
  pk VARCHAR(20),
  PRIMARY KEY(pk, EVENT_NAME, OBJECT_INSTANCE_BEGIN)
) DEFAULT CHARSET=utf8;


# The CAST(... AS DECIMAL(60,0)) prevents errors which might show up in case
# we run with the original data type UNSIGNED BIGINT.
CREATE TABLE mysqltest.socket_summary_by_instance_detail (
  EVENT_NAME varchar(128) NOT NULL,
  OBJECT_INSTANCE_BEGIN bigint(20) unsigned NOT NULL,
  COUNT_READ                DECIMAL(60,0) NOT NULL,
  SUM_TIMER_READ            DECIMAL(60,0) NOT NULL,
  SUM_NUMBER_OF_BYTES_READ  DECIMAL(60,0) NOT NULL,
  COUNT_WRITE               DECIMAL(60,0) NOT NULL,
  SUM_TIMER_WRITE           DECIMAL(60,0) NOT NULL,
  SUM_NUMBER_OF_BYTES_WRITE DECIMAL(60,0) NOT NULL,
  COUNT_MISC                DECIMAL(60,0) NOT NULL,
  SUM_TIMER_MISC            DECIMAL(60,0) NOT NULL,
  statement VARCHAR(500),
  run INTEGER
) DEFAULT CHARSET=utf8;

#
# Auxiliary SQL functions used to shorten some commands.
#
CREATE FUNCTION mysqltest.min_of_triple
   (f1 DECIMAL(60,0), f2 DECIMAL(60,0), f3 DECIMAL(60,0))
   RETURNS DECIMAL(60,0)
   RETURN IF(IF(f1 < f2,f1,f2) < f3,IF(f1 < f2,f1,f2), f3);
CREATE FUNCTION mysqltest.max_of_triple
   (f1 DECIMAL(60,0), f2 DECIMAL(60,0), f3 DECIMAL(60,0))
   RETURNS DECIMAL(60,0)
   RETURN IF(IF(f1 > f2,f1,f2) > f3,IF(f1 > f2,f1,f2), f3);

#
# Auxiliary table for experiments with SELECTs earning different result sets.
#
CREATE TABLE mysqltest.my_aux (col1 INTEGER, col2 VARCHAR(1024), PRIMARY KEY(col1));
INSERT INTO mysqltest.my_aux SET col1 = 0, col2 = REPEAT('a',0);
INSERT INTO mysqltest.my_aux SET col1 = 1, col2 = REPEAT('a',0);
INSERT INTO mysqltest.my_aux SET col1 = 2, col2 = REPEAT('a',1);
INSERT INTO mysqltest.my_aux SET col1 = 3, col2 = REPEAT('a',1024);

#
# Auxiliary mysqltest variables used to shorten commands and to ensure
# that we run all time the right operation.
#
let $truncate=
TRUNCATE TABLE mysqltest.my_socket_summary_by_instance;
#
let $insert_before=
INSERT INTO mysqltest.my_socket_summary_by_instance
SELECT *,'Before' FROM performance_schema.socket_summary_by_instance;
#
let $insert_after=
INSERT INTO mysqltest.my_socket_summary_by_instance
SELECT *,'After' FROM performance_schema.socket_summary_by_instance;
#
let $insert_pseudo_before=
INSERT INTO mysqltest.my_socket_summary_by_instance
(EVENT_NAME, OBJECT_INSTANCE_BEGIN,
COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT,
COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ,
SUM_NUMBER_OF_BYTES_READ,
COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE,
SUM_NUMBER_OF_BYTES_WRITE,
COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC,
pk)
SELECT EVENT_NAME, OBJECT_INSTANCE_BEGIN,
0, 0, 0, 0, 0,
0, 0, 0, 0, 0,
0,
0, 0, 0, 0, 0,
0,
0, 0, 0, 0, 0,
'Pseudo_Before'
FROM mysqltest.my_socket_summary_by_instance t1
WHERE OBJECT_INSTANCE_BEGIN NOT IN
      (SELECT OBJECT_INSTANCE_BEGIN
       FROM mysqltest.my_socket_summary_by_instance t2
       WHERE pk = 'Before');
#
let $insert_delta=
INSERT INTO mysqltest.socket_summary_by_instance_detail
      (EVENT_NAME,OBJECT_INSTANCE_BEGIN,
       COUNT_READ, SUM_TIMER_READ, SUM_NUMBER_OF_BYTES_READ,
       COUNT_WRITE,SUM_TIMER_WRITE,SUM_NUMBER_OF_BYTES_WRITE,
       COUNT_MISC, SUM_TIMER_MISC, statement,run)
SELECT EVENT_NAME,OBJECT_INSTANCE_BEGIN,
       t1.COUNT_READ                - t2.COUNT_READ,
       t1.SUM_TIMER_READ            - t2.SUM_TIMER_READ,
       t1.SUM_NUMBER_OF_BYTES_READ  - t2.SUM_NUMBER_OF_BYTES_READ,
       t1.COUNT_WRITE               - t2.COUNT_WRITE,
       t1.SUM_TIMER_WRITE           - t2.SUM_TIMER_WRITE,
       t1.SUM_NUMBER_OF_BYTES_WRITE - t2.SUM_NUMBER_OF_BYTES_WRITE,
       t1.COUNT_MISC                - t2.COUNT_MISC,
       t1.SUM_TIMER_MISC            - t2.SUM_TIMER_MISC,
       NULL,NULL
FROM mysqltest.my_socket_summary_by_instance t1
JOIN mysqltest.my_socket_summary_by_instance t2
USING (EVENT_NAME,OBJECT_INSTANCE_BEGIN)
WHERE t1.pk = 'After' AND t2.pk LIKE '%Before';
#
let $get_object_instance_begin=
SELECT OBJECT_INSTANCE_BEGIN INTO @con1_object_instance_begin
FROM performance_schema.socket_summary_by_instance AS t1
WHERE (EVENT_NAME,OBJECT_INSTANCE_BEGIN)
      NOT IN (SELECT EVENT_NAME,OBJECT_INSTANCE_BEGIN
              FROM mysqltest.my_socket_summary_by_instance AS t2
              WHERE pk = 'Before');

# Use this whenever you print data.
let $column_list=
RPAD(EVENT_NAME,               38, ' ') AS EVENT_NAME,
LPAD(OBJECT_INSTANCE_BEGIN,    20, ' ') AS OBJECT_INSTANCE,
LPAD(COUNT_READ,                7, ' ') AS CREAD,
LPAD(SUM_TIMER_READ,           12, ' ') AS TREAD,
LPAD(SUM_NUMBER_OF_BYTES_READ,  7, ' ') AS BREAD,
LPAD(COUNT_WRITE,               7, ' ') AS CWRITE,
LPAD(SUM_TIMER_WRITE,          12, ' ') AS TWRITE,
LPAD(SUM_NUMBER_OF_BYTES_WRITE, 7, ' ') AS BWRITE,
LPAD(COUNT_MISC,                7, ' ') AS CMISC,
LPAD(SUM_TIMER_MISC,           13, ' ') AS TMISC,
RPAD(STATEMENT,                50, ' ') AS STATEMENT,
LPAD(RUN,                       5, ' ') AS RUN;

# Determine OBJECT_INSTANCE_BEGIN of the connection default
# which acts as the observer
eval $truncate;
eval $insert_before;
--disconnect default
--connect (default,localhost,root,,,,)
# --echo ########### Disconnect/Connect
# --enable_query_log
eval $insert_after;
eval $get_object_instance_begin;
SET @default_object_instance_begin = @con1_object_instance_begin;

# Wait till the old default connection has disappeared
let $wait_timeout= 5;
let $wait_condition=
SELECT COUNT(*) = 1
FROM performance_schema.threads
WHERE processlist_user = 'root';
--source include/wait_condition.inc
--enable_query_log
if (!$success)
{
   --enable_query_log
   --enable_result_log
   --echo # Error: The disconnect of the old default connection
   --echo #        (user = 'root') failed. We expect to have only one connection
   --echo #        with user = 'root'. And this is our current connection.
   SELECT * FROM performance_schema.threads
   WHERE processlist_user = 'root';
   --echo # abort
   exit;
}

# Disable instrumenting of the current default session.
# Required for check 1.2
UPDATE performance_schema.threads
SET INSTRUMENTED='NO' WHERE PROCESSLIST_ID = CONNECTION_ID();

--echo # 1. Basic checks
--echo # 1.1 Check that the entry of the disconnected old default session really
--echo #     disappeared from performance_schema.socket_summary_by_instance.
#===============================================================================
# This failed at some point in history when the instrumenting for the
# session to be disconnected was disabled.
if(`SELECT COUNT(*) FROM performance_schema.socket_summary_by_instance
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE '%client_connection'`)
{
   --enable_query_log
   --enable_result_log
   --echo # Error: The disconnected old default session did not disappear from
   --echo #        socket_summary_by_instance.
   SELECT * FROM performance_schema.socket_summary_by_instance
   WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
     AND EVENT_NAME LIKE '%client_connection';
}

TRUNCATE TABLE performance_schema.socket_summary_by_instance;

--echo # 1.2 Check the base line
#===============================
eval $truncate;
--source ../include/socket_summary_check.inc

# --disable_query_log
# --disable_query_log

--echo # 2. Variations on Connect
let $is_connect= 1;
--echo # 2.1 Connect fails because the user is unknown
--echo #     length of user name = 4 character
--echo #     length of default db = 9 character
#========================================================================
let $connect_host= localhost;
let $connect_db= mysqltest;
let $connect_user= boot;
--source ../include/socket_event.inc

--echo # 2.2 Connect fails because the user is unknown
--echo #     length of user name = 14 character (10 more than in 2.1)
--echo #     length of default db = 9 character
#========================================================================
let $connect_host= localhost;
let $connect_db= mysqltest;
let $connect_user= boot0123456789;
--source ../include/socket_event.inc

--echo # 2.3 Connect should pass, host = localhost
--echo #     length of user name  = 4 character
--echo #     length of default db = 9 character
#========================================================================
let $connect_host= localhost;
let $connect_db= mysqltest;
let $connect_user= root;
--source ../include/socket_event.inc

--echo # 2.4 Connect should pass, host = localhost
--echo #     length of user name  = 4 character
--echo #     length of default db = 14 character (5 more than 2.3)
#========================================================================
let $connect_host= localhost;
let $connect_db= mysqlsupertest;
let $connect_user= root;
--source ../include/socket_event.inc

--echo # 2.5 Connect should pass, host = localhost
--echo #     length of user name  = 10 character
--echo #     length of default db = 9 character
#========================================================================
GRANT ALL PRIVILEGES ON *.* TO 'root012345'@'localhost';
let $connect_host= localhost;
let $connect_db= mysqltest;
let $connect_user= root012345;
--source ../include/socket_event.inc
DROP USER 'root012345'@'localhost';

--echo # 2.6 Connect should pass, host = localhost
--echo #     length of user name  = 14 character
--echo #     length of default db = 9 character
#========================================================================
GRANT ALL PRIVILEGES ON *.* to 'root0123456789'@'localhost';
let $connect_host= localhost;
let $connect_db= mysqltest;
let $connect_user= root0123456789;
--source ../include/socket_event.inc
DROP USER 'root0123456789'@'localhost';

--echo # 2.7 Connect should pass, host = my_localhost
--echo #     length of user name  = 4 character
--echo #     length of default db = 9 character
--echo #     connection runs through server_tcpip_socket !
#========================================================================
let $connect_host= $my_localhost;
let $connect_db= mysqltest;
let $connect_user= root;
--source ../include/socket_event.inc

#========================================================================
--connect (con1,localhost,root,,mysqltest,,)
# Experiments showed some unexpected result in the counter difference
# which got con1 for the next statement (see 3.1).
# The measured diff was too high and was probably caused by some
# too much delayed counter maintenance for the connect.
# We run here just some SQL statement because counter maintenance
# for SQL statements is more fast and reliable than far Connect.
DO 1;
--connection default
--source ../include/wait_till_sleep.inc
--disable_query_log

--echo # 3 Variations on SELECT
# Attention: Don't use
# - any double quotes within the statements because sourced scripts
#   already "decorate" $variables with double quotes
# - UNION because this leads to result set related byte write
#   counters which cannot good compared to select without union
let $is_connect= 0;
eval $get_object_instance_begin;
--echo # 3.1 Check a SELECT ending with server sending an error message.
--echo #     Error message is short (unknown table).
#========================================================================
let $statement= SELECT col2 FROM does_not_exist;
--source ../include/socket_event.inc

--echo # 3.2 SELECT ending with server sending an error message.
--echo #     Now the statement is a bit longer but the error message
--echo #     length does again not depend on statement.
#=======================================================================
let $statement= SELECT col2 FROM does_not_exist WHERE col1 = 0;
--source ../include/socket_event.inc

--echo # 3.3 SELECT ending with server sending an error message.
--echo #     The statement has the same length like in 3.2 but the error
--echo #     message is now different and much longer.
#=======================================================================
let $statement= SELECT col2 FROM does_not_exist WHERE col1 A 0;
--source ../include/socket_event.inc

--echo # 3.4 SELECT ending with server sending an error message.
--echo #     Statement and error message are a bit longer than in 3.1
--echo #     because the table name is longer.
#=======================================================================
let $statement= SELECT col2 FROM does_not_exist0123;
--source ../include/socket_event.inc

--echo # 3.5 SELECT earning an empty result set.
#=======================================================
let $statement= SELECT col2 FROM mysqltest.my_aux WHERE col1 = -1;
--source ../include/socket_event.inc

--echo # 3.6 SELECT earning an empty result set.
--echo #     Short column name is replaced by longer alias.
#==========================================================
let $statement= SELECT col2 AS my_super_col FROM mysqltest.my_aux WHERE col1 = -1;
--source ../include/socket_event.inc

--echo # 3.7 SELECT earning one row with an empty string.
#================================================================
let $statement= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1;
--source ../include/socket_event.inc

--echo # 3.8 SELECT earning one row with one string one char long.
#=========================================================================
let $statement= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 2;
--source ../include/socket_event.inc

--echo # 3.9 SELECT earning one row with one string 1024 char long.
#==========================================================================
let $statement= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 3;
--source ../include/socket_event.inc

--echo # 3.10 SELECT earning two rows with an empty string
#==========================================================================
let $statement= SELECT col2 FROM mysqltest.my_aux WHERE col1 < 2;
--source ../include/socket_event.inc

--echo # 3.11 Check that the preceding Connects/SQL command runs have not
--echo #      caused some unexpected state.
#==========================================================================
let $my_rules= COUNT(*) = 2;
let $part=
FROM performance_schema.threads
WHERE NAME LIKE '%one_connection';
if(`SELECT NOT ( $my_rules ) $part `)
{
   --echo # ERROR: There must be only two user connections
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%client_connection';
if(`SELECT NOT ( $my_rules ) $part `)
{
   --echo # ERROR: There must be only two instances with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $my_rules= COUNT(*) = 1;
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%server_unix_socket';
if(`SELECT NOT ( $my_rules ) $part `)
{
   --echo # ERROR: There must be only one instance with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}
let $part=
FROM performance_schema.socket_summary_by_instance
WHERE EVENT_NAME LIKE '%server_tcpip_socket';
if(`SELECT NOT ( $my_rules ) $part `)
{
   --echo # ERROR: There must be only one instance with this EVENT_NAME.
   eval
   SELECT * $part;
   --echo # abort
   exit;
}

--echo # 4. Check delta (value_after_action - value_before_action) details
# 4.0  . Negative deltas cannot have happened because the counter columns within
#        socket_summary_by_instance_detail are defined as UNSIGNED BIGINT.
#        = The INSERT which computes the diff would have been failed.
--echo # 4.1 Check that
--echo #     - no change in COUNT_* leads to no change in
--echo #       SUM_TIMER_* and no change in SUM_NUMBER_OF_BYTES_*
--echo #     - increased COUNT_READ leads to increased
--echo #       SUM_NUMBER_OF_BYTES_READ
--echo #     - increased COUNT_WRITE leads to increased
--echo #       SUM_NUMBER_OF_BYTES_WRITE
--echo #     Attention:
--echo #     The time required for some action might be below timer resolution.
--echo #     Therefore some increased COUNT_* does not need to lead to an
--echo #     increased SUM_TIMER_*.
#==========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET SUM_TIMER_MISC = 13, COUNT_MISC  = 0
  WHERE statement LIKE '%WHERE col1 = 3'
    AND EVENT_NAME LIKE '%client_connection'
    AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  LIMIT 1;
  --disable_info
}

let $my_rules=
((COUNT_READ  = 0 AND SUM_TIMER_READ  = 0 AND SUM_NUMBER_OF_BYTES_READ  = 0)
  OR
 (COUNT_READ  > 0                         AND SUM_NUMBER_OF_BYTES_READ  > 0))
AND
((COUNT_WRITE = 0 AND SUM_TIMER_WRITE = 0 AND SUM_NUMBER_OF_BYTES_WRITE = 0)
  OR
 (COUNT_WRITE > 0                         AND SUM_NUMBER_OF_BYTES_WRITE > 0))
AND
((COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0)
  OR
(COUNT_MISC > 0));
if(`SELECT COUNT(*) FROM mysqltest.socket_summary_by_instance_detail
    WHERE NOT ( $my_rules ) `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE NOT ( $my_rules )
   ORDER BY EVENT_NAME, OBJECT_INSTANCE, STATEMENT, RUN;
   let $print_details= 1;
}

--echo # 4.2 Results must be stable
#==========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_WRITE = 13
  WHERE statement LIKE '%WHERE col1 = 3'
    AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND EVENT_NAME LIKE '%client_connection'
  LIMIT 1;
  --disable_info
}

# eval
# SELECT
# $column_list
# FROM mysqltest.socket_summary_by_instance_detail
# WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
# ORDER BY EVENT_NAME, statement,run;

# In case we are able to wait all time till perfschema has finished the
# maintenance of counters than the following must be valid.
let $my_rules=
COUNT(DISTINCT SUM_NUMBER_OF_BYTES_READ)  = 1 AND
COUNT(DISTINCT COUNT_WRITE)               = 1 AND
COUNT(DISTINCT SUM_NUMBER_OF_BYTES_WRITE) = 1;

# In case we do not get the results somehow deterministic than we
# we should go with the less strict check based on CV.
#
# Compute coefficient of variation (CV) to detect 'notable' variances in the
# byte count and operation counts. The acceptable range for the CV is purely
# subjective, however, the CV is a dimensionless quantity therefore valid
# across platforms.
# let $my_rules=
# STD(COUNT_READ)/AVG(COUNT_READ)                               <= 0.2 AND
# STD(SUM_NUMBER_OF_BYTES_READ)/AVG(SUM_NUMBER_OF_BYTES_READ)   <= 0.2 AND
# STD(COUNT_WRITE)/AVG(COUNT_WRITE)                             <= 0.2 AND
# STD(SUM_NUMBER_OF_BYTES_WRITE)/AVG(SUM_NUMBER_OF_BYTES_WRITE) <= 0.2 AND
# STD(COUNT_MISC)/AVG(COUNT_MISC)                               <= 0.4;

let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
GROUP BY EVENT_NAME, statement
HAVING NOT ($my_rules) ;
if(`SELECT COUNT(statement) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for GROUP BY EVENT_NAME, statement
   eval
   SELECT $column_list
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
     AND (EVENT_NAME, statement)
         IN (SELECT EVENT_NAME, statement
             $part)
   ORDER BY EVENT_NAME, statement, run, OBJECT_INSTANCE_BEGIN;
   let $print_details= 1;
}

--echo # 4.3 Counters must be 0 in client_connection for the default session
--echo #     Instrumenting is disabled since a long time and the counter were
--echo #     reset via TRUNCATE just after the disabling.
#==========================================================================
let $my_rules=
COUNT_STAR  = 0 AND SUM_TIMER_WAIT  = 0
AND
COUNT_READ  = 0 AND SUM_TIMER_READ  = 0 AND SUM_NUMBER_OF_BYTES_READ  = 0
AND
COUNT_WRITE = 0 AND SUM_TIMER_WRITE = 0 AND SUM_NUMBER_OF_BYTES_WRITE = 0
AND
COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0;
if(`SELECT COUNT(*) FROM performance_schema.socket_summary_by_instance
    WHERE NOT ( $my_rules )
      AND OBJECT_INSTANCE_BEGIN = @default_object_instance_begin`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   # Attention: We use here performance_schema.socket_summary_by_instance
   #            and not mysqltest.socket_summary_by_instance_detail.
   #            Therefore the convenient $column_list cannot be used.
   eval
   SELECT
      COUNT_STAR, SUM_TIMER_WAIT,
      COUNT_READ,SUM_TIMER_READ,SUM_NUMBER_OF_BYTES_READ,
      COUNT_WRITE,SUM_TIMER_WRITE,SUM_NUMBER_OF_BYTES_WRITE,
      COUNT_MISC,SUM_TIMER_MISC
   FROM performance_schema.socket_summary_by_instance
   WHERE OBJECT_INSTANCE_BEGIN = @default_object_instance_begin;
   let $print_details= 1;
}

#---------------------------------------------------------------------------

--echo # 4.4 Check the differences caused by SQL statements
--echo # 4.4.1 There must be no changes in counters of instances
--echo #       NOT LIKE '%client_connection' because everything gets charged
--echo #       into client_connection of the acting connection.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_WRITE = 13
  WHERE statement LIKE '%WHERE col1 = 3'
    AND EVENT_NAME NOT LIKE '%client_connection'
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_READ  = 0 AND SUM_TIMER_READ  = 0 AND SUM_NUMBER_OF_BYTES_READ  = 0
AND
COUNT_WRITE = 0 AND SUM_TIMER_WRITE = 0 AND SUM_NUMBER_OF_BYTES_WRITE = 0
AND
COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
    WHERE NOT ( $my_rules )
      AND EVENT_NAME NOT LIKE '%client_connection'
      AND statement NOT LIKE 'Connect%';
if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
      $column_list
   $part
   ORDER BY EVENT_NAME, OBJECT_INSTANCE_BEGIN, statement, run;
   let $print_details= 1;
}

--echo # 4.4.2 In case of SELECT and our scenarios even COUNT_READ and COUNT_MISC
--echo #       are stable.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_READ = 13
  WHERE statement LIKE '%WHERE col1 = 3'
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT(DISTINCT COUNT_READ)  = 1 AND
COUNT(DISTINCT COUNT_MISC)  = 1;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement NOT LIKE '%Connect%'
GROUP BY EVENT_NAME, statement
HAVING NOT ($my_rules) ;
if(`SELECT COUNT(statement) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for GROUP BY EVENT_NAME, statement
   eval
   SELECT $column_list
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
     AND (EVENT_NAME, statement)
         IN (SELECT EVENT_NAME, statement
             $part)
   ORDER BY EVENT_NAME, statement, run, OBJECT_INSTANCE_BEGIN;
   let $print_details= 1;
}

--echo # 4.4.3 In our testing scenarios we get for the client_connection entry
--echo #       of the acting connection
--echo #       -> OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
--echo #       COUNT_MISC = 0 AND SUM_TIMER_MISC = 0
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_MISC = 13
  WHERE statement LIKE '%WHERE col1 = 3'
    AND EVENT_NAME LIKE '%client_connection'
    AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_MISC = 0 AND SUM_TIMER_MISC = 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE NOT ( $my_rules )
      AND EVENT_NAME LIKE '%client_connection'
      AND statement NOT LIKE 'Connect%'
      AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin;
if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
      $column_list
   $part
   ORDER BY EVENT_NAME, OBJECT_INSTANCE_BEGIN, statement, run;
   let $print_details= 1;
}

# Initialize variables
let $my_rules= my_rules_not_set;
let $stmt1=    stmt1_not_set;
let $stmt2=    stmt2_not_set;
# $title_prefix is used for the generation of titles
let $title_prefix= 4.4;
# $check_num is used for the generation of titles and gets incremented after
# every call of the current script.
let $check_num= 4;
# $column_list is used for the generation of error information and valid for
# every sub test.
let $diff_column_list=
t2.COUNT_READ - t1.COUNT_READ AS D_COUNT_READ,
t2.COUNT_READ                 AS S2_COUNT_READ,
t1.COUNT_READ                 AS S1_COUNT_READ,
t2.SUM_NUMBER_OF_BYTES_READ - t1.SUM_NUMBER_OF_BYTES_READ AS D_SUM_NUMBER_OF_BYTES_READ,
t2.SUM_NUMBER_OF_BYTES_READ                               AS S2_SUM_NUMBER_OF_BYTES_READ,
t1.SUM_NUMBER_OF_BYTES_READ                               AS S1_SUM_NUMBER_OF_BYTES_READ,
t2.COUNT_WRITE - t1.COUNT_WRITE AS D_COUNT_WRITE,
t2.COUNT_WRITE                  AS S2_COUNT_WRITE,
t1.COUNT_WRITE                  AS S1_COUNT_WRITE,
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE AS D_SUM_NUMBER_OF_BYTES_WRITE,
t2.SUM_NUMBER_OF_BYTES_WRITE                                AS S2_SUM_NUMBER_OF_BYTES_WRITE,
t1.SUM_NUMBER_OF_BYTES_WRITE                                AS S1_SUM_NUMBER_OF_BYTES_WRITE,
t2.COUNT_MISC - t1.COUNT_MISC AS D_COUNT_MISC,
t2.COUNT_MISC                 AS S2_COUNT_MISC,
t1.COUNT_MISC                 AS S1_COUNT_MISC;
# $part is used for the generation of "check" statements + error information
# and valid for every sub test.
let $part=
FROM mysqltest.socket_summary_by_instance_detail t1
JOIN mysqltest.socket_summary_by_instance_detail t2
USING (EVENT_NAME, OBJECT_INSTANCE_BEGIN, run)
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE ('%client_connection')
  AND run = 1;

--echo # Check the differences between changes caused by SQL statements
--echo # These differences must correspond to parameters like
--echo # - statement, table name or column name length
--echo # - number of rows in result set, size of rows in result set etc.
#            --> Statement NOT LIKE '%Connect%'

let stmt1= SELECT col2 FROM does_not_exist;
let stmt2= SELECT col2 FROM does_not_exist WHERE col1 = 0;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         36         1         59         1 SELECT col2 FROM does_not_exist
#        3         51         1         59         1 SELECT col2 FROM does_not_exist WHERE col1 = 0
# The string of the statement gets charged into SUM_NUMBER_OF_BYTES_READ.
# The server error message gets charged into SUM_NUMBER_OF_BYTES_WRITE.
let $msg=
# One statement is longer than the other.
# Both statements fail with the same error message (table does not exist);
#
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE = 0  AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt1= SELECT col2 FROM does_not_exist WHERE col1 = 0;
let $stmt2= SELECT col2 FROM does_not_exist WHERE col1 A 0;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         51         1         59         1 SELECT col2 FROM does_not_exist WHERE col1 = 0
#        3         51         1        162         1 SELECT col2 FROM does_not_exist WHERE col1 A 0
let $msg=
# Both statements have the same length and fail.
# The length of the error messages differs.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE > 0  AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt1= SELECT col2 FROM does_not_exist;
let $stmt2= SELECT col2 FROM does_not_exist0123;
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         36         1          59        1 SELECT col2 FROM does_not_exist
#        3         40         1          63        1 SELECT col2 FROM does_not_exist0123
let $msg=
# Both statements fail (table does not exist).
# The length of the statement and the length of the error messages differs.
# Reason for both differences is the length of the table name.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

# Assuming that some new check should be added.
# How to enforce that a lot info is printed so that it becomes easy to derive
# the right value for $my_rules?
#----------------------------------------------------------------------------
# let $my_rules= 0;
# This will cause that suite/perfschema/include/socket_check1.inc concludes that
# the check via $my_rules failed and it will print debug information.
# let $stmt1= SELECT col2 FROM does_not_exist WHERE col1 = 0;
# let $stmt2= SELECT col2 FROM does_not_exist WHERE col1 A 0;
# let $my_rules= 0;
# --source ../include/socket_check1.inc

let $stmt2= SELECT col2 AS my_super_col FROM mysqltest.my_aux WHERE col1 = -1;
let $stmt1= SELECT col2 FROM mysqltest.my_aux WHERE col1 = -1;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         54         1          78        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = -1
#        3         70         1          86        1 SELECT col2 AS my_super_col FROM mysqltest.my_aux WHERE col1 = -1
let $msg=
# Both statements get an empty result set.
# The length of the statements and the length of the result sets differs.
# Reason for both differences is the length of the some column name.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE = LENGTH('my_super_col') - LENGTH('col2') AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt2= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1;
let $stmt1= SELECT col2 FROM mysqltest.my_aux WHERE col1 = -1;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
# t1     3         54         1          78        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = -1
# t2     3         53         1          83        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1
let $msg=
# Both statements differ in the statement length.
# One statement earns an empty result set.
# The other statement earns one row containing an empty string.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t1.SUM_NUMBER_OF_BYTES_READ  - t2.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt1') - LENGTH('$stmt2') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE > 0  AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt2= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 2;
let $stmt1= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         53         1          83        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1
#        3         53         1          84        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 2
let $msg=
# Both statements have the same length.
# One statement earns an one row containing an empty string.
# The other statement earns one row containing a string 1 byte long.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE = 1  AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt2= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 3;
let $stmt1= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1;
#
# CNT_READ BYTES_READ CNT_WRITE BYTES_WRITE CNT_MISC statement
#        3         53         1          83        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1
#        3         53         1        1109        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 3
let $msg=
# Both statements have the same length.
# One statement earns an one row containing an empty string.
# The other statement earns one row containing a string 1024 byte long.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE >= 1024 AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

let $stmt2= SELECT col2 FROM mysqltest.my_aux WHERE col1 < 2;
let $stmt1= SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1;
#
# CNT_READ BYTES_READ  CNT_WRITE   BYTES_WRITE CNT_MISC statement
# t1     3         53          1            83        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 = 1
# t2     3         53          1            88        1 SELECT col2 FROM mysqltest.my_aux WHERE col1 < 2
let $msg=
# Both statements have the same length.
# One statement earns an one row containing an empty string.
# The other statement earns two rows containing an empty string.;
let $my_rules=
t2.COUNT_READ                - t1.COUNT_READ                = 0  AND
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1') AND
t2.COUNT_WRITE               - t1.COUNT_WRITE               = 0  AND
t2.SUM_NUMBER_OF_BYTES_WRITE - t1.SUM_NUMBER_OF_BYTES_WRITE > 0  AND
t2.COUNT_MISC                - t1.COUNT_MISC                = 0;
--source ../include/socket_check1.inc

--echo # 4.5 Check the differences caused by Connects
--echo #     Attention: Succesful Connects run an additional "DO 1".
--echo # 4.5.1 Connects do not charge anything into READ or WRITE counters
--echo #       of the instance with EVENT_NAME NOT LIKE ('%client_connection%').
--echo #       This mean all these counters must be 0.
let $my_rules=
COUNT_READ  = 0 AND SUM_TIMER_READ  = 0 AND SUM_NUMBER_OF_BYTES_READ  = 0 AND
COUNT_WRITE = 0 AND SUM_TIMER_WRITE = 0 AND SUM_NUMBER_OF_BYTES_WRITE = 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%')
  AND EVENT_NAME NOT LIKE ('%client_connection%')
  AND NOT ( $my_rules );
if(`SELECT COUNT(*) $part `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.2 Connects using for host the value 'localhost'
--echo # 4.5.2.1 For the instance with EVENT_NAME LIKE '%server_tcpip_socket'
--echo #         COUNT_MISC = 0 AND SUM_TIMER_MISC = 0 must be valid
--echo #         because we run through server_unix_socket.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_MISC  = 13
  WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND statement LIKE ('%Connect%localhost%')
    AND EVENT_NAME LIKE ('%server_tcpip_socket%')
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%localhost%')
  AND EVENT_NAME LIKE ('%server_tcpip_socket%')
  AND NOT ( $my_rules );
if(`SELECT COUNT(*) $part `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.2.2 For the instance with EVENT_NAME LIKE '%server_unix_socket'
--echo #         COUNT_MISC > 0 must be valid.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_MISC  = 0
  WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND statement LIKE ('%Connect%localhost%')
    AND EVENT_NAME LIKE ('%server_unix_socket%')
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_MISC  > 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%localhost%')
  AND EVENT_NAME LIKE ('%server_unix_socket%')
  AND NOT ( $my_rules );
if(`SELECT COUNT(*) $part `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.3 Connects using for host a value <> 'localhost'
--echo # 4.5.3.1 For the instance with EVENT_NAME LIKE '%server_unix_socket'
--echo #         COUNT_MISC = 0 AND SUM_TIMER_MISC = 0 must be valid
--echo #         because we run through server_tcpip_socket.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  eval
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_MISC  = 13
  WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND EVENT_NAME LIKE ('%server_unix_socket%')
    AND statement LIKE ('%Connect%$my_localhost%')
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%$my_localhost%')
  AND EVENT_NAME LIKE ('%server_unix_socket%')
  AND NOT ( $my_rules );
if(`SELECT COUNT(*) $part `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.3.2 For the instance with EVENT_NAME LIKE '%server_tcpip_socket'
--echo #         COUNT_MISC > 0 must be valid.
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  eval
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET COUNT_MISC  = 0
  WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%$my_localhost%')
  AND EVENT_NAME LIKE ('%server_tcpip_socket%')
  LIMIT 1;
  --disable_info
}

let $my_rules=
COUNT_MISC  > 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('%Connect%$my_localhost%')
  AND EVENT_NAME LIKE ('%server_tcpip_socket%')
  AND NOT ( $my_rules );
if(`SELECT COUNT(*) $part `)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.4 Failing Connects do not cause any row with EVENT_NAME
--echo #       LIKE '%client_connection'
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  eval
  UPDATE mysqltest.socket_summary_by_instance_detail
  SET statement = 'Connect boot '
  WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND statement LIKE ('Connect%root%')
    AND EVENT_NAME LIKE ('%client_connection')
  LIMIT 1;
  --disable_info
}

let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('Connect%boot%')
  AND EVENT_NAME LIKE ('%client_connection');
if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect that there are no rows because
   --echo # - failing connects do not cause a row with "client_connection"
   --echo # - all failing connects contain a user name LIKE '%boot%'
   eval
   SELECT
   $column_list
   $part;
   let $print_details= 1;
}

--echo # 4.5.5 Successful Connects cause a new instance with EVENT_NAME
--echo #       LIKE '%client_connection'
#===========================================================================
# Enable the following lines for debugging the check.
# Attention: socket_summary_by_instance_detail is after that rotten.
if(0)
{
  --enable_info
  DELETE
  FROM mysqltest.socket_summary_by_instance_detail
  WHERE EVENT_NAME LIKE ('%client_connection')
    AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
    AND statement LIKE ('Connect%root%')
  LIMIT 1;
  --disable_info
}

# - connects which should be successful have statement LIKE ('Connect%root%').
# - We try every type of Connect $loop_rounds times.
#   Therefore we should find $loop_rounds rows with
#   - EVENT_NAME LIKE ('%client_connection')
#   AND
#   - OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
#     We do not want to count the entry of belonging to the default connection.
#   AND
#   - statement LIKE ('Connect%root%')
#     The connects which should be successful.
#
let $my_rules=
COUNT(*) = $loop_rounds;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE EVENT_NAME LIKE ('%client_connection')
  AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND statement LIKE ('Connect%root%')
GROUP BY statement
HAVING NOT ( $my_rules );

if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for GROUP BY statement
   --echo #
   eval
   SELECT
   $column_list
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE EVENT_NAME LIKE ('%client_connection')
     AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
     AND statement IN
         (SELECT statement
          $part);
   let $print_details= 1;
}

--echo # 4.6 Check the differences caused by Connects
--echo #     - INSTANCES with an EVENT_NAME like server_tcpip_socket or
--echo #       server_unix_socket are already checked
--echo #     - the stability of results is already checked
--echo #       So we con go with the results of the first run.

# Typical content of mysqltest.socket_summary_by_instance_detail
#
# eval
# SELECT $column_list
# FROM mysqltest.socket_summary_by_instance_detail
# WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
#   AND EVENT_NAME LIKE ('%client_connection')
#   AND statement LIKE ('Connect%')
#   AND run = 1
# ORDER BY event_name,statement, run;
# CREAD    TREAD BREAD CWRITE   TWRITE BWRITE CMISC    TMISC STATEMENT
#     4  6149616    79      3 34008480    117     3 38914128 Connect (con*,::ffff:127.0.0.1,root,,mysqltest,,)
#     4  7012368    84      3 10112256    117     2 43067376 Connect (con*,localhost,root,,mysqlsupertest,,)
#     4  7172880    79      3 10247688    117     2 40128000 Connect (con*,localhost,root,,mysqltest,,)
#     4  6706392    85      3 15509472    117     2 34851168 Connect (con*,localhost,root012345,,mysqltest,,)
#     4 10543632    89      3 10578744    117     2 39460872 Connect (con*,localhost,root0123456789,,mysqltest,,)

--echo # 4.6.1 The SUM_OF_BYTES_WRITE value is the same for all Connects.
#========================================================================
let $my_rules= COUNT(DISTINCT SUM_NUMBER_OF_BYTES_WRITE) = 1;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE ('%client_connection')
  AND statement LIKE ('Connect%')
  AND run = 1;
if(`SELECT NOT ( $my_rules) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for all Connects
   --echo #
   eval
   SELECT
   statement, SUM_NUMBER_OF_BYTES_WRITE
   $part;
   let $print_details= 1;
}

--echo # 4.6.2 The SUM_OF_BYTES_WRITE value hast to be > 100.
#============================================================
let $my_rules= SUM_NUMBER_OF_BYTES_WRITE > 100;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE ('%client_connection')
  AND statement LIKE ('Connect%')
  AND NOT ( $my_rules )
  AND run = 1;
if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for all Connects
   --echo #
   eval
   SELECT
   statement, SUM_NUMBER_OF_BYTES_WRITE
   $part;
   let $print_details= 1;
}

--echo # 4.6.3 COUNT_READ, COUNT_WRITE and COUNT_MISC have to be to be > 0
#=========================================================================
let $my_rules=
COUNT_READ > 0 AND COUNT_WRITE > 0 AND COUNT_MISC > 0;
let $part=
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE ('%client_connection')
  AND statement LIKE ('Connect%')
  AND NOT ( $my_rules )
  AND run = 1;
if(`SELECT COUNT(*) $part`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo # for all Connects
   --echo #
   eval
   SELECT
   statement, COUNT_READ, COUNT_WRITE, COUNT_MISC
   $part;
   let $print_details= 1;
}

--echo # 4.6.4 Checks based on comparison of results for connects
let $part0=
FROM mysqltest.socket_summary_by_instance_detail t1
JOIN mysqltest.socket_summary_by_instance_detail t2
USING (EVENT_NAME, run)
WHERE EVENT_NAME LIKE ('%client_connection')
  AND run = 1
  AND t2.OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND t1.OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin;
let $part1=
SELECT RPAD(statement,55,' ') AS STATEMENT,
       LENGTH(statement), SUM_NUMBER_OF_BYTES_READ
FROM mysqltest.socket_summary_by_instance_detail
WHERE OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
  AND EVENT_NAME LIKE ('%client_connection')
  AND run = 1;


--echo # 4.6.4 The user name length affects the SUM_OF_BYTES_READ value
#======================================================================
# CREAD    TREAD BREAD CWRITE   TWRITE BWRITE CMISC    TMISC STATEMENT
#     4  6706392    85      3 15509472    117     2 34851168 Connect (con*,localhost,root012345,,mysqltest,,)
#     4 10543632    89      3 10578744    117     2 39460872 Connect (con*,localhost,root0123456789,,mysqltest,,)
let $stmt2= Connect (con*,localhost,root0123456789,,mysqltest,,);
let $stmt1= Connect (con*,localhost,root012345,,mysqltest,,);
let $my_rules=
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1');
if(`SELECT NOT ($my_rules)
    $part0
    AND t2.statement = '$stmt2'
    AND t1.statement = '$stmt1'`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   $part1
   AND statement IN('$stmt2','$stmt1');
   let $print_details= 1;
}

--echo # 4.6.5 The database name length affects the SUM_OF_BYTES_READ value
#==========================================================================
# CREAD    TREAD BREAD CWRITE   TWRITE BWRITE CMISC    TMISC STATEMENT
#     4  7012368    84      3 10112256    117     2 43067376 Connect (con*,localhost,root,,mysqlsupertest,,)
#     4  7172880    79      3 10247688    117     2 40128000 Connect (con*,localhost,root,,mysqltest,,)
let $stmt2= Connect (con*,localhost,root,,mysqlsupertest,,);
let $stmt1= Connect (con*,localhost,root,,mysqltest,,);
let $my_rules=
t2.SUM_NUMBER_OF_BYTES_READ  - t1.SUM_NUMBER_OF_BYTES_READ  = LENGTH('$stmt2') - LENGTH('$stmt1');
if(`SELECT NOT ($my_rules)
    $part0
    AND t2.statement = '$stmt2'
    AND t1.statement = '$stmt1'`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   $part1
   AND statement IN('$stmt2','$stmt1');
   let $print_details= 1;
}

--echo # 5. Check the impact of TRUNCATE on socket_summary_by_instance.
--echo #    It must reset all counters.
#=======================================================================
# We do not need to check if the majority of counters is <> 0 because if
# we ever hit such a bad state than a lot of the preceding checks would
# have already failed and reported this.
TRUNCATE TABLE performance_schema.socket_summary_by_instance;
let $my_rules=
COUNT_STAR  = 0 AND SUM_TIMER_WAIT  = 0
AND
COUNT_READ  = 0 AND SUM_TIMER_READ  = 0 AND SUM_NUMBER_OF_BYTES_READ  = 0
AND
COUNT_WRITE = 0 AND SUM_TIMER_WRITE = 0 AND SUM_NUMBER_OF_BYTES_WRITE = 0
AND
COUNT_MISC  = 0 AND SUM_TIMER_MISC  = 0;
if(`SELECT COUNT(*) FROM performance_schema.socket_summary_by_instance
    WHERE NOT ( $my_rules )
      AND OBJECT_INSTANCE_BEGIN = @default_object_instance_begin`)
{
   --enable_query_log
   --enable_result_log
   --echo # The statistics looks suspicious.
   --echo # We expect
   --echo #    $my_rules
   --echo #
   eval
   SELECT
      COUNT_STAR, SUM_TIMER_WAIT,
      COUNT_READ,SUM_TIMER_READ,SUM_NUMBER_OF_BYTES_READ,
      COUNT_WRITE,SUM_TIMER_WRITE,SUM_NUMBER_OF_BYTES_WRITE,
      COUNT_MISC,SUM_TIMER_MISC
   FROM performance_schema.socket_summary_by_instance
   WHERE OBJECT_INSTANCE_BEGIN = @default_object_instance_begin;
}


if($print_details)
{
   --enable_query_log
   --enable_result_log
   --horizontal_results
   --echo # Dump detailed differences after - before statement execution
   --echo # 1. The statement executing connection and hopefully noone else
   SELECT @default_object_instance_begin;
   SELECT EVENT_NAME, OBJECT_INSTANCE_BEGIN,
          COUNT_READ,  SUM_NUMBER_OF_BYTES_READ,
          COUNT_WRITE, SUM_NUMBER_OF_BYTES_WRITE,
          COUNT_MISC,  statement
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE EVENT_NAME LIKE '%client_connection%'
     AND OBJECT_INSTANCE_BEGIN <> @default_object_instance_begin
   ORDER BY statement, run;
   --echo # 2. The connection default
   SELECT EVENT_NAME,
          COUNT_READ,  SUM_NUMBER_OF_BYTES_READ,
          COUNT_WRITE, SUM_NUMBER_OF_BYTES_WRITE,
          COUNT_MISC,  statement
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE OBJECT_INSTANCE_BEGIN = @default_object_instance_begin
   ORDER BY statement,run;
   --echo # 3. The "server_unix_socket"
   # WHERE OBJECT_INSTANCE_BEGIN = @default_object_instance_begin
   SELECT EVENT_NAME,
          COUNT_READ,  SUM_NUMBER_OF_BYTES_READ,
          COUNT_WRITE, SUM_NUMBER_OF_BYTES_WRITE,
          COUNT_MISC,  statement
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE EVENT_NAME LIKE '%server_unix_socket%'
   ORDER BY statement,run;
   --echo # 4. The "server_tcpip_socket"
   SELECT EVENT_NAME,
          COUNT_READ,  SUM_NUMBER_OF_BYTES_READ,
          COUNT_WRITE, SUM_NUMBER_OF_BYTES_WRITE,
          COUNT_MISC,  statement
   FROM mysqltest.socket_summary_by_instance_detail
   WHERE EVENT_NAME LIKE '%server_tcpip_socket%'
   ORDER BY statement,run;
   --echo # 5. mysqltest.my_socket_summary_by_instance
   --vertical_results
   SELECT * FROM mysqltest.my_socket_summary_by_instance;
   --horizontal_results
}

--echo # 6. Cleanup
#==================
# Cleanup
--disable_query_log
eval
UPDATE performance_schema.setup_timers
SET TIMER_NAME = '$wait_timer'
WHERE NAME = 'wait';
DROP SCHEMA mysqltest;
DROP SCHEMA mysqlsupertest;
--connection con1
--disconnect con1
--source include/wait_until_disconnected.inc
--connection default
--enable_query_log

