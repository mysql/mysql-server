--source include/no_valgrind_without_big.inc
# suite/funcs_1/t/storedproc.test
#
# Check general properties of stored procedures.
#
############################################################################

# Bug#37746 - Arithmetic range ("int") is smaller than expected
# This code is in place to ensure this test is only skipped
# for the Win64 platform
if(`SELECT CONVERT(@@version_compile_os using latin1) IN ("Win64")`)
{
--skip Bug#37746 2009-07-07 pcrews Arithmetic range ("int") is smaller than expected
}

# It is assumed that the storage engine used for some tables has no impact on
# the outcome of this test.
let $engine_type= InnoDB;

--source suite/funcs_1/storedproc/load_sp_tb.inc
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';

# Set names can be removed after Bug#25974249 is fixed
set names latin1;
# ==============================================================================
echo;
echo
Section 3.1.1 - Syntax checks for the CREATE PROCEDURE, CREATE
FUNCTION, ALTER PROCEDURE, ALTER FUNCTION, DROP PROCEDURE, DROP FUNCTION, SHOW
CREATE PROCEDURE, SHOW CREATE FUNCTION, SHOW CREATE PROCEDURE STATUS, SHOW
CREATE FUNCTION STATUS, and CALL statements:;
echo --------------------------------------------------------------------------------;


# ------------------------------------------------------------------------------
echo;
echo
Testcase 4.1.1:
---------------
Ensure that all clauses that should be supported are supported
CREATE PROCEDURE;
echo --------------------------------------------------------------------------------;

USE db_storedproc;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
--error ER_TOO_LONG_IDENT
DROP PROCEDURE IF EXISTS sp1_thisisaveryverylongname234872934_thisisaveryverylongname234872934;

--error ER_TOO_LONG_IDENT
CREATE PROCEDURE sp1_thisisaveryverylongname234872934_thisisaveryverylongname234872934 (f1 char(20) )
            SELECT * from t1 where f2 = f1;
--error ER_TOO_LONG_IDENT
CALL sp1_thisisaveryverylongname234872934_thisisaveryverylongname234872934('aaaa');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
--error ER_TOO_LONG_IDENT
DROP PROCEDURE IF EXISTS sp1_thisisaveryverylongname234872934_thisisaveryverylongnameabcde;

delimiter //;
--error ER_TOO_LONG_IDENT
CREATE PROCEDURE sp1_thisisaveryverylongname234872934_thisisaveryverylongnameabcde( f1 TINYTEXT )
   LANGUAGE SQL DETERMINISTIC SQL SECURITY DEFINER COMMENT 'this is simple'
BEGIN
   SET @v1 = f1;
   SELECT @v1, @v1;
END//
delimiter ;//

--error ER_TOO_LONG_IDENT
CALL sp1_thisisaveryverylongname234872934_thisisaveryverylongnameabcde( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 BINARY )
   LANGUAGE SQL DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET @v1 = f1;
   SELECT @v1;
END//
delimiter ;//

CALL sp1( 34 );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 BLOB )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   set @v1 = f1;
   SELECT @v1;
END//
delimiter ;//

CALL sp1( 34 );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 INT )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET @v1 = f1;
   SELECT @v1;
END//
delimiter ;//

CALL sp1( 34 );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_TOO_BIG_PRECISION
CREATE PROCEDURE sp1( f1 DECIMAL(256, 30) )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET @v1 = f1;
   SELECT @v1;
END//
DROP PROCEDURE IF EXISTS sp1//

--error ER_TOO_BIG_PRECISION
CREATE PROCEDURE sp1( f1 DECIMAL(66, 30) )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET @v1 = f1;
   SELECT @v1;
END//
DROP PROCEDURE IF EXISTS sp1//
delimiter ;//


# Check assignment of float values to DECIMAL(65, 30) parameters of
# PRODDUREs and FUNCTIONs.
###########################################################################
# - The assignment of float values causes that conversions with OS/compiler
#   specific math libraries are involved.
#   --> The content depends on the testing box and simple printing
#       of content will often lead to differences.
# - We have the same conversions when assigning float values to columns
#   of tables.
# --> Reveal that we have a consistent behaviour per testing box.
#
# Checks that floating point values assigned to objects of type DECIMAL
# end up with correct DECIMAL values (truncated to a border of the DECIMAL
# value range or reasonable nearby the floating point value) must be done
# in other tests.
###########################################################################
--disable_warnings
DROP TABLE IF EXISTS t1_aux;
DROP PROCEDURE IF EXISTS sproc_1;
DROP FUNCTION IF EXISTS func_1;
--enable_warnings
CREATE TABLE t1_aux ( f1 DECIMAL(65, 30) );
INSERT INTO t1_aux SET f1 = NULL;
delimiter //;
CREATE PROCEDURE sproc_1(f1 DECIMAL(65, 30), OUT f2 DECIMAL(65, 30))
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET f2 = NULL;
   SET f2 = f1;
   SET @v2_proc = f1;
END//
CREATE FUNCTION func_1(f1 DECIMAL(65, 30)) RETURNS DECIMAL(65,30)
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
    RETURN f1;
END//
delimiter ;//
--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';
--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS WHERE db = 'db_storedproc';

let $test_value = 1.7976931348623157493578e+308;
--source suite/funcs_1/storedproc/param_check.inc
#
# Check all ...E+nnn
let digits= 100;
let $run= 1;
while ($run)
{
   let $test_value = 0.1234567890987654321e+$digits;
   --source suite/funcs_1/storedproc/param_check.inc
   let $run = `SELECT $digits > 0`;
   if ($run)
   {
      dec $digits;
   }
}
# Check all ...E-nnn
let digits= 100;
let $run= 1;
while ($run)
{
   let $test_value = 0.1234567890987654321e-$digits;
   --source suite/funcs_1/storedproc/param_check.inc
   let $run = `SELECT $digits > 0`;
   if ($run)
   {
      dec $digits;
   }
}

# Cleanup
DROP PROCEDURE sproc_1;
DROP FUNCTION  func_1;
DROP TABLE     t1_aux;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 ENUM("value1", "value1") )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SELECT f1;
END//
delimiter ;//

CALL sp1( "value1" );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 SET("value1", "value1") )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SELECT f1;
END//
delimiter ;//

CALL sp1( "value1, value1" );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 ENUM("value1", "value1") )
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SELECT f1;
END//
delimiter ;//

CALL sp1( "value1" );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS WHERE db = 'db_storedproc';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 TEXT ) LANGUAGE SQL SELECT f1;

CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 text ) deterministic SELECT f1;
CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 TEXT ) NOT DETERMINISTIC SELECT f1;
CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 TEXT ) SQL SECURITY DEFINER SELECT f1;
CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 TEXT ) SQL SECURITY INVOKER SELECT f1;
CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1( f1 TEXT ) COMMENT 'this is simple' SELECT f1;
CALL sp1( 'abc' );

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE STATUS LIKE 'sp1';

# cleanup
DROP PROCEDURE sp1_thisisaveryverylongname234872934_thisisaveryverylongname234872934;
DROP PROCEDURE sp1_thisisaveryverylongname234872934_thisisaveryverylongnameabcde;
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.2:
              ---------------
              Ensure that all clauses that should be supported are supported
              CREATE FUNCTION;
--source include/show_msg80.inc


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

CREATE FUNCTION fn1 (s CHAR(20)) RETURNS CHAR(50)
   RETURN CONCAT('hello, ', s, '!');
SELECT fn1('world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 MEDIUMTEXT ) RETURNS MEDIUMTEXT
   LANGUAGE SQL DETERMINISTIC SQL SECURITY DEFINER COMMENT 'this is simple'
BEGIN
   SET @v1 = 'hello';
   SET f1 = CONCAT( @v1, f1 );
   RETURN f1;
END//
delimiter ;//

SELECT fn1( ' world');

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
# 1425: Too big scale 63 specified for column ''. Maximum is 30.
--error ER_TOO_BIG_SCALE
CREATE FUNCTION fn1( f1 DECIMAL(63, 31) ) RETURNS DECIMAL(63, 31)
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET f1 = 1000000 + f1;
   RETURN f1;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
SELECT fn1( 1.3326e+8 );

delimiter //;
CREATE FUNCTION fn1( f1 DECIMAL(63, 30) ) RETURNS DECIMAL(63, 30)
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   SET f1 = 1000000 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 1.3326e+8 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 ENUM("value1", "value1") ) RETURNS DECIMAL(63, 30)
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   RETURN f1;
END//
delimiter ;//

# warnings for this select disabled due to diffs with/without --ps-protocol:
# without ps-protocol the following warning is shown:
# +Note   1291    Column '' has duplicated value 'value1' in SET
# +Warning        1265    Data truncated for column 'f1' at row 1
# Reported as BUG#33396
--disable_warnings ER_DUPLICATED_VALUE_IN_TYPE ONCE
SELECT fn1( "value1" );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SET("value1", "value1") ) RETURNS DECIMAL(63, 30)
   LANGUAGE SQL NOT DETERMINISTIC SQL SECURITY INVOKER COMMENT 'this is simple'
BEGIN
   RETURN f1;
END//
delimiter ;//

# warnings for this select disabled due to diffs with/without --ps-protocol:
# without ps-protocol the following warning is shown:
# +Note   1291    Column '' has duplicated value 'value1' in SET
# +Warning        1265    Data truncated for column 'f1' at row 1
# Reported as BUG#33396
--disable_warnings WARN_DATA_TRUNCATED,ER_DUPLICATED_VALUE_IN_TYPE ONCE
SELECT fn1( "value1, value1" );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT LANGUAGE SQL
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT DETERMINISTIC
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT NOT DETERMINISTIC
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT SQL SECURITY DEFINER
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT SQL SECURITY INVOKER
BEGIN
  SET f1 = 1 + f1;
  RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 SMALLINT ) RETURNS SMALLINT COMMENT 'this is simple'
BEGIN
   SET f1 = 1 + f1;
   RETURN f1;
END//
delimiter ;//

SELECT fn1( 126 );

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

# cleanup
DROP FUNCTION fn1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.3:
              ---------------
              Ensure that all clauses that should be supported are supported
              SHOW CREATE PROC;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

CREATE PROCEDURE sp1 (f1 char(20) )
    SELECT * from t1 where f2 = f1;

--replace_column 5 <modified> 6 <created>
show CREATE PROCEDURE sp1;

# cleanup
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.4:
              ---------------
show create function;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

CREATE FUNCTION fn1 (s char(20)) returns char(50)
   return concat('hello, ', s, '!');

--replace_column 5 <modified> 6 <created>
show CREATE FUNCTION fn1;

# cleanup
DROP FUNCTION fn1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.5:
              ---------------
SHOW PROCEDURE status;
--source include/show_msg80.inc


CREATE PROCEDURE sp5()
   SELECT * from t1;

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp5';

# cleanup
DROP PROCEDURE sp5;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.6:
              ---------------
show function status;
--source include/show_msg80.inc


delimiter //;
CREATE FUNCTION fn5(a int) returns int
BEGIN
   set @b = 0.9 * a;
   return @b;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn5';

# cleanup
DROP FUNCTION fn5;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.7:
              ---------------
CALL procedure;
--source include/show_msg80.inc

--disable_warnings
DROP PROCEDURE IF EXISTS sp7a;
DROP PROCEDURE IF EXISTS sp7b;
DROP PROCEDURE IF EXISTS sp7c;
--enable_warnings

CREATE PROCEDURE sp7a(a char(20))
    SELECT * from t1 where t1.f2 = a;

CALL sp7a( 'xyz' );

CREATE PROCEDURE sp7b (a char (20), out b char(20))
    SELECT f1 into b from t1 where t1.f2= a;

CALL sp7b('xyz', @out_param);
SELECT @out_param;

delimiter //;
CREATE PROCEDURE sp7c (a char (20), out b char(20), inout c int)
BEGIN
SELECT f1 into b from t1 where t1.f2=a;
   update t1 set t1.f2=999 where t1.f4=c;
SELECT f2 into c from t1 where t1.f2=999;
END//
delimiter ;//

--disable_warnings
set @c=1;
CALL sp7c('xyz', @out_param, @c);
SELECT @out_param;
SELECT @c;
--enable_warnings

# cleanup
DROP PROCEDURE sp7a;
DROP PROCEDURE sp7b;
DROP PROCEDURE sp7c;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.8:
              ---------------
calling function;
--source include/show_msg80.inc


CREATE FUNCTION fn8(a char(20)) returns char(50)
return concat('hello, ', a, '!');
SELECT fn8('world');

# cleanup
DROP FUNCTION fn8;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.9:
              ---------------
drop procedure;
--source include/show_msg80.inc

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp9;

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

CREATE PROCEDURE sp9()SELECT * from t1;

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

DROP PROCEDURE sp9;

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

CREATE PROCEDURE sp9()SELECT * from t1;

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

DROP PROCEDURE IF EXISTS sp9;

--sorted_result
--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='sp9';

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.10:
              ----------------
DROP FUNCTION;
--source include/show_msg80.inc

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn10;

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';


CREATE FUNCTION fn10() returns int return 100;

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';

DROP FUNCTION fn10;

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';

CREATE FUNCTION fn10() returns int return 100;

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';

DROP FUNCTION IF EXISTS fn10;

--replace_column 24 <created> 25 <modified>
SELECT * from information_schema.routines where specific_name='fn10' and routine_type='FUNCTION';


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.11:
              ----------------
alter proc;
--source include/show_msg80.inc


create user 'user_1'@'localhost';
grant execute on db_storedproc.* to 'user_1'@'localhost';
flush privileges;
drop table IF EXISTS mysql.t1;
create table mysql.t1( f1 char );
DROP PROCEDURE IF EXISTS sp11;
CREATE PROCEDURE sp11() insert into mysql.t1 values('a');
SELECT security_type from information_schema.routines where specific_name='sp11';

--replace_result $MASTER_MYPORT MYSQL_PORT $MASTER_MYSOCK MYSQL_SOCK
connect (u_1, localhost, user_1, , db_storedproc);
--source suite/funcs_1/include/show_connection.inc

CALL sp11();

connection default;
USE db_storedproc;
--source suite/funcs_1/include/show_connection.inc

alter procedure sp11 sql security invoker;
SELECT security_type from information_schema.routines where specific_name='sp11';

--replace_result $MASTER_MYPORT MYSQL_PORT $MASTER_MYSOCK MYSQL_SOCK
connection u_1;
--source suite/funcs_1/include/show_connection.inc
USE db_storedproc;

--error ER_TABLEACCESS_DENIED_ERROR
CALL sp11();

commit work;
disconnect u_1;
connection default;
--source suite/funcs_1/include/show_connection.inc

alter procedure sp11 sql security DEFINER;
SELECT security_type from information_schema.routines where specific_name='sp11';
CALL sp11();

# cleanup
DROP USER 'user_1'@'localhost';
DROP PROCEDURE sp11;
drop table mysql.t1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.12:
              ----------------
alter function;
--source include/show_msg80.inc


CREATE FUNCTION fn12() returns int
 return 100;
SELECT security_type from information_schema.routines where specific_name='fn12';
SELECT fn12();

alter function fn12 sql security invoker;
SELECT security_type from information_schema.routines where specific_name='fn12';
SELECT fn12();

alter function fn12 sql security DEFINER;
SELECT security_type from information_schema.routines where specific_name='fn12';
SELECT fn12();

# cleanup
DROP FUNCTION fn12;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.13:
              ----------------
alter proc;
--source include/show_msg80.inc


DROP PROCEDURE IF EXISTS sp11;
CREATE PROCEDURE sp11()
   SELECT * from t1;

SELECT comment from information_schema.routines where specific_name='sp11';
alter procedure sp11 comment 'this is simple';
SELECT comment from information_schema.routines where specific_name='sp11';

# cleanup
DROP PROCEDURE sp11;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.14:
              ----------------
alter function;
--source include/show_msg80.inc

DROP FUNCTION IF EXISTS fn12;
CREATE FUNCTION fn12() returns int
    return 100;
  SELECT routine_comment from information_schema.routines where specific_name='fn12';

  alter function fn12 comment 'this is simple';
  SELECT routine_comment from information_schema.routines where specific_name='fn12';

# cleanup
DROP FUNCTION fn12;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.15:
              ----------------
Ensure that any invalid stored procedure name is never accepted, and that an
appropriate error message is returned when the name is rejected;
--source include/show_msg80.inc


--error ER_SP_NO_DROP_SP
CREATE PROCEDURE sp1()
DROP PROCEDURE sp1;

--error ER_PARSE_ERROR
CREATE PROCEDURE !_sp1( f1 char(20) )
SELECT * from t1 where f2 = f1;

CREATE PROCEDURE `function`()
   SELECT * from t1 where f2=f1;
DROP PROCEDURE `function`;

--error ER_PARSE_ERROR
CREATE PROCEDURE accessible()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE add()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE all()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE alter()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE analyze()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE and()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE as()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE asc()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE asensitive()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE before()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE between()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE bigint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE binary()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE blob()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE both()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE by()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE call()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE cascade()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE case()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE change()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE char()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE character()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE check()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE collate()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE column()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE condition()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE constraint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE continue()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE convert()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE create()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE cross()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE current_date()
  SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE current_time()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE current_timestamp()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE current_user()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE cursor()
  SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE database()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE databases()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE day_hour()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE day_microsecond()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE day_minute()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE day_second()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE dec()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE decimal()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE declare()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE default()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE delayed()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE delete()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE desc()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE describe()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE deterministic()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE distinct()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE distinctrow()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE div()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE double()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE drop()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE dual()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE each()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE else()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE elseif()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE enclosed()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE escaped()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE exists()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE exit()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE explain()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE false()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE fetch()
   SELECT * from t1 where f2=f1;

#--error ER_PARSE_ERROR
CREATE PROCEDURE fields()
   SELECT * from t1 where f2=f1;
DROP PROCEDURE fields;

--error ER_PARSE_ERROR
CREATE PROCEDURE float()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE for()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE force()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE foreign()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE from()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE fulltext()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE grant()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE group()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE having()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE high_priority()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE hour_microsecond()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE hour_minute()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE hour_second()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE if()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE ignore()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE in()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE index()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE infile()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE inner()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE inout()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE insensitive()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE insert()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int1()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int2()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int3()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int4()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE int8()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE integer()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE interval()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE into()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE is()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE iterate()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE join()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE key()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE keys()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE kill()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE leading()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE leave()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE left()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE like()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE limit()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE linear()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE lines()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE load()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE localtime()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE localtimestamp()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE lock()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE long()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE longblob()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE longtext()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE loop()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE low_priority()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE master_ssl_verify_server_cert()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE match()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE mediumblob()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE mediumint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE mediumtext()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE middleint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE minute_microsecond()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE minute_second()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE mod()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE modifies()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE natural()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE not()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE no_write_to_binlog()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE null()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE numeric()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE on()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE optimize()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE option()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE optionally()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE or()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE order()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE out()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE outer()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE outfile()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE precision()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE primary()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE procedure()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE purge()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE range()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE read()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE reads()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE real()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE references()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE regexp()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE release()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE rename()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE repeat()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE replace()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE require()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE restrict()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE return()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE revoke()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE right()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE rlike()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE schema()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE schemas()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE second_microsecond()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE select()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sensitive()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE separator()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE set()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE show()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE smallint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE spatial()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE specific()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sql()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sqlexception()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sqlstate()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sqlwarning()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sql_big_result()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sql_calc_found_rows()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE sql_small_result()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE ssl()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE starting()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE straight_join()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE table()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE terminated()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE then()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE tinyblob()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE tinyint()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE tinytext()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE to()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE trailing()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE trigger()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE true()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE undo()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE union()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE unique()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE unlock()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE unsigned()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE update()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE usage()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE use()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE using()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE utc_date()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE utc_time()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE utc_timestamp()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE values()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE varbinary()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE varchar()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE varcharacter()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE varying()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE when()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE where()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE while()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE with()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE write()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE xor()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE year_month()
   SELECT * from t1 where f2=f1;

--error ER_PARSE_ERROR
CREATE PROCEDURE zerofill()
   SELECT * from t1 where f2=f1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.15:
              ----------------
Ensure that any invalid function name is never accepted, and that an appropriate
error message is returned when the name is rejected;
--source include/show_msg80.inc


--error ER_PARSE_ERROR
CREATE FUNCTION !_fn1(f1 char) returns char
    return f1;

--disable_warnings
--error ER_PARSE_ERROR
CREATE FUNCTION char(f1 char) returns char
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION char binary(f1 char binary) returns char binary
    return f1;
--error ER_PARSE_ERROR
CREATE FUNCTION char ascii(f1 char ascii) returns char ascii
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION char not null(f1 char not null) returns char not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION char binary not null(f1 char binary not null) returns char binary not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION char ascii not null(f1 char ascii not null) returns char ascii not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinytext(f1 tinytext) returns tinytext
    return f1;

#--error ER_PARSE_ERROR
CREATE FUNCTION text(f1 text) returns text
    return f1;
  DROP FUNCTION text;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumtext(f1 mediumtext) returns mediumtext
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION longtext(f1 longtext) returns longtext
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinytext not null(f1 tinytext not null) returns tinytext not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION text not null(f1 text not null) returns text not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumtext not null(f1 mediumtext not null) returns mediumtext not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION longtext not null(f1 longtext not null) returns longtext not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyblob(f1 tinyblob) returns tinyblob
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION blob(f1 blob) returns blob
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumblob(f1 mediumblob) returns mediumblob
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION longblob(f1 longblob) returns longblob
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyblob not null(f1 tinyblob not null) returns tinyblob not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION blob not null(f1 blob not null) returns blob not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumblob not null(f1 mediumblob not null) returns mediumblob not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION longblob not null(f1 longblob not null) returns longblob not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION binary(f1 binary) returns binary
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION binary not null(f1 binary not null) returns binary not null
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyint(f1 tinyint) returns tinyint
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyint unsigned(f1 tinyint unsigned) returns tinyint unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyint zerofill(f1 tinyint zerofill) returns tinyint zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION tinyint unsigned zerofill(f1 tinyint unsigned zerofill) returns tinyint unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION smallint(f1 smallint) returns smallint
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION smallint unsigned(f1 smallint unsigned) returns smallint unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION smallint zerofill(f1 smallint zerofill) returns smallint zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION smallint unsigned zerofill(f1 smallint unsigned zerofill) returns smallint unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumint(f1 mediumint) returns mediumint
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumint unsigned(f1 mediumint unsigned) returns mediumint unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumint zerofill(f1 mediumint zerofill) returns mediumint zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION mediumint unsigned zerofill(f1 mediumint unsigned zerofill) returns mediumint unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int(f1 int) returns int
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int1(f1 int1) returns int1
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int2(f1 int2) returns int2
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int3(f1 int3) returns int3
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int4(f1 int4) returns int4
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int8(f1 int8) returns int8
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int unsigned(f1 int unsigned) returns int unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int zerofill(f1 int zerofill) returns int zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION int unsigned zerofill(f1 int unsigned zerofill) returns int unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION bigint(f1 bigint) returns bigint
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION bigint unsigned(f1 bigint unsigned) returns bigint unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION bigint zerofill(f1 bigint zerofill) returns bigint zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION bigint unsigned zerofill(f1 bigint unsigned zerofill) returns bigint unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION decimal(f1 decimal) returns decimal
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION decimal unsigned(f1 decimal unsigned) returns decimal unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION decimal zerofill(f1 decimal zerofill) returns decimal zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION decimal unsigned zerofill(f1 decimal unsigned zerofill) returns decimal unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION numeric(f1 numeric) returns numeric
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION numeric unsigned(f1 numeric unsigned) returns numeric unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION numeric zerofill(f1 numeric zerofill) returns numeric zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION numeric unsigned zerofill(f1 numeric unsigned zerofill) returns numeric unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION real(f1 real) returns real
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION real unsigned(f1 real unsigned) returns real unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION real zerofill(f1 real zerofill) returns real zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION real unsigned zerofill(f1 real unsigned zerofill) returns real unsigned zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION float(f1 float) returns float
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION float unsigned(f1 float unsigned) returns float unsigned
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION float zerofill(f1 float zerofill) returns float zerofill
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION float unsigned zerofill(f1 float unsigned zerofill) returns float unsigned zerofill
    return f1;

CREATE FUNCTION date(f1 date) returns date
    return f1;
DROP FUNCTION date;

CREATE FUNCTION time(f1 time) returns time
    return f1;
DROP FUNCTION time;

CREATE FUNCTION datetime(f1 datetime) returns datetime
    return f1;
DROP FUNCTION datetime;

CREATE FUNCTION timestamp(f1 timestamp) returns timestamp
    return f1;
DROP FUNCTION timestamp;

CREATE FUNCTION year(f1 year) returns year
    return f1;
DROP FUNCTION year;

--error ER_PARSE_ERROR
CREATE FUNCTION year(4)(f1 year(4)) returns year(4)
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION enum("1enum", "2enum")(f1 enum("1enum", "2enum")) returns enum("1enum", "2enum")
    return f1;

--error ER_PARSE_ERROR
CREATE FUNCTION set("1set", "2set")(f1 set("1set", "2set")) returns set("1set", "2set")
    return f1;
--enable_warnings

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 char ) returns char
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_NOT_SUPPORTED_YET
CREATE FUNCTION fn1(f1 char binary ) returns char binary
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 char ascii ) returns char ascii
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 char not null ) returns char not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 char binary not null ) returns char binary not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 char ascii not null ) returns char ascii not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinytext ) returns tinytext
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 text ) returns text
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumtext ) returns mediumtext
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 longtext ) returns longtext
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 tinytext not null ) returns tinytext not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 text not null ) returns text not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 mediumtext not null ) returns mediumtext not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 longtext not null ) returns longtext not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinyblob ) returns tinyblob
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 blob ) returns blob
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumblob ) returns mediumblob
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 longblob ) returns longblob
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 tinyblob not null ) returns tinyblob not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 blob not null ) returns blob not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 mediumblob not null ) returns mediumblob not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 longblob not null ) returns longblob not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 binary ) returns binary
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 binary not null ) returns binary not null
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinyint ) returns tinyint
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinyint unsigned ) returns tinyint unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinyint zerofill ) returns tinyint zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 tinyint unsigned zerofill ) returns tinyint unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 smallint ) returns smallint
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 smallint unsigned ) returns smallint unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 smallint zerofill ) returns smallint zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 smallint unsigned zerofill ) returns smallint unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumint ) returns mediumint
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumint unsigned ) returns mediumint unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumint zerofill ) returns mediumint zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 mediumint unsigned zerofill ) returns mediumint unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int ) returns int
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int unsigned ) returns int unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int1 unsigned ) returns int1 unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int2 unsigned ) returns int2 unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int3 unsigned ) returns int3 unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int4 unsigned ) returns int4 unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int8 unsigned ) returns int8 unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int zerofill ) returns int zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 int unsigned zerofill ) returns int unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 bigint ) returns bigint
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 bigint unsigned ) returns bigint unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 bigint zerofill ) returns bigint zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 bigint unsigned zerofill ) returns bigint unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 decimal ) returns decimal
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 decimal unsigned ) returns decimal unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 decimal zerofill ) returns decimal zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 decimal unsigned zerofill ) returns decimal unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 numeric ) returns numeric
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 numeric unsigned ) returns numeric unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 numeric zerofill ) returns numeric zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 numeric unsigned zerofill ) returns numeric unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 real ) returns real
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 real unsigned ) returns real unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 real zerofill ) returns real zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 real unsigned zerofill ) returns real unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 float ) returns float
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 float unsigned ) returns float unsigned
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 float zerofill ) returns float zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 float unsigned zerofill ) returns float unsigned zerofill
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 date ) returns date
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 time ) returns time
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 datetime ) returns datetime
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 timestamp ) returns timestamp
    return f1;

DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1(f1 year ) returns year
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 year(f1 4) ) returns year(4)
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 enum(f1 "1enum", "2enum") ) returns enum("1enum", "2enum")
    return f1;

DROP FUNCTION IF EXISTS fn1;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1(f1 set(f1 "1set", "2set") ) returns set("1set", "2set")
    return f1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.16:
              ----------------
Ensure that a reference to a non-existent stored procedure is rejected with an
appropriate error message;
--source include/show_msg80.inc

DROP PROCEDURE IF EXISTS sp16;

--error ER_SP_DOES_NOT_EXIST
CALL sp16( 'xyz' );

CREATE DATABASE db1;
USE db1;

delimiter //;
CREATE PROCEDURE sp16()
BEGIN
    set @var1 = 1;
    SELECT @var1;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
CALL db_storedproc.sp16();

# cleanup
USE db_storedproc;
DROP PROCEDURE db1.sp16;
DROP DATABASE db1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.17:
              ----------------
Ensure that it is possible to drop, create and CALL/execute a procedure and a
function with the same name, even in the same database;
--source include/show_msg80.inc

USE db_storedproc;
DROP FUNCTION IF EXISTS sp1;
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1 ()
BEGIN
    declare x enum( 'db1', 'test' ) default 'test';
    SELECT x;
END//
delimiter ;//

CALL sp1();


CREATE FUNCTION sp1 (y char) returns char return y;
  SELECT sp1( 'a' );

DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
CALL db_storedproc.sp1( );
SELECT db_storedproc.sp1( 'a' );

DROP FUNCTION db_storedproc.sp1;
USE db_storedproc;

--error ER_SP_DOES_NOT_EXIST
SELECT sp1('a');

DROP PROCEDURE sp1;

--error ER_SP_DOES_NOT_EXIST
CALL sp1();

--error ER_SP_DOES_NOT_EXIST
SELECT sp1('a');

# cleanup
USE db_storedproc;
DROP DATABASE db1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.18:
              ----------------
Ensure that it is possible to alter a procedure and
a function with the same name, in the same database;
--source include/show_msg80.inc


USE db_storedproc;
DROP PROCEDURE IF EXISTS sp1;
DROP FUNCTION IF EXISTS sp1;
set @x=null; set @y=null;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    set @x= 1;
    SELECT @x;
END//
delimiter ;//

CREATE FUNCTION sp1 () returns int return 2.2;
CALL db_storedproc.sp1();
SELECT db_storedproc.sp1();

DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
USE db1;
alter procedure db_storedproc.sp1 sql security invoker;
--sorted_result
SELECT routine_name, routine_type, security_type from information_schema.routines
       where routine_schema like 'db_storedproc%' and routine_name='sp1';

alter function db_storedproc.sp1 sql security invoker;
--sorted_result
SELECT routine_name, routine_type, security_type from information_schema.routines
       where routine_schema like 'db_storedproc%' and routine_name='sp1';

CALL db_storedproc.sp1();

SELECT db_storedproc.sp1();

USE db_storedproc;
alter procedure sp1 sql security DEFINER;
CALL db_storedproc.sp1();

SELECT db_storedproc.sp1();

alter function sp1 sql security DEFINER;
--sorted_result
SELECT routine_name, routine_type, security_type from information_schema.routines
       where routine_schema like 'db_storedproc%' and routine_name='sp1';
CALL db_storedproc.sp1();

SELECT db_storedproc.sp1();

# cleanup
USE db_storedproc;
DROP DATABASE db1;
DROP PROCEDURE db_storedproc.sp1;
DROP FUNCTION db_storedproc.sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.19:
              ----------------
verify altering procedure and function with the same name, does not affect
properties of a procedure and a function with the same name in the different
database.;
--source include/show_msg80.inc

CREATE DATABASE db_storedproc_3122;
USE db_storedproc;
SET @x = NULL;
SET @y = NULL;
DROP PROCEDURE IF EXISTS sp1;
DROP FUNCTION IF EXISTS sp1;
DROP PROCEDURE IF EXISTS db_storedproc_3122.sp1;
DROP FUNCTION IF EXISTS db_storedproc_3122.sp1;
delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    SET @x = 1;
    SELECT @x;
END//
delimiter ;//

# FIXME ps-protocol vs. normal difference when returning float instead of double
CREATE FUNCTION db_storedproc_3122.sp1() RETURNS DOUBLE RETURN 2.2;
CALL sp1();
  SELECT db_storedproc_3122.sp1();
  USE db_storedproc_3122;

delimiter //;
CREATE PROCEDURE sp1 ()
BEGIN
    SET @x = 3;
    SELECT @x;
END//
delimiter ;//

CREATE FUNCTION db_storedproc.sp1() RETURNS DOUBLE RETURN 4.4;
CALL sp1();
SELECT db_storedproc.sp1();

ALTER PROCEDURE db_storedproc_3122.sp1 SQL SECURITY INVOKER;
ALTER FUNCTION sp1 SQL SECURITY INVOKER;

--sorted_result
SELECT routine_name, routine_type, security_type from information_schema.routines
       where routine_schema like 'db_storedproc%' and routine_name='sp1';

CALL db_storedproc.sp1();

SELECT db_storedproc.sp1();
CALL db_storedproc_3122.sp1();
SELECT db_storedproc_3122.sp1();

# clean up
USE db_storedproc;
DROP DATABASE db_storedproc_3122;
DROP FUNCTION db_storedproc.sp1;
DROP PROCEDURE db_storedproc.sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.20:
              ----------------
Ensure that it is possible to alter the comment of a procedure
and a function with the same name, even in the same database;
--source include/show_msg80.inc


USE db_storedproc;
set @x=null;

--disable_warnings
DROP PROCEDURE IF EXISTS sp1;
DROP FUNCTION IF EXISTS sp1;
--enable_warnings

CREATE PROCEDURE sp1 () set @x= 1;
CREATE FUNCTION sp1 () returns int return 2;

DROP DATABASE IF EXISTS db_storedproc_3122;
CREATE DATABASE db_storedproc_3122;
USE db_storedproc_3122;

CREATE PROCEDURE sp1 () set @x= 3;
CREATE FUNCTION sp1 () returns int return 4;

alter procedure sp1 sql security invoker comment 'this is a procedure';
alter function sp1 sql security invoker comment 'this is a function';

alter procedure sp1 sql security DEFINER;
alter function sp1 sql security DEFINER;
--replace_column 5 <modified> 6 <created>
show CREATE PROCEDURE sp1;
--replace_column 5 <modified> 6 <created>
show CREATE FUNCTION sp1;

# clean up
USE db_storedproc;
DROP DATABASE db_storedproc_3122;
DROP FUNCTION db_storedproc.sp1;
DROP PROCEDURE db_storedproc.sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.21:
              ----------------
Ensure that it is not possible to create two procedures with same name
in same database;
--source include/show_msg80.inc

USE db_storedproc;
set @x=null;
set @y=null;

CREATE DATABASE db1;
DROP PROCEDURE IF EXISTS sp1;
CREATE PROCEDURE sp1 () set @x=1;

--error ER_SP_ALREADY_EXISTS
CREATE PROCEDURE sp1 () set @x=2;

CALL sp1();
SELECT @x;
USE db1;
--error ER_SP_ALREADY_EXISTS
CREATE PROCEDURE db_storedproc.sp1 () set @x=3;
CALL db_storedproc.sp1();
  SELECT @x;

DROP PROCEDURE IF EXISTS db_storedproc.sp1;
CREATE PROCEDURE db_storedproc.sp1 () set @x=1;
--error ER_SP_ALREADY_EXISTS
CREATE PROCEDURE db_storedproc.sp1 () set @x=2;
CALL db_storedproc.sp1();
SELECT @x;

# clean up
USE db_storedproc;
DROP DATABASE db1;
DROP PROCEDURE db_storedproc.sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.1.22:
              ----------------
Ensure that it is not possible to create two functions with same name in the
same database;
--source include/show_msg80.inc

USE db_storedproc;
DROP DATABASE IF EXISTS db1;
CREATE DATABASE db1;
DROP FUNCTION IF EXISTS fn1;
CREATE FUNCTION fn1 () returns int return 1;
--error ER_SP_ALREADY_EXISTS
CREATE FUNCTION fn1 () returns int return 2;
SELECT fn1();
USE db1;
--error ER_SP_ALREADY_EXISTS
CREATE FUNCTION db_storedproc.fn1 () returns int return 3;
SELECT db_storedproc.fn1();
DROP FUNCTION IF EXISTS db_storedproc.fn1;
CREATE FUNCTION db_storedproc.fn1 () returns int return 1;
--error ER_SP_ALREADY_EXISTS
CREATE FUNCTION db_storedproc.fn1 () returns int return 2;
SELECT db_storedproc.fn1();

# clean up
USE db_storedproc;
DROP DATABASE db1;
DROP FUNCTION db_storedproc.fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.23:
              ----------------
Ensure that it is possible to create two or more procedures with the same name,
providing each resides in different databases;
--source include/show_msg80.inc


USE db_storedproc;
set @x=null;
set @y=null;
DROP PROCEDURE IF EXISTS sp1;
CREATE PROCEDURE sp1 () set @x= 1;
DROP DATABASE IF EXISTS test3124;
CREATE DATABASE test3124;
USE test3124;
CREATE PROCEDURE sp1 () set @y= 2;
CALL sp1();
SELECT @x, @y;
USE db_storedproc;
CALL sp1();
SELECT @x, @y;

# clean up
USE db_storedproc;
DROP DATABASE test3124;
DROP PROCEDURE db_storedproc.sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.24:
              ----------------
Ensure that it is possible to create two or more functions with the same name,
providing each resides in different databases.;
--source include/show_msg80.inc


USE db_storedproc;
DROP FUNCTION IF EXISTS f1;
CREATE FUNCTION f1 () returns int return 1;
DROP DATABASE IF EXISTS test3125;
CREATE DATABASE test3125;
USE test3125; CREATE FUNCTION f1 () returns int return 2;
SELECT f1();
USE db_storedproc;
SELECT f1();

# clean up
USE db_storedproc;
DROP DATABASE test3125;
DROP FUNCTION db_storedproc.f1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.25:
              ----------------
Ensure that any invalid function name is never accepted, and that an appropriate
error message is returned when the name is rejected. (invalid func name);
--source include/show_msg80.inc

delimiter //;
--error ER_PARSE_ERROR
CREATE FUNCTION !_fn1( f1 char(20) ) returns int
BEGIN
   SELECT * from t1 where f2 = f1;
   return 1;
END//
delimiter ;//

delimiter //;
--error ER_PARSE_ERROR
CREATE FUNCTION fn1( f1 char(20) ) return int
BEGIN
   SELECT * from t1 where f2 = f1;
   return 1;
END//
delimiter ;//

CREATE FUNCTION fn1() returns int
  return 'a';

--error ER_PARSE_ERROR
CREATE FUNCTION procedure() returns int
  return 1;

--error ER_PARSE_ERROR
CREATE FUNCTION fn1(a char) returns int lang sql return 1;

--error ER_PARSE_ERROR
CREATE FUNCTION fn1(a char) returns int deterministic( return 1);

--error ER_PARSE_ERROR
CREATE FUNCTION fn1(a char) returns int non deterministic return 1;

--error ER_PARSE_ERROR
CREATE FUNCTION fn1(a char) returns int not deterministic comment 'abc' language sql sql security refiner return 1;

# clean up
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;


# ==============================================================================
#
# test plan section: 4.2 - syntax checks for programming statements - 1
#
# ==============================================================================

# ------------------------------------------------------------------------------
let $message= Testcase 4.1.1:
              ---------------
              Ensure that all clauses that should be supported are supported.
              CREATE PROCEDURE;
--source include/show_msg80.inc


USE db_storedproc;

  set @count = 0;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1(cnt int(20))
BEGIN
    SELECT count(*) into cnt from t2;
    set @count = cnt;
END//
delimiter ;//

CALL sp1( 10 );

  SELECT @count;

# clean up
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.2:
BEGINend;
--source include/show_msg80.inc


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( cnt int(20) )
BEGIN
    SELECT count(*) into cnt from t2;
    set @count = cnt;
    SELECT @count;
END//
delimiter ;//

CALL sp1( 10 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

# missing BEGIN
# PLEASE NOTE:
# this test client has the MULTI_QUERY capability,
# so that the following request (starting at 'CREATE' and ending at the //
# delimiter) is interpreted as follows:
# 1) it's a multi query
# 2) the first query is a valid CREATE PROCEDURE statement, and the
# procedure consist of only one SELECT statement
# 3) the second query is a SET statement, which is broken since it's
# referencing an unknown column 'cnt'
# 4) the next query (SELECT @count) is not parsed or executed, since 3)
# failed

delimiter //;
--error ER_BAD_FIELD_ERROR
CREATE PROCEDURE sp1( cnt int(20) )
    SELECT count(*) into cnt from t2;
    set @count = cnt;
    SELECT @count;
END//
delimiter ;//

CALL sp1( 10 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE sp1;

# wrong order of BEGIN and END
delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( cnt int(20) )
END
    SELECT count(*) into cnt from t2;
    set @count = cnt;
    SELECT @count;
BEGIN//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
CALL sp1( 10 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

# invalid usage of BEGIN + END
delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( cnt int(20) )
BEGIN
   SELECT count(*) into cnt from t2;
   BEGIN
      BEGIN END;
   BEGIN
   END;
   set @count = cnt;
   SELECT @count;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.4:
              ---------------
Ensure that every BEGIN statement is coupled with a terminating END statement.
(BEGIN with no END);
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x char;
    declare y char;
    SELECT f1, f2 into x, y from t2 limit 1;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase ....:
              --------------
;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  accessible:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  add:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  all:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BADSTATEMENT
CREATE PROCEDURE sp1()
  alter:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  analyze:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  and:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  as:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  asc:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  asensitive:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  before:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  between:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  bigint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  binary:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  blob:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  both:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  by:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  call:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  cascade:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  case:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  change:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  char:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  character:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  check:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  collate:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  column:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  condition:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  constraint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  continue:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  convert:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  create:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  cross:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  current_date:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  current_time:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  current_timestamp:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  current_user:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  cursor:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  database:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  databases:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  day_hour:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  day_microsecond:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  day_minute:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  day_second:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  dec:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  decimal:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  declare:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  default:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  delayed:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  delete:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  desc:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  describe:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  deterministic:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  distinct:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  distinctrow:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  div:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  double:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
drop:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  dual:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  each:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  else:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  elseif:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  enclosed:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  escaped:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  exists:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  exit:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  explain:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  false:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  fetch:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  float:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  float4:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  float8:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  for:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  force:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  foreign:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  from:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  fulltext:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  grant:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  group:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  having:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  high_priority:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  hour_microsecond:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  hour_minute:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  hour_second:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  if:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  ignore:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  in:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  index:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  infile:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  inner:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  inout:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  insensitive:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  insert:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int1:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int2:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int3:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int4:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  int8:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  integer:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  interval:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  into:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  is:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  iterate:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  join:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  key:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  keys:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  kill:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  leading:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  leave:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  left:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  like:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  limit:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  linear:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  lines:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  load:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  localtime:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  localtimestamp:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  lock:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  long:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  longblob:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  longtext:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  loop:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  low_priority:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  master_ssl_verify_server_cert:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  match:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  mediumblob:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  mediumint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  mediumtext:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  middleint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  minute_microsecond:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  minute_second:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  mod:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  modifies:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  natural:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  not:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  no_write_to_binlog:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  null:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;


delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  numeric:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  on:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  optimize:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  option:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  optionally:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  or:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  order:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  out:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  outer:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  outfile:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  precision:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  primary:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  procedure:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  purge:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  range:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  read:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  reads:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

# delimiter //;
# --error ER_PARSE_ERROR
# CREATE PROCEDURE sp1()
#   read_only:BEGIN
#     SELECT @x;
# END//
# delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  read_write:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  real:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  references:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  regexp:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  release:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  rename:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  repeat:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  replace:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  require:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  restrict:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  return:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  revoke:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  right:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  rlike:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  schema:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  schemas:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  second_microsecond:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  select:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sensitive:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  separator:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  set:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  show:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  smallint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  spatial:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  specific:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sql:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sqlexception:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sqlstate:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sqlwarning:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sql_big_result:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sql_calc_found_rows:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  sql_small_result:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  ssl:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  starting:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  straight_join:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  table:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  terminated:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  then:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  tinyblob:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  tinyint:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  tinytext:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  to:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  trailing:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  trigger:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  true:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  undo:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  union:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  unique:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BADSTATEMENT
CREATE PROCEDURE sp1()
  unlock:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  unsigned:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  update:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  usage:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  use:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  using:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  utc_date:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  utc_time:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  utc_timestamp:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  values:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  varbinary:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  varchar:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  varcharacter:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  varying:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  when:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  where:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  while:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  with:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  write:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  xor:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  year_month:BEGIN
    SELECT @x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
  zerofill:BEGIN
    SELECT @x;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.6:
              ---------------
Ensure that the labels for multiple BEGIN an END work properly;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;


delimiter //;
CREATE PROCEDURE sp1( )
begin_label: BEGIN
    declare x char;
    declare y char;
    set x = '1';
    set y = '2';
    label1: BEGIN
      declare x char;
      declare y char;
      SELECT f1, f2 into x, y from t2 limit 1;
    END label1;
    set @v1 = x;
    set @v2 = y;
    SELECT @v1, @v2;
END begin_label//
delimiter ;//

CALL sp1();

# clean up
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.7:
              ---------------
Ensure that the labels enclosing each BEGIN/END compound statement must match.;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_LABEL_MISMATCH
CREATE PROCEDURE sp1( )
begin1_label: BEGIN
    declare x char;
    declare y char;
    SELECT lf1, f1 into x, y from t2 limit 1;
    begin2_label: BEGIN
      declare x char;
      declare y char;
      SELECT f1, f2 into x, y from t2 limit 1;
    END begin2_changed;
END begin1_changed//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.8:
              ---------------
Ensure that it is possible to put a beginning label at the start of a
BEGIN/END compound statement without also requiring an ending label
at the END of the same statement.;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
    begin_label: BEGIN
    declare x char;
    declare y char;
    SELECT f1, f2 into x, y from t2 limit 1;
END//
delimiter ;//

CALL sp1();

# clean up
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.9:
              ---------------
Ensure that it is not possible to put an ending label at the END of
a BEGIN/END compound statement without also requiring a matching
beginning label at the start of the same statement;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare x char;
    declare y char;
    SELECT f1, f2 into x, y from t2 limit 1;
END begin_label//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.10:
              ----------------
Ensure that every beginning label must END with a colon(:);
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
begin_label BEGIN
   declare x char;
   declare y char;
   SELECT f1, f2 into x, y from t2 limit 1;
END begin_label//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.11:
              ----------------
Ensure that every beginning label with the same scope must be unique. (same label names);
--source include/show_msg80.inc


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_SP_LABEL_REDEFINE
CREATE PROCEDURE sp6( )
begin_samelabel: BEGIN
    declare x char;
    declare y char;
    SELECT f1, f2 into x, y from t2 limit 1;
    begin_samelabel: BEGIN
      declare x char;
      declare y char;
      SELECT f1, f2 into x, y from t2 limit 1;
    END begin_samelabel;
    begin_samelabel: BEGIN
      declare x char;
      declare y char;
      SELECT f1, f2 into x, y from t2 limit 1;
    END begin_samelabel;
END begin_samelabel//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.12:
              ----------------
Ensure that the variables, cursors, conditions, and handlers declared for
a stored procedure (with the declare statement) may only be properly defined;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_TOO_BIG_SCALE
CREATE PROCEDURE sp6( )
BEGIN
    declare x char default 'a';
    declare y integer default 1;
    declare z float default 1.1;
    declare a enum("value1", "value2") default 'value1';
    declare b decimal(255, 255) default 1.2e+12;
    declare c mediumtext default 'mediumtext';
    declare d datetime default '2005-02-02 12:12:12';
    declare e char default 'b';
    declare cur1 cursor for SELECT f1 from db_storedproc.t2;
    declare continue handler for sqlstate '02000' set @x2 = 1;
    open cur1;
    fetch cur1 into e;
    SELECT x, y, z, a, b, c, d, e;
    close cur1;
END//
delimiter ;//

CALL sp6();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6( )
BEGIN
    declare x12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567 char default '0';
    SELECT x12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567;
END//
delimiter ;//

CALL sp6();

# clean up
DROP PROCEDURE sp6;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.13:
              ----------------
Ensure that the variables declared for a stored procedure (with the declare
statement) may only be defined in the correct order.;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare x default '0' char;
    SELECT x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare x char, integer default '0';
    SELECT x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare x1, x2 char, integer default '0', 1;
    SELECT x;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
   declare char x;
   declare char y;
   SELECT f1, f2 into x, y from t2 limit 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
   declare char x, y1 integer default 0;
   declare char y;
   SELECT f1, f2 into x, y from t2 limit 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare x default 'a' char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare condition notable for sqlstate '42s22';
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare condition for notable sqlstate '42s22';
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare condition for sqlstate notable '42s22';
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare condition for sqlstate '42s22' notable;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare cursor cur1 for SELECT f1 from db_storedproc.t2;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare cursor for cur1 SELECT f1 from db_storedproc.t2;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare cursor for SELECT cur1 f1 from db_storedproc.t2;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare handler continue for sqlstate '02000' set @x2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare handler exit for sqlstate '02000' set @x2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6( )
BEGIN
    declare handler undo for sqlstate '02000' set @x2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare char x;
    SELECT f1 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare char binary  x;
    SELECT f2 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare char ascii  x;
    SELECT f3 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinytext  x;
    SELECT f4 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare  x;
    SELECT f5 text  into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumtext  x;
    SELECT f6 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longtext  x;
    SELECT f7 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyblob  x;
    SELECT f8 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare blob x;
    SELECT f9 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumblob  x;
    SELECT f10 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longblob  x;
    SELECT f11 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare binary  x;
    SELECT f12 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint  x;
    SELECT f13 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint unsigned  x;
    SELECT f14 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint zerofill  x;
    SELECT f15 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint unsigned zerofill  x;
    SELECT f16 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint  x;
    SELECT f17 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint unsigned   x;
    SELECT f18 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint zerofill  x;
    SELECT f19 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint unsigned zerofill  x;
    SELECT f20 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint  x;
    SELECT f21 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint unsigned  x;
    SELECT f22 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint zerofill  x;
    SELECT f23 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint unsigned zerofill  x;
    SELECT f24 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int  x;
    SELECT f25 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int unsigned  x;
    SELECT f26 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int zerofill  x;
    SELECT f27 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int unsigned zerofill  x;
    SELECT f28 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint  x;
    SELECT f29 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint unsigned  x;
    elect f30 into x from tb1 limit 9998, 1;
END//
delimiter ;//


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint zerofill  x;
    SELECT f31 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint unsigned zerofill  x;
    SELECT f32 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal  x;
    SELECT f33 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal unsigned  x;
    SELECT f34 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal zerofill  x;
    SELECT f35 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal unsigned zerofill not null  x;
    SELECT f36 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (0) not null  x;
    SELECT f37 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (64) not null  x;
    SELECT f38 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (0) unsigned not null  x;
    SELECT f39 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (64) unsigned not null  x;
    SELECT f40 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (0) zerofill not null  x;
    SELECT f41 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (64) zerofill not null  x;
    SELECT f42 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (0) unsigned zerofill not null  x;
    SELECT f43 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (64) unsigned zerofill not null  x;
    SELECT f44 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (00) not null  x;
    SELECT f45 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (63, 30) not null  x;
    SELECT f46 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (00) unsigned not null  x;
    SELECT f47 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (63, 30) unsigned not null  x;
    SELECT f48 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (00) zerofill not null  x;
    SELECT f49 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (63, 30) zerofill not null  x;
    SELECT f50 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (00) unsigned zerofill not null  x;
    SELECT f51 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal (63, 30) unsigned zerofill not null  x;
    SELECT f52 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric not null  x;
    SELECT f53 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric unsigned not null  x;
    SELECT f54 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric zerofill not null  x;
    SELECT f55 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric unsigned zerofill not null  x;
    SELECT f56 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (0) not null  x;
    SELECT f57 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (64) not nul x;
    SELECT f58 into x from tb1 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (0) unsigned  x;
    SELECT f59 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (64) unsigned  x;
    SELECT f60 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (0) zerofill  x;
    SELECT f61 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (64) zerofill  x;
    SELECT f62 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (0) unsigned zerofill  x;
    SELECT f63 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (64) unsigned zerofill  x;
    SELECT f64 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (00)  x;
    SELECT f65 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (63, 30)  x;
    SELECT f66 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;


delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (00) unsigned  x;
    SELECT f67 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (63, 30) unsigned  x;
    SELECT f68 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (00) zerofill  x;
    SELECT f69 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (63, 30) zerofill  x;
    SELECT f70 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (00) unsigned zerofill  x;
    SELECT f71 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric (63, 30) unsigned zerofill  x;
    SELECT f72 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real  x;
    SELECT f73 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real unsigned  x;
    SELECT f74 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real zerofill  x;
    SELECT f75 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real unsigned zerofill  x;
    SELECT f76 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double  x;
    SELECT f77 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double unsigned  x;
    SELECT f78 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double zerofill  x;
    SELECT f79 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double unsigned zerofill  x;
    SELECT f80 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float not null  x;
    SELECT f81 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float unsigned not null  x;
    SELECT f82 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float zerofill not null  x;
    SELECT f83 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float unsigned zerofill not null  x;
    SELECT f84 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(0) not null  x;
    SELECT f85 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(23) not null  x;
    SELECT f86 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(0) unsigned not null  x;
    SELECT f87 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(23) unsigned not null  x;
    SELECT f88 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(0) zerofill not null  x;
    SELECT f89 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(23) zerofill not null  x;
    SELECT f90 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(0) unsigned zerofill not null  x;
    SELECT f91 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(23) unsigned zerofill not null  x;
    SELECT f92 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(24) not null  x;
    SELECT f93 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(53) not null  x;
    SELECT f94 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(24) unsigned not null  x;
    SELECT f95 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(53) unsigned not null  x;
    SELECT f96 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(24) zerofill not null  x;
    SELECT f97 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(53) zerofill not null  x;
    SELECT f98 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(24) unsigned zerofill not null  x;
    SELECT f99 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float(53) unsigned zerofill not null  x;
    SELECT f100 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare date not null  x;
    SELECT f101 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare time not null  x;
    SELECT f102 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare datetime not null  x;
    SELECT f103 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare timestamp not null  x;
    SELECT f104 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare year not null  x;
    SELECT f105 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare year(4) not null  x;
    SELECT f107 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare enum("1enum", "2enum") not null  x;
    SELECT f108 into x from tb2 limit 9998, 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare set("1set", "2set") not nul x;
    SELECT f109 into x from tb2 limit 9998, 1;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.14:
              ----------------
Ensure that the handlers declared for a stored procedure (with the declare
statement) may only be defined in the correct order;
--source include/show_msg80.inc


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_VARCOND_AFTER_CURSHNDLR
CREATE PROCEDURE sp1()
BEGIN
   declare continue handler for sqlstate '23000' set @x2 = 1;
   declare x char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_SP_VARCOND_AFTER_CURSHNDLR
CREATE PROCEDURE sp6( )
BEGIN
    declare cursor1 cursor for SELECT f1 from tb1;
    declare x char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_SP_VARCOND_AFTER_CURSHNDLR
CREATE PROCEDURE sp6( )
BEGIN
    declare cursor1 cursor for SELECT f1 from tb1;
    declare sqlcondition condition for sqlstate '02000';
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_SP_CURSOR_AFTER_HANDLER
CREATE PROCEDURE sp6( )
BEGIN
    declare sqlcondition condition for sqlstate '02000';
    declare continue handler for sqlcondition set @x=1;
    declare cursor1 cursor for SELECT f1 from tb1;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.15:
              ----------------
Ensure that the declare statement can declare multiple variables both separately
and all at once from a variable list. (multiple declaration);
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
   BEGIN
      DECLARE x1 CHAR(100) DEFAULT 'outer';
      BEGIN
         DECLARE x1 CHAR(100) DEFAULT x1;
      END;
   END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;


delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z char default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z char ascii default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinytext default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z text default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumtext default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z longtext default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinyblob default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z blob default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumblob default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z longblob default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z binary default null;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinyint default -126;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinyint unsigned default 253;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinyint zerofill default -1;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z tinyint unsigned zerofill default 1;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z smallint default -32768;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z smallint unsigned default 65535;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z smallint zerofill default -1;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z smallint unsigned zerofill default 1;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumint default -8388608;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumint unsigned default 16777215;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumint zerofill default -1;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z mediumint unsigned zerofill default 1;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z int default -2147483648;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z int unsigned default 4294967295;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z int zerofill default -1;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z int unsigned zerofill default 1;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z bigint default -9223372036854775808;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z bigint unsigned default 18446744073709551615;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z bigint zerofill default -1;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z bigint unsigned zerofill default 1;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

#FIXME check again with -3.402823466e+38
let $default_minus38= -34028234660123456789012345678901234567;

delimiter //;
eval CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z decimal default $default_minus38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z decimal unsigned default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

#FIXME check again with -3.402823466e+38
delimiter //;
eval CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z decimal zerofill default $default_minus38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z decimal unsigned zerofill default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z numeric default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z numeric unsigned default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z numeric zerofill default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z numeric unsigned zerofill default 1.175494351e-38;
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z real default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z real unsigned default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z real zerofill default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z real unsigned zerofill default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z float default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z float unsigned default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z float zerofill default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z float unsigned zerofill default 1.175494351e-38;
    SELECT x, y, z;
END//
delimiter ;//

--replace_result e-038 e-38
CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z date default '2005-02-02';
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z time default '12:20:12';
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z datetime default '2005-02-02 12:20:12';
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z timestamp default '20050202122012';
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z year default 2005;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z year(4) default 2005;
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z enum("1enum", "2enum") default "2enum";
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x, y, z set("1set", "2set") default "2set";
    SELECT x, y, z;
END//
delimiter ;//

CALL sp1();

# clean up
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.16:
              ----------------
Ensure that the declare statement can declare multiple variables both separately
and all at once from a variable list. (multiple declaration).;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6( )
BEGIN
   declare a, b char default '2';
   declare c, d float default 1.3;
   declare e, f text default 'text';
   declare g, h enum("value1", "value2" ) default 'value1';
   declare i, j datetime default '2005-02-02 12:12:12';
   declare k, l blob default 'blob';
   SELECT a, b, c, d, e, f, g, h, k, l;
END//
delimiter ;//

CALL sp6();

# clean up
DROP PROCEDURE sp6;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.17:
              ----------------
Ensure that the invalid variable declarations are rejected, with an appropriate
error message.;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
   declare @x char;
   SELECT f2 into x from t2 limit 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare accessible char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare add char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare all char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare alter char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare analyze char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare and char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare as char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare asc char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare asensitive char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare before char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare between char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare bigint char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare binary char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare blob char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare both char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare by char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare call char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare cascade char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare case char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare change char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare char char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare character char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare check char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare collate char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare column char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare condition char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare constraint char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare continue char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare convert char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare create char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare cross char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare current_date char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare current_time char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare current_timestamp char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare current_user char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare cursor char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare database char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare databases char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare day_hour char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare day_microsecond char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare day_minute char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare day_second char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare dec char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare decimal char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare declare char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare default char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare delayed char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare delete char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare desc char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare describe char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare deterministic char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare distinct char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare distinctrow char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare div char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare double char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare drop char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare dual char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare each char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare else char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare elseif char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare enclosed char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare escaped char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare exists char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare exit char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare explain char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare false char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare fetch char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare float char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare float4 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare float8 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare for char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare force char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare foreign char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare from char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare fulltext char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare grant char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare group char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare having char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare high_priority char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare hour_microsecond char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare hour_minute char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare hour_second char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare if char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare ignore char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare in char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare index char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare infile char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare inner char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare inout char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare insensitive char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare insert char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int1 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int2 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int3 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int4 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare int8 char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare integer char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare interval char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare into char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare is char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare iterate char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare join char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare key char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare keys char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare kill char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare leading char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare leave char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare left char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare like char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare limit char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare linear char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare lines char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare load char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare localtime char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare localtimestamp char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare lock char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare long char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare longblob char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare longtext char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare loop char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare low_priority char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare master_ssl_verify_server_cert char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare match char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare mediumblob char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare mediumint char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare mediumtext char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare middleint char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare minute_microsecond char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare minute_second char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare mod char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare modifies char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare natural char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare not char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare no_write_to_binlog char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare null char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare numeric char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare on char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare optimize char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare option char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare optionally char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare or char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare order char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare out char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare outer char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare outfile char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare precision char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare primary char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare procedure char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare purge char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare range char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare read char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare reads char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
# FIXME 31947
#--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare read_only char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare read_write char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare real char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare references char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare regexp char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare release char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare rename char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare repeat char;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare replace char;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
   declare require char;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare restrict char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare return char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare revoke char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare right char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare rlike char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare schema char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare schemas char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare second_microsecond char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare SELECT char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sensitive char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare separator char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare set char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare show char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare smallint char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare spatial char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare specific char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sql char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sqlexception char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sqlstate char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sqlwarning char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sql_big_result char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sql_calc_found_rows char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare sql_small_result char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare ssl char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare starting char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare straight_join char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare table char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare terminated char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare then char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare tinyblob char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare tinyint char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare tinytext char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare to char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare trailing char;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare trigger char;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare true char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare undo char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare union char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare unique char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare unlock char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare unsigned char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare update char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare usage char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare use char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare using char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare utc_date char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare utc_time char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare utc_timestamp char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare values char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare varbinary char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare varchar char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare varcharacter char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare varying char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare when char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare where char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare while char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare with char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare write char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare xor char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare year_month char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare zerofill char;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase :
              ----------
Ensure that every possible type of condition may be declared for a stored procedure
( covered in more detail in handlers section.);
--source include/show_msg80.inc

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
   declare cond1 condition for sqlstate 'HY000';

   declare cond2 condition for sqlstate '23000';

   declare cond3 condition for sqlstate 'HY001';

   declare cond4 condition for sqlstate '08004';

   declare cond5 condition for sqlstate '08S01';

   declare cond6 condition for sqlstate '42000';

   declare cond7 condition for sqlstate '28000';

   declare cond8 condition for sqlstate '3D000';

   declare cond9 condition for sqlstate '42S01';

   declare cond10 condition for sqlstate '42S02';

   declare cond11 condition for sqlstate '42S22';

   declare cond12 condition for sqlstate '21S01';

   declare cond13 condition for sqlstate '42S21';

   declare cond14 condition for sqlstate '42S12';

   declare cond15 condition for sqlstate '22004';

   declare cond16 condition for sqlstate '25000';

   declare cond17 condition for sqlstate '40001';

   declare cond18 condition for sqlstate '21000';

   declare cond19 condition for sqlstate '01000';

   declare cond20 condition for sqlstate '22003';

   declare cond21 condition for sqlstate '22007';

   declare cond22 condition for sqlstate '0A000';

   declare cond23 condition for sqlstate '70100';

   declare cond24 condition for sqlstate '2F005';

   declare cond25 condition for sqlstate '24000';

   declare cond26 condition for sqlstate '02000';

   declare continue handler for cond2 set @x2 = 1;

   declare continue handler for cond1 set @x2 = 1;

   declare continue handler for cond3 set @x2 = 1;

   declare continue handler for cond4 set @x2 = 1;

   declare continue handler for cond5 set @x2 = 1;

   declare continue handler for cond7 set @x2 = 1;

   declare continue handler for cond6 set @x2 = 1;

   declare continue handler for cond8 set @x2 = 1;

   declare continue handler for cond9 set @x2 = 1;

   declare continue handler for cond10 set @x2 = 1;

   declare continue handler for cond11 set @x2 = 1;

   declare continue handler for cond12 set @x2 = 1;

   declare continue handler for cond13 set @x2 = 1;

   declare continue handler for cond14 set @x2 = 1;

   declare continue handler for cond15 set @x2 = 1;

   declare continue handler for cond16 set @x2 = 1;

   declare continue handler for cond17 set @x2 = 1;

   declare continue handler for cond18 set @x2 = 1;

   declare continue handler for cond19 set @x2 = 1;

   declare continue handler for cond20 set @x2 = 1;

   declare continue handler for cond21 set @x2 = 1;

   declare continue handler for cond22 set @x2 = 1;

   declare continue handler for cond23 set @x2 = 1;

   declare continue handler for cond24 set @x2 = 1;

   declare continue handler for cond25 set @x2 = 1;

   declare continue handler for cond26 set @x2 = 1;


   set @x = 1;

   insert into t2 values (1);

   set @x = 2;

   insert into t2 values (1);

   set @x = 3;
END//
delimiter ;//

CALL sp1();

# clean up
DROP PROCEDURE sp1;

# testcase: ensure that invalid condition declarations are rejected, with an appropriate error message.


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare @x char;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare x char1;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare accessible condition for sqlstate '02000';
    declare exit handler for add set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare add condition for sqlstate '02000';
    declare exit handler for add set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare all condition for sqlstate '02000';
    declare exit handler for all set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare alter condition for sqlstate '02000';
    declare exit handler for alter set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare analyze condition for sqlstate '02000';
    declare exit handler for analyze set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare and condition for sqlstate '02000';
    declare exit handler for and set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare as condition for sqlstate '02000';
    declare exit handler for as set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare asc condition for sqlstate '02000';
    declare exit handler for asc set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare asensitive condition for sqlstate '02000';
    declare exit handler for asensitive set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare before condition for sqlstate '02000';
    declare exit handler for before set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare between condition for sqlstate '02000';
    declare exit handler for between set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint condition for sqlstate '02000';
    declare exit handler for bigint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare binary condition for sqlstate '02000';
    declare exit handler for binary set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare blob condition for sqlstate '02000';
    declare exit handler for blob set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare both condition for sqlstate '02000';
    declare exit handler for both set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare by condition for sqlstate '02000';
    declare exit handler for by set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare call condition for sqlstate '02000';
    declare exit handler for CALL set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cascade condition for sqlstate '02000';
    declare exit handler for cascade set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare case condition for sqlstate '02000';
    declare exit handler for case set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare change condition for sqlstate '02000';
    declare exit handler for change set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare char condition for sqlstate '02000';
    declare exit handler for char set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare character condition for sqlstate '02000';
    declare exit handler for character set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare check condition for sqlstate '02000';
    declare exit handler for check set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
#--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare collate condition for sqlstate '02000';
    declare exit handler for collate set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare column condition for sqlstate '02000';
    declare exit handler for column set @var2 = 1;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare condition condition for sqlstate '02000';
    declare exit handler for condition set @var2 = 1;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
#--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare connection condition for sqlstate '02000';
    declare exit handler for connection set @var2 = 1;
END//
delimiter ;//
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare constraint condition for sqlstate '02000';
    declare exit handler for constraint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare continue condition for sqlstate '02000';
    declare exit handler for continue set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare convert condition for sqlstate '02000';
    declare exit handler for convert set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare create condition for sqlstate '02000';
    declare exit handler for create set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cross condition for sqlstate '02000';
    declare exit handler for cross set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_date condition for sqlstate '02000';
    declare exit handler for current_date set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_time condition for sqlstate '02000';
    declare exit handler for current_time set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_timestamp condition for sqlstate '02000';
    declare exit handler for current_timestamp set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_user condition for sqlstate '02000';
    declare exit handler for current_user set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cursor condition for sqlstate '02000';
    declare exit handler for cursor set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare database condition for sqlstate '02000';
    declare exit handler for database set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare databases condition for sqlstate '02000';
    declare exit handler for databases set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_hour condition for sqlstate '02000';
    declare exit handler for day_hour set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_microsecond condition for sqlstate '02000';
    declare exit handler for day_microsecond set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_minute condition for sqlstate '02000';
    declare exit handler for day_minute set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_second condition for sqlstate '02000';
    declare exit handler for day_second set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare dec condition for sqlstate '02000';
    declare exit handler for dec set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal condition for sqlstate '02000';
    declare exit handler for decimal set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare declare condition for sqlstate '02000';
    declare exit handler for declare set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare default condition for sqlstate '02000';
    declare exit handler for default set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare delayed condition for sqlstate '02000';
    declare exit handler for delayed set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare delete condition for sqlstate '02000';
    declare exit handler for delete set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare desc condition for sqlstate '02000';
    declare exit handler for desc set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare describe condition for sqlstate '02000';
    declare exit handler for describe set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare deterministic condition for sqlstate '02000';
    declare exit handler for deterministic set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare distinct condition for sqlstate '02000';
    declare exit handler for distinct set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare distinctrow condition for sqlstate '02000';
    declare exit handler for distinctrow set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare div condition for sqlstate '02000';
    declare exit handler for div set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double condition for sqlstate '02000';
    declare exit handler for double set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare drop condition for sqlstate '02000';
    declare exit handler for drop set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare dual condition for sqlstate '02000';
    declare exit handler for dual set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare each condition for sqlstate '02000';
    declare exit handler for each set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare else condition for sqlstate '02000';
    declare exit handler for else set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare elseif condition for sqlstate '02000';
    declare exit handler for elseif set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare enclosed condition for sqlstate '02000';
    declare exit handler for enclosed set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare escaped condition for sqlstate '02000';
    declare exit handler for escaped set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare exists condition for sqlstate '02000';
    declare exit handler for exists set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare exit condition for sqlstate '02000';
    declare exit handler for exit set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare explain condition for sqlstate '02000';
    declare exit handler for explain set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare false condition for sqlstate '02000';
    declare exit handler for false set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare fetch condition for sqlstate '02000';
    declare exit handler for fetch set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float condition for sqlstate '02000';
    declare exit handler for float set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float4 condition for sqlstate '02000';
    declare exit handler for add set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float8 condition for sqlstate '02000';
    declare exit handler for add set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare for condition for sqlstate '02000';
    declare exit handler for for set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare force condition for sqlstate '02000';
    declare exit handler for force set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare foreign condition for sqlstate '02000';
    declare exit handler for foreign set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare from condition for sqlstate '02000';
    declare exit handler for from set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare fulltext condition for sqlstate '02000';
    declare exit handler for fulltext set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare grant condition for sqlstate '02000';
    declare exit handler for grant set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare group condition for sqlstate '02000';
    declare exit handler for group set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare having condition for sqlstate '02000';
    declare exit handler for having set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare high_priority condition for sqlstate '02000';
    declare exit handler for high_priority set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_microsecond condition for sqlstate '02000';
    declare exit handler for hour_microsecond set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_minute condition for sqlstate '02000';
    declare exit handler for hour_minute set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_second condition for sqlstate '02000';
    declare exit handler for hour_second set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare if condition for sqlstate '02000';
    declare exit handler for if set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare ignore condition for sqlstate '02000';
    declare exit handler for ignore set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare in condition for sqlstate '02000';
    declare exit handler for in set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare index condition for sqlstate '02000';
    declare exit handler for index set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare infile condition for sqlstate '02000';
    declare exit handler for infile set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare inner condition for sqlstate '02000';
    declare exit handler for inner set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare inout condition for sqlstate '02000';
    declare exit handler for inout set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare insensitive condition for sqlstate '02000';
    declare exit handler for insensitive set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare insert condition for sqlstate '02000';
    declare exit handler for insert set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int1 condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int2 condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int3 condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int4 condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int8 condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare integer condition for sqlstate '02000';
    declare exit handler for integer set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare interval condition for sqlstate '02000';
    declare exit handler for interval set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare into condition for sqlstate '02000';
    declare exit handler for into set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare is condition for sqlstate '02000';
    declare exit handler for is set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare iterate condition for sqlstate '02000';
    declare exit handler for iterate set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare join condition for sqlstate '02000';
    declare exit handler for join set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare key condition for sqlstate '02000';
    declare exit handler for key set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare keys condition for sqlstate '02000';
    declare exit handler for keys set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare kill condition for sqlstate '02000';
    declare exit handler for kill set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare leading condition for sqlstate '02000';
    declare exit handler for leading set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare leave condition for sqlstate '02000';
    declare exit handler for leave set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare left condition for sqlstate '02000';
    declare exit handler for left set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare like condition for sqlstate '02000';
    declare exit handler for like set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare limit condition for sqlstate '02000';
    declare exit handler for limit set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare linear condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare lines condition for sqlstate '02000';
    declare exit handler for lines set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare load condition for sqlstate '02000';
    declare exit handler for load set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare localtime condition for sqlstate '02000';
    declare exit handler for localtime set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare localtimestamp condition for sqlstate '02000';
    declare exit handler for localtimestamp set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare lock condition for sqlstate '02000';
    declare exit handler for lock set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare long condition for sqlstate '02000';
    declare exit handler for long set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longblob condition for sqlstate '02000';
    declare exit handler for longblob set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longtext condition for sqlstate '02000';
    declare exit handler for longtext set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare loop condition for sqlstate '02000';
    declare exit handler for loop set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare low_priority condition for sqlstate '02000';
    declare exit handler for low_priority set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare master_ssl_verify_server_cert condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare match condition for sqlstate '02000';
    declare exit handler for match set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumblob condition for sqlstate '02000';
    declare exit handler for mediumblob set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint condition for sqlstate '02000';
    declare exit handler for mediumint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumtext condition for sqlstate '02000';
    declare exit handler for mediumtext set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare middleint condition for sqlstate '02000';
    declare exit handler for middleint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare minute_microsecond condition for sqlstate '02000';
    declare exit handler for minute_microsecond set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare minute_second condition for sqlstate '02000';
    declare exit handler for minute_second set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mod condition for sqlstate '02000';
    declare exit handler for mod set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare modifies condition for sqlstate '02000';
    declare exit handler for modifies set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare natural condition for sqlstate '02000';
    declare exit handler for natural set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare not condition for sqlstate '02000';
    declare exit handler for not set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare no_write_to_binlog condition for sqlstate '02000';
    declare exit handler for no_write_to_binlog set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare null condition for sqlstate '02000';
    declare exit handler for null set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric condition for sqlstate '02000';
    declare exit handler for numeric set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare on condition for sqlstate '02000';
    declare exit handler for on set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare optimize condition for sqlstate '02000';
    declare exit handler for optimize set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare option condition for sqlstate '02000';
    declare exit handler for option set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare optionally condition for sqlstate '02000';
    declare exit handler for optionally set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare or condition for sqlstate '02000';
    declare exit handler for or set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare order condition for sqlstate '02000';
    declare exit handler for order set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare out condition for sqlstate '02000';
    declare exit handler for out set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare outer condition for sqlstate '02000';
    declare exit handler for outer set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare outfile condition for sqlstate '02000';
    declare exit handler for outfile set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare precision condition for sqlstate '02000';
    declare exit handler for precision set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare primary condition for sqlstate '02000';
    declare exit handler for primary set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare procedure condition for sqlstate '02000';
    declare exit handler for procedure set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare purge condition for sqlstate '02000';
    declare exit handler for purge set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare range condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read condition for sqlstate '02000';
    declare exit handler for read set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare reads condition for sqlstate '02000';
    declare exit handler for reads set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read_only condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read_write condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real condition for sqlstate '02000';
    declare exit handler for real set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare references condition for sqlstate '02000';
    declare exit handler for references set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare regexp condition for sqlstate '02000';
    declare exit handler for regexp set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare release condition for sqlstate '02000';
    declare exit handler for int set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare rename condition for sqlstate '02000';
    declare exit handler for rename set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare repeat condition for sqlstate '02000';
    declare exit handler for repeat set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare replace condition for sqlstate '02000';
    declare exit handler for replace set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare require condition for sqlstate '02000';
    declare exit handler for require set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare restrict condition for sqlstate '02000';
    declare exit handler for restrict set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare return condition for sqlstate '02000';
    declare exit handler for return set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare revoke condition for sqlstate '02000';
    declare exit handler for revoke set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare right condition for sqlstate '02000';
    declare exit handler for right set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare rlike condition for sqlstate '02000';
    declare exit handler for rlike set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare schema condition for sqlstate '02000';
    declare exit handler for schema set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare schemas condition for sqlstate '02000';
    declare exit handler for schemas set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare second_microsecond condition for sqlstate '02000';
    declare exit handler for second_microsecond set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare select condition for sqlstate '02000';
    declare exit handler for SELECT set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sensitive condition for sqlstate '02000';
    declare exit handler for sensitive set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare separator condition for sqlstate '02000';
    declare exit handler for separator set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare set condition for sqlstate '02000';
    declare exit handler for set set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare show condition for sqlstate '02000';
    declare exit handler for show set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint condition for sqlstate '02000';
    declare exit handler for smallint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare spatial condition for sqlstate '02000';
    declare exit handler for spatial set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare specific condition for sqlstate '02000';
    declare exit handler for specific set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql condition for sqlstate '02000';
    declare exit handler for sql set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlexception condition for sqlstate '02000';
    declare exit handler for sqlexception set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlstate condition for sqlstate '02000';
    declare exit handler for sqlstate set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlwarning condition for sqlstate '02000';
    declare exit handler for sqlwarning set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_big_result condition for sqlstate '02000';
    declare exit handler for sql_big_result set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_calc_found_rows condition for sqlstate '02000';
    declare exit handler for sql_calc_found_rows set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_small_result condition for sqlstate '02000';
    declare exit handler for sql_small_result set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare ssl condition for sqlstate '02000';
    declare exit handler for ssl set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare starting condition for sqlstate '02000';
    declare exit handler for starting set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare straight_join condition for sqlstate '02000';
    declare exit handler for straight_join set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare table condition for sqlstate '02000';
    declare exit handler for table set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare terminated condition for sqlstate '02000';
    declare exit handler for terminated set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare then condition for sqlstate '02000';
    declare exit handler for then set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyblob condition for sqlstate '02000';
    declare exit handler for tinyblob set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint condition for sqlstate '02000';
    declare exit handler for tinyint set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinytext condition for sqlstate '02000';
    declare exit handler for tinytext set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare to condition for sqlstate '02000';
    declare exit handler for to set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare trailing condition for sqlstate '02000';
    declare exit handler for trailing set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare trigger condition for sqlstate '02000';
    declare exit handler for trigger set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare true condition for sqlstate '02000';
    declare exit handler for true set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare undo condition for sqlstate '02000';
    declare exit handler for undo set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare union condition for sqlstate '02000';
    declare exit handler for union set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unique condition for sqlstate '02000';
    declare exit handler for unique set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unlock condition for sqlstate '02000';
    declare exit handler for unlock set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unsigned condition for sqlstate '02000';
    declare exit handler for unsigned set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare update condition for sqlstate '02000';
    declare exit handler for update set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare usage condition for sqlstate '02000';
    declare exit handler for usage set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare use condition for sqlstate '02000';
    declare exit handler for USE set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare using condition for sqlstate '02000';
    declare exit handler for using set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_date condition for sqlstate '02000';
    declare exit handler for utc_date set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_time condition for sqlstate '02000';
    declare exit handler for utc_time set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_timestamp condition for sqlstate '02000';
    declare exit handler for utc_timestamp set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare values condition for sqlstate '02000';
    declare exit handler for values set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varbinary condition for sqlstate '02000';
    declare exit handler for varbinary set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varchar condition for sqlstate '02000';
    declare exit handler for varchar set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varcharacter condition for sqlstate '02000';
    declare exit handler for varcharacter set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varying condition for sqlstate '02000';
    declare exit handler for varying set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare when condition for sqlstate '02000';
    declare exit handler for when set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare where condition for sqlstate '02000';
    declare exit handler for where set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare while condition for sqlstate '02000';
    declare exit handler for while set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare with condition for sqlstate '02000';
    declare exit handler for with set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare write condition for sqlstate '02000';
    declare exit handler for write set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare xor condition for sqlstate '02000';
    declare exit handler for xor set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare year_month condition for sqlstate '02000';
    declare exit handler for year_month set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare zerofill condition for sqlstate '02000';
    declare exit handler for zerofill set @var2 = 1;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase :
              ----------
Ensure that every possible type of handler may be declared for
a stored procedure (continue- handler_type ).;
--source include/show_msg80.inc

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '23000' set @x2 = 1;

    set @x = 1;

    insert into t2(f1) values (1);

    set @x = 2;

    insert into t2(f1) values (1);

    set @x = 3;
END//
delimiter ;//

CALL sp1();

# cleanup

DROP PROCEDURE sp1;


# testcase: ensure that every possible type of handler may be declared
#            for a stored procedure (undo - handler_type ).
# ?????????? undo handler not supported as of now


DROP PROCEDURE IF EXISTS handler1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE handler1()
BEGIN
    declare undo handler for sqlstate '23000' set @x2 = 1;

    set @x = 1;

    insert into t values (1);

    set @x = 2;

    insert into t values (1);

    set @x = 3;
END//
delimiter ;//

# testcase: ensure that invalid handler declarations are rejected with an
#            appropriate error message. (continue- handler_type).


DROP PROCEDURE IF EXISTS handler1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE handler1()
BEGIN
    declare continueinv handler for sqlstate '2300' set @x2 = 1;

    set @x = 1;

    insert into t values (1);

    set @x = 2;

    insert into t values (1);

    set @x = 3;
END//
delimiter ;//

# testcase: ensure that invalid handler declarations are rejected with
#            an appropriate error message (undo - handler_type ).


DROP PROCEDURE IF EXISTS handler1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE handler1()
BEGIN
    declare undoinv handler for sqlstate '2300' set @x2 = 1;

    set @x = 1;

    insert into t values (1);

    set @x = 2;

    insert into t values (1);

    set @x = 3;
END//
delimiter ;//

# testcase: ensure that invalid handler declarations are rejected with an
#            appropriate error message (exit- handler_type )


DROP PROCEDURE IF EXISTS handler1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE handler1 ()
BEGIN
    declare exitinv handler for sqlstate '2300' set @x2 = 1;

    set @x = 1;

    insert into t values (1);

    set @x = 2;

    insert into t values (1);

    set @x = 3;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare accessible handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare add handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare all handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare alter handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare analyze handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare and handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare as handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare asc handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare asensitive handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare before handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare between handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare bigint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare binary handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare blob handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare both handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare by handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare call handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cascade handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare case handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare change handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare char handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare character handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare check handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare collate handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare column handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare condition handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare constraint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

--error ER_PARSE_ERROR
delimiter //;
CREATE PROCEDURE sp1( )
 BEGIN
   declare continue handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare convert handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare create handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cross handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_date handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_time handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_timestamp handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare current_user handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare cursor handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare database handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare databases handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_hour handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_microsecond handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_minute handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare day_second handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare dec handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare decimal handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare declare handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare default handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare delayed handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare delete handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare desc handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare describe handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare deterministic handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare distinct handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare distinctrow handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare div handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare double handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare drop handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare dual handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare each handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare else handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare elseif handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare enclosed handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare escaped handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare exists handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

--error ER_PARSE_ERROR
delimiter //;
CREATE PROCEDURE sp1( )
 BEGIN
   declare exit handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare explain handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare false handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare fetch handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float4 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare float8 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare for handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare force handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare foreign handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare from handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare fulltext handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare grant handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare group handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare having handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare high_priority handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_microsecond handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_minute handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare hour_second handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare if handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare ignore handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare in handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare index handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare infile handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare inner handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare inout handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare insensitive handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare insert handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int1 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int2 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int3 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int4 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare int8 handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare integer handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare interval handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare into handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare is handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare iterate handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare join handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare key handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare keys handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare kill handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare leading handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare leave handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare left handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare like handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare limit handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare linear handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare lines handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare load handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare localtime handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare localtimestamp handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare lock handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare long handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longblob handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare longtext handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare loop handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare low_priority handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare master_ssl_verify_server_cert handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare match handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumblob handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mediumtext handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare middleint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare minute_microsecond handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare minute_second handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare mod handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare modifies handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare natural handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare not handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare no_write_to_binlog handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare null handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare numeric handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare on handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare optimize handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare option handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare optionally handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare or handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare order handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare out handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare outer handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare outfile handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare precision handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare primary handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare privileges handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare procedure handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare purge handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare range handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare reads handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read_only handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare read_write handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare real handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare references handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare regexp handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare release handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare rename handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare repeat handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare replace handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare require handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare restrict handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare return handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare revoke handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare right handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare rlike handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare schema handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare schemas handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare second_microsecond handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare select handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sensitive handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare separator handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare set handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare show handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare smallint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare spatial handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare specific handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlexception handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlstate handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sqlwarning handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_big_result handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_calc_found_rows handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare sql_small_result handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare ssl handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare starting handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare straight_join handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare table handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare terminated handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare then handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyblob handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinyint handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare tinytext handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare to handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare trailing handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare trigger handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare true handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare undo handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare union handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unique handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unlock handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare unsigned handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare update handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare usage handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare use handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare using handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_date handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_time handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare utc_timestamp handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare values handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varbinary handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varchar handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varcharacter handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare varying handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare when handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare where handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare while handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare with handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare write handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare xor handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare year_month handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1( )
BEGIN
    declare zerofill handler for sqlstate '02000' set @var2 = 1;
END//
delimiter ;//


# ==============================================================================
#
# test plan section: 4.2 - syntax checks for programming statements - 2
#
# ==============================================================================


USE db_storedproc;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.26:;
--source include/show_msg80.inc

# testcase: ensure that the scope of every variable, cursor, condition and handler
#            declared for a stored procedure (with the declare statement) is properly applied.


set @v1='0';
set @v2='0';
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x char;
    declare y char;
    declare cond1 condition for sqlstate '42000';
    declare cur1 cursor for SELECT f1 from t2 limit 1;
    declare continue handler for cond1 set @x = 4;
    set @x = '1';
    set @y = '2';
    BEGIN
      declare x char;
      declare y char;
      declare cur1 cursor for SELECT f1 from t2 limit 2, 1;
      declare continue handler for sqlstate '42000' set @x = 3;
      open cur1;
      fetch cur1 into y;
      close cur1;
    CALL nonsexist();
      SELECT x, y, @x;
    END;
    open cur1;
    fetch cur1 into y;
    close cur1;
  CALL nonsexist();
    set @v1 = @x;
    set @v2 = y;
END//
delimiter ;//

CALL sp1();
  SELECT @v1, @v2;

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.28:;
--source include/show_msg80.inc

# testcase: ensure that the set statement can assign a value to every local variable
#            declared within a stored procedures definition, as well as to every
#            appropriate global server variable.

SET @x = 0;
SET @y = 0;
DROP PROCEDURE IF EXISTS sp1;

SET @start_global_value = @@GLOBAL.sort_buffer_size;
delimiter //;
CREATE PROCEDURE sp1()
BEGIN
   DECLARE CONTINUE HANDLER FOR SQLSTATE '42000' SET @x2 = 1;
   SET SESSION SORT_BUFFER_SIZE = 10 * 1024 * 1024;
   SELECT @@sort_buffer_size;
   SET @x = 4;
   SET @y = 3;
   SET GLOBAL SORT_BUFFER_SIZE = 2 * 1024 * 1024;
   SELECT @@sort_buffer_size;
   SET @@sort_buffer_size = 10 * 1024 * 1024;
   SELECT @@sort_buffer_size;
END//
delimiter ;//
CALL sp1();
SELECT @x, @y;
SET @@GLOBAL.sort_buffer_size = @start_global_value;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.29:;
--source include/show_msg80.inc

# testcase: ensure that the set statement can assign values to variables either
#            separately or multiple variables in a list.


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx char default 'x';
    declare xy char default 'y';
    declare xz char default 'z';
    set @xx = xx, @xy = xy;
    set @xz = xz;
    SELECT @xx, @xy, @xz;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.30:;
--source include/show_msg80.inc

# testcase: ensure that the set statement may assign only those values to a variable
#            that are appropriate for that variables data type definition

# integer data_type.

  set @xx=0;

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx int;
    set xx = 'asd';
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    set @xx = xx;
    SELECT @xx;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx int;
    set xx = 5;
    set @xx = xx;
    SELECT @xx;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.31 - a:;
--source include/show_msg80.inc

# character data_type

  set @xx=0;

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx char;
    set xx = 'temp';
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    set @xx = xx;
END//
delimiter ;//

CALL sp1();

  SELECT @xx;

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.31 - b:;
--source include/show_msg80.inc

# float data_type

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx float;
    set xx = 'asd';
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT xx;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx float;
    set xx = 1.6;
    SELECT xx;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.31 - c:;
--source include/show_msg80.inc

# datetime data_type

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx datetime;
    set xx = 'asd';
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT xx;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx datetime;
    set xx = '2006-06-06 01:01:01';
    SELECT xx;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.31 - d:;
--source include/show_msg80.inc

# varchar data_type

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx varchar(20);
    set xx = "abcdefghijk";
    SELECT xx;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.31 - e:;
--source include/show_msg80.inc

# tinyint

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx tinyint;
    set xx = 'asd';
    GET DIAGNOSTICS @n = NUMBER;
    GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
    SELECT @err_no, @err_txt;
    SELECT xx;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare xx tinyint;
    set xx = -125;
    SELECT xx;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.37:;
--source include/show_msg80.inc

# testcase: ensure that the SELECT  into statement that retrieves column values
#            with inappropriate data types for the matching variables in its variable
#            list is rejected, with an appropriate error message.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare x integer; declare y integer;
    SELECT sal, f2 into x, y from t2 limit 1;
    set @x=x; set @y=y;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x char ascii;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinytext;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x text;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumtext;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x longtext;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinyblob;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x blob;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumblob;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x longblob;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x binary;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

--disable_warnings

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinyint;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinyint unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinyint zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x tinyint unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x smallint;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x smallint unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x smallint zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x smallint unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumint;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumint unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;
delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumint zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x mediumint unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x int;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x int unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x int zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x int unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x bigint;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x bigint unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x bigint zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x bigint unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x decimal;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x decimal unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x decimal zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x decimal unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x numeric;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x numeric unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x numeric zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x numeric unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x real;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x real unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x real zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x real unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x float;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x float unsigned;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x float zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x float unsigned zerofill;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x date;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x time;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x datetime;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x timestamp;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x year;
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x year(4);
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x enum("1enum", "2enum");
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare x set("1set", "2set");
    SELECT f1 into x from t2 limit 1;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.38:;
--source include/show_msg80.inc

# testcase: ensure that the declare condition for statement can declare a properly
#            named condition for every possible sqlstate and mysql-specific error code.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare notable condition for sqlstate '42S02';
    declare continue handler for notable set @x2=1;
    set @x = 1;
    insert into t2(f1) values (1);
    set @x = 2;
    insert into t2(f1) values (1);
    set @x = 3;
END//
delimiter ;//

CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.39:;
--source include/show_msg80.inc

# testcase: ensure that no two conditions declared with the same scope may have the
#            same condition name (same condition name in same scope)

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_DUP_COND
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '42000';
    declare cond1 condition for sqlstate '23000';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values(1);
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.41:;
--source include/show_msg80.inc

# testcase: ensure that every sqlstate value declared with a declare  condition for
#            statement is a character string that is 5 character.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '1';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '12';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '123';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '1234';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '123456';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.42:;
--source include/show_msg80.inc

# testcase: ensure that the declare  condition for statement cannot declare a
#            condition for an invalid sqlstate.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate 'abcdefghi';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '42000test';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '00000@#$%^&';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate 'null';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate ' ';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate 1234567890;
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '2005-03-03';
    declare continue handler for cond1 set @var2 = 1;
    insert into tnull values( 1);
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.43:;
--source include/show_msg80.inc

# testcase: ensure that the declare  condition for statement cannot declare a
#            condition for the successful completion sqlstate: 00000.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

--echo expect failure, SQLSTATE 00000 is not an acceptable value
--echo for an SP's handler
delimiter //;
--ERROR ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare cond1 condition for sqlstate '00000';
    declare continue handler for cond1 set @var2 = 1;
    set @x=1;
    SELECT @var2;
END//
delimiter ;//

--echo ensure SP doesn't exist
--ERROR ER_SP_DOES_NOT_EXIST
CALL sp1();

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.45:;
--source include/show_msg80.inc

# testcase: ensure that within the same scope, no two handlers may be declared for the same condition.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_DUP_HANDLER
CREATE PROCEDURE handler1 ()
BEGIN
      declare continue handler for sqlstate '23000' set @varr1 = 5;
        declare continue handler for sqlstate '23000' set @varr3 = 7;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS handler1;

delimiter //;
--error ER_SP_DUP_HANDLER
CREATE PROCEDURE handler1 ()
BEGIN
      declare mycondition condition for sqlstate '23000';
    declare continue handler for mycondition set @varr3 = 7;
        declare continue handler for sqlstate '23000' set @varr3 = 7;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.46:;
--source include/show_msg80.inc

# testcase: ensure that every sqlstate value declared with a declare  handler for
#            statement is a character string that is 5 characters long.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '1' set @var2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '12' set @var2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '123' set @var2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '1234' set @var2 = 1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '123456' set @var2 = 1;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.47:;
--source include/show_msg80.inc

# testcase: ensure that the declare  handler for statement cannot declare a condition
#            for an invalid sqlstate.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '42s0200test'  set @var2 = 1;
    insert into tnull values( 1);
          SELECT @var2;
END//
delimiter ;//

# cleanup
#drop table IF EXISTS tnull;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.48:;
--source include/show_msg80.inc

# testcase: ensure that the declare  handler for statement cannot declare a condition
#            for the successful completion sqlstate:  00000.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

--echo This creation should fail, SQLSTATE 00000 is unacceptable
--ERROR ER_SP_BAD_SQLSTATE
delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare continue handler for sqlstate '00000'  set @var2 = 1;
    set @x=1;
          SELECT @var2;
END//
delimiter ;//

--echo Verify SP wasn't created
--ERROR ER_SP_DOES_NOT_EXIST
CALL sp1();

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTSsp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.52:;
--source include/show_msg80.inc

# testcase: ensure that no two cursors in a stored procedure can have the same name.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_DUP_CURS
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
    declare cur1 cursor for SELECT f1, f2 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newlf1, newf3, newsal;
        set count = count - 1;
      END while;
      close cur1;
    END;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.53:;
--source include/show_msg80.inc

# testcase: ensure that a cursor declaration may not include a SELECT  into statement.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_BAD_CURSOR_SELECT
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, lf1, f3, f4 into @w, @x, @y, @z from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newlf1, newf3, newsal;
        set count = count - 1;
      END while;
      close cur1;
      END;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.54:;
--source include/show_msg80.inc

# testcase: ensure that a cursor declaration that includes an order by
#            claUSE may not be an updateable cursor.

#FIXME: testcase empty / missing

# ------------------------------------------------------------------------------
let $message= Testcase 4.2.55:;
--source include/show_msg80.inc

# testcase: ensure that open <cursor name> fails unless a cursor with
#            the same name has already been declared.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
--error ER_SP_CURSOR_MISMATCH
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      close cur1;
    END;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 0;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      BEGIN
        open cur1;
        set count = count - 1;
        while count > 0 do
          fetch cur1 into newf1, newf2, newf3, newf4;
          set count = count - 1;
        END while;
      END;
      close cur1;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_ALREADY_OPEN
CALL sp1();


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.56:;
--source include/show_msg80.inc

# testcase: ensure that open <cursor name> fails if the same cursor is currently already open.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      close cur1;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_ALREADY_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.57:;
--source include/show_msg80.inc

# testcase: ensure that fetch <cursor name> fails unless a cursor with the same name is already open.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2;
    declare cur2 cursor for SELECT f1, f2 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur2;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      close cur1;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;






# ------------------------------------------------------------------------------
let $message= Testcase 4.2.59:;
--source include/show_msg80.inc

# testcase: ensure that fetch <cursor name> fails with an appropriate error message
#            if it is executed before the cursor has been opened.


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      open cur1;
      close cur1;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 10;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    BEGIN
      declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf3, newf4;
        set count = count - 1;
      END while;
      open cur1;
      close cur1;
    END;
    close cur1;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.60:;
--source include/show_msg80.inc

# testcase: ensure that fetch <cursor name> fails with an appropriate error message
#            if it is executed after the cursor has been closed.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      close cur1;
      set count = count - 1;
      while count > 0 do
          fetch cur1 into newf1, newf2, newf4, newf3;
          set count = count - 1;
      END while;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    close cur1;
    BEGIN
      declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
      open cur1;
      END;
    fetch cur1 into newf1, newf2, newf3, newf4;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;




# ------------------------------------------------------------------------------
let $message= Testcase 4.2.62:;
--source include/show_msg80.inc

# testcase: ensure that fetch <cursor name> fails with an appropriate error message
#            if the data type of the column values being fetched are not appropriate
#            for the matching fetch variables to which the data is being assigned.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf2 char(20);
    declare newf1 int1;
    declare cur1 cursor for SELECT f1, f3 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2;
        set @x = newf1;
        set @y = newf2;
        SELECT @x, @y;
        set count = count - 1;
          END while;
      close cur1;
    END;
END//
delimiter ;//

#This test seems to make no sense, as always NULL may be set.
#--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.63:;
--source include/show_msg80.inc

# testcase: ensure that close <cursor name> fails unless a cursor with the same name is already open.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      close cur1;
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      close cur1;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 0;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      declare cur1 cursor for SELECT f1, f2, f3, f4 from t2;
      open cur1;
    END;
    close cur1;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.64:;
--source include/show_msg80.inc

# testcase: ensure that all cursors are closed when a transaction terminates with a commit statement.

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
      BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    BEGIN
      open cur1;
      start transaction;
      fetch cur1 into newf1, newf2, newf4, newf3;
      commit;
      fetch cur1 into newf1, newf2, newf4, newf3;
    END;
END//
delimiter ;//

--error ER_SP_FETCH_NO_DATA
CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.65:;
--source include/show_msg80.inc

# testcase: ensure that all cursors are closed when a transaction terminates with a rollback statement.


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    BEGIN
      open cur1;
      fetch cur1 into newf1, newf2, newf4, newf3;
      rollback;
      fetch cur1 into newf1, newf2, newf4, newf3;
      commit;
    END;
END//
delimiter ;//

--error ER_SP_FETCH_NO_DATA
CALL sp1();

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.2.66:;
--source include/show_msg80.inc

# testcase: ensure that the result set of the cursor that has been closed is not
#            longer available to the fetch statement.


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
      set count = count - 1;
      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
        set count = count - 1;
      END while;
      close cur1;
      fetch cur1 into newf1, newf2, newf4, newf3;
    END;
END//
delimiter ;//

--error ER_SP_CURSOR_NOT_OPEN
CALL sp1();

# cleanup
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.2.67:;
--source include/show_msg80.inc

# testcase: ensure that cursor declared within a compound statement is closed when
#            that compound statement ends (without cursor close statement)


DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 20, 10;
    declare continue handler for sqlstate '02000' set done = 1;
    BEGIN
      open cur1;
#      set count = count - 1;
#      while count > 0 do
        fetch cur1 into newf1, newf2, newf4, newf3;
#        set count = count - 1;
#      END while;
    END;
    fetch cur1 into newf1, newf2, newf4, newf3;
END//
delimiter ;//

#--error ER_SP_FETCH_NO_DATA
CALL sp1();

# cleanup
DROP PROCEDURE sp1;






# ------------------------------------------------------------------------------
let $message= Testcase 4.2.70:;
--source include/show_msg80.inc

# testcase: ensure that multiple cursors, nested within multiple compound statements
#            within a stored procedure always act correctly and return the expected result.

  create table temp1( f1 char(20), f2 char(20), f3 int, f4 char(20) );
  create table temp2( f1 char(20), f2 char(20), f3 int, f4 char(20) );

DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( )
BEGIN
    declare done int default 0;
    declare count integer default 20;
    declare newf1 char(20);
    declare newf2 char(20);
    declare newf3 char(20);
    declare newf4 integer;
    declare newf21 char(20);
    declare newf22 char(20);
    declare newf23 char(20);
    declare newf24 integer;
    declare cur1 cursor for SELECT f1, f2, f4, f5 from t2 limit 7, 1;
    declare cur2 cursor for SELECT f1, f2, f4, f5 from t2 limit 15, 1;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    BEGIN
      set count = 10;
      BEGIN
        open cur2;
        while count > 0 do
          fetch cur1 into newf1, newf2, newf4, newf3;
          set count = count - 1;
        END while;
      END;
      insert into temp1 values(newf1, newf2, newf4, newf3);
      close cur1;
    END;
    BEGIN
      set count = 10;
      while count > 0 do
        fetch cur2 into newf21, newf22, newf24, newf23;
        set count = count - 1;
      END while;
    END;
    insert into temp2 values(newf21, newf22, newf24, newf23);
    close cur2;
END//
delimiter ;//

CALL sp1();

SELECT count(*) from temp1;
SELECT * from temp2;

# cleanup
DROP PROCEDURE sp1;
drop table temp1;
drop table temp2;


# ==============================================================================
let $message= Section 3.1.3 - Syntax checks for the stored procedure-specific flow control statements
              .               IF, CASE, LOOP, LEAVE, ITERATE, REPEAT, WHILE:;
--source include/show_msg80.inc

USE db_storedproc;

# ------------------------------------------------------------------------------
let $message= Testcase 4.3.1:;
--source include/show_msg80.inc

# testcase : ensure that all clauses that should be supported are supported

--disable_warnings
DROP PROCEDURE IF EXISTS sp1;
DROP TABLE IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
--enable_warnings

#FIXME: change back to $engine_type for INNODB and MYISAM, but MEMORY doesn't support this
--replace_result $engine_type <engine_to_be_tested>
eval
CREATE TABLE res_t3_itisalongname_1381742_itsaverylongname_1381742(
   middleinitial CHAR, lastname VARCHAR(50),
   age_averylongfieldname_averylongname_1234569 INT, COMMENT VARCHAR(100))
ENGINE=$engine_type;

INSERT INTO res_t3_itisalongname_1381742_itsaverylongname_1381742
VALUES('a', 'aaaaaaaaaabbbbbbbbc', 0, 'default');

delimiter //;
CREATE PROCEDURE sp1(a INT)
BEGIN
   DECLARE itisjustaverylargevariablename_xxxxxxxxxxxxxxxxxxxxx CHAR;
   DECLARE itisjustaverylargevarcharvariablename_xxxxxxxxxxxxxxxxxxxxx VARCHAR(100);
   DECLARE itisjustamediumsizeintintegervariablename INTEGER;
   SET itisjustaverylargevariablename_xxxxxxxxxxxxxxxxxxxxx = 'b';
   SET itisjustaverylargevarcharvariablename_xxxxxxxxxxxxxxxxxxxxx
      = 'oldmacdonalds)(*&(^^%$&^%$&^%*^)(*^#@$@%';
   SET itisjustamediumsizeintintegervariablename = 5;
   SET @comment='a';
   label1: LOOP
      IF a > 100 THEN
         SET @comment = 'value of a is greater than 100';
      ELSEIF a < 100 THEN
         IF a < 50 THEN
            SET @comment = 'value of a is less than 50';
         ELSEIF a < 25 THEN
            SET @comment = 'value of a is less than 25';
         ELSE
            SET @comment = 'value of a is greater than 50 and less than 100';
         END IF;
      ELSE
         SET @comment = 'value of a is 100';
      END IF;

      IF itisjustamediumsizeintintegervariablename = 0 THEN LEAVE label1;
      END IF;
      INSERT INTO res_t3_itisalongname_1381742_itsaverylongname_1381742
      VALUES(itisjustaverylargevariablename_xxxxxxxxxxxxxxxxxxxxx,
             CONCAT(itisjustaverylargevarcharvariablename_xxxxxxxxxxxxxxxxxxxxx,
             '  ', a), a, @comment);
      SET itisjustamediumsizeintintegervariablename
         = itisjustamediumsizeintintegervariablename - 1;
      ITERATE label1;
   END LOOP label1;
END//
delimiter ;//

CALL sp1(101);

CALL sp1(100);

CALL sp1(75);

CALL sp1(40);

CALL sp1(20);

CALL sp1(-1);

SELECT * from res_t3_itisalongname_1381742_itsaverylongname_1381742
 ORDER BY middleinitial, lastname, age_averylongfieldname_averylongname_1234569;

# cleanup
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.2:;
--source include/show_msg80.inc

# testcase: ensure that all clauses that should be supported are supported (case, while, repeat)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp2;

delimiter //;
CREATE PROCEDURE sp2( action char(20) )
BEGIN
   declare v1 char(20);
   declare v2 char(20);
   declare count integer;
   set v1 = 'f1';
   set v2 = 'address';
   set count = 1;
   case when action = 'delete'  then
      insert into t3 values(v1, v2, count);
      delete from t3 where f1=v1;
   when action = 'insert' then
      repeat
         insert into t3 values(v1, v2, count);
         set count = count + 1;
      until count > 5
      END repeat;
      set count = 1;
      label1: repeat
        insert into t3 values(v1, v2, count);
      if count > 5 then leave label1;
            END if;
              set count = count + 1;
      until count > 5
      END repeat;
                set count = 1;
      while count < 5 do
        insert into t3 values(v1, v2, count);
        set count = count + 1;
      END while;
      set count = 1;
      label1: while count < 5 do
        insert into t3 values(v1, v2, count);
        if count > 5 then leave label1;
                END if;
        set count = count + 1;
      END while;
  else
      set @dummystring = 'temp value';
  END case;
END//
delimiter ;//

CALL sp2( 'insert' );
--sorted_result
SELECT * from t3 where f3 <=5 && f3 >= 0;

SELECT count(*) from t3;
CALL sp2( 'delete' );
SELECT count(*) from t3;

CALL sp2 ('test');
SELECT @dummystring;

# cleanup
DROP PROCEDURE sp2;


# ------------------------------------------------------------------------------
let $message= Testcase 4.1.2:
              ---------------
Ensure that all sub-clauses that should not be supported are disallowed with
an appropriate error message. (case);
--source include/show_msg80.inc


--disable_warnings
drop table IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE IF EXISTS sp3;
--enable_warnings

create table res_t3_itisalongname_1381742_itsaverylongname_1381742 (name char, address varchar(50), age_averylongfieldname_averylongname_1234569 smallint);

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp3( action char(20) )
BEGIN
label1: case
  when action = 'delete'  then
  delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
else
      set @dummystring = 'temp value';
      iterate label1;
END case label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp3( action char(20) )
BEGIN
label1: BEGIN
  case
  action = 'delete'  then
  delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
  else
      set @dummystring = 'temp value';
      iterate label1;
  END case;
  END label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp3( action char(20) )
BEGIN
case
  when action = 'delete'  then
    delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
  then action = 'truncate'  when
  truncate from res_t3_itisalongname_1381742_itsaverylongname_1381742;
  else
      set @dummystring = 'temp value';
      iterate label1;
  END case;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp3( action char(20) )
BEGIN
declare v1 char(20);
declare v2 char(20);
declare count integer;
set v1 = 'f1';
set v2= 'address';
set count = 1;
case action
  when 'delete'  then
  when 'delete'  then
    delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
  END case;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;


delimiter //;
CREATE PROCEDURE sp3( action char(20) )
BEGIN
   declare count int default 1;
   declare done int default 0;
   declare continue handler for sqlstate 'HY000' set done=1;
   label1: loop
      case
         when action = 'delete'  then
            label3:BEGIN
               delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
            END label3;
         when action = 'insert' then
            label2: while count < 10 do
            BEGIN
               insert into res_t3_itisalongname_1381742_itsaverylongname_1381742
                  values('xxxxxxxxxxxxxxxxxxx', '1231230981(*&(*&)(*&(', count);
               GET DIAGNOSTICS @n = NUMBER;
               GET DIAGNOSTICS CONDITION @n @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
               set count = count + 1;
               if count= 10 then
                  set done=1;
               END if;
            END;
            END while label2;
         else
            set @dummystring = 'temp value';
            iterate label1;
      END case;
      if done=1 then
         leave label1;
      END if;
   END loop label1;
   SELECT count, done;
   SELECT @err_no, @err_txt;
END//
delimiter ;//

CALL sp3('insert');

# cleanup
DROP PROCEDURE sp3;
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.4:;
--source include/show_msg80.inc

# testcase: ensure that all supported sub-clauses are supported only in the correct order (if)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp4()
BEGIN
declare count int;
  set count = 1;
  label1: loop
    if count > 10 then leave label1;
    else
      set count = count + 1;
    elseif count > 20 then
      leave label1;
    END if;
    iterate label1;
  END loop label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp4()
BEGIN
declare count int;
  set count = 1;
  label1: loop
    else
      set count = count + 1;
    if count > 20 then
      leave label1;
    END if;
    iterate label1;
  END loop label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp4()
BEGIN
declare count int;
  set count = 1;
  label1: loop
    elseif count > 20 then
      leave label1;
    else
      set count=count+1;
    END if;
    iterate label1;
  END loop label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp4()
BEGIN
declare count int;
  set count = 1;
  label1: loop
    END if;
    if count > 20 then
      leave label1;
    else
      set count=count+1;
    iterate label1;
  END loop label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp4()
BEGIN
  declare i int default 10;
  if i > 20 then
    set i=25;
  END if
  declare count int;
  set count = 1;
  label1: loop
    if count > 20 then
      leave label1;
    else
      set count=count+1;
    iterate label1;
  END loop label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
CREATE PROCEDURE sp4()
BEGIN
  declare idummy int default 10;
  declare count int;
  set count = 1;
  label1: loop
  BEGIN
    if count < 20 then
      BEGIN
        declare idummy2 int default 10;
        set count=count+1;
      END;
    else
      BEGIN
        SELECT idummy2;
        leave label1;
      END;
    END if;
    iterate label1;
  END;
  END loop label1;
END//
delimiter ;//

--error ER_BAD_FIELD_ERROR
CALL sp4();

# cleanup
DROP PROCEDURE sp4;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.5:;
--source include/show_msg80.inc

#test case: ensure that all supported sub-clauses are supported only in the correct order (case)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp5()
BEGIN
  declare count integer default 1;
  set count = 1;
  case
  else
    set count = 10;
  when count  = 1 then
    set count =  count + 1;
  END case;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp5(count int)
BEGIN
  when case count = 1 then
    set count = 10;
  when count  = 2 then
    set count =  count + 1;
  END case;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp5(count int)
BEGIN
  END case;
  when count = 1 then
    set count = 10;
  when count  = 2 then
    set count =  count + 1;
  END case;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp5(count int)
BEGIN
  when count = 1 then
    set count = 10;
  case when count  = 2 then
    set count =  count + 1;
  END case;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.6:
              ---------------
Ensure that all supported sub-clauses are supported only in the correct order (repeat).;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1: repeat
    set count1 = count1 + 1;
    if count1 > 5 then leave label1; END if;
  END repeat;
  until count1 > 5
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1:   until count1 > 5
  repeat
    set count1 = count1 + 1;
    if count1 > 5 then leave label1; END if;
  END repeat;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1: END repeat
    set count1 = count1 + 1;
    if count1 > 5 then leave label1; END if;
  until count1 > 5
  repeat;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1: repeat
    set count1 = count1 + 1;
    if count1 > 5 then leave label1; END if;
  END repeat;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1: repeat
    set count1 = count1 + 1;
    if count1 > 5 then leave label1; END if;
  until count1 > 10;
  SELECT count1;
  END repeat;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6()
BEGIN
  declare count1 integer default 1;
  label1: repeat
    set count1 = count1-1;
  until count1 < 0
  END repeat label1;
  SELECT count1;
END//
delimiter ;//

CALL sp6();

# cleanup
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.7:;
--source include/show_msg80.inc

# testcase: ensure that an appropriate error message is returned if a
#        sub claUSE is out-of-order in a stored procedure definition (loop, if, iterate, leave).

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp7;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp7()
BEGIN
  label1: loop
    set @dummystring = 'temp value';
    if count > 10 then leave label1;
    END if;
    label1 iterate;
  END label1 loop;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp7;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp7()
BEGIN
  label1: END loop;
    set @dummystring = 'temp value';
    if count > 10 then leave label1;
    END if;
    iterate label1;
  loop;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp7;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp7()
BEGIN
  label1: iterate label1;
  loop
    set @dummystring = 'temp value';
    if count > 10 then leave label1;
    END if;

  END loop label1;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.8:;
--source include/show_msg80.inc

# testcase: ensure that an appropriate error message is returned if a sub claUSE is
#        out-of-order in a stored procedure definition. (while)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp8;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp8()
BEGIN
  declare v1 int default 5;
  do while v1 > 0
    set v1 = v1 - 1;
    END while;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp8;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp8()
BEGIN
  declare v1 int default 5;
  do v1 > 0 while
    set v1 = v1 - 1;
  END while;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp8;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp8()
BEGIN
  declare v1 int default 5;
  END while;
    set v1 = v1 - 1;
  while v1 > 0 do;
END//
delimiter ;//

# ------------------------------------------------------------------------------
let $message= Testcase 4.3.12:;
--source include/show_msg80.inc

# testcase : ensure that the labels enclosing each loop statement must match

--disable_warnings
drop table IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE IF EXISTS sp12;
--enable_warnings

create table res_t3_itisalongname_1381742_itsaverylongname_1381742( f1 char(20), f2 varchar(20), f3 smallint);

delimiter //;
--error ER_SP_LABEL_MISMATCH
CREATE PROCEDURE sp12( )
BEGIN
  declare count1 integer default 1;
  declare count2 int;
  label1: loop
    if count1 > 2 then leave label1;
    END if;
    insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
    label2: loop
      if count2 > 2 then leave label2;
      END if;
      set count2 = count2 + 1;
    END loop label1;
    set count1 = count1 + 1;
    iterate label1;
  END loop label2;
END//
delimiter ;//

# cleanup
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;



# ------------------------------------------------------------------------------
let $message= Testcase 4.3.13:;
--source include/show_msg80.inc

# ensure that it is possible to put a beginning label at the start of a loop statement
#         without also requiring an ending label at the END of the same statement

--disable_warnings
drop table IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE IF EXISTS sp13;
--enable_warnings

create table res_t3_itisalongname_1381742_itsaverylongname_1381742( f1 char(20), f2 varchar(20), f3 smallint);

delimiter //;
CREATE PROCEDURE sp13( )
BEGIN
  declare count1 integer default 1;
  lable1: loop
    if count1 > 2 then leave lable1;
    END if;
    insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
    set count1 = count1 + 1;
    iterate lable1;
  END loop;
END//
delimiter ;//

CALL sp13();
SELECT * from res_t3_itisalongname_1381742_itsaverylongname_1381742;

# cleanup
DROP PROCEDURE sp13;
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.14:;
--source include/show_msg80.inc

# testcase: ensure that it is not possible to put an ending label at the END of a loop statement
#            without also requiring a matching beginning label at the start of the same statement.

--disable_warnings
drop table IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE IF EXISTS sp14;
--enable_warnings

create table res_t3_itisalongname_1381742_itsaverylongname_1381742( f1 char(20), f2 varchar(20), f3 smallint);

delimiter //;
--error ER_SP_LILABEL_MISMATCH
CREATE PROCEDURE sp14( )
BEGIN
    declare count1 integer default 1;
    loop
      if count1 > 2 then leave lable1;
      END if;
      insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      set count1 = count1 + 1;
      iterate lable1;
    END loop label1;
END//
delimiter ;//

# cleanup
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.15:;
--source include/show_msg80.inc

# ensure that every beginning label must END with a colon (:)

--disable_warnings
drop table IF EXISTS res_t3_itisalongname_1381742_itsaverylongname_1381742;
DROP PROCEDURE IF EXISTS sp15;
--enable_warnings

create table res_t3_itisalongname_1381742_itsaverylongname_1381742( f1 char(20), f2 varchar(20), f3 smallint);

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp15( )
BEGIN
    declare count1 integer default 1;
    label1 loop
      if count1 > 2 then leave lable1;
      END if;
      insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      set count1 = count1 + 1;
      iterate lable1;
    END loop label1;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.16:
              ----------------
Ensure that every beginning label with the same scope must be unique.;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp16;

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

delimiter //;
--error ER_SP_LABEL_REDEFINE
CREATE PROCEDURE sp16( )
BEGIN
    declare count1 integer default 1;
    declare count2 integer default 1;
    label1: repeat
      set count1 = count1 + 1;
      set count2 = 1;
      label1: repeat
        set count2 = count2 + 1;
        insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( xyz , pqr, count1);
        until count2 > 3
      END repeat label1;
      until count1 > 3
    END repeat label1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp16;

delimiter //;
--error ER_SP_LABEL_REDEFINE
CREATE PROCEDURE sp16( )
BEGIN
  declare count1 integer default 1;
  declare count2 integer default 1;
  declare count3 integer default 1;
  label1: repeat
    set count1 = count1 + 1;
    label1: repeat
      set count2 = count2 + 1;
      SELECT count2;
      until count2 > 3
    END repeat label1;
    SELECT count1;
  until count1 > 3
  END repeat label1;
  label1: repeat
    set count3 = count3 + 1;
    SELECT count3;
  until count3 > 3
  END repeat label1;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.17:;
--source include/show_msg80.inc

# testcase: ensure that the repeat statement acts correctly for all variants,
#            including cases where statements are nested.



# ------------------------------------------------------------------------------
let $message= Testcase 4.3.18:;
--source include/show_msg80.inc

# testcase : ensure that the labels enclosing each repeat statement must match.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp18;

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

delimiter //;
--error ER_SP_LABEL_MISMATCH
CREATE PROCEDURE sp18( )
BEGIN
    declare count1 integer default 1;
    label1: repeat
      set count1 = count1 + 1;
      insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      until count1 < 3
    END repeat label2;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.19:;
--source include/show_msg80.inc

# testcase: ensure that it is possible to put a beginning label at the start of
#            a repeat statement without also requiring an ending label at the
#            END of the same statement.

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp19;

delimiter //;
CREATE PROCEDURE sp19( )
BEGIN
    declare count1 integer default 1;
    label1: repeat
      set count1 = count1 + 1;
      insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      until count1 < 3
    END repeat;
END//
delimiter ;//

CALL sp19();
SELECT * from res_t3_itisalongname_1381742_itsaverylongname_1381742;

# cleanup
DROP PROCEDURE sp19;


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.20:;
--source include/show_msg80.inc

# testcase: ensure that it is not possible to put an ending label at the END of a
#            repeat statement without also requiring a matching beginning label
#            at the start of the same statement.

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp20;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp20( )
BEGIN
    declare count1 integer default 1;
    repeat
      set count1 = count1 + 1;
      insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      until count1 < 3
    END repeat label1;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.21:;
--source include/show_msg80.inc

# ensure that the while statement acts correctly for all variants,
#         including cases where statements are nested



# ------------------------------------------------------------------------------
let $message= Testcase 4.3.22:;
--source include/show_msg80.inc

# testcase: ensure that the labels enclosing each while statement must match.

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp22;

delimiter //;
--error ER_SP_LABEL_MISMATCH
CREATE PROCEDURE sp22( )
BEGIN
    declare count1 integer default 1;
    declare count2 integer default 1;
    while count1 < 3 do
      set count1 = count1 + 1;
      set count2 = 1;
      label1: while count2 < 3 do
        set count2 = count2 + 1;
        insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      END while label2;
    END while;
END//
delimiter ;//


# ------------------------------------------------------------------------------
let $message= Testcase 4.3.23:;
--source include/show_msg80.inc

# testcase: ensure that it is not possible to put an ending label at the END of
#            a while statement without also requiring a matching beginning label
#            at the start of the same statement.

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp23;

delimiter //;
--error ER_PARSE_ERROR
CREATE PROCEDURE sp23( )
BEGIN
    declare count1 integer default 1;
    declare count2 integer default 1;
    while count1 < 3 do
      set count1 = count1 + 1;
      set count2 = 1;
      while count2 < 3 do
        set count2 = count2 + 1;
        insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      END while label1;
    END while;
END//
delimiter ;//




# ------------------------------------------------------------------------------
let $message= Testcase 4.3.25:;
--source include/show_msg80.inc

# testcase: ensure that it is possible to put a beginning label at the start of a
#            while statement without also requiring an ending label at the END of the same statement.

delete from res_t3_itisalongname_1381742_itsaverylongname_1381742;
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp25;

delimiter //;
CREATE PROCEDURE sp25( )
BEGIN
    declare count1 integer default 1;
    declare count2 integer default 1;
    while count1 < 3 do
      set count1 = count1 + 1;
      set count2 = 1;
      label1: while count2 < 3 do
        set count2 = count2 + 1;
        insert into res_t3_itisalongname_1381742_itsaverylongname_1381742 values( 'xyz' , 'pqr', count1);
      END while;
    END while;
END//
delimiter ;//

CALL sp25 ();
SELECT * from res_t3_itisalongname_1381742_itsaverylongname_1381742;

# cleanup
DROP PROCEDURE sp25;
drop table res_t3_itisalongname_1381742_itsaverylongname_1381742;


# ==============================================================================
let $message= Section 3.1.4 - Checks for the global nature of stored procedures:;
--source include/show_msg80.inc

USE db_storedproc;

# ------------------------------------------------------------------------------
let $message= Testcase 4.4.1:;
--source include/show_msg80.inc

# testcase: ensure that, regardless of the database in which it was created,
#            a stored procedure can be called (for a procedure) from any #database

--disable_warnings
DROP PROCEDURE IF EXISTS sp1;
DROP DATABASE IF EXISTS d40401;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 ( n char(20) )
BEGIN
    SELECT n;
END//
delimiter ;//

  CREATE DATABASE d40401;
  USE d40401;

CALL db_storedproc.sp1('abcd');

  USE db_storedproc;

# cleanup
DROP PROCEDURE sp1;
DROP DATABASE d40401;


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.2:;
--source include/show_msg80.inc

# testcase: ensure that, regardless of the database in which it was created,
#      a stored procedure can be executed (for a function) from any database.

--disable_warnings
DROP FUNCTION IF EXISTS fn1;
DROP FUNCTION IF EXISTS fn11;
DROP DATABASE IF EXISTS d40402;
--enable_warnings

delimiter //;
CREATE FUNCTION fn1(n int) returns int
  BEGIN
  declare a int;
  set a = 9 * n;
  return a;
END//
delimiter ;//

  CREATE DATABASE d40402;
  USE d40402;


    SELECT db_storedproc.fn1(100);

    SELECT db_storedproc.fn1(1000);

delimiter //;
CREATE FUNCTION db_storedproc.fn11(n int) returns int
BEGIN
    declare a int;
    set a = 9 * n;
    return a;
END//
delimiter ;//

  SELECT db_storedproc.fn11(100);

  SELECT db_storedproc.fn11(1000);

  USE db_storedproc;

# cleanup
DROP FUNCTION fn1;
DROP FUNCTION fn11;
DROP DATABASE d40402;




# ------------------------------------------------------------------------------
let $message= Testcase 4.4.3:;
--source include/show_msg80.inc

# testcase: ensure that the USE of a stored procedure from a database other than the database in
#      which it was created does not permanently change the database in use.

--disable_warnings
DROP DATABASE IF EXISTS d1;
DROP DATABASE IF EXISTS d2;
--enable_warnings

  CREATE DATABASE d1;
  CREATE DATABASE d2;

  USE d1;

  create table res_t41(a char(5), b char(10));
  insert into res_t41 values('abcde', 'a!@#$%^&*(');

  USE d2;

  create table res_t42(a char(5), b char(10));

  USE d1;

delimiter //;
CREATE PROCEDURE sp2(n char (20))
BEGIN
         SELECT res_t41.a, res_t41.b into @a, @b from res_t41 where res_t41.b = n;
         insert into d2.res_t42 values (@a, @b);
END//
delimiter ;//

  USE d2;

CALL d1.sp2('a!@#$%^&*(');

  show warnings;

  SELECT * from d1.res_t41;
  SELECT * from res_t42;

# cleanup
  USE db_storedproc;
DROP DATABASE d1;
DROP DATABASE d2;


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.4:;
--source include/show_msg80.inc

# testcase : ensure that the mysql-specific USE <database name> statement is disallowed
#       in a stored procedure.

CREATE DATABASE d1;
USE d1;

delimiter //;
--error ER_SP_BADSTATEMENT
CREATE PROCEDURE sp3()
BEGIN
    USE d1;
END//
delimiter ;//

# cleanup
  USE db_storedproc;
DROP DATABASE d1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.4.5:;
--source include/show_msg80.inc

# testcase: ensure that when a database is dropped, all stored procedures #created within
#            that database are also cleanly dropped.

  CREATE DATABASE d1;

  USE d1;
  create table t43(a char(5), b char(10));
  insert into t43 values('abcde', 'a!@#$%^&*(');

CREATE PROCEDURE d1.sp4()
   SELECT * from d1.t43;

--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'sp4';

  USE db_storedproc;
DROP DATABASE d1;
  CREATE DATABASE d1;

  USE d1;
  create table t44(a char(5), b char(10));

--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'sp4';

# cleanup
  USE db_storedproc;
DROP DATABASE d1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.6:;
--source include/show_msg80.inc

# testcase: ensure that a stored procedure created without a qualifying #database name belongs
#            to the database in USE at creation time.


  USE db_storedproc;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

CREATE PROCEDURE sp5()
  SELECT * from db_storedproc.t4 limit 0, 10;

  SELECT routine_schema from information_schema.routines where specific_name = 'sp5';

# cleanup
DROP PROCEDURE sp5;


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.7:;
--source include/show_msg80.inc

# testcase: ensure that a stored procedure created with a qualifying database
#        name belongs to the database specified.

  USE db_storedproc;

--disable_warnings
drop table IF EXISTS t46;
DROP PROCEDURE IF EXISTS sp6;
--enable_warnings

  create table t46(f1 char(20), f2 char(20));
  insert into t46 values ('abcd', 'wxyz');

CREATE PROCEDURE db_storedproc.sp6()
  SELECT * from db_storedproc.t4 limit 0, 10;

  SELECT routine_schema from information_schema.routines where specific_name = 'sp6';

# cleanup
drop table t46;
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.8:;
--source include/show_msg80.inc

# testcase : ensure that, regardless of the database in which it was created,
#       a procedure can be altered from any database.

--disable_warnings
DROP DATABASE IF EXISTS d1;
DROP DATABASE IF EXISTS d2;
--enable_warnings

  CREATE DATABASE d1;
  CREATE DATABASE d2;

  USE d1;

CREATE PROCEDURE sp8 ( n char(20) ) sql security DEFINER comment 'initial'
  SELECT * from t1 where t1.f1 = n;

  USE d2;
  alter procedure d1.sp8 sql security DEFINER comment 'updated';
--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'sp8' and routine_schema = 'd1';


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.9:;
--source include/show_msg80.inc

# testcase :ensure that, regardless of the database in which it was created,
#      a stored procedure can be executed (for a function) from any database.

  USE d1;

--disable_warnings
DROP FUNCTION IF EXISTS fn1;
DROP FUNCTION IF EXISTS fn11;
--enable_warnings

delimiter //;
CREATE FUNCTION d1.fn2(n int) returns int sql security invoker comment 'initial'
BEGIN
    declare a int;
    set a = 0.9 * n;
    return a;
END//
delimiter ;//

  USE d2;
  alter function d1.fn2 sql security DEFINER comment 'updated';
--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'fn2' and routine_schema = 'd1';


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.10:;
--source include/show_msg80.inc

# testcase: ensure that, regardless of the database in which it was created,
#      a procedure can be dropped from any database.


  USE d1;

CREATE PROCEDURE sp9 ( n char(20) )
  SELECT * from t1 where t1.f1 = n;

  USE d2;
DROP PROCEDURE d1.sp9;
--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'sp9' and routine_schema = 'd1';


# ------------------------------------------------------------------------------
let $message= Testcase 4.4.11:;
--source include/show_msg80.inc

# testcase: ensure that, regardless of the database in which it was created,
#      a function can be dropped from any database.


  USE d1;

delimiter //;
CREATE FUNCTION d1.fn3(n int) returns int
BEGIN
    declare a int;
    set a = 0.9 * n;
    return a;
END//
delimiter ;//

  USE d2;
DROP FUNCTION d1.fn3;
--replace_column 24 modified 25 created
  SELECT * from information_schema.routines where specific_name = 'fn3' and routine_schema = 'd1';

# cleanup

  USE db_storedproc;
DROP DATABASE d1;
DROP DATABASE d2;


# ==============================================================================
# test plan section: 4.5 -
# ==============================================================================
let $message= Section 3.1.5 - Parameter use checks:
Functions with all data types;
--source include/show_msg80.inc

#FIXME hpux11
let $plus_20=   1.00e+20;
let $plus_24=   1.00e+24;
let $plus_30=   1.00e+30;
let $plus_36=   1.00e+36;
let $plus_40=   1.00e+40;
let $minus_30= -1.00e+30;
let $minus_36= -1.00e+36;
let $minus_40= -1.00e+40;

let $callvar01m= -1.00e+20;
let $callvar01p=  1.00e+20;
let $callvar02=  -9.22e+18;
let $callvar03=  -9.22e+18;

let $procvar01_m30= -1.00e+30;
let $procvar01_m36= -1.00e+36;
let $procvar01_m40= -1.00e+40;
let $procvar01_20=  1.00e+20;
let $procvar01_24=  1.00e+24;
let $procvar01_30=  1.00e+30;
let $procvar01_36=  1.00e+36;
let $procvar01_40=  1.00e+40;

#################123456789-123456789-123456789-123456789-
let $plus_20=   100000000000000000000;
let $plus_24=   1000000000000000000000000;
let $plus_30=   1000000000000000000000000000000;
let $plus_36=   1000000000000000000000000000000000000;
let $plus_40=   10000000000000000000000000000000000000000;
let $minus_30= -1000000000000000000000000000000;
let $minus_36= -1000000000000000000000000000000000000;
let $minus_40= -10000000000000000000000000000000000000000;

let $procvar_m00=   -1.00e+22;
let $procvar_00=     1.00e+22;
let $procvar01_m30= $procvar_m00;
let $procvar01_m36= $procvar_m00;
let $procvar01_m40= $procvar_m00;
let $procvar01_20=  $procvar_00;
let $procvar01_24=  $procvar_00;
let $procvar01_30=  $procvar_00;
let $procvar01_36=  $procvar_00;
let $procvar01_40=  $procvar_00;
let $procvar03= -9.22e+18;
let $procvar05= -9.22e+18;
let $procvar07= -9.22e+18;


CREATE DATABASE d1;
USE d1;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1( f1 bigint) returns bigint
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn1(-9.22e+18);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn2;

delimiter //;
CREATE FUNCTION fn2( f1 bigint unsigned) returns bigint unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn2(1.84e+19);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn3;

delimiter //;
CREATE FUNCTION fn3( f1 bigint unsigned zerofill) returns bigint unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn3(1.84e+17);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn4;

delimiter //;
CREATE FUNCTION fn4( f1 bigint zerofill) returns bigint zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn4(-9.22e+15);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn5;

delimiter //;
CREATE FUNCTION fn5( f1 decimal) returns decimal
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn5(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn6;

delimiter //;
CREATE FUNCTION fn6( f1 decimal (0)) returns decimal (0)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn6(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn7;

delimiter //;
CREATE FUNCTION fn7( f1 decimal (0) unsigned) returns decimal (0) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn7(99999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn8;

delimiter //;
CREATE FUNCTION fn8( f1 decimal (0) unsigned zerofill) returns decimal (0) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn8(999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn9;

delimiter //;
CREATE FUNCTION fn9( f1 decimal (0) zerofill) returns decimal (0) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn9(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn10;

delimiter //;
CREATE FUNCTION fn10( f1 decimal (0, 0)) returns decimal (0, 0)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn10(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn11;

delimiter //;
CREATE FUNCTION fn11( f1 decimal (0, 0) unsigned) returns decimal (0, 0) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn11(99999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn12;

delimiter //;
CREATE FUNCTION fn12( f1 decimal (0, 0) unsigned zerofill) returns decimal (0, 0) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn12(999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn13;

delimiter //;
CREATE FUNCTION fn13( f1 decimal (0, 0) zerofill) returns decimal (0, 0) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn13(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn14;

delimiter //;
CREATE FUNCTION fn14( f1 decimal (63, 30)) returns decimal (63, 30)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn14(-1.00e+21);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn15;

delimiter //;
CREATE FUNCTION fn15( f1 decimal (63, 30) unsigned) returns decimal (63, 30) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn15(1.00e+16);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn16;

delimiter //;
CREATE FUNCTION fn16( f1 decimal (63, 30) unsigned zerofill) returns decimal (63, 30) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn16(1.00e+16);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn17;

delimiter //;
CREATE FUNCTION fn17( f1 decimal (63, 30) zerofill) returns decimal (63, 30) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn17(-1.00e+21);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn18_d;

delimiter //;
CREATE FUNCTION fn18_d( f1 decimal (64)) returns decimal (64)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

#FIXME hpux11
eval SELECT fn18_d( $minus_30 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn19_du;

delimiter //;
CREATE FUNCTION fn19_du( f1 decimal (64) unsigned) returns decimal (64) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

eval SELECT fn19_du( $plus_20 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn20_duz;

delimiter //;
CREATE FUNCTION fn20_duz( f1 decimal (64) unsigned zerofill) returns decimal (64) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

eval SELECT fn20_duz( $plus_24 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn21_d_z;

delimiter //;
CREATE FUNCTION fn21_d_z( f1 decimal (64) zerofill) returns decimal (64) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn21_d_z(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn22;

delimiter //;
CREATE FUNCTION fn22( f1 decimal unsigned) returns decimal unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn22(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn23;

delimiter //;
CREATE FUNCTION fn23( f1 decimal unsigned zerofill) returns decimal unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn23(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn24;

delimiter //;
CREATE FUNCTION fn24( f1 decimal zerofill) returns decimal zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn24(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn25;

delimiter //;
CREATE FUNCTION fn25( f1 double) returns double
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn25(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn26;

delimiter //;
CREATE FUNCTION fn26( f1 double unsigned) returns double unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn26(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn27;

delimiter //;
CREATE FUNCTION fn27( f1 double unsigned zerofill) returns double unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn27(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn28;

delimiter //;
CREATE FUNCTION fn28( f1 double zerofill) returns double zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn28(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn29;


delimiter //;
CREATE FUNCTION fn29( f1 float) returns float
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn29(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn30;

delimiter //;
CREATE FUNCTION fn30( f1 float unsigned) returns float unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn30(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn31;

delimiter //;
CREATE FUNCTION fn31( f1 float unsigned zerofill) returns float unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn31(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn32;

delimiter //;
CREATE FUNCTION fn32( f1 float zerofill) returns float zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn32(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn33;

delimiter //;
CREATE FUNCTION fn33( f1 float(0)) returns float(0)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn33(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn34;

delimiter //;
CREATE FUNCTION fn34( f1 float(0) unsigned) returns float(0) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn34(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn35;

delimiter //;
CREATE FUNCTION fn35( f1 float(0) unsigned zerofill) returns float(0) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn35(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn36;

delimiter //;
CREATE FUNCTION fn36( f1 float(0) zerofill) returns float(0) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn36(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn37;

delimiter //;
CREATE FUNCTION fn37( f1 float(23)) returns float(23)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn37(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn38;

delimiter //;
CREATE FUNCTION fn38( f1 float(23) unsigned) returns float(23) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn38(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn39;

delimiter //;
CREATE FUNCTION fn39( f1 float(23) unsigned zerofill) returns float(23) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn39(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn40;

delimiter //;
CREATE FUNCTION fn40( f1 float(23) zerofill) returns float(23) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn40(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn41;

delimiter //;
CREATE FUNCTION fn41( f1 float(24)) returns float(24)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn41(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn42;

delimiter //;
CREATE FUNCTION fn42( f1 float(24) unsigned) returns float(24) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn42(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn43;

delimiter //;
CREATE FUNCTION fn43( f1 float(24) unsigned zerofill) returns float(24) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn43(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn44;

delimiter //;
CREATE FUNCTION fn44( f1 float(24) zerofill) returns float(24) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn44(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn45;

delimiter //;
CREATE FUNCTION fn45( f1 float(53)) returns float(53)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn45(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn46;

delimiter //;
CREATE FUNCTION fn46( f1 float(53) unsigned) returns float(53) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn46(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn47;

delimiter //;
CREATE FUNCTION fn47( f1 float(53) unsigned zerofill) returns float(53) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn47(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn48;

delimiter //;
CREATE FUNCTION fn48( f1 float(53) zerofill) returns float(53) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn48(1.00e+00);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn49;

delimiter //;
CREATE FUNCTION fn49( f1 int) returns int
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn49(-2.15e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn50;

delimiter //;
CREATE FUNCTION fn50( f1 int unsigned) returns int unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn50(4.29e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn51;

delimiter //;
CREATE FUNCTION fn51( f1 int unsigned zerofill) returns int unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn51(4.29e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn52;

delimiter //;
CREATE FUNCTION fn52( f1 int zerofill) returns int zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn52(2.15e+08);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn53;

delimiter //;
CREATE FUNCTION fn53( f1 mediumint) returns mediumint
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn53(-8388600);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn54;

delimiter //;
CREATE FUNCTION fn54( f1 mediumint unsigned) returns mediumint unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn54(16777201);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn55;

delimiter //;
CREATE FUNCTION fn55( f1 mediumint unsigned zerofill) returns mediumint unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn55(16777210);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn56;

delimiter //;
CREATE FUNCTION fn56( f1 mediumint zerofill) returns mediumint zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn56(-8388601);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn57;

delimiter //;
CREATE FUNCTION fn57( f1 numeric) returns numeric
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn57(-999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn58;

delimiter //;
CREATE FUNCTION fn58( f1 numeric (0)) returns numeric (0)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn58(-999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn59;

delimiter //;
CREATE FUNCTION fn59( f1 numeric (0) unsigned) returns numeric (0) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn59(9999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn60;

delimiter //;
CREATE FUNCTION fn60( f1 numeric (0) unsigned zerofill) returns numeric (0) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn60(99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn61;

delimiter //;
CREATE FUNCTION fn61( f1 numeric (0) zerofill) returns numeric (0) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn61(-99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn62;

delimiter //;
CREATE FUNCTION fn62( f1 numeric (0, 0)) returns numeric (0, 0)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn62(-999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn63;

delimiter //;
CREATE FUNCTION fn63( f1 numeric (0, 0) unsigned) returns numeric (0, 0) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn63(9999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn64;

delimiter //;
CREATE FUNCTION fn64( f1 numeric (0, 0) unsigned zerofill) returns numeric (0, 0) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn64(99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn65;

delimiter //;
CREATE FUNCTION fn65( f1 numeric (0, 0) zerofill) returns numeric (0, 0) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn65(-99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn66;

delimiter //;
CREATE FUNCTION fn66( f1 numeric (63, 30)) returns numeric (63, 30)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn66(-1e+36);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn67;

delimiter //;
CREATE FUNCTION fn67( f1 numeric (63, 30) unsigned) returns numeric (63, 30) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn67(1e+36);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn68;

delimiter //;
CREATE FUNCTION fn68( f1 numeric (63, 30) unsigned zerofill) returns numeric (63, 30) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn68(1e+36);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn69;

delimiter //;
CREATE FUNCTION fn69( f1 numeric (63, 30) zerofill) returns numeric (63, 30) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn69(-1e+36);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn70_n;

delimiter //;
CREATE FUNCTION fn70_n( f1 numeric (64)) returns numeric (64)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

#FIXME hpux11
#SELECT fn70_n(-1e+40);
eval SELECT fn70_n( $minus_30 );
eval SELECT fn70_n( $minus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn71_nu;

delimiter //;
CREATE FUNCTION fn71_nu( f1 numeric (64) unsigned) returns numeric (64) unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

#FIXME hpux11
#SELECT fn71_nu(1.00e+40);
eval SELECT fn71_nu( $plus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn72_nuz;

delimiter //;
CREATE FUNCTION fn72_nuz( f1 numeric (64) unsigned zerofill) returns numeric (64) unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

#FIXME hpux11
#SELECT fn72_nuz(1.00e+40);
eval SELECT fn72_nuz( $plus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn73_n_z;

delimiter //;
CREATE FUNCTION fn73_n_z( f1 numeric (64) zerofill) returns numeric (64) zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

#FIXME hpux11
#SELECT fn73_n_z(1.00e+40);
eval SELECT fn73_n_z( $plus_40 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn74;

delimiter //;
CREATE FUNCTION fn74( f1 numeric unsigned) returns numeric unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn74(999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn75;

delimiter //;
CREATE FUNCTION fn75( f1 numeric unsigned zerofill) returns numeric unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn75(999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn76;

delimiter //;
CREATE FUNCTION fn76( f1 numeric zerofill) returns numeric zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn76(-999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn77;

delimiter //;
CREATE FUNCTION fn77( f1 real) returns real
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn77(1.1);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn78;

delimiter //;
CREATE FUNCTION fn78( f1 real unsigned) returns real unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn78(1.1);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn79;

delimiter //;
CREATE FUNCTION fn79( f1 real unsigned zerofill) returns real unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn79(1.1);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn80;

delimiter //;
CREATE FUNCTION fn80( f1 real zerofill) returns real zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

--disable_ps_protocol ONCE
SELECT fn80(1.1);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn81;

delimiter //;
CREATE FUNCTION fn81( f1 smallint) returns smallint
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn81(-32701);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn82;

delimiter //;
CREATE FUNCTION fn82( f1 smallint unsigned) returns smallint unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn82(65531);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn83;

delimiter //;
CREATE FUNCTION fn83( f1 smallint unsigned zerofill) returns smallint unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn83(65531);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn84;

delimiter //;
CREATE FUNCTION fn84( f1 smallint zerofill) returns smallint zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn84(-32601);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn85;

delimiter //;
CREATE FUNCTION fn85( f1 tinyint) returns tinyint
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn85(-115);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn86;

delimiter //;
CREATE FUNCTION fn86( f1 tinyint unsigned) returns tinyint unsigned
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn86(251);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn87;

delimiter //;
CREATE FUNCTION fn87( f1 tinyint unsigned zerofill) returns tinyint unsigned zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn87(201);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn88;

delimiter //;
CREATE FUNCTION fn88( f1 tinyint zerofill) returns tinyint zerofill
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  return f1;
END//
delimiter ;//

SELECT fn88(-101);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn89;

delimiter //;
CREATE FUNCTION fn89( f1 enum('1enum', '2enum')) returns enum('1enum', '2enum')
BEGIN
 IF f1 = '1enum' THEN
   SET f1 = '2enum';
  ELSE
   SET f1 = '1enum';
 END IF;
 RETURN f1;
END//
delimiter ;//

SELECT fn89( '1enum');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn90;

delimiter //;
CREATE FUNCTION fn90( f1 set('1set', '2set')) returns set('1set', '2set')
BEGIN
   IF f1 = '1set' THEN
      SET f1 = '2set';
   ELSE
      SET f1 = '1set';
   END IF;
   RETURN f1;
END//
delimiter ;//

SELECT fn90( '1set');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn91;

delimiter //;
CREATE FUNCTION fn91( f1 date) returns date
BEGIN
  set f1 = adddate(f1, interval 31 day);
  return f1;
END//
delimiter ;//

SELECT fn91('1997-12-31');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn92;


delimiter //;
CREATE FUNCTION fn92( f1 time) returns time
BEGIN
  set f1 = addtime(f1, '02:00:00.999998');
  return f1;
END//
delimiter ;//

SELECT fn92( '23:59:59.999999');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn93;


delimiter //;
CREATE FUNCTION fn93( f1 datetime) returns datetime
BEGIN
  set f1 = addtime(f1, '1 1:1:1.000002');
  return f1;
END//
delimiter ;//

SELECT fn93('1997-12-31 23:59:59.999999');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn94;


delimiter //;
CREATE FUNCTION fn94( f1 char) returns char
BEGIN
  set f1 = concat('a', f1);
  return f1;
END//
delimiter ;//

SELECT fn94( 'h');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn95;


delimiter //;
CREATE FUNCTION fn95( f1 char ascii) returns char ascii
BEGIN
  set f1 = concat('a', f1);
  return f1;
END//
delimiter ;//

SELECT fn95('h');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn96;

delimiter //;
CREATE FUNCTION fn96( f1 binary) returns binary(2)
BEGIN
  set f1 = concat('a', f1);
  return f1;
END//
delimiter ;//

SELECT fn96( 'h');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn97;

delimiter //;
CREATE FUNCTION fn97( f1 longtext) returns longtext
BEGIN
  set f1 = concat('hello', f1);
  return f1;
END//
delimiter ;//

SELECT fn97( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn98;

delimiter //;
CREATE FUNCTION fn98( f1 mediumtext) returns mediumtext
BEGIN
  set f1 = concat('hello', f1);
  return f1;
END//
delimiter ;//

SELECT fn98( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn99;

delimiter //;
CREATE FUNCTION fn99( f1 text) returns text
BEGIN
  set f1 = concat('hello', f1);
  return f1;
END//
delimiter ;//

SELECT fn99( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn100;

delimiter //;
CREATE FUNCTION fn100( f1 tinytext) returns tinytext
BEGIN
  set f1 = concat('hello', f1);
  return f1;
END//
delimiter ;//

SELECT fn100( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn101;

delimiter //;
CREATE FUNCTION fn101( f1 year) returns year
BEGIN
  set f1 = f1 + 10;
  return f1;
END//
delimiter ;//

SELECT fn101(51);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn102;

delimiter //;
CREATE FUNCTION fn102( f1 year(4)) returns year(4)
BEGIN
  set f1 = f1 + 51;
  return f1;
END//
delimiter ;//

SELECT fn102(1982);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn103;

delimiter //;
CREATE FUNCTION fn103( f1 geometrycollection) returns geometrycollection
BEGIN
  set f1 = f1;
  return f1;
END//
delimiter ;//

SELECT fn103('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0@');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn104;

delimiter //;
CREATE FUNCTION fn104( f1 linestring) returns linestring
BEGIN
  set f1 = f1;
  return f1;
END//
delimiter ;//

SELECT fn104('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0@');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn105;

delimiter //;
CREATE FUNCTION fn105( f1 point) returns point
BEGIN
  set f1 = f1;
  return f1;
END//
delimiter ;//

SELECT fn105('\0\0\0\0\0\0\0\0\0\0\0\0\04@\0\0\0\0\0\04@');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn106;

delimiter //;
CREATE FUNCTION fn106( f1 polygon) returns polygon
BEGIN
  set f1 = f1;
  return f1;
END//
delimiter ;//

SELECT fn106('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0@');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn107;

delimiter //;
CREATE FUNCTION fn107( f1 timestamp) returns timestamp
BEGIN
  set f1 = now();
  return f1;
END//
delimiter ;//

--replace_column 1 returned
SELECT fn107(20050510080451);

USE db_storedproc;
DROP DATABASE d1;


# ==============================================================================
# test plan section: 4.5 - stored procs with in, out parameters using all datatypes
# ==============================================================================

CREATE DATABASE db1;
USE db1;

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1( f1 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp1(-9.22e+18);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp2;

delimiter //;
CREATE PROCEDURE sp2( f1 bigint unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp2(1.84e+19);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;

delimiter //;
CREATE PROCEDURE sp3( f1 bigint unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp3(1.84e+17);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

delimiter //;
CREATE PROCEDURE sp4( f1 bigint zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp4(-9.22e+15);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp5;

delimiter //;
CREATE PROCEDURE sp5( f1 decimal)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp5(-1.00e+09);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6( f1 decimal (0))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp6(-1.00e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp7;

delimiter //;
CREATE PROCEDURE sp7( f1 decimal (0) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp7(99999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp8;

delimiter //;
CREATE PROCEDURE sp8( f1 decimal (0) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp8(999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp9;

delimiter //;
CREATE PROCEDURE sp9( f1 decimal (0) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp9(-1.00e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp10;

delimiter //;
CREATE PROCEDURE sp10( f1 decimal (0, 0))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp10(-1.00e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp11;

delimiter //;
CREATE PROCEDURE sp11( f1 decimal (0, 0) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp11(99999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp12;

delimiter //;
CREATE PROCEDURE sp12( f1 decimal (0, 0) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp12(999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp13;

delimiter //;
CREATE PROCEDURE sp13( f1 decimal (0, 0) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp13(-1.00e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp14;

delimiter //;
CREATE PROCEDURE sp14( f1 decimal (63, 30))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp14(-1.00e+21);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp15;

delimiter //;
CREATE PROCEDURE sp15( f1 decimal (63, 30) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp15(1.00e+16);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp16;

delimiter //;
CREATE PROCEDURE sp16( f1 decimal (63, 30) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp16(1.00e+16);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp17;

delimiter //;
CREATE PROCEDURE sp17( f1 decimal (63, 30) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp17(-1.00e+21);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp18_d;

delimiter //;
CREATE PROCEDURE sp18_d( f1 decimal (64))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp18_d(-1.00e+30);
eval CALL sp18_d( $minus_30 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp19_du;

delimiter //;
CREATE PROCEDURE sp19_du( f1 decimal (64) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp19_du(1.00e+20);
eval CALL sp19_du( $plus_20 );
CALL sp19_du(1.00e+24);
eval CALL sp19_du( $plus_24 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp20_duz;

delimiter //;
CREATE PROCEDURE sp20_duz( f1 decimal (64) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp20_duz(1.00e+20);
eval CALL sp20_duz( $plus_20 );
CALL sp20_duz(1.00e+24);
eval CALL sp20_duz( $plus_24 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp21;

delimiter //;
CREATE PROCEDURE sp21( f1 decimal (64) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp21(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp22;

delimiter //;
CREATE PROCEDURE sp22( f1 decimal unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp22(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp23;

delimiter //;
CREATE PROCEDURE sp23( f1 decimal unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp23(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp24;

delimiter //;
CREATE PROCEDURE sp24( f1 decimal zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp24(-1.00e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp25;

delimiter //;
CREATE PROCEDURE sp25( f1 double)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp25(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp26;

delimiter //;
CREATE PROCEDURE sp26( f1 double unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp26(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp27;

delimiter //;
CREATE PROCEDURE sp27( f1 double unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp27(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp28;

delimiter //;
CREATE PROCEDURE sp28( f1 double zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp28(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp29;

delimiter //;
CREATE PROCEDURE sp29( f1 float)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp29(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp30;

delimiter //;
CREATE PROCEDURE sp30( f1 float unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp30(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp31;

delimiter //;
CREATE PROCEDURE sp31( f1 float unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp31(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp32;

delimiter //;
CREATE PROCEDURE sp32( f1 float zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp32(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp33;

delimiter //;
CREATE PROCEDURE sp33( f1 float(0))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp33(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp34;

delimiter //;
CREATE PROCEDURE sp34( f1 float(0) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp34(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp35;

delimiter //;
CREATE PROCEDURE sp35( f1 float(0) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp35(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp36;

delimiter //;
CREATE PROCEDURE sp36( f1 float(0) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp36(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp37;

delimiter //;
CREATE PROCEDURE sp37( f1 float(23))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp37(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp38;

delimiter //;
CREATE PROCEDURE sp38( f1 float(23) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp38(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp39;

delimiter //;
CREATE PROCEDURE sp39( f1 float(23) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp39(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp40;

delimiter //;
CREATE PROCEDURE sp40( f1 float(23) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp40(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp41;

delimiter //;
CREATE PROCEDURE sp41( f1 float(24))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp41(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp42;

delimiter //;
CREATE PROCEDURE sp42( f1 float(24) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp42(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp43;

delimiter //;
CREATE PROCEDURE sp43( f1 float(24) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp43(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp44;

delimiter //;
CREATE PROCEDURE sp44( f1 float(24) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp44(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp45;

delimiter //;
CREATE PROCEDURE sp45( f1 float(53))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp45(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp46;

delimiter //;
CREATE PROCEDURE sp46( f1 float(53) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp46(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp47;

delimiter //;
CREATE PROCEDURE sp47( f1 float(53) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp47(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp48;

delimiter //;
CREATE PROCEDURE sp48( f1 float(53) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp48(1.00e+00);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp49;

delimiter //;
CREATE PROCEDURE sp49( f1 int)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp49(-2.15e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp50;

delimiter //;
CREATE PROCEDURE sp50( f1 int unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp50(4.29e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp51;

delimiter //;
CREATE PROCEDURE sp51( f1 int unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp51(4.29e+09);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp52;

delimiter //;
CREATE PROCEDURE sp52( f1 int zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp52(2.15e+08);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp53;

delimiter //;
CREATE PROCEDURE sp53( f1 mediumint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp53(-8388600);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp54;

delimiter //;
CREATE PROCEDURE sp54( f1 mediumint unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp54(16777201);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp55;

delimiter //;
CREATE PROCEDURE sp55( f1 mediumint unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp55(16777210);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp56;

delimiter //;
CREATE PROCEDURE sp56( f1 mediumint zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp56(-8388601);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp57;

delimiter //;
CREATE PROCEDURE sp57( f1 numeric)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp57(-999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp58;

delimiter //;
CREATE PROCEDURE sp58( f1 numeric (0))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp58(-999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp59;

delimiter //;
CREATE PROCEDURE sp59( f1 numeric (0) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp59(9999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp60;

delimiter //;
CREATE PROCEDURE sp60( f1 numeric (0) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp60(99999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp61;

delimiter //;
CREATE PROCEDURE sp61( f1 numeric (0) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp61(-99999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp62;

delimiter //;
CREATE PROCEDURE sp62( f1 numeric (0, 0))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp62(-999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp63;

delimiter //;
CREATE PROCEDURE sp63( f1 numeric (0, 0) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp63(9999999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp64;

delimiter //;
CREATE PROCEDURE sp64( f1 numeric (0, 0) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp64(99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp65;

delimiter //;
CREATE PROCEDURE sp65( f1 numeric (0, 0) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp65(-99999999);


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp66_n;

delimiter //;
CREATE PROCEDURE sp66_n( f1 numeric (63, 30))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp66_n(-1e+36);
eval CALL sp66_n( $minus_36 );

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp67_nu;

delimiter //;
CREATE PROCEDURE sp67_nu( f1 numeric (63, 30) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp67_nu(1e+36);
eval CALL sp67_nu( $plus_36 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp68_nuz;

delimiter //;
CREATE PROCEDURE sp68_nuz( f1 numeric (63, 30) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp68_nuz(1e+36);
eval CALL sp68_nuz( $plus_36 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp69_n_z;

delimiter //;
CREATE PROCEDURE sp69_n_z( f1 numeric (63, 30) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp69_n_z(-1e+36);
eval CALL sp69_n_z( $minus_36 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp70_n;

delimiter //;
CREATE PROCEDURE sp70_n( f1 numeric (64))
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
CALL sp70_n(-1e+40);
eval CALL sp70_n( $minus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp71_nu;

delimiter //;
CREATE PROCEDURE sp71_nu( f1 numeric (64) unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
CALL sp71_nu(1.00e+40);
eval CALL sp71_nu( $plus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp72_nuz;

delimiter //;
CREATE PROCEDURE sp72_nuz( f1 numeric (64) unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
CALL sp72_nuz(1.00e+40);
eval CALL sp72_nuz( $plus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp73_n_z;

delimiter //;
CREATE PROCEDURE sp73_n_z( f1 numeric (64) zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
CALL sp73_n_z(1.00e+40);
eval CALL sp73_n_z( $plus_40 );


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp74;

delimiter //;
CREATE PROCEDURE sp74( f1 numeric unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp74(999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp75;

delimiter //;
CREATE PROCEDURE sp75( f1 numeric unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp75(999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp76;

delimiter //;
CREATE PROCEDURE sp76( f1 numeric zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp76(-999999999);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp77;

delimiter //;
CREATE PROCEDURE sp77( f1 real)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp77(1.1);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp78;

delimiter //;
CREATE PROCEDURE sp78( f1 real unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp78(1.1);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp79;

delimiter //;
CREATE PROCEDURE sp79( f1 real unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp79(1.1);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp80;

delimiter //;
CREATE PROCEDURE sp80( f1 real zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp80(1.1);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp81;

delimiter //;
CREATE PROCEDURE sp81( f1 smallint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp81(-32701);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp82;

delimiter //;
CREATE PROCEDURE sp82( f1 smallint unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp82(65531);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp83;

delimiter //;
CREATE PROCEDURE sp83( f1 smallint unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp83(65531);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp84;

delimiter //;
CREATE PROCEDURE sp84( f1 smallint zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp84(-32601);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp85;

delimiter //;
CREATE PROCEDURE sp85( f1 tinyint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp85(-115);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp86;

delimiter //;
CREATE PROCEDURE sp86( f1 tinyint unsigned)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp86(251);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp87;

delimiter //;
CREATE PROCEDURE sp87( f1 tinyint unsigned zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp87(201);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp88;

delimiter //;
CREATE PROCEDURE sp88( f1 tinyint zerofill)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
  SELECT f1;
END//
delimiter ;//

CALL sp88(-101);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp89;

delimiter //;
CREATE PROCEDURE sp89( f1 enum('1enum', '2enum'))
BEGIN
 IF f1 = '1enum' THEN set f1 = '2enum'; ELSE  set f1 = '1enum'; END IF;
END//
delimiter ;//

CALL sp89( '1enum');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp90;

delimiter //;
CREATE PROCEDURE sp90( f1 set('1set', '2set'))
BEGIN
 IF f1 = '1set' THEN  set f1 = '2set';  ELSE set f1 = '1set'; END IF;
END//
delimiter ;//

CALL sp90( '1set');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp91;

delimiter //;
CREATE PROCEDURE sp91( f1 date)
BEGIN
  set f1 = adddate(f1, interval 31 day);
  SELECT f1;
END//
delimiter ;//

CALL sp91( '1997-12-31');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp92;

delimiter //;
CREATE PROCEDURE sp92( f1 time)
BEGIN
  set f1 = addtime(f1, '02:00:00.999998');
  SELECT f1;
END//
delimiter ;//

CALL sp92( '23:59:59.999999');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp93;

delimiter //;
CREATE PROCEDURE sp93( f1 datetime)
BEGIN
  set f1 = addtime(f1, '1 1:1:1.000002');
  SELECT f1;
END//
delimiter ;//

CALL sp93('1997-12-31 23:59:59.999999');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp94;

delimiter //;
CREATE PROCEDURE sp94( f1 char)
BEGIN
  set f1 = concat('a', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp94( 'h');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp95;

delimiter //;
CREATE PROCEDURE sp95( f1 char ascii)
BEGIN
  set f1 = concat('a', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp95( 'h');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp96;

delimiter //;
CREATE PROCEDURE sp96( f1 char binary)
BEGIN
  set f1 = concat('a', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp96( 'h');


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp97;

delimiter //;
CREATE PROCEDURE sp97( f1 longtext)
BEGIN
  set f1 = concat('hello', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp97( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp98;

delimiter //;
CREATE PROCEDURE sp98( f1 mediumtext)
BEGIN
  set f1 = concat('hello', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp98( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp99;

delimiter //;
CREATE PROCEDURE sp99( f1 text)
BEGIN
  set f1 = concat('hello', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp99( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp100;

delimiter //;
CREATE PROCEDURE sp100( f1 tinytext)
BEGIN
  set f1 = concat('hello', f1);
  SELECT f1;
END//
delimiter ;//

CALL sp100( 'world');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp101;

delimiter //;
CREATE PROCEDURE sp101( f1 year)
BEGIN
  set f1 = f1 + 10;
  SELECT f1;
END//
delimiter ;//

CALL sp101(51);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp102;

delimiter //;
CREATE PROCEDURE sp102( f1 year(4))
BEGIN
  set f1 = f1 + 51;
  SELECT f1;
END//
delimiter ;//

CALL sp102(1982);

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp103;

delimiter //;
CREATE PROCEDURE sp103( f1 geometrycollection)
BEGIN
  set f1 = f1;
  SELECT f1;
END//
delimiter ;//

CALL sp103('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0@');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp104;

delimiter //;
CREATE PROCEDURE sp104( f1 linestring)
BEGIN
  set f1 = f1;
  SELECT f1;
END//
delimiter ;//

CALL sp104('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0@');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp105;

delimiter //;
CREATE PROCEDURE sp105( f1 point)
BEGIN
  set f1 = f1;
  SELECT f1;
END//
delimiter ;//

CALL sp105('\0\0\0\0\0\0\0\0\0\0\0\0\04@\0\0\0\0\0\04@');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp106;

delimiter //;
CREATE PROCEDURE sp106( f1 polygon)
BEGIN
  set f1 = f1;
  SELECT f1;
END//
delimiter ;//

CALL sp106('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\04@\0\0\0\0\0\0?\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0 @\0\0\0\0\0\0@\0\0\0\0\0\0@');

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp107;

delimiter //;
CREATE PROCEDURE sp107( f1 timestamp)
BEGIN
  set f1 = now() + 0 + f1;
  SELECT f1;
END//
delimiter ;//

--replace_column 1 returned
CALL sp107(2.00e+13);

USE db_storedproc;
DROP DATABASE db1;


# ==============================================================================
# test plan section: 4.5 - parameter checks - multiple data types in stored procedure and functions
# ==============================================================================

CREATE DATABASE db1;
USE db1;

--disable_warnings
DROP PROCEDURE IF EXISTS sp1;
delimiter //;
CREATE PROCEDURE sp1( in f1 year, inout f2 year, out f3 year, in f4 year,
                     inout f5 year, out f6 year, in f7 year(4), inout f8 year(4),
                     out f9 year(4), in f10 year(4), inout f11 year(4), out f12 year(4))
BEGIN
  set f1 = f1 + 10; set f2 = f2 + 10; set f3 = f2 + 10;
  set f4 = f4 + 10; set f5 = f5 + 10; set f6 = f5 + 10;
  set f7 = f7 + 51; set f8 = f8 + 51; set f9 = f8 + 51;
  set f10 = f10 + 51; set f11 = f11 + 51; set f12 = f11 + 51;
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute01;
delimiter //;
CREATE PROCEDURE spexecute01()
BEGIN
  declare var1 year;
  declare var2 year;
  declare var3 year;
  declare var4 year;
  declare var5 year(4);
  declare var6 year(4);
  declare var7 year(4);
  declare var8 year(4);
  set var1 = 51;
  set var3 = 51;
  set var5 = 1982;
  set var7 = 1982;
  CALL sp1(51, var1, var2, 51, var3, var4, 1982, var5, var6, 1982, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute01();
DROP PROCEDURE spexecute01;
DROP PROCEDURE sp1;


DROP PROCEDURE IF EXISTS sp2;
delimiter //;
CREATE PROCEDURE sp2( in f1 text, inout f2 text, out f3 text, in f4 text, inout f5 text,
                     out f6 text, in f7 tinytext, inout f8 tinytext, out f9 tinytext,
                     in f10 tinytext, inout f11 tinytext, out f12 tinytext)
BEGIN
  set f1 = concat('hello', f1); set f2 = concat('hello', f2); set f3 = concat('hello', f2);
  set f4 = concat('hello', f4); set f5 = concat('hello', f5); set f6 = concat('hello', f5);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f8);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute02;
delimiter //;
CREATE PROCEDURE spexecute02()
BEGIN
  declare var1 text;
  declare var2 text;
  declare var3 text;
  declare var4 text;
  declare var5 tinytext;
  declare var6 tinytext;
  declare var7 tinytext;
  declare var8 tinytext;
  set var1 =  'world';
  set var3 =  'world';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp2( 'world', var1, var2, 'world', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute02();
DROP PROCEDURE spexecute02;
DROP PROCEDURE sp2;


DROP PROCEDURE IF EXISTS sp3;
delimiter //;
CREATE PROCEDURE sp3( in f1 char, inout f2 char, out f3 char, in f4 char ascii,
                     inout f5 char ascii, out f6 char ascii, in f7 longtext,
                     inout f8 longtext, out f9 longtext, in f10 mediumtext,
                     inout f11 mediumtext, out f12 mediumtext)
BEGIN
  set f1 = concat('a', f1); set f2 = concat('a', f2); set f3 = concat('a', f1);
  set f4 = concat('a', f4); set f5 = concat('a', f5); set f6 = concat('a', f4);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f9);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute03;
delimiter //;
CREATE PROCEDURE spexecute03()
BEGIN
  declare var1 char;
  declare var2 char;
  declare var3 char ascii;
  declare var4 char ascii;
  declare var5 longtext;
  declare var6 longtext;
  declare var7 mediumtext;
  declare var8 mediumtext;
  set var1 =  'h';
  set var3 =  'h';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp3( 'h', var1, var2, 'h', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute03();

DROP PROCEDURE spexecute03;
DROP PROCEDURE sp3;


DROP PROCEDURE IF EXISTS sp4;
delimiter //;
CREATE PROCEDURE sp4( in f1 bigint, inout f2 bigint, out f3 bigint,
                     in f4 bigint, inout f5 bigint, out f6 bigint,
                     in f7 bigint, inout f8 bigint, out f9 bigint,
                     in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
   set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10);
   set f6 = f5;
   set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10);
   set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8;
   set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10);
   set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11;
   set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10);
   set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute04;
delimiter //;
CREATE PROCEDURE spexecute04()
BEGIN
  declare var1 bigint;
  declare var2 bigint;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -9.22e+18;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp4(-9.22e+18, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute04();
DROP PROCEDURE spexecute04;
DROP PROCEDURE sp4;

# sp5 removed

DROP PROCEDURE IF EXISTS sp6;
delimiter //;
CREATE PROCEDURE sp6( in f1 timestamp, inout f2 timestamp, out f3 timestamp, in f4 timestamp, inout f5 timestamp, out f6 timestamp, in f7 timestamp, inout f8 timestamp, out f9 timestamp, in f10 timestamp, inout f11 timestamp, out f12 timestamp)
BEGIN
  set f1 = now() + 0 + f1; set f2 = now() + 0 + f2; set f3 = now() + 0 + f1;
  set f4 = now() + 0 + f4; set f5 = now() + 0 + f5; set f6 = now() + 0 + f5;
  set f7 = now() + 0 + f7; set f8 = now() + 0 + f8; set f9 = now() + 0 + f8;
  set f10 = now() + 0 + f10; set f11 = now() + 0 + f11; set f12 = now() + 0 + f11;
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute06;
delimiter //;
CREATE PROCEDURE spexecute06()
BEGIN
  declare var1 timestamp;
  declare var2 timestamp;
  declare var3 timestamp;
  declare var4 timestamp;
  declare var5 timestamp;
  declare var6 timestamp;
  declare var7 timestamp;
  declare var8 timestamp;
  set var1 = 2.00e+13;
  set var3 = 2.00e+13;
  set var5 = 2.00e+13;
  set var7 = 2.00e+13;
  CALL sp6(2.00e+13, var1, var2, 2.00e+13, var3, var4, 2.00e+13, var5, var6, 2.00e+13, var7, var8);
END//
delimiter ;//

--replace_column 1 returned 2 returned 3 returned 4 returned 5 returned 6 returned 7 returned 8 returned 9 returned 10 returned 11 returned 12 returned
CALL spexecute06();
DROP PROCEDURE spexecute06;
DROP PROCEDURE sp6;


DROP PROCEDURE IF EXISTS sp07;
delimiter //;
CREATE PROCEDURE sp07( IN  f1 BIGINT UNSIGNED,
                     INOUT f2 BIGINT UNSIGNED,
                     OUT   f3 BIGINT UNSIGNED,
                     IN    f4 BIGINT,
                     INOUT f5 BIGINT,
                     OUT   f6 BIGINT,
                     IN    f7 BIGINT,
                     INOUT f8 BIGINT,
                     OUT   f9 BIGINT,
                     IN    f10 BIGINT,
                     INOUT f11 BIGINT,
                     OUT   f12 BIGINT)
BEGIN
   SELECT f1, f2, f3;
   SELECT f4, f5, f6;
   SELECT f7, f8, f9;
   SELECT f10, f11, f12;
   set f3 = f2;
   set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
   set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10);
   set f3 = (f3 * 2); set f3 = (f3 - 10); set f3 = (f3 + 10);
   set f6 = f5;
   set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10);
   set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8;
   set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10);
   set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11;
   set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10);
   set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3;
   SELECT f4, f5, f6;
   SELECT f7, f8, f9;
   SELECT f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute07;
delimiter //;
CREATE PROCEDURE spexecute07()
BEGIN
  declare var1 bigint unsigned;
  declare var2 bigint unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 =  1.84e+19;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  SELECT var1, var2;
  SELECT var3, var4;
  SELECT var5, var6;
  SELECT var7, var8;
  CALL sp07( var1, var1, var2, var3, var3, var4,
             var5, var5, var6, var7, var7, var8 );
  SELECT var1, var2;
  SELECT var3, var4;
  SELECT var5, var6;
  SELECT var7, var8;
END//
delimiter ;//

CALL spexecute07();
DROP PROCEDURE spexecute07;
DROP PROCEDURE sp07;


DROP PROCEDURE IF EXISTS sp8;
delimiter //;
CREATE PROCEDURE sp8( in   f1 bigint unsigned zerofill,
                     inout f2 bigint unsigned zerofill,
                     out   f3 bigint unsigned zerofill,
                     in    f4 bigint,
                     inout f5 bigint,
                     out   f6 bigint,
                     in    f7 bigint,
                     inout f8 bigint,
                     out   f9 bigint,
                     in    f10 bigint,
                     inout f11 bigint,
                     out   f12 bigint)
BEGIN
   set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
   set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10);
   set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5;
   set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10);
   set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8;
   set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10);
   set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11;
   set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10);
   set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute08;
delimiter //;
CREATE PROCEDURE spexecute08()
BEGIN
   declare var1 bigint unsigned zerofill;
   declare var2 bigint unsigned zerofill;
   declare var3 bigint;
   declare var4 bigint;
   declare var5 bigint;
   declare var6 bigint;
   declare var7 bigint;
   declare var8 bigint;
   set var1 = 1.84e+17;
   set var3 = -9.22e+18;
   set var5 = -9.22e+18;
   set var7 = -9.22e+18;
   CALL sp8(1.84e+17, var1, var2, -9.22e+18, var3, var4,
                      -9.22e+18, var5, var6, -9.22e+18, var7, var8);
   SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute08();
DROP PROCEDURE spexecute08;
DROP PROCEDURE sp8;


DROP PROCEDURE IF EXISTS sp9;
delimiter //;
CREATE PROCEDURE sp9( in   f1 bigint zerofill,
                     inout f2 bigint zerofill,
                     out   f3 bigint zerofill,
                     in    f4 bigint,
                     inout f5 bigint,
                     out   f6 bigint,
                     in    f7 bigint,
                     inout f8 bigint,
                     out   f9 bigint,
                     in    f10 bigint,
                     inout f11 bigint,
                     out   f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10);
   set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10);
   set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5;
   set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10);
   set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8;
   set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10);
   set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11;
   set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10);
   set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute09;
delimiter //;
CREATE PROCEDURE spexecute09()
BEGIN
   declare var1 bigint zerofill;
   declare var2 bigint zerofill;
   declare var3 bigint;
   declare var4 bigint;
   declare var5 bigint;
   declare var6 bigint;
   declare var7 bigint;
   declare var8 bigint;
   set var1 = -9.22e+15;
   set var3 = -9.22e+18;
   set var5 = -9.22e+18;
   set var7 = -9.22e+18;
   CALL sp9(-9.22e+15, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
   SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute09();
DROP PROCEDURE spexecute09;
DROP PROCEDURE sp9;


DROP PROCEDURE IF EXISTS sp10;
delimiter //;
CREATE PROCEDURE sp10( in f1 decimal,
                      inout f2 decimal,
                      out f3 decimal,
                      in f4 bigint,
                      inout f5 bigint,
                      out f6 bigint,
                      in f7 bigint,
                      inout f8 bigint,
                      out f9 bigint,
                      in f10 bigint,
                      inout f11 bigint,
                      out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute10;
delimiter //;
CREATE PROCEDURE spexecute10()
BEGIN
   declare var1 decimal;
   declare var2 decimal;
   declare var3 bigint;
   declare var4 bigint;
   declare var5 bigint;
   declare var6 bigint;
   declare var7 bigint;
   declare var8 bigint;
   set var1 = -1.00e+09;
   set var3 = -9.22e+18;
   set var5 = -9.22e+18;
   set var7 = -9.22e+18;
   CALL sp10(-1.00e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
   SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute10();
DROP PROCEDURE spexecute10;
DROP PROCEDURE sp10;


DROP PROCEDURE IF EXISTS sp11;
delimiter //;
CREATE PROCEDURE sp11( in f1 decimal (0), inout f2 decimal (0), out f3 decimal (0), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute11;
delimiter //;
CREATE PROCEDURE spexecute11()
BEGIN
  declare var1 decimal (0);
  declare var2 decimal (0);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = --1.00e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp11(--1.00e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute11();
DROP PROCEDURE spexecute11;
DROP PROCEDURE sp11;


DROP PROCEDURE IF EXISTS sp12;
delimiter //;
CREATE PROCEDURE sp12( in f1 decimal (0) unsigned, inout f2 decimal (0) unsigned, out f3 decimal (0) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute12;
delimiter //;
CREATE PROCEDURE spexecute12()
BEGIN
  declare var1 decimal (0) unsigned;
  declare var2 decimal (0) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 99999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp12(99999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute12();
DROP PROCEDURE spexecute12;
DROP PROCEDURE sp12;


DROP PROCEDURE IF EXISTS sp13;
delimiter //;
CREATE PROCEDURE sp13( in f1 decimal (0, 0) zerofill, inout f2 decimal (0, 0) zerofill, out f3 decimal (0, 0) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute13;
delimiter //;
CREATE PROCEDURE spexecute13()
BEGIN
  declare var1 decimal (0, 0) zerofill;
  declare var2 decimal (0, 0) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -1.00e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp13(-1.00e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute13();
DROP PROCEDURE spexecute13;
DROP PROCEDURE sp13;


DROP PROCEDURE IF EXISTS sp14;
delimiter //;
CREATE PROCEDURE sp14( in f1 decimal (63, 30), inout f2 decimal (63, 30), out f3 decimal (63, 30), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f3 = f2;
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute14;
delimiter //;
CREATE PROCEDURE spexecute14()
BEGIN
  declare var1 decimal (63, 30);
  declare var2 decimal (63, 30);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -1.00e+21;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp14(-1.00e+21, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute14();
DROP PROCEDURE spexecute14;
DROP PROCEDURE sp14;


DROP PROCEDURE IF EXISTS sp15;
delimiter //;
CREATE PROCEDURE sp15( in f1 double, inout f2 double, out f3 double, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute15;
delimiter //;
CREATE PROCEDURE spexecute15()
BEGIN
  declare var1 double;
  declare var2 double;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp15(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute15();
DROP PROCEDURE spexecute15;
DROP PROCEDURE sp15;


DROP PROCEDURE IF EXISTS sp16;
delimiter //;
CREATE PROCEDURE sp16( in f1 double zerofill, inout f2 double zerofill, out f3 double zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute16;
delimiter //;
CREATE PROCEDURE spexecute16()
BEGIN
  declare var1 double zerofill;
  declare var2 double zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp16(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute16();
DROP PROCEDURE spexecute16;
DROP PROCEDURE sp16;


DROP PROCEDURE IF EXISTS sp17;
delimiter //;
CREATE PROCEDURE sp17( in f1 double unsigned, inout f2 double unsigned, out f3 double unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute17;
delimiter //;
CREATE PROCEDURE spexecute17()
BEGIN
  declare var1 double unsigned;
  declare var2 double unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp17(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute17();
DROP PROCEDURE spexecute17;
DROP PROCEDURE sp17;


DROP PROCEDURE IF EXISTS sp18;
delimiter //;
CREATE PROCEDURE sp18( in f1 double unsigned zerofill, inout f2 double unsigned zerofill, out f3 double unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute18;
delimiter //;
CREATE PROCEDURE spexecute18()
BEGIN
  declare var1 double unsigned zerofill;
  declare var2 double unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp18(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute18();
DROP PROCEDURE spexecute18;
DROP PROCEDURE sp18;


DROP PROCEDURE IF EXISTS sp19;
delimiter //;
CREATE PROCEDURE sp19( in f1 float unsigned, inout f2 float unsigned, out f3 float unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute19;
delimiter //;
CREATE PROCEDURE spexecute19()
BEGIN
  declare var1 float unsigned;
  declare var2 float unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp19(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute19();
DROP PROCEDURE spexecute19;
DROP PROCEDURE sp19;


DROP PROCEDURE IF EXISTS sp20;
delimiter //;
CREATE PROCEDURE sp20( in f1 float unsigned zerofill, inout f2 float unsigned zerofill, out f3 float unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute20;
delimiter //;
CREATE PROCEDURE spexecute20()
BEGIN
  declare var1 float unsigned zerofill;
  declare var2 float unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp20(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute20();
DROP PROCEDURE spexecute20;
DROP PROCEDURE sp20;


DROP PROCEDURE IF EXISTS sp21;
delimiter //;
CREATE PROCEDURE sp21( in f1 float zerofill, inout f2 float zerofill, out f3 float zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute21;
delimiter //;
CREATE PROCEDURE spexecute21()
BEGIN
  declare var1 float zerofill;
  declare var2 float zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp21(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute21();
DROP PROCEDURE spexecute21;
DROP PROCEDURE sp21;


DROP PROCEDURE IF EXISTS sp22;
delimiter //;
CREATE PROCEDURE sp22( in f1 float(0), inout f2 float(0), out f3 float(0), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute22;
delimiter //;
CREATE PROCEDURE spexecute22()
BEGIN
  declare var1 float(0);
  declare var2 float(0);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp22(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute22();
DROP PROCEDURE spexecute22;
DROP PROCEDURE sp22;


DROP PROCEDURE IF EXISTS sp23;
delimiter //;
CREATE PROCEDURE sp23( in f1 numeric, inout f2 numeric, out f3 numeric, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute23;
delimiter //;
CREATE PROCEDURE spexecute23()
BEGIN
  declare var1 numeric;
  declare var2 numeric;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp23(-999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute23();
DROP PROCEDURE spexecute23;
DROP PROCEDURE sp23;


DROP PROCEDURE IF EXISTS sp24;
delimiter //;
CREATE PROCEDURE sp24( in f1 real, inout f2 real, out f3 real, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute24;
delimiter //;
CREATE PROCEDURE spexecute24()
BEGIN
  declare var1 real;
  declare var2 real;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.1;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp24(1.1, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute24();
DROP PROCEDURE spexecute24;
DROP PROCEDURE sp24;


DROP PROCEDURE IF EXISTS sp25;
delimiter //;
CREATE PROCEDURE sp25( in f1 smallint, inout f2 smallint, out f3 smallint, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute25;
delimiter //;
CREATE PROCEDURE spexecute25()
BEGIN
  declare var1 smallint;
  declare var2 smallint;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -32701;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp25(-32701, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute25();
DROP PROCEDURE spexecute25;
DROP PROCEDURE sp25;


DROP PROCEDURE IF EXISTS sp26;
delimiter //;
CREATE PROCEDURE sp26( in f1 date, inout f2 date, out f3 date, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
  set f1 = adddate(f1, interval 31 day); set f2 = adddate(f2, interval 31 day); set f3 = adddate(f2, interval 31 day);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute26;
delimiter //;
CREATE PROCEDURE spexecute26()
BEGIN
  declare var1 date;
  declare var2 date;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 =  '1997-12-31';
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp26( '1997-12-31', var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute26();
DROP PROCEDURE spexecute26;
DROP PROCEDURE sp26;


DROP PROCEDURE IF EXISTS sp27;
delimiter //;
CREATE PROCEDURE sp27( in f1 time, inout f2 time, out f3 time, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
  set f1 = addtime(f1, '02:00:00.999998'); set f2 = addtime(f2, '02:00:00.999998'); set f3 = addtime(f2, '02:00:00.999998');
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute27;
delimiter //;
CREATE PROCEDURE spexecute27()
BEGIN
  declare var1 time;
  declare var2 time;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 =  '23:59:59.999999';
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp27( '23:59:59.999999', var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute27();
DROP PROCEDURE spexecute27;
DROP PROCEDURE sp27;


DROP PROCEDURE IF EXISTS sp28;
delimiter //;
CREATE PROCEDURE sp28( in f1 datetime, inout f2 datetime, out f3 datetime, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
  set f1 = addtime(f1, '1 1:1:1.000002'); set f2 = addtime(f2, '1 1:1:1.000002'); set f3 = addtime(f1, '1 1:1:1.000002');
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute28;
delimiter //;
CREATE PROCEDURE spexecute28()
BEGIN
  declare var1 datetime;
  declare var2 datetime;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = '1997-12-31 23:59:59.999999';
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp28('1997-12-31 23:59:59.999999', var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute28();
DROP PROCEDURE spexecute28;
DROP PROCEDURE sp28;


DROP PROCEDURE IF EXISTS sp29;
delimiter //;
CREATE PROCEDURE sp29( in f1 float(0) unsigned, inout f2 float(0) unsigned, out f3 float(0) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute29;
delimiter //;
CREATE PROCEDURE spexecute29()
BEGIN
  declare var1 float(0) unsigned;
  declare var2 float(0) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp29(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute29();
DROP PROCEDURE spexecute29;
DROP PROCEDURE sp29;


DROP PROCEDURE IF EXISTS sp30;
delimiter //;
CREATE PROCEDURE sp30( in f1 float(0) zerofill, inout f2 float(0) zerofill, out f3 float(0) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute30;
delimiter //;
CREATE PROCEDURE spexecute30()
BEGIN
  declare var1 float(0) zerofill;
  declare var2 float(0) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp30(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute30();
DROP PROCEDURE spexecute30;
DROP PROCEDURE sp30;


DROP PROCEDURE IF EXISTS sp31;
delimiter //;
CREATE PROCEDURE sp31( in f1 float(23), inout f2 float(23), out f3 float(23), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute31;
delimiter //;
CREATE PROCEDURE spexecute31()
BEGIN
  declare var1 float(23);
  declare var2 float(23);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp31(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute31();
DROP PROCEDURE spexecute31;
DROP PROCEDURE sp31;


DROP PROCEDURE IF EXISTS sp32;
delimiter //;
CREATE PROCEDURE sp32( in f1 float(23) unsigned, inout f2 float(23) unsigned, out f3 float(23) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute32;
delimiter //;
CREATE PROCEDURE spexecute32()
BEGIN
  declare var1 float(23) unsigned;
  declare var2 float(23) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp32(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute32();
DROP PROCEDURE spexecute32;
DROP PROCEDURE sp32;


DROP PROCEDURE IF EXISTS sp33;
delimiter //;
CREATE PROCEDURE sp33( in f1 float(23) zerofill, inout f2 float(23) zerofill, out f3 float(23) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute33;
delimiter //;
CREATE PROCEDURE spexecute33()
BEGIN
  declare var1 float(23) zerofill;
  declare var2 float(23) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp33(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute33();
DROP PROCEDURE spexecute33;
DROP PROCEDURE sp33;


DROP PROCEDURE IF EXISTS sp34;
delimiter //;
CREATE PROCEDURE sp34( in f1 float(24), inout f2 float(24), out f3 float(24), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute34;
delimiter //;
CREATE PROCEDURE spexecute34()
BEGIN
  declare var1 float(24);
  declare var2 float(24);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp34(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute34();
DROP PROCEDURE spexecute34;
DROP PROCEDURE sp34;


DROP PROCEDURE IF EXISTS sp35;
delimiter //;
CREATE PROCEDURE sp35( in f1 float(24) unsigned, inout f2 float(24) unsigned, out f3 float(24) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute35;
delimiter //;
CREATE PROCEDURE spexecute35()
BEGIN
  declare var1 float(24) unsigned;
  declare var2 float(24) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp35(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute35();
DROP PROCEDURE spexecute35;
DROP PROCEDURE sp35;


DROP PROCEDURE IF EXISTS sp36;
delimiter //;
CREATE PROCEDURE sp36( in f1 float(24) zerofill, inout f2 float(24) zerofill, out f3 float(24) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute36;
delimiter //;
CREATE PROCEDURE spexecute36()
BEGIN
  declare var1 float(24) zerofill;
  declare var2 float(24) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp36(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute36();
DROP PROCEDURE spexecute36;
DROP PROCEDURE sp36;


DROP PROCEDURE IF EXISTS sp37;
delimiter //;
CREATE PROCEDURE sp37( in f1 float(53), inout f2 float(53), out f3 float(53), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute37;
delimiter //;
CREATE PROCEDURE spexecute37()
BEGIN
  declare var1 float(53);
  declare var2 float(53);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp37(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute37();
DROP PROCEDURE spexecute37;
DROP PROCEDURE sp37;


DROP PROCEDURE IF EXISTS sp38;
delimiter //;
CREATE PROCEDURE sp38( in f1 float(53) unsigned, inout f2 float(53) unsigned, out f3 float(53) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute38;
delimiter //;
CREATE PROCEDURE spexecute38()
BEGIN
  declare var1 float(53) unsigned;
  declare var2 float(53) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp38(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute38();
DROP PROCEDURE spexecute38;
DROP PROCEDURE sp38;


DROP PROCEDURE IF EXISTS sp39;
delimiter //;
CREATE PROCEDURE sp39( in f1 float(53) zerofill, inout f2 float(53) zerofill, out f3 float(53) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute39;
delimiter //;
CREATE PROCEDURE spexecute39()
BEGIN
  declare var1 float(53) zerofill;
  declare var2 float(53) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp39(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute39();
DROP PROCEDURE spexecute39;
DROP PROCEDURE sp39;


DROP PROCEDURE IF EXISTS sp40;
delimiter //;
CREATE PROCEDURE sp40( in f1 real unsigned, inout f2 real unsigned, out f3 real unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute40;
delimiter //;
CREATE PROCEDURE spexecute40()
BEGIN
  declare var1 real unsigned;
  declare var2 real unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.1;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp40(1.1, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute40();
DROP PROCEDURE spexecute40;
DROP PROCEDURE sp40;


DROP PROCEDURE IF EXISTS sp41;
delimiter //;
CREATE PROCEDURE sp41( in f1 real unsigned zerofill, inout f2 real unsigned zerofill, out f3 real unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute41;
delimiter //;
CREATE PROCEDURE spexecute41()
BEGIN
  declare var1 real unsigned zerofill;
  declare var2 real unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.1;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp41(1.1, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute41();
DROP PROCEDURE spexecute41;
DROP PROCEDURE sp41;


DROP PROCEDURE IF EXISTS sp42;
delimiter //;
CREATE PROCEDURE sp42( in f1 real zerofill, inout f2 real zerofill, out f3 real zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute42;
delimiter //;
CREATE PROCEDURE spexecute42()
BEGIN
  declare var1 real zerofill;
  declare var2 real zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.1;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp42(1.1, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute42();
DROP PROCEDURE spexecute42;
DROP PROCEDURE sp42;


DROP PROCEDURE IF EXISTS sp43;
delimiter //;
CREATE PROCEDURE sp43( in f1 numeric (0), inout f2 numeric (0), out f3 numeric (0), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute43;
delimiter //;
CREATE PROCEDURE spexecute43()
BEGIN
  declare var1 numeric (0);
  declare var2 numeric (0);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp43(-999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute43();
DROP PROCEDURE spexecute43;
DROP PROCEDURE sp43;


DROP PROCEDURE IF EXISTS sp44;
delimiter //;
CREATE PROCEDURE sp44( in f1 numeric (0) unsigned, inout f2 numeric (0) unsigned, out f3 numeric (0) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute44;
delimiter //;
CREATE PROCEDURE spexecute44()
BEGIN
  declare var1 numeric (0) unsigned;
  declare var2 numeric (0) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 9999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp44(9999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute44();
DROP PROCEDURE spexecute44;
DROP PROCEDURE sp44;


DROP PROCEDURE IF EXISTS sp45;
delimiter //;
CREATE PROCEDURE sp45( in f1 numeric (0) zerofill, inout f2 numeric (0) zerofill, out f3 numeric (0) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute45;
delimiter //;
CREATE PROCEDURE spexecute45()
BEGIN
  declare var1 numeric (0) zerofill;
  declare var2 numeric (0) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -99999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp45(-99999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute45();
DROP PROCEDURE spexecute45;
DROP PROCEDURE sp45;


DROP PROCEDURE IF EXISTS sp46;
delimiter //;
CREATE PROCEDURE sp46( in f1 numeric (0, 0), inout f2 numeric (0, 0), out f3 numeric (0, 0), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute46;
delimiter //;
CREATE PROCEDURE spexecute46()
BEGIN
  declare var1 numeric (0, 0);
  declare var2 numeric (0, 0);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp46(-999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute46();
DROP PROCEDURE spexecute46;
DROP PROCEDURE sp46;


DROP PROCEDURE IF EXISTS sp47;
delimiter //;
CREATE PROCEDURE sp47( in f1 numeric (0, 0) unsigned, inout f2 numeric (0, 0) unsigned, out f3 numeric (0, 0) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute47;
delimiter //;
CREATE PROCEDURE spexecute47()
BEGIN
  declare var1 numeric (0, 0) unsigned;
  declare var2 numeric (0, 0) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 9999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp47(9999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute47();
DROP PROCEDURE spexecute47;
DROP PROCEDURE sp47;


DROP PROCEDURE IF EXISTS sp48;
delimiter //;
CREATE PROCEDURE sp48( in f1 numeric (0, 0) zerofill, inout f2 numeric (0, 0) zerofill, out f3 numeric (0, 0) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute48;
delimiter //;
CREATE PROCEDURE spexecute48()
BEGIN
  declare var1 numeric (0, 0) zerofill;
  declare var2 numeric (0, 0) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -99999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp48(-99999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute48();
DROP PROCEDURE spexecute48;
DROP PROCEDURE sp48;


DROP PROCEDURE IF EXISTS sp49;
delimiter //;
CREATE PROCEDURE sp49( in f1 numeric unsigned, inout f2 numeric unsigned, out f3 numeric unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute49;
delimiter //;
CREATE PROCEDURE spexecute49()
BEGIN
  declare var1 numeric unsigned;
  declare var2 numeric unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp49(-999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute49();
DROP PROCEDURE spexecute49;
DROP PROCEDURE sp49;


DROP PROCEDURE IF EXISTS sp50;
delimiter //;
CREATE PROCEDURE sp50( in f1 numeric unsigned zerofill, inout f2 numeric unsigned zerofill, out f3 numeric unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute50;
delimiter //;
CREATE PROCEDURE spexecute50()
BEGIN
  declare var1 numeric unsigned zerofill;
  declare var2 numeric unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 9999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp50(9999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute50();
DROP PROCEDURE spexecute50;
DROP PROCEDURE sp50;


DROP PROCEDURE IF EXISTS sp51;
delimiter //;
CREATE PROCEDURE sp51( in f1 numeric zerofill, inout f2 numeric zerofill, out f3 numeric zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute51;
delimiter //;
CREATE PROCEDURE spexecute51()
BEGIN
  declare var1 numeric zerofill;
  declare var2 numeric zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -99999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp51(-99999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute51();
DROP PROCEDURE spexecute51;
DROP PROCEDURE sp51;


DROP PROCEDURE IF EXISTS sp52;
delimiter //;
CREATE PROCEDURE sp52( in f1 numeric (63, 30), inout f2 numeric (63, 30), out f3 numeric (63, 30), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute52;
delimiter //;
eval CREATE PROCEDURE spexecute52()
BEGIN
  declare var1 numeric (63, 30);
  declare var2 numeric (63, 30);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_m36;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp52($callvar01m, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute52();
DROP PROCEDURE spexecute52;
DROP PROCEDURE sp52;


DROP PROCEDURE IF EXISTS sp53;
delimiter //;
CREATE PROCEDURE sp53( in f1 numeric (64), inout f2 numeric (64), out f3 numeric (64), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute53;
delimiter //;
eval CREATE PROCEDURE spexecute53()
BEGIN
  declare var1 numeric (64);
  declare var2 numeric (64);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_m40;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp53($callvar01m, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute53();
DROP PROCEDURE spexecute53;
DROP PROCEDURE sp53;


DROP PROCEDURE IF EXISTS sp54;
delimiter //;
CREATE PROCEDURE sp54( in f1 numeric (64) unsigned, inout f2 numeric (64) unsigned, out f3 numeric (64) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute54;
delimiter //;
eval CREATE PROCEDURE spexecute54()
BEGIN
  declare var1 numeric (64) unsigned;
  declare var2 numeric (64) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_40;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp54($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute54();
DROP PROCEDURE spexecute54;
DROP PROCEDURE sp54;


DROP PROCEDURE IF EXISTS sp55;
delimiter //;
CREATE PROCEDURE sp55( in f1 numeric (64) zerofill, inout f2 numeric (64) zerofill, out f3 numeric (64) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute55;
delimiter //;
eval CREATE PROCEDURE spexecute55()
BEGIN
  declare var1 numeric (64) zerofill;
  declare var2 numeric (64) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_m40;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp55($callvar01m, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute55();
DROP PROCEDURE spexecute55;
DROP PROCEDURE sp55;


DROP PROCEDURE IF EXISTS sp56;
delimiter //;
CREATE PROCEDURE sp56( in f1 year, inout f2 year, out f3 year, in f4 year, inout f5 year, out f6 year, in f7 year, inout f8 year, out f9 year, in f10 year, inout f11 year, out f12 year)
BEGIN
  set f1 = f1 + 10; set f2 = f2 + 10; set f3 = f2 + 10;
  set f4 = f4 + 10; set f5 = f5 + 10; set f6 = f5 + 10;
  set f7 = f7 + 10; set f8 = f8 + 10; set f9 = f8 + 10;
  set f10= f10+ 10; set f11 = f11 + 10; set f12 = f11 + 10;
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute56;
delimiter //;
CREATE PROCEDURE spexecute56()
BEGIN
  declare var1 year;
  declare var2 year;
  declare var3 year;
  declare var4 year;
  declare var5 year;
  declare var6 year;
  declare var7 year;
  declare var8 year;
  set var1 = 51;
  set var3 = 51;
  set var5 = 51;
  set var7 = 51;
  CALL sp56(51, var1, var2, 51, var3, var4, 51, var5, var6, 51, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute56();
DROP PROCEDURE spexecute56;
DROP PROCEDURE sp56;


DROP PROCEDURE IF EXISTS sp57;
delimiter //;
CREATE PROCEDURE sp57( in f1 year(4), inout f2 year(4), out f3 year(4), in f4 year(4), inout f5 year(4), out f6 year(4), in f7 year(4), inout f8 year(4), out f9 year(4), in f10 year(4), inout f11 year(4), out f12 year(4))
BEGIN
  set f1 = f1 + 51; set f2 = f2 + 51; set f3 = f2 + 51;
  set f4 = f4 + 51; set f5 = f5 + 51; set f6 = f5 + 51;
  set f7 = f7 + 51; set f8 = f8 + 51; set f9 = f8 + 51;
  set f10 = f10 + 51; set f11 = f11 + 51; set f12 = f11 + 51;
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute57;
delimiter //;
CREATE PROCEDURE spexecute57()
BEGIN
  declare var1 year(4);
  declare var2 year(4);
  declare var3 year(4);
  declare var4 year(4);
  declare var5 year(4);
  declare var6 year(4);
  declare var7 year(4);
  declare var8 year(4);
  set var1 = 1982;
  set var3 = 1982;
  set var5 = 1982;
  set var7 = 1982;
  CALL sp57(1982, var1, var2, 1982, var3, var4, 1982, var5, var6, 1982, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute57();
DROP PROCEDURE spexecute57;
DROP PROCEDURE sp57;


DROP PROCEDURE IF EXISTS sp58;
delimiter //;
CREATE PROCEDURE sp58( in f1 text, inout f2 text, out f3 text, in f4 text, inout f5 text, out f6 text, in f7 text, inout f8 text, out f9 text, in f10 text, inout f11 text, out f12 text)
BEGIN
  set f1 = concat('hello', f1); set f2 = concat('hello', f2); set f3 = concat('hello', f2);
  set f4 = concat('hello', f4); set f5 = concat('hello', f5); set f6 = concat('hello', f5);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f8);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute58;
delimiter //;
CREATE PROCEDURE spexecute58()
BEGIN
  declare var1 text;
  declare var2 text;
  declare var3 text;
  declare var4 text;
  declare var5 text;
  declare var6 text;
  declare var7 text;
  declare var8 text;
  set var1 =  'world';
  set var3 =  'world';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp58( 'world', var1, var2, 'world', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute58();
DROP PROCEDURE spexecute58;
DROP PROCEDURE sp58;


DROP PROCEDURE IF EXISTS sp59;
delimiter //;
CREATE PROCEDURE sp59( in f1 tinytext, inout f2 tinytext, out f3 tinytext, in f4 tinytext, inout f5 tinytext, out f6 tinytext, in f7 tinytext, inout f8 tinytext, out f9 tinytext, in f10 tinytext, inout f11 tinytext, out f12 tinytext)
BEGIN
  set f1 = concat('hello', f1); set f2 = concat('hello', f2); set f3 = concat('hello', f2);
  set f4 = concat('hello', f4); set f5 = concat('hello', f5); set f6 = concat('hello', f5);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f8);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute59;
delimiter //;
CREATE PROCEDURE spexecute59()
BEGIN
  declare var1 tinytext;
  declare var2 tinytext;
  declare var3 tinytext;
  declare var4 tinytext;
  declare var5 tinytext;
  declare var6 tinytext;
  declare var7 tinytext;
  declare var8 tinytext;
  set var1 =  'world';
  set var3 =  'world';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp59( 'world', var1, var2, 'world', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute59();
DROP PROCEDURE spexecute59;
DROP PROCEDURE sp59;


DROP PROCEDURE IF EXISTS sp60;
delimiter //;
CREATE PROCEDURE sp60( in f1 char, inout f2 char, out f3 char, in f4 char, inout f5 char, out f6 char, in f7 char, inout f8 char, out f9 char, in f10 char, inout f11 char, out f12 char)
BEGIN
  set f1 = concat('a', f1); set f2 = concat('a', f2); set f3 = concat('a', f1);
  set f4 = concat('a', f4); set f5 = concat('a', f5); set f6 = concat('a', f5);
  set f7 = concat('a', f7); set f8 = concat('a', f8); set f9 = concat('a', f8);
  set f10 = concat('a', f10); set f11 = concat('a', f11); set f12 = concat('a', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute60;
delimiter //;
CREATE PROCEDURE spexecute60()
BEGIN
  declare var1 char;
  declare var2 char;
  declare var3 char;
  declare var4 char;
  declare var5 char;
  declare var6 char;
  declare var7 char;
  declare var8 char;
  set var1 =  'h';
  set var3 =  'h';
  set var5 =  'h';
  set var7 =  'h';
  CALL sp60( 'h', var1, var2, 'h', var3, var4, 'h', var5, var6, 'h', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute60();
DROP PROCEDURE spexecute60;
DROP PROCEDURE sp60;


DROP PROCEDURE IF EXISTS sp61;
delimiter //;
CREATE PROCEDURE sp61( in f1 char ascii, inout f2 char ascii, out f3 char ascii, in f4 char ascii, inout f5 char ascii, out f6 char ascii, in f7 char ascii, inout f8 char ascii, out f9 char ascii, in f10 char ascii, inout f11 char ascii, out f12 char ascii)
BEGIN
  set f1 = concat('a', f1); set f2 = concat('a', f2); set f3 = concat('a', f2);
  set f4 = concat('a', f4); set f5 = concat('a', f5); set f6 = concat('a', f4);
  set f7 = concat('a', f7); set f8 = concat('a', f8); set f9 = concat('a', f9);
  set f10 = concat('a', f10); set f11 = concat('a', f11); set f12 = concat('a', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute61;
delimiter //;
CREATE PROCEDURE spexecute61()
BEGIN
  declare var1 char ascii;
  declare var2 char ascii;
  declare var3 char ascii;
  declare var4 char ascii;
  declare var5 char ascii;
  declare var6 char ascii;
  declare var7 char ascii;
  declare var8 char ascii;
  set var1 =  'h';
  set var3 =  'h';
  set var5 =  'h';
  set var7 =  'h';
  CALL sp61( 'h', var1, var2, 'h', var3, var4, 'h', var5, var6, 'h', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute61();

DROP PROCEDURE spexecute61;
DROP PROCEDURE sp61;


DROP PROCEDURE IF EXISTS sp62;
delimiter //;
CREATE PROCEDURE sp62( in f1 longtext, inout f2 longtext, out f3 longtext, in f4 longtext, inout f5 longtext, out f6 longtext, in f7 longtext, inout f8 longtext, out f9 longtext, in f10 longtext, inout f11 longtext, out f12 longtext)
BEGIN
  set f1 = concat('hello', f1); set f2 = concat('hello', f2); set f3 = concat('hello', f2);
  set f4 = concat('hello', f4); set f5 = concat('hello', f5); set f6 = concat('hello', f5);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f8);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute62;
delimiter //;
CREATE PROCEDURE spexecute62()
BEGIN
  declare var1 longtext;
  declare var2 longtext;
  declare var3 longtext;
  declare var4 longtext;
  declare var5 longtext;
  declare var6 longtext;
  declare var7 longtext;
  declare var8 longtext;
  set var1 =  'world';
  set var3 =  'world';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp62( 'world', var1, var2, 'world', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute62();
DROP PROCEDURE spexecute62;
DROP PROCEDURE sp62;


DROP PROCEDURE IF EXISTS sp63;
delimiter //;
CREATE PROCEDURE sp63( in f1 mediumtext, inout f2 mediumtext, out f3 mediumtext, in f4 mediumtext, inout f5 mediumtext, out f6 mediumtext, in f7 mediumtext, inout f8 mediumtext, out f9 mediumtext, in f10 mediumtext, inout f11 mediumtext, out f12 mediumtext)
BEGIN
  set f1 = concat('hello', f1); set f2 = concat('hello', f2); set f3 = concat('hello', f3);
  set f4 = concat('hello', f4); set f5 = concat('hello', f5); set f6 = concat('hello', f5);
  set f7 = concat('hello', f7); set f8 = concat('hello', f8); set f9 = concat('hello', f8);
  set f10 = concat('hello', f10); set f11 = concat('hello', f11); set f12 = concat('hello', f11);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute63;
delimiter //;
CREATE PROCEDURE spexecute63()
BEGIN
  declare var1 mediumtext;
  declare var2 mediumtext;
  declare var3 mediumtext;
  declare var4 mediumtext;
  declare var5 mediumtext;
  declare var6 mediumtext;
  declare var7 mediumtext;
  declare var8 mediumtext;
  set var1 =  'world';
  set var3 =  'world';
  set var5 =  'world';
  set var7 =  'world';
  CALL sp63( 'world', var1, var2, 'world', var3, var4, 'world', var5, var6, 'world', var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute63();

DROP PROCEDURE spexecute63;
DROP PROCEDURE sp63;


DROP PROCEDURE IF EXISTS sp64;
delimiter //;
CREATE PROCEDURE sp64( in f1 decimal, inout f2 decimal, out f3 decimal, in f4 decimal, inout f5 decimal, out f6 decimal, in f7 decimal, inout f8 decimal, out f9 decimal, in f10 decimal, inout f11 decimal, out f12 decimal)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f2 / 2); set f3 = (f2 * 2); set f3 = (f2 - 10); set f3 = (f2 + 10);
   set f4 = (f4 / 2); set f4 = (f4 * 2); set f4 = (f4 - 10); set f4 = (f4 + 10); set f5 = (f5 / 2); set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f5 / 2); set f6 = (f5 * 2); set f6 = (f5 - 10); set f6 = (f5 + 10);
   set f7 = (f7 / 2); set f7 = (f7 * 2); set f7 = (f7 - 10); set f7 = (f7 + 10); set f8 = (f8 / 2); set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f8 / 2); set f9 = (f8 * 2); set f9 = (f8 - 10); set f9 = (f8 + 10);
   set f10 = (f10 / 2); set f10 = (f10 * 2); set f10 = (f10 - 10); set f10 = (f10 + 10); set f11 = (f11 / 2); set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f11 / 2); set f12 = (f11 * 2); set f12 = (f11 - 10); set f12 = (f11 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute64;
delimiter //;
CREATE PROCEDURE spexecute64()
BEGIN
  declare var1 decimal;
  declare var2 decimal;
  declare var3 decimal;
  declare var4 decimal;
  declare var5 decimal;
  declare var6 decimal;
  declare var7 decimal;
  declare var8 decimal;
  set var1 = --1.00e+09;
  set var3 = --1.00e+09;
  set var5 = --1.00e+09;
  set var7 = --1.00e+09;
  CALL sp64(--1.00e+09, var1, var2, --1.00e+09, var3, var4, --1.00e+09, var5, var6, --1.00e+09, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute64();
DROP PROCEDURE spexecute64;
DROP PROCEDURE sp64;


DROP PROCEDURE IF EXISTS sp65;
delimiter //;
CREATE PROCEDURE sp65( in f1 decimal (0, 0) unsigned zerofill, inout f2 decimal (0, 0) unsigned zerofill, out f3 decimal (0, 0) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute65;
delimiter //;
CREATE PROCEDURE spexecute65()
BEGIN
  declare var1 decimal (0, 0) unsigned zerofill;
  declare var2 decimal (0, 0) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 999999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp65(999999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute65();
DROP PROCEDURE spexecute65;
DROP PROCEDURE sp65;


DROP PROCEDURE IF EXISTS sp66;
delimiter //;
CREATE PROCEDURE sp66( in f1 decimal (63, 30) unsigned, inout f2 decimal (63, 30) unsigned, out f3 decimal (63, 30) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute66;
delimiter //;
CREATE PROCEDURE spexecute66()
BEGIN
  declare var1 decimal (63, 30) unsigned;
  declare var2 decimal (63, 30) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+16;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp66(1.00e+16, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute66();
DROP PROCEDURE spexecute66;
DROP PROCEDURE sp66;


DROP PROCEDURE IF EXISTS sp67;
delimiter //;
CREATE PROCEDURE sp67( in f1 decimal (63, 30) unsigned zerofill, inout f2 decimal (63, 30) unsigned zerofill, out f3 decimal (63, 30) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute67;
delimiter //;
CREATE PROCEDURE spexecute67()
BEGIN
  declare var1 decimal (63, 30) unsigned zerofill;
  declare var2 decimal (63, 30) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+16;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp67(1.00e+16, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute67();
DROP PROCEDURE spexecute67;
DROP PROCEDURE sp67;


DROP PROCEDURE IF EXISTS sp68;
delimiter //;
CREATE PROCEDURE sp68( in f1 decimal (63, 30) zerofill, inout f2 decimal (63, 30) zerofill, out f3 decimal (63, 30) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute68;
delimiter //;
CREATE PROCEDURE spexecute68()
BEGIN
  declare var1 decimal (63, 30) zerofill;
  declare var2 decimal (63, 30) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -1.00e+21;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp68(-1.00e+21, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute68();
DROP PROCEDURE spexecute68;
DROP PROCEDURE sp68;


DROP PROCEDURE IF EXISTS sp69;
delimiter //;
CREATE PROCEDURE sp69( in f1 decimal (64), inout f2 decimal (64), out f3 decimal (64), in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute69;
delimiter //;
eval CREATE PROCEDURE spexecute69()
BEGIN
  declare var1 decimal (64);
  declare var2 decimal (64);
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_m30;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp69($callvar01m, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute69();
DROP PROCEDURE spexecute69;
DROP PROCEDURE sp69;


DROP PROCEDURE IF EXISTS sp70;
delimiter //;
CREATE PROCEDURE sp70( in f1 decimal (64) unsigned, inout f2 decimal (64) unsigned, out f3 decimal (64) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute70;
delimiter //;
eval CREATE PROCEDURE spexecute70()
BEGIN
  declare var1 decimal (64) unsigned;
  declare var2 decimal (64) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_20;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp70($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute70();
DROP PROCEDURE spexecute70;
DROP PROCEDURE sp70;


DROP PROCEDURE IF EXISTS sp71;
delimiter //;
CREATE PROCEDURE sp71( in f1 decimal (64) unsigned zerofill, inout f2 decimal (64) unsigned zerofill, out f3 decimal (64) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute71;
delimiter //;
eval CREATE PROCEDURE spexecute71()
BEGIN
  declare var1 decimal (64) unsigned zerofill;
  declare var2 decimal (64) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_24;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp71($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute71();
DROP PROCEDURE spexecute71;
DROP PROCEDURE sp71;


DROP PROCEDURE IF EXISTS sp72;
delimiter //;
CREATE PROCEDURE sp72( in f1 decimal (64) zerofill, inout f2 decimal (64) zerofill, out f3 decimal (64) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute72;
delimiter //;
CREATE PROCEDURE spexecute72()
BEGIN
  declare var1 decimal (64) zerofill;
  declare var2 decimal (64) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp72(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute72();
DROP PROCEDURE spexecute72;
DROP PROCEDURE sp72;


DROP PROCEDURE IF EXISTS sp73;
delimiter //;
CREATE PROCEDURE sp73( in f1 decimal unsigned, inout f2 decimal unsigned, out f3 decimal unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute73;
delimiter //;
CREATE PROCEDURE spexecute73()
BEGIN
  declare var1 decimal unsigned;
  declare var2 decimal unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp73(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute73();
DROP PROCEDURE spexecute73;
DROP PROCEDURE sp73;


DROP PROCEDURE IF EXISTS sp74;
delimiter //;
CREATE PROCEDURE sp74( in f1 decimal unsigned zerofill, inout f2 decimal unsigned zerofill, out f3 decimal unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute74;
delimiter //;
CREATE PROCEDURE spexecute74()
BEGIN
  declare var1 decimal unsigned zerofill;
  declare var2 decimal unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp74(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute74();
DROP PROCEDURE spexecute74;
DROP PROCEDURE sp74;


DROP PROCEDURE IF EXISTS sp75;
delimiter //;
CREATE PROCEDURE sp75( in f1 decimal zerofill, inout f2 decimal zerofill, out f3 decimal zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute75;
delimiter //;
CREATE PROCEDURE spexecute75()
BEGIN
  declare var1 decimal zerofill;
  declare var2 decimal zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -1.00e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp75(-1.00e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute75();
DROP PROCEDURE spexecute75;
DROP PROCEDURE sp75;


DROP PROCEDURE IF EXISTS sp76;
delimiter //;
CREATE PROCEDURE sp76( in f1 float(0) unsigned zerofill, inout f2 float(0) unsigned zerofill, out f3 float(0) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute76;
delimiter //;
CREATE PROCEDURE spexecute76()
BEGIN
  declare var1 float(0) unsigned zerofill;
  declare var2 float(0) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp76(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute76();
DROP PROCEDURE spexecute76;
DROP PROCEDURE sp76;


DROP PROCEDURE IF EXISTS sp77;
delimiter //;
CREATE PROCEDURE sp77( in f1 float(23) unsigned zerofill, inout f2 float(23) unsigned zerofill, out f3 float(23) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute77;
delimiter //;
CREATE PROCEDURE spexecute77()
BEGIN
  declare var1 float(23) unsigned zerofill;
  declare var2 float(23) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp77(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute77();
DROP PROCEDURE spexecute77;
DROP PROCEDURE sp77;


DROP PROCEDURE IF EXISTS sp78;
delimiter //;
CREATE PROCEDURE sp78( in f1 float(24) unsigned zerofill, inout f2 float(24) unsigned zerofill, out f3 float(24) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute78;
delimiter //;
CREATE PROCEDURE spexecute78()
BEGIN
  declare var1 float(24) unsigned zerofill;
  declare var2 float(24) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp78(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute78();
DROP PROCEDURE spexecute78;
DROP PROCEDURE sp78;


DROP PROCEDURE IF EXISTS sp79;
delimiter //;
CREATE PROCEDURE sp79( in f1 float(53) unsigned zerofill, inout f2 float(53) unsigned zerofill, out f3 float(53) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute79;
delimiter //;
CREATE PROCEDURE spexecute79()
BEGIN
  declare var1 float(53) unsigned zerofill;
  declare var2 float(53) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 1.00e+00;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp79(1.00e+00, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute79();
DROP PROCEDURE spexecute79;
DROP PROCEDURE sp79;


DROP PROCEDURE IF EXISTS sp80;
delimiter //;
CREATE PROCEDURE sp80( in f1 int, inout f2 int, out f3 int, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute80;
delimiter //;
CREATE PROCEDURE spexecute80()
BEGIN
  declare var1 int;
  declare var2 int;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -2.15e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp80(-2.15e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute80();
DROP PROCEDURE spexecute80;
DROP PROCEDURE sp80;


DROP PROCEDURE IF EXISTS sp81;
delimiter //;
CREATE PROCEDURE sp81( in f1 int unsigned, inout f2 int unsigned, out f3 int unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute81;
delimiter //;
CREATE PROCEDURE spexecute81()
BEGIN
  declare var1 int unsigned;
  declare var2 int unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 4.29e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp81(4.29e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute81();
DROP PROCEDURE spexecute81;
DROP PROCEDURE sp81;


DROP PROCEDURE IF EXISTS sp82;
delimiter //;
CREATE PROCEDURE sp82( in f1 int unsigned zerofill, inout f2 int unsigned zerofill, out f3 int unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute82;
delimiter //;
CREATE PROCEDURE spexecute82()
BEGIN
  declare var1 int unsigned zerofill;
  declare var2 int unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 4.29e+09;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp82(4.29e+09, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute82();
DROP PROCEDURE spexecute82;
DROP PROCEDURE sp82;


DROP PROCEDURE IF EXISTS sp83;
delimiter //;
CREATE PROCEDURE sp83( in f1 int zerofill, inout f2 int zerofill, out f3 int zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute83;
delimiter //;
CREATE PROCEDURE spexecute83()
BEGIN
  declare var1 int zerofill;
  declare var2 int zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 2.15e+08;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp83(2.15e+08, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute83();
DROP PROCEDURE spexecute83;
DROP PROCEDURE sp83;


DROP PROCEDURE IF EXISTS sp84;
delimiter //;
CREATE PROCEDURE sp84( in f1 mediumint, inout f2 mediumint, out f3 mediumint, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute84;
delimiter //;
CREATE PROCEDURE spexecute84()
BEGIN
  declare var1 mediumint;
  declare var2 mediumint;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -8388600;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp84(-8388600, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute84();
DROP PROCEDURE spexecute84;
DROP PROCEDURE sp84;


DROP PROCEDURE IF EXISTS sp85;
delimiter //;
CREATE PROCEDURE sp85( in f1 mediumint unsigned, inout f2 mediumint unsigned, out f3 mediumint unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute85;
delimiter //;
CREATE PROCEDURE spexecute85()
BEGIN
  declare var1 mediumint unsigned;
  declare var2 mediumint unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 16777201;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp85(16777201, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute85();
DROP PROCEDURE spexecute85;
DROP PROCEDURE sp85;


DROP PROCEDURE IF EXISTS sp86;
delimiter //;
CREATE PROCEDURE sp86( in f1 mediumint unsigned zerofill, inout f2 mediumint unsigned zerofill, out f3 mediumint unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute86;
delimiter //;
CREATE PROCEDURE spexecute86()
BEGIN
  declare var1 mediumint unsigned zerofill;
  declare var2 mediumint unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 16777210;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp86(16777210, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute86();
DROP PROCEDURE spexecute86;
DROP PROCEDURE sp86;


DROP PROCEDURE IF EXISTS sp87;
delimiter //;
CREATE PROCEDURE sp87( in f1 mediumint zerofill, inout f2 mediumint zerofill, out f3 mediumint zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute87;
delimiter //;
CREATE PROCEDURE spexecute87()
BEGIN
  declare var1 mediumint zerofill;
  declare var2 mediumint zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -8388601;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp87(-8388601, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute87();
DROP PROCEDURE spexecute87;
DROP PROCEDURE sp87;


DROP PROCEDURE IF EXISTS sp88;
delimiter //;
CREATE PROCEDURE sp88( in f1 numeric (0) unsigned zerofill, inout f2 numeric (0) unsigned zerofill, out f3 numeric (0) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute88;
delimiter //;
CREATE PROCEDURE spexecute88()
BEGIN
  declare var1 numeric (0) unsigned zerofill;
  declare var2 numeric (0) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 99999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp88(99999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute88();
DROP PROCEDURE spexecute88;
DROP PROCEDURE sp88;


DROP PROCEDURE IF EXISTS sp89;
delimiter //;
CREATE PROCEDURE sp89( in f1 numeric (0, 0) unsigned zerofill, inout f2 numeric (0, 0) unsigned zerofill, out f3 numeric (0, 0) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute89;
delimiter //;
CREATE PROCEDURE spexecute89()
BEGIN
  declare var1 numeric (0, 0) unsigned zerofill;
  declare var2 numeric (0, 0) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 99999999;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp89(99999999, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute89();
DROP PROCEDURE spexecute89;
DROP PROCEDURE sp89;


DROP PROCEDURE IF EXISTS sp90;
delimiter //;
CREATE PROCEDURE sp90( in f1 numeric (63, 30) unsigned, inout f2 numeric (63, 30) unsigned, out f3 numeric (63, 30) unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute90;
delimiter //;
eval CREATE PROCEDURE spexecute90()
BEGIN
  declare var1 numeric (63, 30) unsigned;
  declare var2 numeric (63, 30) unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_36;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp90($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

#FIXME: hpux11 - check later again with E+40
CALL spexecute90();
DROP PROCEDURE spexecute90;
DROP PROCEDURE sp90;


DROP PROCEDURE IF EXISTS sp91;
delimiter //;
CREATE PROCEDURE sp91( in f1 numeric (63, 30) unsigned zerofill, inout f2 numeric (63, 30) unsigned zerofill, out f3 numeric (63, 30) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute91;
delimiter //;
eval CREATE PROCEDURE spexecute91()
BEGIN
  declare var1 numeric (63, 30) unsigned zerofill;
  declare var2 numeric (63, 30) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_36;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp91($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

#FIXME: hpux11 - check later again with E+40
CALL spexecute91();
DROP PROCEDURE spexecute91;
DROP PROCEDURE sp91;


DROP PROCEDURE IF EXISTS sp92;
delimiter //;
CREATE PROCEDURE sp92( in f1 numeric (63, 30) zerofill, inout f2 numeric (63, 30) zerofill, out f3 numeric (63, 30) zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute92;
delimiter //;
eval CREATE PROCEDURE spexecute92()
BEGIN
  declare var1 numeric (63, 30) zerofill;
  declare var2 numeric (63, 30) zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_m36;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp92($callvar01m, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute92();
DROP PROCEDURE spexecute92;
DROP PROCEDURE sp92;


DROP PROCEDURE IF EXISTS sp93;
delimiter //;
CREATE PROCEDURE sp93( in f1 numeric (64) unsigned zerofill, inout f2 numeric (64) unsigned zerofill, out f3 numeric (64) unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute93;
delimiter //;
eval CREATE PROCEDURE spexecute93()
BEGIN
  declare var1 numeric (64) unsigned zerofill;
  declare var2 numeric (64) unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = $procvar01_40;
  set var3 = $procvar03;
  set var5 = $procvar05;
  set var7 = $procvar07;
  CALL sp93($callvar01p, var1, var2, $callvar02, var3, var4, $callvar03, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute93();
DROP PROCEDURE spexecute93;
DROP PROCEDURE sp93;


DROP PROCEDURE IF EXISTS sp94;
delimiter //;
CREATE PROCEDURE sp94( in f1 smallint, inout f2 smallint, out f3 smallint, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute94;
delimiter //;
CREATE PROCEDURE spexecute94()
BEGIN
  declare var1 smallint;
  declare var2 smallint;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -32701;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp94(-32701, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute94();
DROP PROCEDURE spexecute94;
DROP PROCEDURE sp94;


DROP PROCEDURE IF EXISTS sp95;
delimiter //;
CREATE PROCEDURE sp95( in f1 smallint unsigned, inout f2 smallint unsigned, out f3 smallint unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute95;
delimiter //;
CREATE PROCEDURE spexecute95()
BEGIN
  declare var1 smallint unsigned;
  declare var2 smallint unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 65531;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp95(65531, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute95();
DROP PROCEDURE spexecute95;
DROP PROCEDURE sp95;


DROP PROCEDURE IF EXISTS sp96;
delimiter //;
CREATE PROCEDURE sp96( in f1 smallint unsigned zerofill, inout f2 smallint unsigned zerofill, out f3 smallint unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute96;
delimiter //;
CREATE PROCEDURE spexecute96()
BEGIN
  declare var1 smallint unsigned zerofill;
  declare var2 smallint unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 65531;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp96(65531, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute96();
DROP PROCEDURE spexecute96;
DROP PROCEDURE sp96;


DROP PROCEDURE IF EXISTS sp97;
delimiter //;
CREATE PROCEDURE sp97( in f1 smallint zerofill, inout f2 smallint zerofill, out f3 smallint zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute97;
delimiter //;
CREATE PROCEDURE spexecute97()
BEGIN
  declare var1 smallint zerofill;
  declare var2 smallint zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -32601;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp97(-32601, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute97();
DROP PROCEDURE spexecute97;
DROP PROCEDURE sp97;


DROP PROCEDURE IF EXISTS sp98;
delimiter //;
CREATE PROCEDURE sp98( in f1 tinyint, inout f2 tinyint, out f3 tinyint, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute98;
delimiter //;
CREATE PROCEDURE spexecute98()
BEGIN
  declare var1 tinyint;
  declare var2 tinyint;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -115;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp98(-115, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute98();
DROP PROCEDURE spexecute98;
DROP PROCEDURE sp98;


DROP PROCEDURE IF EXISTS sp99;
delimiter //;
CREATE PROCEDURE sp99( in f1 tinyint unsigned, inout f2 tinyint unsigned, out f3 tinyint unsigned, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute99;
delimiter //;
CREATE PROCEDURE spexecute99()
BEGIN
  declare var1 tinyint unsigned;
  declare var2 tinyint unsigned;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 251;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp99(251, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute99();
DROP PROCEDURE spexecute99;
DROP PROCEDURE sp99;


DROP PROCEDURE IF EXISTS sp100;
delimiter //;
CREATE PROCEDURE sp100( in f1 tinyint unsigned zerofill, inout f2 tinyint unsigned zerofill, out f3 tinyint unsigned zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
   SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute100;
delimiter //;
CREATE PROCEDURE spexecute100()
BEGIN
  declare var1 tinyint unsigned zerofill;
  declare var2 tinyint unsigned zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = 201;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp100(201, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute100();
DROP PROCEDURE spexecute100;
DROP PROCEDURE sp100;


DROP PROCEDURE IF EXISTS sp101;
delimiter //;
CREATE PROCEDURE sp101( in f1 tinyint zerofill, inout f2 tinyint zerofill, out f3 tinyint zerofill, in f4 bigint, inout f5 bigint, out f6 bigint, in f7 bigint, inout f8 bigint, out f9 bigint, in f10 bigint, inout f11 bigint, out f12 bigint)
BEGIN
   set f1 = (f1 / 2); set f1 = (f1 * 2); set f1 = (f1 - 10); set f1 = (f1 + 10); set f2 = (f2 / 2); set f2 = (f2 * 2); set f2 = (f2 - 10); set f2 = (f2 + 10); set f3 = (f1 / 2); set f3 = (f1 * 2); set f3 = (f1 - 10); set f3 = (f1 + 10);
   set f6 = f5; set f5 = (f5 * 2); set f5 = (f5 - 10); set f5 = (f5 + 10); set f6 = (f6 * 2); set f6 = (f6 - 10); set f6 = (f6 + 10);
   set f9 = f8; set f8 = (f8 * 2); set f8 = (f8 - 10); set f8 = (f8 + 10); set f9 = (f9 * 2); set f9 = (f9 - 10); set f9 = (f9 + 10);
   set f12 = f11; set f11 = (f11 * 2); set f11 = (f11 - 10); set f11 = (f11 + 10); set f12 = (f12 * 2); set f12 = (f12 - 10); set f12 = (f12 + 10);
  SELECT f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12;
END//
delimiter ;//

DROP PROCEDURE IF EXISTS spexecute101;
delimiter //;
CREATE PROCEDURE spexecute101()
BEGIN
  declare var1 tinyint zerofill;
  declare var2 tinyint zerofill;
  declare var3 bigint;
  declare var4 bigint;
  declare var5 bigint;
  declare var6 bigint;
  declare var7 bigint;
  declare var8 bigint;
  set var1 = -101;
  set var3 = -9.22e+18;
  set var5 = -9.22e+18;
  set var7 = -9.22e+18;
  CALL sp101(-101, var1, var2, -9.22e+18, var3, var4, -9.22e+18, var5, var6, -9.22e+18, var7, var8);
  SELECT var1, var2, var3, var4, var5, var6, var7, var8;
END//
delimiter ;//

CALL spexecute101();
DROP PROCEDURE spexecute101;
DROP PROCEDURE sp101;

USE db_storedproc;
DROP DATABASE db1;



USE db_storedproc;
# ------------------------------------------------------------------------------
let $message= Testcase 4.7.2:
FIXME: a wrong testcase number and/or description has been detected here. This
FIXME: needs to be checked to be sure where the missing testcase is located.
.
check for "allow_invalid_dates" server sql mode
;
--source include/show_msg80.inc

--disable_warnings
DROP PROCEDURE IF EXISTS sp2;
drop table IF EXISTS temp_table;
--enable_warnings

create table temp_table (f1 datetime);

set @@sql_mode = 'allow_invalid_dates';

delimiter //;
CREATE PROCEDURE sp2 ()
BEGIN
    declare a datetime;
    set a = '2005-03-14 01:01:02';
    insert into temp_table values(a);
END//
delimiter ;//

show CREATE PROCEDURE sp2;

set @@sql_mode = 'traditional';

CALL sp2 ();
SELECT * from temp_table;

SELECT @@sql_mode;

# cleanup
DROP PROCEDURE sp2;
drop table temp_table;


# ------------------------------------------------------------------------------
let $message= Testcase 4.7.3:
FIXME: a wrong testcase number and/or description has been detected here. This
FIXME: needs to be checked to be sure where the missing testcase is located.
.
check for *high_not_precedence* server sql mode
;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp3;

set @@sql_mode = 'high_not_precedence';

delimiter //;
CREATE PROCEDURE sp3()
BEGIN
    declare a int signed;
    declare b int unsigned;
    set a = -5;
    set b = 5;
    SELECT not 1 between a and b;
END//
delimiter ;//

show CREATE PROCEDURE sp3;

set @@sql_mode='';

CALL sp3();
SELECT @@sql_mode;

# cleanup
DROP PROCEDURE sp3;


# ------------------------------------------------------------------------------
let $message= Testcase 4.7.4:
FIXME: a wrong testcase number and/or description has been detected here. This
FIXME: needs to be checked to be sure where the missing testcase is located.
.
check for combination of server sql modes
;
--source include/show_msg80.inc

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp4;

set @@sql_mode = 'ansi, error_for_division_by_zero';

# now set the corrent value:
set @@sql_mode = 'ansi,error_for_division_by_zero';

SHOW VARIABLES LIKE 'sql_mode';

delimiter //;
CREATE PROCEDURE sp4()
BEGIN
    declare a int;
    declare b int;
    declare c int;
    set a = 0;
    set b = 1;
    set c = b/a;
    show warnings;
END//
delimiter ;//

show CREATE PROCEDURE sp4;

set @@sql_mode='';

CALL sp4();

# cleanup
DROP PROCEDURE sp4;
set @@sql_mode='';


# ==============================================================================
let $message= Section 3.1.8 - SHOW statement checks:;
--source include/show_msg80.inc


USE db_storedproc;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.1:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a procedure is properly recorded and displayed when a show create
#        procedure statement is executed.

--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
DROP PROCEDURE IF EXISTS sp6a;
DROP PROCEDURE IF EXISTS sp6b;
DROP PROCEDURE IF EXISTS sp6c;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp6a (i1 longtext, out i2 mediumint , inout i3 longblob, in i4 year, out i5 real)
language sql
BEGIN
   set @x=i1;
   set @y=@x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE sp6b (out i1 longtext, out i2 mediumint , out i3 longblob, out i4 year, out i5 real)
deterministic
BEGIN
   set @x=i1;
   set @y=@x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE sp6c (inout i1 longtext, inout  i2 mediumint , inout i3 longblob, inout  i4 year, inout  i5 real) comment 'this is a comment'
BEGIN
   set @x=i1;
   set @y=@x;
END//
delimiter ;//

show CREATE PROCEDURE sp6a;

show CREATE PROCEDURE sp6b;

show CREATE PROCEDURE sp6c;

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6a';

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6b';

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6c';

# cleanup
DROP PROCEDURE sp6a;
DROP PROCEDURE sp6b;
DROP PROCEDURE sp6c;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.2:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a procedure is properly recorded and displayed when a show procedure
#      status statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x=i1;
      set @y=@x;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6';

# cleanup
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.3:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a procedure is not displayed when a show create function
#      statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x=i1;
    set @y=@x;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
SHOW CREATE FUNCTION sp6;

# cleanup
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.4:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a procedure is properly recorded and displayed when a show function
#      status statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE FUNCTION sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real) returns longtext
  BEGIN
    set @x=i1;
    set @y=@x;
    return 0;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
  show  function status like 'sp6';

# cleanup
DROP FUNCTION sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.5:;
--source include/show_msg80.inc

# testcase: ensure that the attempt to execute show CREATE PROCEDURE with the name of a non-existing
#      procedure fails with an appropriate error message.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp7;

--error ER_SP_DOES_NOT_EXIST
  show CREATE PROCEDURE sp7;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.6:;
--source include/show_msg80.inc

# testcase: ensure that the attempt to execute SHOW PROCEDURE status with the name of a non-existing
#          procedure returns an empty set.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

    show  procedure status like 'sp6';



# ------------------------------------------------------------------------------
let $message= Testcase 4.8.7:;
--source include/show_msg80.inc

# testcase: ensure that an attempt to execute show CREATE PROCEDURE with the name of a function fails
#      with an appropriate error message.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (i1 real) returns real
  BEGIN
    return i1;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
  show CREATE PROCEDURE fn1;

# cleanup
DROP FUNCTION fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.8:;
--source include/show_msg80.inc

# testcase: ensure that an attempt to execute SHOW PROCEDURE status with the name of a
#        function returns an empty set.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (i1 real) returns real
  BEGIN
    return i1;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
  show  procedure status like 'fn1';

# cleanup
DROP FUNCTION fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.9:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a function is properly recorded and displayed when a
#        show CREATE FUNCTION statement is executed.

# part of 3.1.8.9

# ------------------------------------------------------------------------------
let $message= Testcase 4.8.10:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a function is properly recorded and displayed when a
# SHOW FUNCTION status.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (i1 real) returns real
BEGIN
   return i1;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';

# cleanup
DROP FUNCTION fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.11:;
--source include/show_msg80.inc

# testcase: ensure that the definition of a function is not displayed when a
#        show CREATE PROCEDURE statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (x int) returns int
  BEGIN
    return x;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
  show CREATE PROCEDURE fn1;

# cleanup
DROP FUNCTION fn1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.8.12:;
--source include/show_msg80.inc

# testcase: ensure that the attempt to execute show CREATE FUNCTION with the name of a
#      non-existing function fails with an appropriate error message.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1(x int) returns int
  BEGIN
            return x;
END//
delimiter ;//

DROP FUNCTION fn1;

--error ER_SP_DOES_NOT_EXIST
  show CREATE FUNCTION fn1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.8.13:;
--source include/show_msg80.inc

# testcase: ensure that the attempt to execute show function status  with the name of a
#      non-existing function returns an empty set.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS f1000;

SHOW FUNCTION STATUS LIKE 'f1000';


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.14:;
--source include/show_msg80.inc

# testcase: ensure that an attempt to execute show CREATE FUNCTION with the name of a procedure
#        fails with an appropriate error message.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp1;

delimiter //;
CREATE PROCEDURE sp1()
BEGIN
    SELECT * from t8;
END//
delimiter ;//

--error ER_SP_DOES_NOT_EXIST
  show CREATE FUNCTION sp1;

# cleanup
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.15:;
--source include/show_msg80.inc

# testcase: ensure that an attempt to execute show function status with the name of a procedure fails with an
#      appropriate error message.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x=i1;
    set @y=@x;
END//
delimiter ;//

--replace_column 5 <modified> 6 <created>
  show  function status like 'sp6';

# cleanup
DROP PROCEDURE sp6;



# ------------------------------------------------------------------------------
let $message= Testcase 4.8.16:;
--source include/show_msg80.inc

# testcase: ensure that all stored procedure changes made with alter procedure are properly recorded
#      and displayed when a  show CREATE PROCEDURE statement is executed.

# part of 3.1.8.9


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.17:;
--source include/show_msg80.inc

# testcase: ensure that all stored procedure changes made with alter procedure are properly recorded
#      and displayed when a  SHOW PROCEDURE status statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x=i1;
    set @y=@x;
END//
delimiter ;//

  alter procedure sp6 sql security invoker;

  alter procedure sp6 comment  'this is a new comment';

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6';

# cleanup
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.18:;
--source include/show_msg80.inc

# testcase: ensure that all stored procedure changes made with alter function are properly recorded
#        and displayed when a show CREATE FUNCTION statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (x int) returns int
  BEGIN
    return x;
END//
delimiter ;//

  alter function fn1 sql security invoker;

  show  create  function  fn1;

# cleanup
DROP FUNCTION fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.19:;
--source include/show_msg80.inc

# testcase: ensure that all function changes made with alter function are properly recorded and
#      displayed when a show  function status statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (i1 longtext) returns longtext
  BEGIN
    return i1;
END//
delimiter ;//

  alter function fn1 sql security invoker;
  alter function fn1 comment 'this is a function 3242#@%$#@';

--replace_column 5 <modified> 6 <created>
  show  function status like 'fn1';

# cleanup
DROP FUNCTION fn1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.8.20:;
--source include/show_msg80.inc

# testcase: ensure that all stored procedure changes made with alter procedure are properly
#      recorded and displayed   when a show CREATE PROCEDURE statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 int , i2 int)
BEGIN
    set @x=i1;
    set @y=@x;
END//
delimiter ;//

  alter procedure sp6 comment 'this is simple';

  show CREATE PROCEDURE sp6;

# cleanup
DROP PROCEDURE sp6;

# ------------------------------------------------------------------------------
let $message= Testcase 4.8.21:;
--source include/show_msg80.inc

# testcase: ensure that when a stored procedure is dropped, its definition no longer appears when
#      a show CREATE PROCEDURE is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 int, i2 int)
BEGIN
    set @x=i1;
    set @y=@x;
END//
delimiter ;//

DROP PROCEDURE sp6;

--error ER_SP_DOES_NOT_EXIST
  show CREATE PROCEDURE sp6;

# ------------------------------------------------------------------------------
let $message= Testcase 4.8.22:;
--source include/show_msg80.inc

# testcase: ensure that when a stored procedure is dropped, its definition no longer appears when
#      SHOW PROCEDURE status.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x=i3;
    set @y=@x;
END//
delimiter ;//

DROP PROCEDURE sp6;

--replace_column 5 <modified> 6 <created>
SHOW PROCEDURE status like 'sp6';


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.23:;
--source include/show_msg80.inc

# testcase: ensure that when a stored procedure is dropped, its definition no longer appears
#      when a statement or a show CREATE FUNCTION statement is executed.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (x int) returns int
  BEGIN
    return x;
END//
delimiter ;//

DROP FUNCTION fn1;

--error ER_SP_DOES_NOT_EXIST
  show CREATE FUNCTION fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.8.24:;
--source include/show_msg80.inc

# testcase: ensure that when a function is dropped, its definition no longer appears when a
# SHOW FUNCTION status statement is executed.
# suppressed: the test does not display an error message. it just returns an empty set

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP FUNCTION IF EXISTS fn1;

delimiter //;
CREATE FUNCTION fn1 (i1 longtext) returns longtext
BEGIN
    return i1;
END//
delimiter ;//

DROP FUNCTION fn1;

--replace_column 5 <modified> 6 <created>
SHOW FUNCTION STATUS LIKE 'fn1';


# ==============================================================================
let $message= Section 3.1.9 - Routine body checks:;
--source include/show_msg80.inc

USE db_storedproc;

# ------------------------------------------------------------------------------
let $message= Testcase 4.9.1:;
--source include/show_msg80.inc

# testcase: verify SELECT sql statements that may be executed by a stored procedure.
#

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS sp6;

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x = i3;
    set @a = i5;
    set @y = @x;
    set @b = @a;
    SELECT * from t9 limit 0, 100;
END//
delimiter ;//

--sorted_result
CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;


# ------------------------------------------------------------------------------
let $message= Testcase 4.9.2:;
--source include/show_msg80.inc

# testcase: verify insert sql statements that can be executed by a stored procedure.
#

--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
drop  table IF EXISTS res_t9;
--enable_warnings

  create table res_t9 (f1 int, f2 char(25), f3 int);

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x = i3;
    set @a = i5;
    set @y = @x;
    set @b = @a;
    insert into res_t9 values (@y, @a, 111);
    SELECT * from res_t9;
END//
delimiter ;//

CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;
drop table res_t9;


# ------------------------------------------------------------------------------
let $message= Testcase 4.9.3:;
--source include/show_msg80.inc

# testcase: verify delete sql statements that may be executed by a stored procedure.
#

--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
drop  table IF EXISTS res_t9;
--enable_warnings

  create table res_t9 (f1 int, f2 char(25), f3 int);

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x = i3;
    set @a = i5;
    set @y = @x;
    set @b = @a;
    insert into res_t9 values (@y, @a, 111);
    SELECT * from res_t9;
    delete from res_t9;
    SELECT * from res_t9;
END//
delimiter ;//


CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;
drop table res_t9;


# ------------------------------------------------------------------------------
let $message= Testcase 4.9.4:;
--source include/show_msg80.inc

# testcase: verify update sql statements that may be executed by a stored procedure.
#

--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
drop  table IF EXISTS res_t9;
--enable_warnings

  create table res_t9 (f1 int, f2 char(25), f3 int);

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x = i3;
    set @a = i5;
    set @y = @x;
    set @b = @a;
    insert into res_t9 values (@y, @a, 111);
    SELECT * from res_t9;
    update res_t9 set f2 = 1000 where f2 = 50;
    SELECT * from res_t9;
END//
delimiter ;//

CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;
drop table res_t9;


# ------------------------------------------------------------------------------
let $message= Testcase 4.9.5:;
--source include/show_msg80.inc

# testcase: verify create sql statements that may be executed by a stored procedure
#
--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
drop table IF EXISTS res_t9;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
   set @x = i1;
   set @y = i3;
   set @z = i5;
   set @a = @x;
   set @b = @y;
   set @c = @z;
   create table res_t9(f1 longtext, f2 longblob, f3 real);
   insert into res_t9 values (@a, @b, @c);
   SELECT * from res_t9;
END//
delimiter ;//

CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
drop table IF EXISTS res_t9;

# ------------------------------------------------------------------------------
let $message= Testcase 4.9.6:;
--source include/show_msg80.inc

# testcase:  verify select/insert/update/create statements are disallowed in a function.
# updated testcase:  verify select/insert/update/create statements are ALLOWED in a function.
#
DROP FUNCTION IF EXISTS fn1;

delimiter //;
--error ER_SP_NO_RETSET
CREATE FUNCTION fn1(i1 longtext) returns longtext
BEGIN
   SELECT * from t9 limit 0, 100;
   return i1;
END//
delimiter ;//

DROP FUNCTION IF EXISTS fn1;
drop table IF EXISTS res_t9;

create table res_t9 (f1 int, f2 char(25), f3 int);
insert into res_t9 values (10, 'abc', 20);

delimiter //;
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
CREATE FUNCTION fn1(i1 longtext) returns longtext
BEGIN
   delete from res_t9;
   drop table res_t9;
   return i1;
END//
delimiter ;//

DROP FUNCTION IF EXISTS fn1;
drop table IF EXISTS res_t9;

delimiter //;
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
CREATE FUNCTION fn1(i1 longtext) returns longtext
BEGIN
    create table res_t9 (f1 longtext, f2 longblob, f3 real);
    drop table res_t9;
    return i1;
END//
delimiter ;//

DROP FUNCTION IF EXISTS fn1;
drop  table IF EXISTS res_t9;

create table res_t9 (f1 int, f2 char(25), f3 int);

delimiter //;
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
CREATE FUNCTION fn1(i1 longtext) returns longtext
BEGIN
   insert into res_t9 values (100, 'abc', 300);
   drop table res_t9;
   return i1;
END//
delimiter ;//

DROP FUNCTION IF EXISTS fn1;
drop  table IF EXISTS res_t9;

create table res_t9 (f1 int, f2 char(25), f3 int);
insert into res_t9 values (10, 'abc', 20);

delimiter //;
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
CREATE FUNCTION fn1(i1 longtext) returns longtext
BEGIN
   update res_t9 set f1 = 20;
   drop table res_t9;
   return i1;
END//
delimiter ;//

# cleanup
drop table res_t9;
DROP FUNCTION IF EXISTS fn1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.9.7:;
--source include/show_msg80.inc

# testcase: verify create index sql statement that may be executed by a stored procedure
#
--disable_warnings
DROP PROCEDURE IF EXISTS sp6;
drop table IF EXISTS res_t9;
--enable_warnings

  create table res_t9 (f1 longtext, f2 longblob, f3 real);

delimiter //;
CREATE PROCEDURE sp6 (i1 longtext, i2 mediumint , i3 longblob, i4 year, i5 real)
BEGIN
    set @x = i1;
    set @y = i3;
    set @z = i5;
    set @a = @x;
    set @b = @y;
    set @c = @z;
    insert into res_t9 values (@a, @b, @c);
    SELECT * from res_t9;
    create index index_1 on res_t9 (f1 (5));
    analyze table res_t9;
    show index from res_t9;
END//
delimiter ;//

CALL sp6 (10, 20, 30, 40, 50);

# cleanup
DROP PROCEDURE sp6;
drop table res_t9;


# ==============================================================================
#
# test plan section: 4.11 - verify handlers with continue and exit conditions
#
# ==============================================================================
let $message= Section 3.1._ - :;
--source include/show_msg80.inc

USE db_storedproc;

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.1:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1318 (er_sp_wrong_no_of_args)
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for 1318 set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.2:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1305 (er_sp_does_not_exist)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for 1305 set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.3:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1318 (er_sp_wrong_no_of_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @xx=1;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare exit handler for 1318 set @x2 = 1;
    set @x=1;
    set @x2=0;
  CALL sp1 (1);
    set @x=0;
END//
delimiter ;//

CALL h1();

  SELECT @x, @x2;

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.4:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1305 (er_sp_does_not_exist)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare exit handler for 1305 set @x2 = 1;
    set @x=1;
    set @x2=0;
  CALL sp1 (1);
    set @x=0;
END//
delimiter ;//

CALL h1 ();

  SELECT @x, @x2;

# cleanup
DROP PROCEDURE h1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.5:;
--source include/show_msg80.inc

# testcase: verify undo handler for error code 1318 (er_sp_wrong_no_of_args)


--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for 1318 set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.6:;
--source include/show_msg80.inc

# testcase: verify undo handler for error code 1305 (er_sp_does_not_exist)


--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for 1318 set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.7:;
--source include/show_msg80.inc

# testcase: verify continue handler for sql state 42000 (er_sp_wrong_no_of_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for sqlstate '42000' set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.8:;
--source include/show_msg80.inc

# testcase: verify continue handler for sql state 42000 (er_sp_does_not_exist)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;


delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for sqlstate '42000' set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.9:;
--source include/show_msg80.inc

# testcase: verify exit handler for sql state 42000 (er_sp_wrong_no_of_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @xx=1;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare exit handler for sqlstate '42000' set @x2 = 1;
    set @x=1;
    set @x2=0;
  CALL sp1 (1);
    set @x=0;
END//
delimiter ;//

CALL h1();

  SELECT @x, @x2;

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.10:;
--source include/show_msg80.inc

# testcase: verify exit handler for sql state 42000 (er_sp_does_not_exist)

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare exit handler for sqlstate '42000' set @x2 = 1;
    set @x=1;
    set @x2=0;
  CALL sp1 (1);
    set @x=0;
END//
delimiter ;//

CALL h1 ();
  SELECT @x, @x2;

# cleanup
DROP PROCEDURE h1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.11:;
--source include/show_msg80.inc

# testcase: verify undo handler for sql state 42000 (er_sp_wrong_no_of_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for sqlstate '42000' set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.12:;
--source include/show_msg80.inc

# testcase: verify undo handler for sql state 42000 (er_sp_does_not_exist)


--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP PROCEDURE IF EXISTS sp1;
--enable_warnings

delimiter //;
CREATE PROCEDURE sp1 (x int, y int)
BEGIN
    set @y=x;
END//
delimiter ;//

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare continue handler for sqlstate '42000' set @x2 = 1;
    set @x=0;
  CALL sp1 (1);
    set @x=1;
    SELECT @x, @x2;
END//
delimiter ;//

CALL h1 ();

# cleanup
DROP PROCEDURE h1;
DROP PROCEDURE sp1;

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.13:;
--source include/show_msg80.inc

# testcase: verify continue handler for sql state 02000 (er_sp_fetch_no_data)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    repeat
      SELECT done;
      fetch cur1 into a, b;
      SELECT done;
      if not done then
        insert into res_t2 values (a, b);
      END if;
    until done END repeat;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.14:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1329 (er_sp_fetch_no_data)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;

  create table res_t1(w char, x char);

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    repeat
      SELECT done;
      fetch cur1 into a, b;
      SELECT done;
      if not done then
        insert into res_t2 values (a, b);
      END if;
    until done END repeat;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.15:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1329 (er_sp_fetch_no_data)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    repeat
      SELECT done;
      set @x=0;
      fetch cur1 into a, b;
      SELECT @x=1;
      if not done then
        insert into res_t2 values (a, b);
      END if;
    until done END repeat;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.16:;
--source include/show_msg80.inc

# testcase: verify exit handler for sql state '02000' (er_sp_fetch_no_data)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '02000' set done = 1;
    open cur1;
    repeat
      SELECT done;
      set @x=0;
      fetch cur1 into a, b;
      SELECT @x=1;
      if not done then
        insert into res_t2 values (a, b);
      END if;
      until done END repeat;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.17:;
--source include/show_msg80.inc

# testcase: verify continue handler for sql state HY000 (er_sp_wrong_no_of_fetch_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate 'HY000' set done = 1;
    open cur1;
    SELECT done;
    fetch cur1 into a;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.18:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1328 (er_sp_wrong_no_of_fetch_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for 1328 set done = 1;
    open cur1;
    SELECT done;
    fetch cur1 into a;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.19:;
--source include/show_msg80.inc

# testcase: verify exit handler for sql state HY000 (er_sp_wrong_no_of_fetch_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for sqlstate 'HY000' set done = 1;
    open cur1;
    SELECT done;
    set @x=0;
    fetch cur1 into a;
    set @x=1;
    SELECT done, @x;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.20:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1328 (er_sp_wrong_no_of_fetch_args)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for 1328 set done = 1;
    open cur1;
    SELECT done;
    set @x=0;
    fetch cur1 into a;
    set @x=1;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.21:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1325 (er_sp_cursor_already_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for 1325 set done = 1;
    open cur1;
    SELECT done;
    open cur1;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.22:;
--source include/show_msg80.inc

# testcase: verify continue handler for sqlstate 24000 (er_sp_cursor_already_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for 1325 set done = 1;
    open cur1;
    SELECT done;
    open cur1;
    set @x=1;
    SELECT done, @x;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.23:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1325 (er_sp_cursor_already_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for 1325 set done = 1;
    open cur1;
    set @x=0;
    SELECT done;
    open cur1;
    set @x=1;
    SELECT done;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.24:;
--source include/show_msg80.inc

# testcase: verify exit handler for sqlstate 24000 (er_sp_cursor_already_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for sqlstate '24000' set done = 1;
    open cur1;
    set @x=0;
    SELECT done;
    open cur1;
    set @x=1;
    SELECT done, @x;
    close cur1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.25:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1326 (er_sp_cursor_not_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for 1326 set done = 1;
    set @x=0;
    fetch cur1 into a, b;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings



# ------------------------------------------------------------------------------
let $message= Testcase 4.11.26:;
--source include/show_msg80.inc

# testcase: verify continue handler for sqlstate 24000 (er_sp_cursor_not_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '24000' set done = 1;
    set @x=0;
    fetch cur1 into a, b;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.27:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1326 (er_sp_cursor_not_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for 1326 set done = 1;
    set @x=0;
    fetch cur1 into a, b;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.28:;
--source include/show_msg80.inc

# testcase: verify exit handler for sqlstate 24000 (er_sp_cursor_not_open)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for sqlstate '24000' set done = 1;
    set @x=0;
    fetch cur1 into a, b;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.29:;
--source include/show_msg80.inc

# testcase: verify continue handler for error code 1339 (er_sp_case_not_found)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for 1339 set done = 1;
    set @x=0;
    case @x
          when 1 then set @x=10;
          when 2 then set @x=11;
    END case;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.30:;
--source include/show_msg80.inc

# testcase: verify continue handler for sqlstate 20000 (er_sp_case_not_found)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare continue handler for sqlstate '20000' set done = 1;
    set @x=0;
    case @x
          when 1 then set @x=10;
          when 2 then set @x=11;
    END case;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.31:;
--source include/show_msg80.inc

# testcase: verify exit handler for error code 1339 (er_sp_case_not_found)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for 1339 set done = 1;
    set @x=0;
    case @x
          when 1 then set @x=10;
          when 2 then set @x=11;
    END case;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.32:;
--source include/show_msg80.inc

# testcase: verify exit handler for sqlstate 20000 (er_sp_case_not_found)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
drop table IF EXISTS res_t2;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

  create table res_t2(y char, z char);

delimiter //;
CREATE PROCEDURE h1()
BEGIN
    declare done int default 0;
    declare a, b char;
    declare cur1 cursor for SELECT w, x from res_t1;
    declare exit handler for sqlstate '20000' set done = 1;
    set @x=0;
    case @x
          when 1 then set @x=10;
          when 2 then set @x=11;
    END case;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
DROP TABLE IF EXISTS res_t2;
--enable_warnings

# ------------------------------------------------------------------------------
let $message= Testcase 4.11.33:;
--source include/show_msg80.inc

# testcase: ensure that no two conditions declared with the same scope may have the same condition name.
#            (same condition name in same scope)

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
--enable_warnings

  create table res_t1(w char, x char);

  insert into res_t1 values('a', 'b');
  insert into res_t1 values('c', 'd');

delimiter //;
--error ER_SP_DUP_COND
CREATE PROCEDURE h1()
BEGIN
      declare condname condition for sqlstate '20000';
    declare done int default 0;
      declare a, b char;
      declare condname condition for sqlstate '20000';
      declare cur1 cursor for SELECT w, x from t1;
    set @x=2;
    case @x
      when 1 then set @x=10;
        when 2 then set @x=11;
    END case;
    set @x=1;
    SELECT done, @x;
END//
delimiter ;//

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP TABLE IF EXISTS res_t1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.35:;

# Ensure that every sqlstate value declared with a declare condition for
# statement and declare handler is a character string that is 5 character and
# cannot be an invalid state.;

--source include/show_msg80.inc

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
drop table IF EXISTS res_t1;
--enable_warnings

CREATE TABLE res_t1(w INT UNIQUE, x CHAR);

insert into res_t1 values (1, 'a');

delimiter //;

--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE h1 ()
begin1_label:BEGIN
   declare condname1 condition for sqlstate '020';
   declare condname2 condition for sqlstate 'wewe';
   declare condname3 condition for 9999;
   declare exit handler for sqlstate '020' set @var1 = 1;
   declare exit handler for sqlstate 'wewe'set @var1 = 1;
   declare exit handler for 9999 set @var1 = 1;
   set @var2 = 1;
   insert into res_t1 values (2, 'b');
   begin2_label: BEGIN
      declare continue handler for sqlstate '90000023' set @var3= 1;
      set @var4 = 1;
      insert into res_t1 values (3, 'c');
   END begin2_label;
END begin1_label//

--error ER_SP_BAD_SQLSTATE
CREATE PROCEDURE h1 ()
begin1_label:BEGIN
   declare condname1 condition for sqlstate '020';
   declare condname2 condition for sqlstate 'wewe';
   declare condname3 condition for 9999;
   set @var2 = 1;
   insert into res_t1 values (2, 'b');
   begin2_label: BEGIN
      declare continue handler for sqlstate '90000023' set @var3= 1;
      set @var4 = 1;
      insert into res_t1 values (3, 'c');
   END begin2_label;
END begin1_label//
delimiter ;//

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP TABLE IF EXISTS res_t1;


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.36:;
--source include/show_msg80.inc

# testcase: ensure that the declare  condition for statement cannot declare a condition for the successful
#            completion sqlstate:  00000.


--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
    declare x1 int default 0;
    BEGIN
        declare condname1 condition for sqlstate '00000';
      declare exit handler for condname1 set @x = 1;
      set x1 = 1;
      set x1 = 2;
    END;
    SELECT @x, x1;
END//
delimiter ;//

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;






# ------------------------------------------------------------------------------
let $message= Testcase 4.11.40:;
--source include/show_msg80.inc

# testcase: ensure that within the same scope, no two handlers may be declared for the same condition

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
--enable_warnings

CREATE TABLE res_t1(w CHAR UNIQUE, x CHAR);
INSERT INTO res_t1 VALUES ('a', 'b');

# suppressed--error for having two similar handlers in the same scope

delimiter //;
--error ER_SP_DUP_HANDLER
CREATE PROCEDURE h1 ()
BEGIN
   DECLARE x1, x2, x3, x4, x5 int default 0;
   DECLARE condname1 CONDITION FOR SQLSTATE '42000';
   DECLARE condname2 CONDITION FOR SQLSTATE '42000';
   DECLARE CONTINUE HANDLER FOR condname1 set x1 = 1;
   DECLARE CONTINUE HANDLER FOR condname1 set x2 = 1;
   DECLARE EXIT HANDLER FOR condname1 SET x3 = 1;
   DECLARE CONTINUE HANDLER FOR condname2 SET x4 = 1;
   DECLARE EXIT HANDLER FOR condname2 SET x5 = 1;
END//
delimiter ;//

#CALL h1();

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
--enable_warnings


# ------------------------------------------------------------------------------
let $message= Testcase 4.11.41:;
--source include/show_msg80.inc

# testcase: ensure that the declare  handler for statement cannot declare a condition for the successful
#            completion sqlstate:  00000.

--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;

delimiter //;
CREATE PROCEDURE h1 ()
BEGIN
   DECLARE x1 INT DEFAULT 0;
   BEGIN
      DECLARE condname1 CONDITION FOR SQLSTATE '00000';
      DECLARE EXIT HANDLER FOR SQLSTATE '00000' SET @x = 1;
      SET x1 = 1;
      SET x1 = 2;
   END;
   SELECT @x, x1;
END//
delimiter ;//

CALL h1();

# cleanup
--disable_warnings ER_SP_DOES_NOT_EXIST ONCE
DROP PROCEDURE IF EXISTS h1;


# ------------------------------------------------------------------------------
# FIXME 3.1.2.53: check numbering difference
let $message= * Testcase 3.1.2.53 (4.11.42):
* Ensure that a handler condition of sqlwarning takes the same action as a
* handler condition defined with an sqlstate that begins with 01.;
--source include/show_msg80.inc


--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
--enable_warnings

delimiter //;
CREATE PROCEDURE h1()
BEGIN
   DECLARE EXIT HANDLER FOR SQLWARNING SET @done = 1;
   SET @done=0;
   SET @x=1;
   INSERT INTO res_t1 VALUES('xxx', 'yy');
   SET @x=0;
END//
delimiter ;//

# table doesn't exist
--error ER_NO_SUCH_TABLE
CALL h1();
SELECT @done, @x;

CREATE TABLE res_t1(w CHAR, x CHAR);
INSERT INTO res_t1 VALUES('a', 'b');
INSERT INTO res_t1 VALUES('c', 'd');

# now table exists
CALL h1();
SELECT @done, @x;

--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
--enable_warnings

delimiter //;
CREATE PROCEDURE h1()
BEGIN
   DECLARE CONTINUE HANDLER FOR SQLWARNING SET @done = 1;
   SET @done=0;
   SET @x=0;
   INSERT INTO res_t1 VALUES('xxx', 'yy');
   SET @x=1;
END//
delimiter ;//

# table doesn't exist
--error ER_NO_SUCH_TABLE
CALL h1();
SELECT @done, @x;

CREATE TABLE res_t1(w CHAR, x CHAR);
INSERT INTO res_t1 VALUES('a', 'b');
INSERT INTO res_t1 VALUES('c', 'd');

# now table exists
CALL h1();
SELECT @done, @x;

# cleanup
--disable_warnings
DROP PROCEDURE IF EXISTS h1;
DROP TABLE IF EXISTS res_t1;
--enable_warnings
SET sql_mode = default;

# ==============================================================================
# USE the same .inc to cleanup before and after the test
--source suite/funcs_1/storedproc/cleanup_sp_tb.inc

# ==============================================================================
let $message= .                               +++ END OF SCRIPT +++;
--source include/show_msg80.inc
# ==============================================================================
