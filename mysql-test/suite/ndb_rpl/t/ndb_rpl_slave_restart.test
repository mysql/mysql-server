--source include/have_multi_ndb.inc
--source include/have_binlog_format_mixed_or_row.inc
--source suite/ndb_rpl/ndb_rpl_init_source_replica.inc

# note: server2 is another "master" connected to the master cluster

#
# Currently test only works with ndb since it retrieves "old"
# binlog positions with mysql.ndb_binlog_index and ndb_apply_status;
#

# create a table with one row, and make sure the other "master" gets it
CREATE TABLE t1 (c1 CHAR(15), c2 CHAR(15), c3 INT, PRIMARY KEY (c3)) ENGINE = NDB ;
# a dummy table such that we can make sure data gets into binlog on server2
CREATE TABLE t2 (a int key) ENGINE = NDB ;
connection server2;
reset binary logs and gtids;
SHOW TABLES;
connection master;
INSERT INTO t1 VALUES ("row1","will go away",1);
SELECT * FROM t1 ORDER BY c3;
connection server2;
SELECT * FROM t1 ORDER BY c3;

# sync slave and retrieve epoch and stop the slave
connection master;
sync_slave_with_master;
SELECT MAX(epoch) FROM mysql.ndb_apply_status into @the_epoch;
--replace_column 1 <the_epoch>
SELECT @the_epoch;
let $the_epoch= `select @the_epoch` ;
SELECT * FROM t1 ORDER BY c3;
STOP REPLICA;

# Ignore the warning generated by ndbcluster's binlog thread
# when mysqld is restarted
--disable_query_log ONCE
call mtr.add_suppression("mysqld startup An incident event has been written");

# restart the slave server
let $mysqld_name=mysqld.1.slave;
let $allow_rpl_inited=1;
--source include/restart_mysqld.inc

# get the master binlog pos from the epoch, from the _other_ "master", server2
connection server2;
# insert some data to t1 which should not come into the binlog
# just so that we can do "show binlog events" to make sure the t1
# update is actually in the server2 binlog
set SQL_LOG_BIN=0;
insert into t2 values (1);
-- source include/rpl/deprecated/show_binlog_events.inc
set SQL_LOG_BIN=1;
--replace_result $the_epoch <the_epoch>
--disable_query_log
--disable_result_log
eval SELECT @the_pos:=Position,
   @the_file:=SUBSTRING_INDEX(REPLACE(FILE,'\\\\','/'), '/', -1)
   FROM mysql.ndb_binlog_index WHERE epoch = $the_epoch ;
let $the_pos= `SELECT @the_pos` ;
let $the_file= `SELECT @the_file` ;

# now connect the slave to the _other_ "master"
connection slave;
--replace_result $MASTER_MYPORT1 <SOURCE_PORT1>
eval CHANGE REPLICATION SOURCE TO
  SOURCE_PORT=$MASTER_MYPORT1,
  SOURCE_LOG_FILE = '$the_file',
  SOURCE_LOG_POS = $the_pos ;
--enable_result_log
--enable_query_log
START REPLICA;

# insert some more values on the first master
connection master;
INSERT INTO t1 VALUES ("row2","will go away",2),("row3","will change",3),("row4","D",4);
DELETE FROM t1 WHERE c3 = 1;
UPDATE t1 SET c2="should go away" WHERE c3 = 2;
UPDATE t1 SET c2="C" WHERE c3 = 3;
DELETE FROM t1 WHERE c3 = 2;

SELECT * FROM t1 ORDER BY c3;

# insert another row, and check that we have it on the slave
connection server2;
INSERT INTO t1 VALUES ("row5","E",5);
SELECT * FROM t1 ORDER BY c3;
sync_slave_with_master;
connection slave;
SELECT * FROM t1 ORDER BY c3;

--echo ==== clean up ====
connection server2;
DROP TABLE t1;
DROP TABLE t2;
sync_slave_with_master;

STOP REPLICA;

# Reset replica back to first master 
connection slave;
--replace_result $MASTER_MYPORT <SOURCE_PORT>
eval CHANGE REPLICATION SOURCE TO
  SOURCE_PORT=$MASTER_MYPORT;

# Stop the binlog dump threads in server2
--connection server2
--source include/rpl/stop_dump_threads.inc
