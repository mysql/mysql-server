# ==== Purpose ====
# The purpose of this script is to test that binary logging returns an error
# if more than one engine is involved and at least one of them it's doing its
# own logging (is *self-logging*), which is the case for NDB engine.
#
# ==== Requirements ====
#
# R1. When more than one engine is involved in binary logging and at least one
#     engine is self-logging then binary logging should return error
#     `ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE`.
#
# ==== Implementation ====
#
# TC1. Verify that when more than one engine is involved in binary logging and
#      at least one engine is self-logging then binary logging should return
#      error `ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE`.
# ------------------------------------------------------------------
# With BINLOG_FORMAT = ROW :
# 1) Create a trigger which inserts data in MYISAM engine upon insertion of
#    data in NDB engine.
# 2) Try to insert data in the NDB ENGINE.
# 3) Verify that error `ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE` is returned.
# 4) Verify that no data was inserted in the NDB engine.
# 5) Verify that no data was inserted in MYISAM engine.
#
# ==== References ====
#
# BUG#39934: Slave stops for engine that only support row-based logging
# BUG#42829: binlogging enabled for all schemas regardless of binlog-db-db /
# binlog-ignore-db
#
# ==== Related test cases ====
#
# rpl.rpl_binlog_format_errors verifies that binary logging returns an error
# for the conditions 1 to 7 listed in the comments section of method
# decide_logging_format(). Condition 8 requires a self-logging engine which
# is the case of NDB and therefore it is tested in this script.

# Need debug so that 'SET @@session.debug' works.
--source include/have_debug.inc
# Need example plugin because it is the only statement-only engine.
--source include/have_example_plugin.inc
# The test changes binlog_format, so there is no reason to run it
# under more than one binlog format.
--source include/have_binlog_format_row.inc
--source include/have_ndb.inc
<<<<<<< HEAD
# The test requires MyISAM engine
--source include/have_myisam.inc
=======
<<<<<<< HEAD
=======
# The test requires MyISAM engine
--source include/have_myisam.inc
# Test requires GTIDs off
--source include/not_gtid_enabled.inc
>>>>>>> upstream/cluster-7.6
>>>>>>> pr/231
--source suite/ndb_rpl/ndb_master-slave.inc

--disable_query_log
CALL mtr.add_suppression("Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT");
CALL mtr.add_suppression("Cannot execute statement: impossible to write to binary log");
--enable_query_log

--echo ==== Initialize ====


--echo [on master]
--source include/rpl_connection_master.inc

CREATE TABLE t (a VARCHAR(100)) ENGINE = MYISAM;
CREATE TABLE t_self_logging (a VARCHAR(100)) ENGINE = NDB;

--echo [on slave]
--source include/sync_slave_sql_with_master.inc

--echo [on master]
--source include/rpl_connection_master.inc

--echo ==== Test ====

--echo ---- binlog_format='row' ----

--echo * Modify tables of more than one engine, one of which is self-logging
--eval CREATE TRIGGER trig_1 AFTER INSERT ON t_self_logging FOR EACH ROW BEGIN INSERT INTO t VALUES (1); END
--error ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE
INSERT INTO t_self_logging VALUES (1);
DROP trigger trig_1;
SELECT * FROM t_self_logging /* Should be empty */;
SELECT * FROM t /* Should be empty */;

<<<<<<< HEAD
=======
<<<<<<< HEAD
--echo * Modify both row-only and stmt-only table
--eval CREATE TRIGGER trig_2 AFTER INSERT ON t_stmt FOR EACH ROW BEGIN INSERT INTO t_row VALUES(1); END
--error ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE
INSERT INTO t_stmt VALUES (1);
SELECT * FROM t_stmt /* should be empty */;
DROP TRIGGER trig_2;

--echo * Stmt-only table and binlog_format='row'
--error ER_BINLOG_ROW_MODE_AND_STMT_ENGINE
INSERT INTO t_stmt VALUES (1);
SELECT * FROM t_stmt /* should be empty */;

--echo * Row injection and stmt-only table: in slave sql thread
INSERT INTO t_slave_stmt VALUES (1);
--echo [on slave]
--connection slave
# 1664 = ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE
--let $slave_sql_errno= 1664
--let $show_slave_sql_error= 1
--source include/wait_for_slave_sql_error_and_skip.inc
--connection slave
SELECT * FROM t_slave_stmt /* should be empty */;

--echo [on master]
--connection master
--echo * Row injection and stmt-only table: use BINLOG statement
# This is a Table_map_event and a Write_rows_event. Together, they are
# equivalent to 'INSERT INTO t_stmt VALUES (1)'
--error ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE
BINLOG '
1gRVShMBAAAALwAAAEABAAAAABcAAAAAAAAABHRlc3QABnRfc3RtdAABDwJkAAE=
1gRVShcBAAAAIAAAAGABAAAQABcAAAAAAAEAAf/+ATE=
';
SELECT * FROM t_stmt /* should be empty */;


--echo ---- binlog_format=mixed ----

--echo [on slave]
--sync_slave_with_master
--source include/stop_slave.inc
SET @@global.binlog_format = MIXED;
--source include/start_slave.inc
--echo [on master]
--connection master
SET @@global.binlog_format = MIXED;
SET @@session.binlog_format = MIXED;

--echo * Unsafe statement and stmt-only engine
--error ER_BINLOG_UNSAFE_AND_STMT_ENGINE
INSERT INTO t_stmt VALUES (UUID());

# Concatenate two unsafe values, and then concatenate NULL to
# that so that the result is NULL and we instead use autoinc.
--echo * Multi-unsafe statement and stmt-only engine
--error ER_BINLOG_UNSAFE_AND_STMT_ENGINE
INSERT INTO t_double_autoinc SELECT CONCAT(UUID(), @@hostname, NULL) FROM mysql.general_log LIMIT 1;


--echo ---- binlog_format=statement ----

--echo [on slave]
--sync_slave_with_master
--source include/stop_slave.inc
SET @@global.binlog_format = STATEMENT;
--source include/start_slave.inc
--echo [on master]
--connection master
SET @@global.binlog_format = STATEMENT;
SET @@session.binlog_format = STATEMENT;

--echo * Row-only engine and binlog_format=statement: innodb-specific message
--error ER_BINLOG_STMT_MODE_AND_ROW_ENGINE
INSERT INTO t_row VALUES (1);
SELECT * FROM t_row /* should be empty */;

# Commented out since innodb gives an error (this is a bug)
#--echo * Same statement, but db filtered out - no error
#USE other;
#INSERT INTO test.t_row VALUES (1);
#USE test;

--echo * Row-only engine and binlog_format=statement: generic message
SET @@session.debug= '+d,no_innodb_binlog_errors';
--error ER_BINLOG_STMT_MODE_AND_ROW_ENGINE
INSERT INTO t_row VALUES (1);
SELECT * FROM t_row /* should be empty */;

--echo * Same statement, but db filtered out - no error
USE other;
INSERT INTO test.t_row VALUES (1);
USE test;
SET @@session.debug= '';
SELECT * FROM t_row /* should contain the value 1 */;

--echo * Row injection and binlog_format=statement: BINLOG statement
# This is a Table_map_event and a Write_rows_event. Together, they are
# equivalent to 'INSERT INTO t VALUES (1)'.
--error ER_BINLOG_ROW_INJECTION_AND_STMT_MODE
BINLOG '
cNpVShMBAAAAKgAAADYBAAAAABcAAAAAAAAABHRlc3QAAXQAAQ8CZAAB
cNpVShcBAAAAIAAAAFYBAAAQABcAAAAAAAEAAf/+ATE=
';
SELECT * FROM t /* should be empty */;

--echo * Same statement, but db filtered out - no error
# This is a Table_map_event and a Write_rows_event. Together, they are
# equivalent to 'INSERT INTO t VALUES (1)'.
USE other;
BINLOG '
cNpVShMBAAAAKgAAADYBAAAAABcAAAAAAAAABHRlc3QAAXQAAQ8CZAAB
cNpVShcBAAAAIAAAAFYBAAAQABcAAAAAAAEAAf/+ATE=
';
USE test;
SELECT * FROM t /* should contain the value 1 */;
DELETE FROM t;

--echo * Unsafe statement and binlog_format=statement
# This will give a warning.
INSERT INTO t VALUES (COALESCE(1, UUID()));
SELECT * FROM t /* should contain the value 1 */;
DELETE FROM t;

--echo * Same statement, but db filtered out - no message
USE other;
INSERT INTO test.t VALUES (COALESCE(1, UUID()));
USE test;
SELECT * FROM t /* should contain the value 1 */;
DELETE FROM t;


--echo ---- master: binlog_format=mixed, slave: binlog_format=statement ----

SET @@global.binlog_format = MIXED;
SET @@session.binlog_format = MIXED;

--echo * Row injection and binlog_format=statement: in slave sql thread
INSERT INTO t VALUES (COALESCE(1, UUID()));
--echo [on slave]
--connection slave
# 1666 = ER_BINLOG_ROW_INJECTION_AND_STMT_MODE
--let $slave_sql_errno= 1666
--let $show_sql_error= 1
--source include/wait_for_slave_sql_error_and_skip.inc
--connection slave
SELECT * FROM t /* should be empty */;
--echo [on master]
--connection master


=======
>>>>>>> upstream/cluster-7.6
>>>>>>> pr/231
--echo ==== Clean up ====
DROP TABLE t, t_self_logging;
--source include/sync_slave_sql_with_master.inc

--source include/rpl_end.inc
