
############################################################
#  1. Create a group with 3 members.
include/group_replication.inc [rpl_server_count=3]
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the connection metadata repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
[connection server1]

############################################################
#  2. Start 2 servers.
#     Only setup recovery_user on server2 for force server3
#     to recover from it.
[connection server1]
include/start_and_bootstrap_group_replication.inc
SET SESSION sql_log_bin= 0;
CREATE TABLE t1 (c1 INT NOT NULL PRIMARY KEY) ENGINE=InnoDB;
SET SESSION sql_log_bin= 1;
[connection server2]
SET SESSION sql_log_bin= 0;
CREATE TABLE t1 (c1 INT NOT NULL PRIMARY KEY) ENGINE=InnoDB;
CREATE USER "recovery_user" IDENTIFIED BY "recovery_password";
GRANT REPLICATION SLAVE ON *.* TO "recovery_user";
GRANT GROUP_REPLICATION_STREAM ON *.* TO "recovery_user";
FLUSH PRIVILEGES;
SET SESSION sql_log_bin= 1;
include/start_group_replication.inc
SET @@GLOBAL.DEBUG='+d,block_applier_updates';

############################################################
#  3. Block applier on server 1 to force the delayed
#     View_change_log_event log to binary log.
[connection server1]
SET @@GLOBAL.DEBUG='+d,block_applier_updates';

############################################################
#  4. Execute a transaction on server2.
[connection server2]
INSERT INTO t1 VALUES (2);

############################################################
#  5. Start Group Replication on server3.
#     It will recover from server2 and will stay on
#     RECOVERING state since server2 has applier stopped.
[connection server3]
SET SESSION sql_log_bin= 0;
CREATE TABLE t1 (c1 INT NOT NULL PRIMARY KEY) ENGINE=InnoDB;
call mtr.add_suppression("There was an error when connecting to the donor server.*");
call mtr.add_suppression("For details please check performance_schema.replication_connection_status table and error log messages of Replica I/O for channel group_replication_recovery.");
CREATE USER "recovery_user" IDENTIFIED BY "recovery_password";
GRANT GROUP_REPLICATION_STREAM ON *.* TO "recovery_user";
FLUSH PRIVILEGES;
SET SESSION sql_log_bin= 1;
CHANGE REPLICATION SOURCE TO SOURCE_USER= 'recovery_user', SOURCE_PASSWORD= 'recovery_password' FOR CHANNEL 'group_replication_recovery';
SET @group_replication_recovery_reconnect_interval_saved= @@GLOBAL.group_replication_recovery_reconnect_interval;
SET GLOBAL group_replication_recovery_reconnect_interval= 1;
SET GLOBAL debug= '+d,group_replication_skip_read_mode';
include/start_group_replication.inc

############################################################
#  6. Setup recovery user on server1 so that server3 can
#     failover to it after server2 failure.
[connection server1]
SET SESSION sql_log_bin= 0;
CREATE USER "recovery_user" IDENTIFIED BY "recovery_password";
GRANT REPLICATION SLAVE ON *.* TO "recovery_user";
FLUSH PRIVILEGES;
SET SESSION sql_log_bin= 1;

############################################################
#  7. server2 will leave the group and remove recovery user
#     to force a server3 to failover recovery to server1.
[connection server2]
SET DEBUG_SYNC = "now WAIT_FOR applier_read_blocked";
SET @@GLOBAL.DEBUG='-d,block_applier_updates';
SET @@GLOBAL.DEBUG='+d,force_sql_thread_error';
SET DEBUG_SYNC = "now SIGNAL resume_applier_read";
include/gr_wait_for_member_state.inc
SET @@GLOBAL.DEBUG='-d,force_sql_thread_error';
include/stop_group_replication.inc
include/stop_dump_threads.inc
SET SESSION sql_log_bin= 0;
DROP USER "recovery_user";
FLUSH PRIVILEGES;
DROP TABLE t1;
SET SESSION sql_log_bin= 1;

############################################################
#  8. server3 recovery process will failover to server1.
[connection server3]
include/gr_wait_for_member_state.inc

############################################################
#  9. Execute 1 transaction on server1 while server3 is on
#     RECOVERING.
[connection server1]
INSERT INTO t1 VALUES (1);
include/assert_binlog_events.inc [Gtid # Query/BEGIN # View_change # Query/COMMIT # Gtid # Query/BEGIN # View_change # Query/COMMIT # !Gtid_transaction]

############################################################
# 10. Server 3 will apply INSERT (1) through recovery.
[connection server3]
include/assert_binlog_events.inc [Gtid # Query/BEGIN # View_change # Query/COMMIT # Gtid # Query/BEGIN # View_change # Query/COMMIT # !Gtid_transaction # !Gtid_transaction]
include/assert.inc ['There is a value 1 in table t1']
include/assert.inc ['There is a value 2 in table t1']

############################################################
# 11. Resume applier on server1.
#     Server3 state will change to ONLINE.
[connection server1]
SET DEBUG_SYNC = "now WAIT_FOR applier_read_blocked";
SET @@GLOBAL.DEBUG='-d,block_applier_updates';
SET DEBUG_SYNC = "now SIGNAL resume_applier_read";
[connection server3]
include/gr_wait_for_member_state.inc

############################################################
# 12. Sync all group members.
[connection server1]
include/assert_binlog_events.inc [Gtid # Query/BEGIN # View_change # Query/COMMIT # Gtid # Query/BEGIN # View_change # Query/COMMIT # !Gtid_transaction # !Gtid_transaction # Gtid # Query/BEGIN # View_change # Query/COMMIT]
[connection server3]
include/assert_binlog_events.inc [Gtid # Query/BEGIN # View_change # Query/COMMIT # Gtid # Query/BEGIN # View_change # Query/COMMIT # !Gtid_transaction # !Gtid_transaction # Gtid # Query/BEGIN # View_change # Query/COMMIT]

############################################################
# 13. Execute more transactions on all members.
#     Transaction on server3 will validate the
#     group_replication_gtid_assignment_block_size option.
[connection server1]
INSERT INTO t1 VALUES (11);
[connection server3]
INSERT INTO t1 VALUES (33);
include/rpl_sync.inc

############################################################
# 14. Sync all group members.
[connection server1]
include/assert.inc [GTID_EXECUTED must contain all committed GTIDs]
include/assert.inc ['There are 4 values in table t1']
[connection server3]
include/assert.inc [GTID_EXECUTED must contain all committed GTIDs]
include/assert.inc ['There are 4 values in table t1']

############################################################
# 15. Clean up.
[connection server1]
SET DEBUG_SYNC= 'RESET';
DROP TABLE t1;
SET SESSION sql_log_bin= 0;
DROP USER "recovery_user";
SET SESSION sql_log_bin= 1;
[connection server2]
SET DEBUG_SYNC= 'RESET';
SET SESSION sql_log_bin = 0;
call mtr.add_suppression("Replica SQL for channel 'group_replication_applier': Relay log read failure: Could not parse relay log event entry.*");
call mtr.add_suppression("The applier thread execution was aborted. Unable to process more transactions, this member will now leave the group.");
call mtr.add_suppression("Fatal error during execution on the Applier process of Group Replication. The server will now leave the group.");
call mtr.add_suppression("The server was automatically set into read only mode after an error was detected.");
call mtr.add_suppression("Skipping leave operation: concurrent attempt to leave the group is on-going.");
SET SESSION sql_log_bin = 1;
[connection server3]
SET @@GLOBAL.group_replication_recovery_reconnect_interval= @group_replication_recovery_reconnect_interval_saved;
SET GLOBAL debug= '-d,group_replication_skip_read_mode';
SET SESSION sql_log_bin= 0;
DROP USER "recovery_user";
SET SESSION sql_log_bin= 1;
include/group_replication_end.inc
