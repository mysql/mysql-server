###############################################################################
#
# When the group is in **multi-primary** mode and the user causes a
# change to **single-primary** mode the group must:
# - 1: Elect a primary. If one is selected by the user, that member must be chosen.
# - 2: The primary shall be writable after processing the current backlog
# - 3: Secondaries shall enable the server super_read_only mode.
# - 4: Update everywhere checks is set to False but only after all
#      transactions from the old primary are applied.
#
#
# Test:
#
#   0. This test needs two servers started in multi primary mode
#   1. Create table to use on test
#   2. Lock table on server2 to monitor
#      group_replication_enforce_update_everywhere_checks
#   3. Push data to server1. It won't be committed on server2 due to the lock
#      on table
#   4. Execute action switch to single primary mode, with server2 as primary
#      member
#   5. Confirm stages on server2
#   6. Since server2 has table t1 locked the values aren't committed, so
#      group_replication_enforce_update_everywhere_checks is enabled
#   7. Unlock table on server2
#   8. On primary member the super_read_only shall be disable
#   9. Confirm server2 is the group primary member.
#   10. server2 after update all queued transactions will disable
#      group_replication_enforce_update_everywhere_checks
#   11. The secondary member shall have the super_read_only enable
#   12. Cleanup
#
###############################################################################

--source include/have_group_replication_plugin.inc
--source include/group_replication.inc

--echo
--echo # 1. Create table to use on test

CREATE TABLE test.t1 (a INT PRIMARY KEY);

--source include/rpl_sync.inc

--let $rpl_connection_name= server2
--source include/rpl_connection.inc

--echo
--echo # 2. Lock table on server2 to monitor
--echo #    group_replication_enforce_update_everywhere_checks

LOCK TABLE t1 WRITE;

--let $server2_uuid= query_get_value(SELECT @@SERVER_UUID, @@SERVER_UUID, 1)

--echo
--echo # 3. Push data to server1.
--echo #    It won't be committed on server2 due to the lock on the table

--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--eval INSERT INTO t1 VALUES (1)
--eval INSERT INTO t1 VALUES (2)
--eval INSERT INTO t1 VALUES (3)

--echo
--echo # 4. Execute action switch to single primary mode,
--echo #    with server2 as primary member

--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--replace_result $server2_uuid MEMBER2_UUID
--send_eval SELECT group_replication_switch_to_single_primary_mode("$server2_uuid")

--echo
--echo # 5. Confirm stages on server2

--let $rpl_connection_name= server2
--source include/rpl_connection.inc

--let $wait_condition=SELECT COUNT(*)=1 FROM performance_schema.events_stages_current WHERE event_name LIKE "%Primary Election: stabilizing transactions%"
--source include/wait_condition.inc

--let $stage_name= `SELECT event_name FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl/Single-primary%";`
--let $assert_text= stage/group_rpl/Single-primary Switch: executing Primary election
--let $assert_cond= "$stage_name" = "stage/group_rpl/Single-primary Switch: executing Primary election"
--source include/assert.inc

--let $stage_name= `SELECT event_name FROM performance_schema.events_stages_current WHERE event_name LIKE "%stage/group_rpl/Primary Election%";`
--let $assert_text= stage/group_rpl/Primary Election: stabilizing transactions from former primaries
--let $assert_cond= "$stage_name" = "stage/group_rpl/Primary Election: stabilizing transactions from former primaries"
--source include/assert.inc

--echo
--echo # 6. Since server2 has table t1 locked, the values aren't committed, so
--echo #    group_replication_enforce_update_everywhere_checks is enabled

--let $assert_text= group_replication_enforce_update_everywhere_checks is ON
--let $assert_cond= "[SELECT @@GLOBAL.group_replication_enforce_update_everywhere_checks]" = "1"
--source include/assert.inc

--echo
--echo # 7. Unlock table on server2

UNLOCK TABLES;

--echo
--echo # 8. On primary member the super_read_only shall be disable

--let $assert_text= The super_read_only mode should be 0 here.
--let $assert_cond= "[SELECT @@GLOBAL.super_read_only]" = 0;
--source include/assert.inc

--echo
--echo # 9. Confirm server2 is the group primary member.

--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--replace_result $server2_uuid MEMBER2_UUID
--reap

--let $rpl_connection_name= server2
--source include/rpl_connection.inc

--echo
--echo # 10. server2 after update all queued transactions will disable
--echo #    group_replication_enforce_update_everywhere_checks

--let $group_replication_expected_uuid=$server2_uuid
--source include/gr_assert_primary_member.inc

--echo
--echo # 11. The secondary member shall have the super_read_only enable

--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--source include/gr_assert_secondary_member.inc

--echo
--echo # 12. Cleanup

--let $rpl_connection_name= server2
--source include/rpl_connection.inc

DROP TABLE t1;

--let $rpl_group_replication_single_primary_mode=1
--let $rpl_group_replication_reset_persistent_vars=1
--source include/group_replication_end.inc
