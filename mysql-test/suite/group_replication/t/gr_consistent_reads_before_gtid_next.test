################################################################################
# Validate that transactions run with group_replication_consistency= 'BEFORE' are
# not affected by group GTIDs set manually on GTID_NEXT that concurrently were
# used by other transactions.
#
# When using `group_replication_consistency=BEFORE`, a user client
# ensures that all transactions that were accepted by the group when
# the transaction started, get committed before it starts. To achieve
# that, it broadcasts a message to the group, waits for it to be
# received, reads `RECEIVED_TRANSACTION_SET` from
# `group_replication_applier` channel, and waits for all those
# transactions in `RECEIVED_TRANSACTION_SET` to be committed, i.e.,
# included in `GTID_EXECUTED`.
# Only transactions originating on other members will go through the
# applier pipeline. Transactions originating on the current member will
# therefore not be added to `RECEIVED_TRANSACTION_SET` the usual way.
# That leads to gaps in the GTID sequence. To prevent the number of
# gaps from growing indefinitely, `RECEIVED_TRANSACTION_SET` on the
# `group_replication_applier` channel is updated periodically by
# adding `GTID_EXECUTED` to it.
# The statement `SET gtid_next=GTID` adds the GTID to `gtid_owned`. It
# is controlled in a mutually exclusive manner within the same server,
# so that two concurrent clients on the same server cannot execute
# `SET gtid_next=GTID` concurrently and with the same GTID. However,
# in Group Replication, the statement may succeed and a transaction
# execute with `gtid_next` set to a GTID that is concurrently used by
# a transaction executing on another member. In this case, it is
# possible for both transactions to reach commit. The first
# transaction that is first in the total order will commit and the
# second one has to rollback.
# The commit pipeline executes in the following order: (1) add GTID to
# gtid_owned; (2) write binlog; (3) commit; (4) atomically add GTID to
# gtid_executed and remove GTID from gtid_owned. Therefore a a GTID to
# be committed only needs to wait to be addted to gtid_executed.
#
# The following scenario can happen:
# - Client 1 on member 1 issues SET gtid_next = X, where X uses the
#   group_replication_group_name for the UUID.
# - Client 2 on member 1 commits a transaction that auto-generates
#   GTID X.
# - Client 3 on member 1 begins a transaction while having
#   group_replication_consistency=BEFORE or BEFORE_AND_AFTER.
# Now, Client 3 will (after broadcasting and receiving a message),
# read `RECEIVED_TRANSACTION_SET`, which includes X. Then it waits for
# X to be committed. The wait will observe that X is in gtid_executed
# already. However, it will also wait for X to be removed from
# gtid_owned. That will not happen, since client 1 holds ownership,
# and the wait function waits for ownership to be released.
#
# To avoid the above issue, the waiting condition was modified to not
# consider owned GTIDs, that is, only committed transactions are
# accounted.
# With the exception that if the executing session owns a GTID that
# was concurrently committed, the transaction execution will error
# out.
#
# Test:
# 00. The test requires two servers: M1 and M2.
# 01. Create a table on the group.
# 02. Use the next GTID generated by the group on GTID_NEXT.
#     The GTID will be UUID:4.
# 03. Commit a transaction on the group that will be logged
#     with GTID UUID:4.
# 04. Wait until `received_transaction_set` from
#     is updated with the GTID_EXECUTED set.
# 05. Perform a consistent read.
#     The read will not be blocked by the GTID_NEXT set on session server1.
# 06. Clean up.
################################################################################

--source include/big_test.inc
--source include/have_group_replication_plugin.inc
--source include/group_replication.inc

--echo
--echo ############################################################
--echo # 01. Create a table on the group.
--let $rpl_connection_name= server1
--source include/connection.inc
CREATE TABLE t1 (c1 INT NOT NULL PRIMARY KEY);


--echo
--echo ############################################################
--echo # 02. Use the next GTID generated by the group on GTID_NEXT.
--echo #     The GTID will be UUID:2.
--let $assert_text= GTID_EXECUTED is UUID:1
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$group_replication_group_name:1"
--source include/assert.inc

--replace_result $group_replication_group_name GROUP_NAME
--eval SET @@SESSION.GTID_NEXT= "$group_replication_group_name:4"


--echo
--echo ############################################################
--echo # 03. Commit a transaction on the group that will be logged
--echo #     with GTID UUID:3.
--let $rpl_connection_name= server_1
--source include/connection.inc
INSERT INTO t1 VALUES (1);

--let $assert_text= GTID_EXECUTED is UUID:1-2
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$group_replication_group_name:1-2"
--source include/assert.inc


--echo
--echo ############################################################
--echo # 04. Wait until `received_transaction_set` from
--echo #     is updated with the GTID_EXECUTED set.
--let $wait_condition= SELECT received_transaction_set="$group_replication_group_name:1-2" FROM performance_schema.replication_connection_status WHERE channel_name="group_replication_applier";
--source include/wait_condition.inc


--echo
--echo ############################################################
--echo # 05. Perform a consistent read.
--echo #     The read will not be blocked by the GTID_NEXT set on session server1.
SET @@SESSION.group_replication_consistency= 'BEFORE';
SELECT * FROM t1;


--echo
--echo ############################################################
--echo # 06. Clean up.
--let $rpl_connection_name= server_1
--source include/connection.inc
SET @@SESSION.group_replication_consistency= DEFAULT;

--let $rpl_connection_name= server1
--source include/connection.inc
ROLLBACK;
SET @@SESSION.GTID_NEXT= "AUTOMATIC";

DROP TABLE t1;

--source include/group_replication_end.inc
