# ==== Purpose ====
#
# Test timestamps generated by writeset dependency tracking algorithm and
# with binlog_transaction_dependency_history_size= 1 (which fallbacks to
# commit order dependency tracking algorithm).
#
# The following properties are tested:
# - With binlog_transaction_dependency_history_size=DEFAULT, the logical timestamps
#   are generated as expected, marking each transaction as conflicting with
#   transactions having intersecting writesets.
#   (type = 0)
# - With binlog_transaction_dependency_history_size= 1, which fallback to COMMIT_ORDER.
#   (type = 1)
# - Additionally, transactions are marked as conflicting with any DDL.
#   (step = 2)
# - Additionally, transactions are marked as conflicting if one appears before
#   and the other after a binlog rotation.
#   (step = 3)
# - Additionally, transactions are marked as conflicting if the writeset history
#   was cleared between the transactions.
#   (step = 4)
#
# - It tests this for INSERT, UPDATE and DELETE statements.
#
# ==== Implementation ====
#
# 1. Apply 8 transactions with different data dependencies and check the binary
#    log generated (step 1). Do the same with DDL in the middle (step 2), with
#    rotation (step 3) and when writeset history becomes full (step 4).
#
# 2. Test ROLLBACK TO SAVEPOINT.
#
# ==== References ====
#
# WL#9556: Writeset-based MTS dependency tracking on master
#

--source include/rpl/init_source_replica.inc
--source include/have_binlog_format_row.inc

--echo #### INITIALIZE ####

--connection slave
call mtr.add_suppression("Transaction is tagged with inconsistent logical timestamps");
call mtr.add_suppression("Cannot execute the current event group in the parallel mode.");

--source include/rpl/stop_replica.inc

SET @save_replica_parallel_type = @@GLOBAL.replica_parallel_type;
SET @save_replica_parallel_workers = @@GLOBAL.replica_parallel_workers;
SET @save_replica_transaction_retries = @@GLOBAL.replica_transaction_retries;

SET GLOBAL replica_parallel_type = LOGICAL_CLOCK;
SET GLOBAL replica_parallel_workers = 3;
SET GLOBAL replica_transaction_retries = 0;

--connection master

SET @save_binlog_transaction_dependency_history_size = @@GLOBAL.binlog_transaction_dependency_history_size;

CREATE TABLE tests (`id` INT NOT NULL, `description` VARCHAR(50), `results` VARCHAR(100), PRIMARY KEY(`id`));
INSERT INTO `tests` (`id`, `description`, `results`) VALUES
(1,  'Writeset',                  '0 1;1 2;1 3;1 4;3 5;3 6;4 7;7 8;6 9;9 10'),
(2,  'Writeset+DDL',              '0 1;1 2;1 3;1 4;4 5;5 6;6 7;7 8;4 9;7 10;10 11;9 12;12 13'),
(3,  'Writeset+rotation',         '0 1;0 2;1 3;3 4;2 5;5 6'),
(4,  'Writeset+history',          '0 1;1 2;1 3;1 4;4 5;4 6;6 7;7 8;6 9;9 10'),
(5,  'Commit_order',              '0 1;1 2;1 3;3 4;4 5;4 6;6 7;7 8;7 9;9 10'),
(6,  'Commit_order+DDL',          '0 1;1 2;1 3;3 4;4 5;5 6;6 7;7 8;4 9;9 10;10 11;10 12;12 13'),
(7,  'Commit_order+rotation',     '0 1;0 2;2 3;3 4;3 5;5 6'),
(8,  'Commit_order+history',      '0 1;1 2;1 3;3 4;4 5;4 6;6 7;7 8;7 9;9 10');

# flush logs to clear previous transactions
FLUSH LOGS;

--let $idx= 0

--echo #### TEST ####

# loop between WRITESET and WRITESET with binlog_transaction_dependency_history_size= 1
--let $type= 0
while ($type < 2)
{
  --inc $type

  --connection master
  if ($type == 1)
  {
    SET GLOBAL binlog_transaction_dependency_history_size= DEFAULT;
    --echo ######## 1. WRITESET ########
  }
  if ($type == 2)
  {
    SET GLOBAL binlog_transaction_dependency_history_size= 1;
    --echo ######## 2. WRITESET with binlog_transaction_dependency_history_size= 1 ########
  }

  # loop between steps
  --let $step= 0
  while ($step < 4)
  {
    --inc $step
    --inc $idx

    --let $testname=`SELECT description FROM tests WHERE id=$idx`
    --echo #### STEP $type.$step TEST $testname ####

    if ($step == 4)
    {
      if ($type == 1)
      {
        --echo History size reduced to 5 to test when it becomes full
        SET GLOBAL binlog_transaction_dependency_history_size=5;
      }
    }

    SELECT @@binlog_transaction_dependency_history_size;

    CREATE TABLE `t1` (`id` int(11) NOT NULL, `val` int(11) NOT NULL,
      PRIMARY KEY (`id`)) ENGINE=InnoDB;

    --connection master
    --echo #TRX2 (session A, independent)
    BEGIN;
    INSERT INTO t1(id, val) VALUES (1, 0),(2, 0),(3, 0);

    --connection master1
    --echo #TRX1 (session B, independent)
    BEGIN;
      INSERT INTO t1(id, val) VALUES (4, 0),(5, 0);
    COMMIT;

    --connection master
    --echo finish TRX2 after TRX1
    COMMIT;

    --connection master1
    --echo #TRX3 (session B, no data dependency, depends on TRX1 (session))
    BEGIN;
      INSERT INTO t1(id, val) VALUES (6, 0),(7, 0);
    COMMIT;

    --connection master
    --echo #TRX5 (session A, depends on TRX2 (session and data) and TRX1(data))
    BEGIN;
      INSERT INTO t1(id, val) VALUES (8, 1);
      UPDATE t1 SET val=val+1 WHERE id=1;
      UPDATE t1 SET val=val+1 WHERE id=4;

    if ($step == 2)
    {
      --connection master1
      --echo Inserted a DDL after TRX5 and check that they run in parallel due to commit_order
      CREATE TABLE `t2` (`id` int(11) NOT NULL, `val` int(11) NOT NULL) ENGINE=InnoDB;
      ALTER TABLE t2 ADD COLUMN b INT;
      DROP TABLE `t2`;
    }

    # flush logs in the middle
    if ($step == 3)
    {
      --connection master1
      --echo Flushing logs in the middle of the set
      FLUSH LOGS;
    }

    --connection server_1
    --echo #TRX4 (session C, depends on TRX2 (data))
    BEGIN;
      UPDATE t1 SET val=val+1 WHERE id=3;
      INSERT INTO t1(id, val) VALUES (9, 1);
    COMMIT;

    --connection master
    --echo finish TRX5 after TRX4
    COMMIT;

    --connection server_1
    --echo #TRX6 (session C, depends on TRX4 (session) and TRX3(data))
    BEGIN;
      DELETE FROM t1 WHERE id=6;
    COMMIT;

    --connection server_1
    --echo #TRX8 (session C, depends on TRX5 (data) and TRX6 (session))
    BEGIN;
      UPDATE t1 SET val=val+1 WHERE id=4;

    --connection master1
    --echo #TRX7 (session B, depends on TRX1 and TRX6 (data) and TRX3 (session))
    BEGIN;
      UPDATE t1 SET val=val+1 WHERE id=5;
      INSERT INTO t1(id, val) VALUES (6, 0);
    COMMIT;

    --connection server_1
    --echo finish TRX8 after TRX7
    COMMIT;

    --connection master
    --echo Drop table and flush logs to force binlog to rotate
    DROP TABLE t1;

    --let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
    --echo Processing binlog $binlog_file
    FLUSH LOGS;

    --let $source_file= $server_1_datadir/$binlog_file
    --let $logical_timestamps=`SELECT results FROM tests WHERE id=$idx`
    --source include/rpl/assert_logical_timestamps.inc
  }
}

--echo
--echo #### Verify that replication was correct ####

--connection slave
--source include/rpl/start_replica.inc

--connection master
--source include/rpl/sync_to_replica.inc

--let $diff_tables= master:test.tests, slave:test.tests
--source include/diff_tables.inc

--connection master
DROP TABLE `tests`;
--source include/rpl/sync_to_replica.inc

--connection master
SET GLOBAL binlog_transaction_dependency_history_size= DEFAULT;
FLUSH LOGS;


--echo
--echo #### Bug#26277771, PART1 ####
# Bug#26277771 original issue due to missing collation in generating hashes
CREATE TABLE t1 (c1 int(10) NOT NULL, c2 varchar(20) NOT NULL, PRIMARY KEY (c1),
                 UNIQUE KEY (c1, c2)) ENGINE=InnoDB DEFAULT CHARSET=latin1; # 0 1
INSERT INTO t1 VALUES (1, 'a'); # 1 2
DELETE FROM t1 WHERE c1=1 AND c2='a'; # 2 3
INSERT INTO t1 VALUES (1, 'A'); # 3 4
--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
-- echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;2 3;3 4
--source include/rpl/assert_logical_timestamps.inc
DROP TABLE t1;
FLUSH LOGS;

--echo
--echo #### Bug#26277771, PART2 ####
# Bug#26277771 issue due to wrong string length calculation
CREATE TABLE t1 (c1 VARCHAR(20) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin NOT NULL PRIMARY KEY); # 0 1
INSERT INTO t1 VALUES ('a'); # 1 2
INSERT INTO t1 VALUES ('A'); # 1 3
INSERT INTO t1 VALUES ('b'); # 1 4
INSERT INTO t1 VALUES ('B'); # 1 5
--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
-- echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;1 3;1 4;1 5
--source include/rpl/assert_logical_timestamps.inc
DROP TABLE t1;
FLUSH LOGS;

--echo
--echo #### Bug#26277771, PART3 ####
# test for unset charset, padding and null terminaton
CREATE TABLE t1 (c1 VARCHAR(20) NOT NULL PRIMARY KEY); # 0 1
INSERT INTO t1 VALUES ('a'); # 1 2
INSERT INTO t1 VALUES ('b'); # 1 3

CREATE TABLE t2 (c1 BINARY(3) NOT NULL PRIMARY KEY); # 3 4
INSERT INTO t2 VALUES ('a'); # 4 5
# copy using strmake will generate same hash for '\0a' and '\0'
# as it was copying till null termination character and binary
# doesn't consider null as temination character.
INSERT INTO t2 VALUES ('\0a'); # 4 6
INSERT INTO t2 VALUES ('\0'); # 4 7
INSERT INTO t2 VALUES ('a '); # 4 8

--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
-- echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;1 3;3 4;4 5;4 6;4 7;4 8
--source include/rpl/assert_logical_timestamps.inc
DROP TABLE t1;
DROP TABLE t2;
FLUSH LOGS;

--echo
--echo #### Bug#26277771, PART4 ####
CREATE TABLE t1 (c1 varchar(20) NOT NULL PRIMARY KEY)
ENGINE=InnoDB CHARACTER SET utf8mb3 COLLATE utf8mb3_bin; # 0 1
INSERT INTO t1 VALUES ('a'); # 1 2
INSERT INTO t1 VALUES ('รก'); # 1 3
--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
--echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;1 3
--source include/rpl/assert_logical_timestamps.inc
DROP TABLE t1;
FLUSH LOGS;


#
# Test ROLLBACK TO SAVEPOINT. The rolled-back rows will still have their
# hashes in the writeset and may cause spurious conflicts.
#
--echo
-- echo #### Test ROLLBACK TO SAVEPOINT ####
CREATE TABLE t1 (a INT PRIMARY KEY);
CREATE TABLE nopk (a INT);
CREATE TABLE parent (a INT PRIMARY KEY);
CREATE TABLE child (a INT PRIMARY KEY, FOREIGN KEY (a) REFERENCES parent(a));

--echo # 1. Hashes of rolled-back rows are removed from writeset
FLUSH LOGS;
INSERT INTO t1 VALUES (1);
BEGIN;
  SAVEPOINT sp;
    UPDATE t1 SET a = 2;
  ROLLBACK TO sp;
  INSERT INTO t1 VALUES (2);
COMMIT;
INSERT INTO t1 VALUES (3);

--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
--echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;1 3
--source include/rpl/assert_logical_timestamps.inc

--echo # 2. If transaction is flagged as updating a non-index table, the flag is not rolled-back
FLUSH LOGS;
INSERT INTO t1 VALUES (4);
BEGIN;
  SAVEPOINT sp;
    INSERT INTO nopk VALUES (1);
  ROLLBACK TO sp;
  INSERT INTO t1 VALUES (5);
COMMIT;
INSERT INTO t1 VALUES (6);

--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
--echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;1 3
--source include/rpl/assert_logical_timestamps.inc

--echo # 3. If transaction is flagged as updating a foreign key parent table, the flag is not rolled-back
FLUSH LOGS;
INSERT INTO t1 VALUES (7);
BEGIN;
  SAVEPOINT sp;
    INSERT INTO parent VALUES (1);
  ROLLBACK TO sp;
  INSERT INTO t1 VALUES (8);
COMMIT;
INSERT INTO t1 VALUES (9);

--let $binlog_file= query_get_value(SHOW BINARY LOG STATUS, File, 1)
--echo Processing binlog $binlog_file
--let $source_file= $server_1_datadir/$binlog_file
--let $logical_timestamps=0 1;1 2;2 3
--source include/rpl/assert_logical_timestamps.inc

--echo # Clean up SAVEPOINT tests
DROP TABLE t1;
DROP TABLE nopk;
DROP TABLE child;
DROP TABLE parent;

#
# Cleanup
#
--echo
--echo #### CLEANUP ####

--source include/rpl/sync_to_replica.inc
--source include/rpl/stop_replica.inc

SET @@GLOBAL.replica_parallel_type= @save_replica_parallel_type;
--disable_warnings
SET @@GLOBAL.replica_parallel_workers= @save_replica_parallel_workers;
--enable_warnings
SET @@GLOBAL.replica_transaction_retries= @save_replica_transaction_retries;

--source include/rpl/start_replica.inc

--connection master
SET @@GLOBAL.binlog_transaction_dependency_history_size= @save_binlog_transaction_dependency_history_size;

--source include/rpl/deinit.inc

