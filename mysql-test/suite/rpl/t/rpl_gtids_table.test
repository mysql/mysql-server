#
# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
#

# ==== Purpose ====
#
# WL#6559 Optimize GTIDs for passive slave - store GTIDs in table
#
# Verify that we can store gtids into gtid_executed table for transactions
# and report GLOBAL.GTID_EXECUTED and GLOBAL.GTID_PURGED correctly on
# master and slave when binlog is enabled.
#

--source include/master-slave.inc
--source include/have_gtid.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
#--source include/have_binlog_format_row.inc

call mtr.add_suppression("test the suppression statement");
--let $master_uuid= `SELECT @@GLOBAL.SERVER_UUID`
SHOW CREATE TABLE mysql.gtid_executed;

--echo # Verify that the specified gtid to GTID_NEXT is stored into
--echo # gtid table and can be reported from global.gtid_executed.
--replace_result $master_uuid MASTER_UUID
--eval SET GTID_NEXT='$master_uuid:3'
BEGIN;
COMMIT;
--echo # Stored gtids MASTER_UUID:1:3 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1:3
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1:3"
--source include/assert.inc

--eval SET GTID_NEXT='AUTOMATIC'
--echo # Verify that these gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed for normal DDLs.
CREATE TABLE IF NOT EXISTS t1 (a int) engine=Innodb;
CREATE TABLE t2 (a int) engine=myisam;
--echo # Stored gtids MASTER_UUID:1-4 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-4
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-4"
--source include/assert.inc

--echo # Verify that these gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed for compound statement with
--echo # regular and temporary tables.
CREATE TEMPORARY TABLE tmp1 (c1 INT) Engine=MyISAM;
CREATE TABLE t3 (a int);
if (`SELECT @@BINLOG_FORMAT = 'ROW'`)
{
  # We did not generate gtid for above 'CREATE TEMPORARY TABLE' statement
  # in row format, but we did in statement format. So let the 'INSERT'
  # statement generate the missed gtid in row format.
  --disable_query_log
  INSERT INTO t3 values(1);
  --enable_query_log
}
--error ER_BAD_TABLE_ERROR
DROP TEMPORARY TABLE tmp1, t3;
DROP TABLE t3;
--echo # Stored gtids MASTER_UUID:1-8 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-8
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-8"
--source include/assert.inc

--echo # Verify that transactions' gtids are stored into gtid table and can be
--echo # reported from global.gtid_executed correctly.
INSERT INTO t2 values(1);
BEGIN;
INSERT INTO t2 values(2);
INSERT INTO t1 values(1);
INSERT INTO t1 values(2);
COMMIT;
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc

--echo # Verify that transaction's gtid is not stored into gtid table
--echo # if the transaction is rollbacked.
BEGIN;
INSERT INTO t1 values(4);
ROLLBACK;
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc


--echo # Verify that transaction's gtid is not stored into gtid table
--echo # if the transaction is rollbacked due to prepare error.
SET SESSION debug="+d,simulate_prepare_error";
INSERT INTO t1 values(5);
SET SESSION debug="-d,simulate_prepare_error";
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on master
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc


--sync_slave_with_master
--echo connection slave
--let $slave_uuid= `SELECT @@GLOBAL.SERVER_UUID`
#call mtr.add_suppression("You need to use --log-bin to make --binlog-format work");

--echo # Verify that the transaction is skiped if its specified gtid
--echo # is already in gtid table.
--replace_result $master_uuid MASTER_UUID
--eval SET @@SESSION.GTID_NEXT= '$master_uuid:6'
INSERT INTO t1 values(11);
--echo # Stored gtids MASTER_UUID:1-11 in gtid_executed table on slave
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11"
--source include/assert.inc

--echo # Verify that the specified gtid to GTID_NEXT is stored into
--echo # gtid table.
--replace_result $master_uuid MASTER_UUID
--eval SET @@SESSION.GTID_NEXT= '$master_uuid:17'
COMMIT;
--echo # Stored gtids MASTER_UUID:1-11:17 in gtid_executed table on slave
--replace_result $master_uuid MASTER_UUID
SELECT * FROM mysql.gtid_executed;
--let $assert_text= committed gtids MASTER_UUID:1-11:17
--let $assert_cond= "[SELECT @@GLOBAL.GTID_EXECUTED]" = "$master_uuid:1-11:17"
--source include/assert.inc

--eval SET GTID_NEXT='AUTOMATIC'
FLUSH LOGS;
--let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--echo # Verify that we can get the correct set of gtid_purged
--echo # when purging logs.
--eval PURGE BINARY LOGS TO '$binlog_file'
--let $assert_text= purged gtids MASTER_UUID:1-11:17
--let $assert_cond= "[SELECT @@GLOBAL.GTID_PURGED]" = "$master_uuid:1-11:17"
--source include/assert.inc

--echo # Verify that transaction's gtid generated on slave is stored
--echo # into gtid table.
BEGIN;
INSERT INTO t1 values(12);
COMMIT;
--echo # Stored gtids MASTER_UUID:1-11:17 and SLAVE_UUID:1
--echo # in gtid_executed table on slave.
--replace_result $master_uuid MASTER_UUID
--eval SELECT * FROM mysql.gtid_executed where sid="$master_uuid"
--replace_result $slave_uuid SLAVE_UUID
--eval SELECT * FROM mysql.gtid_executed where sid="$slave_uuid"

--connection master
DROP TABLE t1, t2;
--sync_slave_with_master
--source include/rpl_end.inc
