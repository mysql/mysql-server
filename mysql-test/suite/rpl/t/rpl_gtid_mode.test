# ==== Purpose ====
#
# Test replication errors that depend on GTID_MODE.
#
# The following classes of errors are tested:
#
# - Errors generated when the server starts.
#   - GTID_MODE and ENFORCE_GTID_CONSISTENCY are incompatible.
#   - todo: GTID_MODE and AUTO_POSITION are incompatible.
# - Errors generated by the master in the replication protocol
#   handshake.
#   - todo: GTID_MODE on master is incompatible with AUTO_POSITION.
# - Errors generated by the slave in the replication protocol
#   handshake.
#   - GTID_MODE on master and slave are incompatible.
#   - GTID_MODE on master is incompatible with AUTO_POSITION.
#   - GTID_MODE on slave is incompatibale with AUTO_POSITION.
#   - Slave receiver thread can not start in AUTO_POSITION mode because
#     slave has GTID-MODE = OFF.
# - Errors generated by a running sender thread.
#   - Cannot replicate GTID-transaction when GTID_MODE = OFF.
#   - Cannot replicate anonymous transaction when GTID_MODE = ON.
#   - Cannot replicate anonymous transaction when AUTO_POSITION = 1.
# - Errors generated by a running receiver thread.
#   - Cannot replicate GTID-transaction when GTID_MODE = OFF.
#   - Cannot replicate anonymous transaction when GTID_MODE = ON.
#   - Cannot replicate anonymous transaction when AUTO_POSITION = 1.
# - GTID_NEXT cannot be set to ANONYMOUS when @@GLOBAL.GTID_MODE = ON.
# - Errors when rotate fails while setting gtid_mode.
#
# ==== References ====
#
# WL#3584: Global Transaction Identifiers
# - Added in this worklog
# WL#7083: GTIDs: Set GTID_MODE=ON online
# - Rewrote the test.

--source include/have_debug_sync.inc
--source include/have_debug.inc
# include/assert_command_output.inc doesn't work for mysqld on windows
--source include/not_windows.inc
--source include/not_group_replication_plugin.inc
--source include/not_gtid_enabled.inc
--let $rpl_gtid_utils= 1
--source include/master-slave.inc

--echo ==== Initialize ====

call mtr.add_suppression("Slave I/O for channel '': The replication receiver thread cannot start");
call mtr.add_suppression("Slave I/O for channel '': The slave IO thread stops");
call mtr.add_suppression("Slave I/O for channel '': Got fatal error 1236 from master when reading data from binary log: 'Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF");
call mtr.add_suppression("Slave I/O for channel '': Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF");
call mtr.add_suppression("GTID_LOG_EVENT or ANONYMOUS_GTID_LOG_EVENT is not expected in an event stream after a GTID_LOG_EVENT or an ANONYMOUS_GTID_LOG_EVENT.");
call mtr.add_suppression("An unexpected event sequence was detected by the IO thread while queuing the event received from master");
call mtr.add_suppression("Detected misconfiguration: replication channel '' was configured with AUTO_POSITION = 1, but the server was started with --gtid-mode=off.");
call mtr.add_suppression("Slave I/O for channel '': Relay log write failure: could not queue event from master");
call mtr.add_suppression("Got fatal error 1236 from master when reading data from binary log: 'Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON");
call mtr.add_suppression("Slave I/O for channel '': Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON");
call mtr.add_suppression("Slave I/O for channel '': Cannot replicate anonymous transaction when AUTO_POSITION = 1");
call mtr.add_suppression("Got fatal error 1236 from master when reading data from binary log: 'Cannot replicate anonymous transaction when AUTO_POSITION = 1,");
call mtr.add_suppression("Slave I/O for channel '': The master uses an unknown GTID_MODE 'on_something'. Treating it as 'ON'.");
call mtr.add_suppression("Slave I/O for channel '': The master uses an unknown GTID_MODE 'off_something'. Treating it as 'OFF'.");
call mtr.add_suppression("Could not open .* for logging.*. Turning logging off for the whole duration of the MySQL server process.");

--let $saved_binlog_error_action=`SELECT @@GLOBAL.binlog_error_action`

--source include/sync_slave_sql_with_master.inc
--source include/stop_slave.inc

--let $saved_innodb_page_size_server2=`SELECT @@innodb_page_size`
--connection master
--let $saved_innodb_page_size_server1=`SELECT @@innodb_page_size`

--let $server1_cmd= $MYSQLD --defaults-group-suffix=.1 --defaults-file=$MYSQLTEST_VARDIR/my.cnf --default-storage-engine=InnoDB --default-tmp-storage-engine=InnoDB --innodb-page-size=$saved_innodb_page_size_server1

--let $server2_cmd= $MYSQLD --defaults-group-suffix=.2 --defaults-file=$MYSQLTEST_VARDIR/my.cnf --default-storage-engine=InnoDB --default-tmp-storage-engine=InnoDB --innodb-page-size=$saved_innodb_page_size_server2

--echo ==== Checks performed at server start ====

--echo ---- gtid-mode=ON requires enforce-gtid-consistency ----

--let $rpl_server_number= 2
--source include/rpl_stop_server.inc

--let $assert_command= $server2_cmd --gtid-mode=on 2>&1
--let $assert_regex= GTID_MODE = ON requires ENFORCE_GTID_CONSISTENCY = ON
--let $assert_status= 1
--source include/assert_command_output.inc

--let $rpl_server_number= 2
--let $rpl_start_with_gtids= 0
--source include/rpl_start_server.inc

--echo ==== Master-slave handshake checks ====

--source include/rpl_connection_master.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = ON;
--source include/rpl_connection_slave.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = ON;

# Prevent rpl_set_gtid_mode.inc from trying to sync.
--let $rpl_skip_sync= 1

--let $master_gtid_mode= 0
while ($master_gtid_mode <= 3)
{
  --let $rpl_gtid_mode= $master_gtid_mode
  --let $rpl_server_numbers= 1
  --source include/rpl_set_gtid_mode.inc

  --let $slave_gtid_mode= 0
  while ($slave_gtid_mode <= 3)
  {
    --let $rpl_gtid_mode= $slave_gtid_mode
    --let $rpl_server_numbers= 2
    --source include/rpl_set_gtid_mode.inc

    --connection slave

    # Master and slave gtid_mode compatibility.
    --let $gtid_modes_compatible= 1
    if ($slave_gtid_mode == 0)
    {
      if ($master_gtid_mode >= 2)
      {
        --let $gtid_modes_compatible= 0
      }
    }
    if ($slave_gtid_mode == 3)
    {
      if ($master_gtid_mode <= 1)
      {
        --let $gtid_modes_compatible= 0
      }
    }

    START SLAVE IO_THREAD;
    if ($gtid_modes_compatible)
    {
      --source include/wait_for_slave_io_to_start.inc
      --source include/stop_slave_io.inc
    }
    if (!$gtid_modes_compatible)
    {
      --let $slave_io_errno= convert_error(ER_SLAVE_FATAL_ERROR)
      --source include/wait_for_slave_io_error.inc
    }

    # Auto_position compatible with slave and/or master
    if ($slave_gtid_mode == 0)
    {
      --error ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF
      CHANGE MASTER TO MASTER_AUTO_POSITION = 1;
      CHANGE MASTER TO MASTER_AUTO_POSITION = 0;
    }

    if ($slave_gtid_mode != 0)
    {
      CHANGE MASTER TO MASTER_AUTO_POSITION = 1;
      START SLAVE IO_THREAD;
      if ($master_gtid_mode != 3)
      {
        --let $slave_io_errno= convert_error(ER_SLAVE_FATAL_ERROR)
        --source include/wait_for_slave_io_error.inc
      }
      if ($master_gtid_mode == 3)
      {
        --source include/wait_for_slave_io_to_start.inc
        --source include/stop_slave_io.inc
      }
      CHANGE MASTER TO MASTER_AUTO_POSITION = 0;
    }

    --inc $slave_gtid_mode
  }
  --inc $master_gtid_mode
}

#
# In all the test cases below for catching an error in sender thread,
# we follow the steps (1-2) mentioned below.
# Before the steps, lets look at some theory:
#
#    0. The way we report errors in sender (aka dump) thread is this:
#
#        a) Relay the error in sender thread to receiver thread.
#
#        b) Receiver thread prefixes 'Got fatal error 1236 from master
#           when reading data from binary log...' to the error that it
#           received from sender thread.  Let call this concatenated
#           message '$concated_message'
#
#        c) Receiver thread reports this error in
#           performance_schema.replication_connection_status as
#           c.1. LAST_ERROR_NUMBER= 1236
#           c.2. LAST_ERROR_MESSAGE= '$concated_message'.
#
# And now the steps:
#
#    1. Wait until receiver thread reports error number 1236 in
#       performance_schema.rpelication_connection_status::LAST_ERROR_MESSAGE
#       This is merely a synchronization point for us to wait until
#       the error was generated.  This is done using
#       include/wait_for_slave_io_error.inc
#
#    2. Check that 1236 was reported for the exact sender thread error
#       that we are testing This is done using include/assert.inc to
#       make sure the correct error messsage was passed from sender
#       thread.

--echo #
--echo # Test for ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF
--echo #   eng "Cannot replicate GTID-transaction when GTID_MODE = OFF, at file %.512s, position %lld. Found a Gtid_log_event when @@GLOBAL.GTID_MODE = OFF.
--echo #

--echo #
--echo # Case 1: Error on Master(sender thread)
--echo #

--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t1 (a int);

--let $rpl_server_numbers= 1,2
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
START SLAVE IO_THREAD;

--let $slave_io_errno= 1236  # ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF
--source include/wait_for_slave_io_error.inc

--let $assert_text= sender thread should report - Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF.
--let $assert_cond= COUNT(*) = 1 FROM performance_schema.replication_connection_status WHERE LAST_ERROR_MESSAGE LIKE "%Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF%";
--source include/assert.inc

--let $assert_text= Receiver thread should report - Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF
--let $assert_only_after= Slave I/O thread for channel '': connected to master
--let $assert_count= 2
--source include/assert_grep.inc

--source include/rpl_connection_master.inc
DROP TABLE t1;

RESET MASTER;
--source include/rpl_connection_slave.inc
RESET SLAVE;

--echo #
--echo # Case 2: Error on Slave(receiver thread)
--echo #

--let $rpl_server_numbers= 1,2
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
--source include/start_slave.inc

--let $rpl_server_numbers= 2
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t2(a int);

--source include/rpl_connection_slave.inc

# Errors in queue_event() are overwritten in SHOW SLAVE STATUS/P_S
# by (1595 ER_SLAVE_RELAY_LOG_WRITE_FAILURE).
# So the only place where old error exists is slave error log.
# Grep error log to look for old error.

--let $slave_io_errno= 1595 # ER_SLAVE_RELAY_LOG_WRITE_FAILURE
--source include/wait_for_slave_io_error.inc

--let $assert_text= Receiver thread should report - Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate GTID-transaction when @@GLOBAL.GTID_MODE = OFF
--let $assert_only_after= Slave I/O thread for channel '': connected to master
--let $assert_count= 1
--source include/assert_grep.inc

--source include/rpl_connection_master.inc
DROP TABLE t2;

--source include/rpl_connection_slave.inc

--let $rpl_server_numbers= 2
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/start_slave.inc

--echo #
--echo #  Warning: "Detected misconfiguration: replication channel '%.192s' was configured with AUTO_POSITION = 1, but the server was started with --gtid-mode=off.  Either reconfigure replication using CHANGE MASTER TO MASTER_AUTO_POSITION = 0 FOR CHANNEL '%.192s', or change GTID_MODE to some value other than OFF, before starting the slave receiver thread."
--echo #

--let $rpl_server_numbers= 1,2
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
--source include/stop_slave.inc
CHANGE MASTER TO MASTER_AUTO_POSITION= 1;

--let $rpl_server_number=2
--let $rpl_start_with_gtids= 0
--source include/rpl_restart_server.inc

SET GLOBAL ENFORCE_GTID_CONSISTENCY = ON;

--let $assert_text= While AUTO_POSITION is set, attempt to restart the slave with gtid-mode= off to get ER_STARTING_WITH_GTID_MODE_OFF_AND_AUTO_POSITION.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Detected misconfiguration: replication channel '' was configured with AUTO_POSITION = 1, but the server was started with --gtid-mode=off
--let $assert_count= 1
--source include/assert_grep.inc

--echo #
--echo # ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF
--echo #   eng "The replication receiver thread for channel '%s' cannot start in AUTO_POSITION mode: this server uses GTID_MODE = OFF."
--echo #

# This should follow the previous test case of warning for the detected misconfiguration between autposition and gtid-mode.

--error ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF
START SLAVE IO_THREAD;

CHANGE MASTER TO MASTER_AUTO_POSITION= 0;

--echo #
--echo # ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON
--echo #   eng "Cannot replicate anonymous transaction when GTID_MODE = ON, at file %.512s, position %lld."

--echo #
--echo # Case 1: Error on master(sender thread)
--echo #

--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t3(a int);

--let $rpl_server_numbers= 1,2
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
START SLAVE IO_THREAD;

--let $slave_io_errno= 1236 # ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON
--source include/wait_for_slave_io_error.inc

--let $assert_text= sender thread should report - Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON.
--let $assert_cond= COUNT(*) = 1 FROM performance_schema.replication_connection_status WHERE LAST_ERROR_MESSAGE LIKE "%Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON%";
--source include/assert.inc

--let $assert_text= While gtid-mode=on, slave expects an anonymous event to get ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON
--let $assert_only_after= Slave I/O thread for channel '': connected to master
--let $assert_count= 2
--source include/assert_grep.inc

--source include/rpl_connection_master.inc
DROP TABLE t3;

--let $slave_io_errno= convert_error(ER_MASTER_FATAL_ERROR_READING_BINLOG)
--source include/rpl_reset.inc

--echo #
--echo # Case 2: Error on slave(receiver thread)
--echo #

--let $rpl_server_numbers= 1
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t4(a int);

--source include/rpl_connection_slave.inc

--let $slave_io_errno= 1595 # ER_SLAVE_RELAY_LOG_WRITE_FAILURE
--source include/wait_for_slave_io_error.inc

--let $assert_text= While gtid-mode=on, slave expects an anonymous event to get ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate anonymous transaction when @@GLOBAL.GTID_MODE = ON
--let $assert_only_after= Slave I/O thread for channel '': connected to master
--let $assert_count= 1
--source include/assert_grep.inc

--source include/stop_slave_sql.inc

--let $rpl_server_numbers= 2
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
DROP TABLE t4;
RESET MASTER;

--source include/rpl_connection_slave.inc
RESET SLAVE;
--source include/start_slave.inc

--source include/rpl_connection_master.inc
--source include/sync_slave_sql_with_master.inc

--echo #
--echo # ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION
--echo #   eng "Cannot replicate anonymous transaction when AUTO_POSITION = 1, at file %.512s, position %lld."
--echo #

--echo #
--echo # Case 1: Error on master(sender thread).
--echo #

--let $rpl_server_numbers= 1,2
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t5(a int);  # gtid1

# sync here so that we are sure table exists on slave, so we can sync DROP TABLE later.
--source include/sync_slave_sql_with_master.inc
--source include/stop_slave.inc

--source include/rpl_connection_master.inc
# Generate at least one GTID transaction before the anonymous for autoposition
# to start from here and then discover the anonymous transaction in binary log.
INSERT INTO t5 VALUES(2);

--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON_PERMISSIVE
--source include/rpl_set_gtid_mode.inc

SET @@SESSION.GTID_NEXT = 'ANONYMOUS';
INSERT INTO t5 VALUES(1);  # anonymous transaction

--let $rpl_server_numbers= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--let $rpl_server_numbers= 2
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
CHANGE MASTER TO MASTER_AUTO_POSITION= 1;
START SLAVE IO_THREAD;

--let $slave_io_errno= 1236 # ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION
--source include/wait_for_slave_io_error.inc

--let $assert_text= sender thread should report - Cannot replicate anonymous transaction when AUTO_POSITION = 1.
--let $assert_cond= COUNT(*) = 1 FROM performance_schema.replication_connection_status WHERE LAST_ERROR_MESSAGE LIKE "%Cannot replicate anonymous transaction when AUTO_POSITION = 1%";
--source include/assert.inc

--let $assert_text= While AUTO_POSITION is enabled, Master sends an anonymous transaction resulting into ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate anonymous transaction when AUTO_POSITION = 1
--let $assert_count= 2
--source include/assert_grep.inc

--let $rpl_server_number=1
--let $rpl_start_with_gtids= 0
--source include/rpl_restart_server.inc

--source include/rpl_connection_master.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = ON;

--source include/rpl_connection_slave.inc
CHANGE MASTER TO MASTER_AUTO_POSITION= 0;

--let $rpl_server_numbers= 2
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
DROP TABLE t5;
RESET MASTER;

--source include/rpl_connection_slave.inc
RESET SLAVE;

--let $rpl_skip_sync=0
--source include/start_slave.inc
--source include/rpl_connection_master.inc
--source include/sync_slave_sql_with_master.inc

--echo #
--echo # Case 2: Error on Slave(receiver thread).
--echo #

# Same test as Case 1 but this time we disable the error in sender thread
# using DBUG_EXECUTE_IF so that receiver thread sees this error now.
# We next verify that the same error is also caught by receiver thread.

--source include/rpl_connection_master.inc
SET @debug_saved= @@GLOBAL.DEBUG;

SET GLOBAL DEBUG= "d,skip_sender_anon_autoposition_error";

--let $rpl_server_numbers= 1,2
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
CREATE TABLE t6(a int);  # gtid1

# sync here so that we are sure table exists on slave, so we can sync DROP TABLE later.
--source include/sync_slave_sql_with_master.inc
--source include/stop_slave.inc

--source include/rpl_connection_master.inc
# Generate at least one GTID transaction before the anonymous for autoposition
# to start from here and then discover the anonymous transaction in binary log.
INSERT INTO t6 VALUES(2);

--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON_PERMISSIVE
--source include/rpl_set_gtid_mode.inc

SET @@SESSION.GTID_NEXT = 'ANONYMOUS';
INSERT INTO t6 VALUES(1);  # anonymous transaction

--let $rpl_server_numbers= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--let $rpl_server_numbers= 2
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_slave.inc
CHANGE MASTER TO MASTER_AUTO_POSITION= 1;
START SLAVE IO_THREAD;

--let $slave_io_errno= 1595 # ER_SLAVE_RELAY_LOG_WRITE_FAILURE
--source include/wait_for_slave_io_error.inc

--let $assert_text= While AUTO_POSITION is enabled, Master sends an anonymous transaction resulting into ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_select= Cannot replicate anonymous transaction when AUTO_POSITION = 1
--let $assert_count= 1
--source include/assert_grep.inc

--source include/rpl_connection_slave.inc
CHANGE MASTER TO MASTER_AUTO_POSITION= 0;

--let $rpl_server_numbers= 1,2
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
SET @@GLOBAL.DEBUG= @debug_saved;
SET DEBUG_SYNC= 'RESET';
DROP TABLE t6;
RESET MASTER;

--source include/rpl_connection_slave.inc
RESET SLAVE;

--let $rpl_skip_sync=0
--source include/start_slave.inc
--source include/rpl_connection_master.inc
--source include/sync_slave_sql_with_master.inc

# It is enough to run this test on 1 server, no replication required.

--echo #
--echo # Verify the behaviour when rotate fails while setting gtid_mode.
--echo #

--source include/rpl_connection_slave.inc
--source include/start_slave.inc

--source include/rpl_connection_master.inc
call mtr.add_suppression("Could not open * for logging");
--source include/sync_slave_sql_with_master.inc

--source include/stop_slave.inc

SET @debug_saved= @@GLOBAL.DEBUG;
SET GLOBAL DEBUG= "d,fault_injection_new_file_rotate_event";

SET GLOBAL binlog_error_action= IGNORE_ERROR;

--error ER_ERROR_ON_WRITE
SET @@GLOBAL.GTID_MODE= OFF_PERMISSIVE;

# Cleanup
SET @@GLOBAL.GTID_MODE= OFF;
SET @@GLOBAL.DEBUG= @debug_saved;
--eval SET GLOBAL binlog_error_action= $saved_binlog_error_action

# Binlog was closed as a result of the error, restart server to recover.
--let $rpl_server_number= 1
--source include/rpl_restart_server.inc

--source include/rpl_connection_master.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = ON;

--echo #
--echo # ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON
--echo # generated when re-acquiring anonymous ownership
--echo #

--source include/rpl_connection_master.inc
SET GTID_NEXT='ANONYMOUS';
CREATE TABLE t7(a int);

--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= ON
--source include/rpl_set_gtid_mode.inc

--error ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON
INSERT INTO t7 values (1);

SET GTID_NEXT='AUTOMATIC';
DROP TABLE t7;

RESET MASTER;
--let $rpl_server_numbers= 1
--let $rpl_skip_sync= 1
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc


# Get rid of the manually generated slave error log file.
#--remove_file $MYSQLTEST_VARDIR/tmp/slave-rpl-gtid-mode.err

--echo #
--echo # Error generated if master has an unknown gtid_mode
--echo #

--connection slave
--source include/stop_slave.inc
RESET SLAVE;
SET @@GLOBAL.DEBUG= 'd,simulate_master_has_unknown_gtid_mode';
START SLAVE IO_THREAD;
--let $slave_io_errno= convert_error(ER_SLAVE_FATAL_ERROR)
--let $show_slave_io_error= 1
--source include/wait_for_slave_io_error.inc
SET @@GLOBAL.DEBUG= @debug_saved;

--echo #
--echo # Warning generated if master has unknown gtid_mode that begins
--echo # with ON or OFF.
--echo #

SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;

SET @@GLOBAL.DEBUG = 'd,simulate_master_has_gtid_mode_on_something';
--source include/start_slave.inc
--let $assert_file=$MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_count= 1
--let $assert_only_after= Slave I/O thread for channel '': connected to master
--let $assert_text= Receiver thread should report that on_something is unknown
--let $assert_select= Slave I/O for channel '': The master uses an unknown GTID_MODE 'on_something'. Treating it as 'ON'.
--source include/assert_grep.inc

--source include/stop_slave.inc
SET @@GLOBAL.DEBUG = 'd,simulate_master_has_gtid_mode_off_something';
--source include/start_slave.inc
--let $assert_text= Receiver thread should report that off_something is unknown
--let $assert_select= Slave I/O for channel '': The master uses an unknown GTID_MODE 'off_something'. Treating it as 'OFF'.
--source include/assert_grep.inc

--source include/stop_slave.inc
RESET SLAVE;

--echo #
--echo # ER_CANT_SET_GTID_MODE generated because AUTO_POSITION = 1.
--echo #

--let $rpl_server_numbers= 1
--let $rpl_gtid_mode= ON
--let $rpl_skip_sync= 1
--source include/rpl_set_gtid_mode.inc

CHANGE MASTER TO MASTER_AUTO_POSITION = 1;
--error ER_CANT_SET_GTID_MODE
SET @@GLOBAL.GTID_MODE = OFF;

CHANGE MASTER TO MASTER_AUTO_POSITION = 0;
SET @@GLOBAL.GTID_MODE = OFF;
--let $rpl_server_numbers= 1
--let $rpl_gtid_mode= OFF
--source include/rpl_set_gtid_mode.inc

--source include/rpl_connection_master.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = OFF;
--source include/rpl_connection_slave.inc
SET GLOBAL ENFORCE_GTID_CONSISTENCY = OFF;

--let $rpl_skip_sync= 0
--let $rpl_only_running_threads= 1
--source include/rpl_end.inc
