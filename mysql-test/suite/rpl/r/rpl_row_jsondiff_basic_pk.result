include/rpl_init.inc [topology=1->2->3->4->5->6]
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
include/rpl_default_connections.inc
include/rpl_stop_slaves.inc
include/begin_replace_combination.inc [BOTH.BINLOG_FORMAT=ROW,MIXED,STATEMENT -> GLOBAL.SLAVE_ROWS_SEARCH_ALGORITHMS=INDEX_SCAN,HASH_SCAN,TABLE_SCAN]
include/rpl_start_slaves.inc
######## INITIALIZE ########
call mtr.add_suppression("Changed limits: max_open_files:*");
CALL mtr.add_suppression("Changed limits: table_open_cache: *");
call mtr.add_suppression("Changed limits: max_open_files:*");
CALL mtr.add_suppression("Changed limits: table_open_cache: *");
call mtr.add_suppression("Changed limits: max_open_files:*");
CALL mtr.add_suppression("Changed limits: table_open_cache: *");
include/rpl_for_each_server_stmt.inc [SET @@SESSION.BINLOG_ROW_IMAGE = MINIMAL;
SET @@SESSION.BINLOG_ROW_VALUE_OPTIONS = PARTIAL_JSON;
SET @@GLOBAL.BINLOG_ROW_IMAGE = MINIMAL;
SET @@GLOBAL.BINLOG_ROW_VALUE_OPTIONS = PARTIAL_JSON;
]
include/rpl_stop_slaves.inc
include/rpl_start_slaves.inc
******** Single JSON column ********
==== Full format ====
---- 1. Update one row using full format (wrong column used) ----
include/rpl_row_jsondiff_scenario.inc
* CREATE TABLE test.t (i INT PRIMARY KEY, j JSON, k JSON)
# Before update
i	j	k
1	[1, 2]	[3, 4]
UPDATE t SET j = JSON_SET(k, '$[0]', 'a') WHERE i = 1
# After update
i	j	k
1	["a", 4]	[3, 4]
# Decoded rows
UPDATE `test`.`t` SET j='["a", 4]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='["a", 4]', k=k WHERE i=1 AND j=CAST('[1, 2]' AS JSON) AND k=CAST('[3, 4]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='["a", 4]', k=k WHERE i=1;
---- 2. Update one row using full format (no JSON function used) ----
include/rpl_row_jsondiff_scenario.inc
* CREATE TABLE test.t (i INT PRIMARY KEY, j JSON)
# Before update
i	j
1	[1, 2]
UPDATE t SET j = CAST(7 AS JSON) WHERE i = 1
# After update
i	j
1	7
# Decoded rows
UPDATE `test`.`t` SET j='7' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='7' WHERE i=1 AND j=CAST('[1, 2]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='7' WHERE i=1;
---- 3. Update one row using full format (wrong JSON function used (1)) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2]
UPDATE t SET j = JSON_MERGE(j, '[8]') WHERE i = 1
Warnings:
Warning	1287	'JSON_MERGE' is deprecated and will be removed in a future release. Please use JSON_MERGE_PRESERVE/JSON_MERGE_PATCH instead
# After update
i	j
1	[1, 2, 8]
# Decoded rows
UPDATE `test`.`t` SET j='[1, 2, 8]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[1, 2, 8]' WHERE i=1 AND j=CAST('[1, 2]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[1, 2, 8]' WHERE i=1;
---- 4. Update one row using full format (wrong JSON function used (2)) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2]
UPDATE t SET j = JSON_MERGE(JSON_REPLACE(j, '$[0]', 3), '[8]') WHERE i = 1
Warnings:
Warning	1287	'JSON_MERGE' is deprecated and will be removed in a future release. Please use JSON_MERGE_PRESERVE/JSON_MERGE_PATCH instead
# After update
i	j
1	[3, 2, 8]
# Decoded rows
UPDATE `test`.`t` SET j='[3, 2, 8]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[3, 2, 8]' WHERE i=1 AND j=CAST('[1, 2]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[3, 2, 8]' WHERE i=1;
---- 5. Update one row using full format (wrong JSON function used (3)) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2]
UPDATE t SET j = JSON_REPLACE(JSON_MERGE(j, '[8]'), '$[0]', 3) WHERE i = 1
Warnings:
Warning	1287	'JSON_MERGE' is deprecated and will be removed in a future release. Please use JSON_MERGE_PRESERVE/JSON_MERGE_PATCH instead
# After update
i	j
1	[3, 2, 8]
# Decoded rows
UPDATE `test`.`t` SET j='[3, 2, 8]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[3, 2, 8]' WHERE i=1 AND j=CAST('[1, 2]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[3, 2, 8]' WHERE i=1;
---- 6. Update one row using full format (full smaller than partial) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvwxyz', '$[0]', 3) WHERE i = 1
# After update
i	j
1	[3, 2]
# Decoded rows
UPDATE `test`.`t` SET j='[3, 2]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[3, 2]' WHERE i=1 AND j=CAST('[1, 2]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[3, 2]' WHERE i=1;
==== Single diffs ====
---- 7. Update one row (REPLACE using JSON_REPLACE in array) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_REPLACE(j, '$[0]', 7) WHERE i = 1
# After update
i	j
1	[7, {"a": 2}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 7) WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', 7) WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', 7) WHERE i=1;
---- 8. Update one row (REPLACE using JSON_SET in array) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_SET(j, '$[0]', "7") WHERE i = 1
# After update
i	j
1	["7", {"a": 2}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', '7') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', '7') WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', '7') WHERE i=1;
---- 9. Update one row (REPLACE using JSON_REPLACE in object) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_REPLACE(j, '$[1].a', CAST('[7]' AS JSON)) WHERE i = 1
# After update
i	j
1	[1, {"a": [7]}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[1].a', CAST('[7]' AS JSON)) WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1].a', CAST('[7]' AS JSON)) WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1].a', CAST('[7]' AS JSON)) WHERE i=1;
---- 10. Update one row (REPLACE using JSON_SET in object) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_SET(j, '$[1].a', CAST('{"a":7}' AS JSON)) WHERE i = 1
# After update
i	j
1	[1, {"a": {"a": 7}}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[1].a', CAST('{"a": 7}' AS JSON)) WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1].a', CAST('{"a": 7}' AS JSON)) WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1].a', CAST('{"a": 7}' AS JSON)) WHERE i=1;
---- 11. Update one row (INSERT using JSON_SET in array) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_SET(j, '$[2]', 3) WHERE i = 1
# After update
i	j
1	[1, {"a": 2}, 3]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_SET(j, '$[2]', 3) WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$[2]', 3) WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$[2]', 3) WHERE i=1;
---- 12. Update one row (INSERT using JSON_SET in object) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_SET(j, '$[1].b', CAST(4 AS DECIMAL)) WHERE i = 1
# After update
i	j
1	[1, {"a": 2, "b": 4}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_SET(j, '$[1].b', 4) WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$[1].b', 4) WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$[1].b', 4) WHERE i=1;
---- 13. Update one row (REMOVE using JSON_REMOVE in array) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_REMOVE(j, '$[1]') WHERE i = 1
# After update
i	j
1	[1]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REMOVE(j, '$[1]') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]') WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]') WHERE i=1;
---- 14. Update one row (REMOVE using JSON_REMOVE in object) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, {"a": 2}]
UPDATE t SET j = JSON_REMOVE(j, '$[1].a') WHERE i = 1
# After update
i	j
1	[1, {}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REMOVE(j, '$[1].a') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1].a') WHERE i=1 AND j=CAST('[1, {"a": 2}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1].a') WHERE i=1;
==== Multiple diffs from one function call ====
---- 15. Update one row (many different update types, using JSON_SET) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]
UPDATE t SET j = JSON_SET(j, '$[0]', 'one', '$[1]', 'two', '$[2].a', 'three', '$[2].b', 'four', '$[2].c', 'five', '$[2].d', 'six', '$[3]', 'seven', '$[4]', 'eight') WHERE i = 1
# After update
i	j
1	["one", "two", {"a": "three", "b": "four", "c": "five", "d": "six", "a long string that ensures that the diff format is smaller than the full format": ""}, "seven", "eight"]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_SET( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2].a', 'three', '$[2].b', 'four'), '$[2].c', 'five', '$[2].d', 'six'), '$[3]', 'seven', '$[4]', 'eight') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_SET( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2].a', 'three', '$[2].b', 'four'), '$[2].c', 'five', '$[2].d', 'six'), '$[3]', 'seven', '$[4]', 'eight') WHERE i=1 AND j=CAST('[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_SET( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2].a', 'three', '$[2].b', 'four'), '$[2].c', 'five', '$[2].d', 'six'), '$[3]', 'seven', '$[4]', 'eight') WHERE i=1;
---- 16. Update one row (many different update types, using JSON_REPLACE) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]
UPDATE t SET j = JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[3].a', 'three', '$[3].b', 'four', '$[0]', 'ONE', '$[1]', 'TWO', '$[3].a', 'THREE', '$[3].b', 'FOUR') WHERE i = 1
# After update
i	j
1	["ONE", "TWO", {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[0]', 'ONE', '$[1]', 'TWO') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[0]', 'ONE', '$[1]', 'TWO') WHERE i=1 AND j=CAST('[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[0]', 'ONE', '$[1]', 'TWO') WHERE i=1;
---- 17. Update one row (using JSON_REMOVE) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]
UPDATE t SET j = JSON_REMOVE(j, '$[1]', '$[2].b', '$[2].a', '$[0]') WHERE i = 1
# After update
i	j
1	[{"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REMOVE(j, '$[1]', '$[0]') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]', '$[0]') WHERE i=1 AND j=CAST('[1, 2, {"a": 3, "b": 4, "a long string that ensures that the diff format is smaller than the full format": ""}]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]', '$[0]') WHERE i=1;
==== Multiple diffs from multiple function calls ====
---- 18. Update one row (using JSON_SET, JSON_REPLACE, and JSON_REMOVE) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_REMOVE(JSON_SET(JSON_REPLACE(JSON_SET(j, '$[0]', 'one'), '$[1]', 'two', '$[2]', CAST('{"a": 1}' AS JSON)), '$[2].b', 2, '$[2].c', 3), '$[0]', '$[0]') WHERE i = 1
# After update
i	j
1	[{"a": 1, "b": 2, "c": 3}, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REMOVE( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2]', CAST('{"a": 1}' AS JSON)), '$[2].b', 2, '$[2].c', 3), '$[0]', '$[0]') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2]', CAST('{"a": 1}' AS JSON)), '$[2].b', 2, '$[2].c', 3), '$[0]', '$[0]') WHERE i=1 AND j=CAST('[1, 2, 3, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE( JSON_SET( JSON_REPLACE(j, '$[0]', 'one', '$[1]', 'two', '$[2]', CAST('{"a": 1}' AS JSON)), '$[2].b', 2, '$[2].c', 3), '$[0]', '$[0]') WHERE i=1;
==== NULL values ====
---- 19. Updating from non-NULL to NULL using JSON_SET ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3, 4]
UPDATE t SET j = JSON_SET(j, NULL, 'a') WHERE i = 1
# After update
i	j
1	NULL
# Decoded rows
UPDATE `test`.`t` SET j=NULL WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1 AND j=CAST('[1, 2, 3, 4]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1;
---- 20. Updating from non-NULL to NULL using JSON_REPLACE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3, 4]
UPDATE t SET j = JSON_REPLACE(j, NULL, 'a') WHERE i = 1
# After update
i	j
1	NULL
# Decoded rows
UPDATE `test`.`t` SET j=NULL WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1 AND j=CAST('[1, 2, 3, 4]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1;
---- 21. Updating from non-NULL to NULL using JSON_REMOVE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3, 4]
UPDATE t SET j = JSON_REMOVE(j, NULL) WHERE i = 1
# After update
i	j
1	NULL
# Decoded rows
UPDATE `test`.`t` SET j=NULL WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1 AND j=CAST('[1, 2, 3, 4]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=NULL WHERE i=1;
---- 22. Updating from NULL to non-NULL using JSON_SET ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	NULL
UPDATE t SET j = JSON_SET('{"a": "a"}', '$.b', j) WHERE i = 1
# After update
i	j
1	{"a": "a", "b": null}
# Decoded rows
UPDATE `test`.`t` SET j='{"a": "a", "b": null}' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='{"a": "a", "b": null}' WHERE i=1 AND j IS NULL;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='{"a": "a", "b": null}' WHERE i=1;
---- 23. Updating from NULL to non-NULL using JSON_REPLACE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	NULL
UPDATE t SET j = JSON_REPLACE('{"a": "a"}', '$.a', j) WHERE i = 1
# After update
i	j
1	{"a": null}
# Decoded rows
UPDATE `test`.`t` SET j='{"a": null}' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='{"a": null}' WHERE i=1 AND j IS NULL;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='{"a": null}' WHERE i=1;
---- 24. Updating from NULL to non-NULL using JSON_REMOVE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	NULL
UPDATE t SET j = JSON_REPLACE('{"a": "a", "b": "b"}', '$.b', 'BB') WHERE i = 1
# After update
i	j
1	{"a": "a", "b": "BB"}
# Decoded rows
UPDATE `test`.`t` SET j='{"a": "a", "b": "BB"}' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='{"a": "a", "b": "BB"}' WHERE i=1 AND j IS NULL;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='{"a": "a", "b": "BB"}' WHERE i=1;
==== No-op updates ====
---- 25. Making a no-op not mentioning the column ----
include/rpl_row_jsondiff_scenario.inc
* CREATE TABLE test.t (i INT PRIMARY KEY, j JSON, x INT)
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2  WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 26. Making a no-op setting the column to itself ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = j WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 27. Making a no-op setting the column to its own value (1) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = CONCAT(j, '') WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 28. Making a no-op setting the column to its own value (2) ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = '["a", {"b": "c"}]' WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 29. Making a no-op using JSON_SET inserting object in non-object or array element in non-array ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_SET(j, '$.a', 0, '$[1][2]', 1, '$[1].b.x', 2) WHERE i = 1
# After update
i	j	x
1	["a", [{"b": "c"}, 1]]	2
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[1]', CAST('[{"b": "c"}, 1]' AS JSON)), x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1]', CAST('[{"b": "c"}, 1]' AS JSON)), x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REPLACE(j, '$[1]', CAST('[{"b": "c"}, 1]' AS JSON)), x=2 WHERE i=1;
---- 30. Making a no-op using JSON_REPLACE with non-existing paths ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_REPLACE(j, '$[9]', 0, '$.x', 1, '$[1].x', 2) WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 31. Making a no-op removing a non-existing path, using JSON_REMOVE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_REMOVE(j, '$[9]', '$[1].x', '$.foo', '$[1][0]') WHERE i = 1
# After update
i	j	x
1	["a"]	2
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REMOVE(j, '$[1]'), x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]'), x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_REMOVE(j, '$[1]'), x=2 WHERE i=1;
---- 32. Making a no-op replacing a JSON value by itself, using JSON_SET ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_SET(j, '$[0]', 'a', '$[1].b', 'c', '$[0]', 'a') WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 33. Making a no-op replacing a JSON value by itself, using JSON_REPLACE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_REPLACE(j, '$[0]', 'a', '$[1].b', 'c', '$[0]', 'a') WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
---- 34. Making a no-op update using JSON_SET, JSON_REPLACE, and JSON_REMOVE ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j	x
1	["a", {"b": "c"}]	1
UPDATE t SET x = 2, j = JSON_SET(JSON_REMOVE(JSON_REPLACE(j,
'$[0]', 'a', '$[1].b', 'c', '$[0]', 'a'),
'$[9]', '$[1].x', '$.foo'),
'$[0]', 'a', '$[1].b', 'c', '$[0]', 'a') WHERE i = 1
# After update
i	j	x
1	["a", {"b": "c"}]	2
# Decoded rows
UPDATE `test`.`t` SET j=j, x=2 WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1 AND j=CAST('["a", {"b": "c"}]' AS JSON) AND x=1;
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=j, x=2 WHERE i=1;
==== Long paths ====
---- 35. Update using long path ----
include/rpl_row_jsondiff_scenario.inc
* CREATE TABLE test.t (i INT PRIMARY KEY, j JSON)
# Before update
i	j
1	{"abc": "def"}
UPDATE t SET j = JSON_SET(j, '$.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'ghi') WHERE i = 1
# After update
i	j
1	{"abc": "def", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa": "ghi"}
# Decoded rows
UPDATE `test`.`t` SET j=JSON_SET(j, '$.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'ghi') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'ghi') WHERE i=1 AND j=CAST('{"abc": "def"}' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'ghi') WHERE i=1;
---- 36. Update using long document ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	{"abc": "def"}
UPDATE t SET j = JSON_SET(j, '$.ghi', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') WHERE i = 1
# After update
i	j
1	{"abc": "def", "ghi": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
# Decoded rows
UPDATE `test`.`t` SET j=JSON_SET(j, '$.ghi', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$.ghi', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') WHERE i=1 AND j=CAST('{"abc": "def"}' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=JSON_SET(j, '$.ghi', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') WHERE i=1;
---- 37. Update using very long document ----
include/rpl_row_jsondiff_scenario.inc
==== Auto-wrapping ====
---- 38. Auto-wrap using JSON_SET ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	{"a": 1}
UPDATE t SET j = JSON_SET(j, '$[1]', 4711) WHERE i = 1
# After update
i	j
1	[{"a": 1}, 4711]
# Decoded rows
UPDATE `test`.`t` SET j='[{"a": 1}, 4711]' WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[{"a": 1}, 4711]' WHERE i=1 AND j=CAST('{"a": 1}' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[{"a": 1}, 4711]' WHERE i=1;
==== Multi-row updates ====
---- 39. Update two rows: both partial ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i = 2 OR i = 4 
# After update
i	j
1	[1, 2, 3]
2	[0, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[0, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4;
# Decoded rows, full image
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2 AND j=CAST('[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
UPDATE `test`.`t` SET i=4, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4 AND j=CAST('[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET i=4, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4;
---- 40. Update two rows: first partial, then full ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i = 2 OR i = 3 
# After update
i	j
1	[1, 2, 3]
2	[0, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[0, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET j='[0, 8, 9]' WHERE i=3;
# Decoded rows, full image
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2 AND j=CAST('[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3 AND j=CAST('[7, 8, 9]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3;
---- 41. Update two rows: first full, then partial ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i = 1 OR i = 2 
# After update
i	j
1	[0, 2, 3]
2	[0, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1 AND j=CAST('[1, 2, 3]' AS JSON);
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2 AND j=CAST('[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
---- 42. Update two rows: both full ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i = 1 OR i = 3 
# After update
i	j
1	[0, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[0, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET j='[0, 8, 9]' WHERE i=3;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1 AND j=CAST('[1, 2, 3]' AS JSON);
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3 AND j=CAST('[7, 8, 9]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3;
---- 43. Update four rows: full, partial, full, partial ----
include/rpl_row_jsondiff_scenario.inc
# Before update
i	j
1	[1, 2, 3]
2	[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[7, 8, 9]
4	[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
UPDATE t SET j = JSON_SET(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i IN (1, 2, 3, 4) 
# After update
i	j
1	[0, 2, 3]
2	[0, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]
3	[0, 8, 9]
4	[0, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]
# Decoded rows
UPDATE `test`.`t` SET j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET j='[0, 8, 9]' WHERE i=3;
UPDATE `test`.`t` SET j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1 AND j=CAST('[1, 2, 3]' AS JSON);
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2 AND j=CAST('[4, 5, 6, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3 AND j=CAST('[7, 8, 9]' AS JSON);
UPDATE `test`.`t` SET i=4, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4 AND j=CAST('[10, 11, 12, "a long string that ensures that the diff format is smaller than the full format"]' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j='[0, 2, 3]' WHERE i=1;
UPDATE `test`.`t` SET i=2, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=2;
UPDATE `test`.`t` SET i=3, j='[0, 8, 9]' WHERE i=3;
UPDATE `test`.`t` SET i=4, j=JSON_REPLACE(j, '$[0]', 'abcdefghijklmnopqrstuvxyz', '$[0]', 0) WHERE i=4;
==== Invalid paths ====
TODO
******** Multiple JSON columns ********
---- 44. Update after null and after non-modified column ----
include/rpl_row_jsondiff_scenario.inc
* CREATE TABLE test.t (i INT PRIMARY KEY, j JSON, k JSON, l JSON, m JSON)
# Before update
i	j	k	l	m
1	[1, 2, 3, 4]	[5, 6, 7, 8]	{"a": 1, "b": 2, "c": 3, "d": 4}	{"e": 8, "f": 6, "g": 7}
UPDATE t SET j = NULL, l = JSON_SET(l, '$.d', "DDD") 
# After update
i	j	k	l	m
1	NULL	[5, 6, 7, 8]	{"a": 1, "b": 2, "c": 3, "d": "DDD"}	{"e": 8, "f": 6, "g": 7}
# Decoded rows
UPDATE `test`.`t` SET j=NULL, l=JSON_REPLACE(l, '$.d', 'DDD') WHERE i=1;
# Decoded rows, full image
UPDATE `test`.`t` SET i=1, j=NULL, k=k, l=JSON_REPLACE(l, '$.d', 'DDD'), m=m WHERE i=1 AND j=CAST('[1, 2, 3, 4]' AS JSON) AND k=CAST('[5, 6, 7, 8]' AS JSON) AND l=CAST('{"a": 1, "b": 2, "c": 3, "d": 4}' AS JSON) AND m=CAST('{"e": 8, "f": 6, "g": 7}' AS JSON);
# Decoded rows, minimal image when master has full image
UPDATE `test`.`t` SET i=1, j=NULL, k=k, l=JSON_REPLACE(l, '$.d', 'DDD'), m=m WHERE i=1;
******** Differences between master and slave ********
TODO: applies ok, does not apply, and mix
######## CLEAN UP ########
include/rpl_for_each_server_stmt.inc [SET @@SESSION.BINLOG_ROW_IMAGE = FULL;
SET @@SESSION.BINLOG_ROW_VALUE_OPTIONS = '';
SET @@GLOBAL.BINLOG_ROW_IMAGE = FULL;
SET @@GLOBAL.BINLOG_ROW_VALUE_OPTIONS = '';
SET SESSION SQL_LOG_BIN = 0; DROP TABLE test.t; SET SESSION SQL_LOG_BIN = 1;
]
include/rpl_stop_slaves.inc
include/end_replace_combination.inc [BOTH.BINLOG_FORMAT=ROW,MIXED,STATEMENT -> GLOBAL.SLAVE_ROWS_SEARCH_ALGORITHMS=INDEX_SCAN,HASH_SCAN,TABLE_SCAN]
include/rpl_start_slaves.inc
include/rpl_end.inc
