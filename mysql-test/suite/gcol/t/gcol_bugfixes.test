################################################################################
# t/gcol_bugfixes.test                                                         #
#                                                                              #
# Purpose:                                                                     #
#  Bug fixes that only need one storage engine                                 #
#                                                                              #
################################################################################

--echo # Bug#21230709: Alter table statement fails with division by zero

CREATE TABLE t1 (
  col1 INTEGER NOT NULL,
  col2 INTEGER NOT NULL,
  col3 INTEGER NOT NULL,
  gcol1 INTEGER GENERATED ALWAYS AS (col3 + col3) VIRTUAL,
  col4 INTEGER DEFAULT NULL,
  col5 INTEGER DEFAULT NULL,
  col6 INTEGER DEFAULT NULL,
  col7 INTEGER DEFAULT NULL,
  col8 INTEGER DEFAULT NULL,
  col9 INTEGER DEFAULT NULL,
  col10 INTEGER DEFAULT NULL,
  col11 INTEGER DEFAULT NULL,
  col12 INTEGER DEFAULT NULL,
  col13 INTEGER DEFAULT NULL,
  col14 INTEGER DEFAULT NULL,
  col15 INTEGER DEFAULT NULL,
  col16 INTEGER DEFAULT NULL,
  col17 INTEGER DEFAULT NULL,
  col18 INTEGER DEFAULT NULL,
  col19 INTEGER DEFAULT NULL,
  col20 INTEGER DEFAULT NULL,
  col21 INTEGER DEFAULT NULL,
  col22 INTEGER DEFAULT NULL,
  col23 INTEGER DEFAULT NULL,
  col24 INTEGER DEFAULT NULL,
  col25 INTEGER DEFAULT NULL,
  col26 INTEGER DEFAULT NULL,
  col27 INTEGER DEFAULT NULL,
  col28 INTEGER DEFAULT NULL,
  col29 INTEGER DEFAULT NULL,
  col30 INTEGER DEFAULT NULL,
  col31 INTEGER DEFAULT NULL,
  col32 INTEGER DEFAULT NULL,
  col33 INTEGER DEFAULT NULL,
  gcol2 INTEGER GENERATED ALWAYS AS (col2 + col2) VIRTUAL,
  gcol3 INTEGER GENERATED ALWAYS AS (gcol2 / gcol2) VIRTUAL,
  PRIMARY KEY (col1),
  KEY idx1 (gcol1)
) engine=innodb;

INSERT INTO t1 (col1, col2, col3)
  VALUES (0,1,2), (1,2,3), (2,3,4), (3,4,5), (4,5,6);

# This is likely needed to ensure we allocate a new record buffer that
# contains zero in the mis-used field
FLUSH TABLE t1;

ALTER TABLE t1 ADD COLUMN extra INTEGER;

DROP TABLE t1;

--echo #
--echo # Bug 21340801 WL8149:ASSERTION `IS_VIRTUAL_GCOL()' FAILED
--echo #

CREATE TABLE t1 (
  c_blob BLOB,
  c_blob_key BLOB GENERATED ALWAYS AS (REPEAT(c_blob,15)) STORED,
  KEY (c_blob_key(200))
); 

INSERT  INTO t1 (c_blob) VALUES ('xceks');

DROP TABLE t1;

--echo #
--echo # Bug#21345972 WL8149:JOIN_CACHE::FILTER_VIRTUAL_GCOL_BASE_COLS(): ASSERTION `FALSE' FAILED.
--echo #

CREATE TABLE c (
                        pk INTEGER AUTO_INCREMENT,
                        col_int_nokey INTEGER /*! NULL */,
                        col_int_key INTEGER GENERATED ALWAYS AS
(col_int_nokey + col_int_nokey) VIRTUAL not null,

                        col_date_nokey DATE /*! NULL */,
                        col_date_key DATE GENERATED ALWAYS AS
(DATE_ADD(col_date_nokey,interval 30 day)) VIRTUAL not null,

                        col_datetime_nokey DATETIME /*! NULL */,
                        col_time_nokey TIME /*! NULL */,

                        col_datetime_key DATETIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,
                        col_time_key TIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,

                        col_varchar_nokey VARCHAR(1) /*! NULL */,
                        col_varchar_key VARCHAR(2) GENERATED ALWAYS AS
(CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,

                        PRIMARY KEY (pk),
                        UNIQUE KEY (col_int_key),
                        UNIQUE KEY (col_varchar_key),
                        UNIQUE KEY (col_date_key),
                        KEY (col_time_key),
                        KEY (col_datetime_key),
                        UNIQUE KEY (col_int_key, col_varchar_key),
                        KEY (col_int_key, col_int_nokey),
                        KEY(col_int_key,col_date_key),
                        KEY(col_int_key, col_time_key),
                        KEY(col_int_key, col_datetime_key),
                        UNIQUE
KEY(col_date_key,col_time_key,col_datetime_key),
                        UNIQUE KEY (col_varchar_key, col_varchar_nokey),
                        UNIQUE KEY (col_int_key, col_varchar_key,
col_date_key, col_time_key, col_datetime_key)
                )  ENGINE=INNODB;

INSERT /*! IGNORE */ INTO c (
                                col_int_nokey,
                                col_date_nokey,
                                col_time_nokey,
                                col_datetime_nokey,
                                col_varchar_nokey
                        ) VALUES (7, '2004-04-09', '14:03:03.042673',
'2001-11-28 00:50:27.051028', 'c'),(1, '2006-05-13', '01:46:09.016386',
'2007-10-09 19:53:04.008332', NULL);

CREATE TABLE bb (
                        pk INTEGER AUTO_INCREMENT,
                        col_int_nokey INTEGER /*! NULL */,
                        col_int_key INTEGER GENERATED ALWAYS AS
(col_int_nokey + col_int_nokey) VIRTUAL not null,

                        col_date_nokey DATE /*! NULL */,
                        col_date_key DATE GENERATED ALWAYS AS
(DATE_ADD(col_date_nokey,interval 30 day)) VIRTUAL not null,

                        col_datetime_nokey DATETIME /*! NULL */,
                        col_time_nokey TIME /*! NULL */,

                        col_datetime_key DATETIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,
                        col_time_key TIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,

                        col_varchar_nokey VARCHAR(1) /*! NULL */,
                        col_varchar_key VARCHAR(2) GENERATED ALWAYS AS
(CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,

                        PRIMARY KEY (pk),
                        UNIQUE KEY (col_int_key),
                        UNIQUE KEY (col_varchar_key),
                        UNIQUE KEY (col_date_key),
                        KEY (col_time_key),
                        KEY (col_datetime_key),
                        UNIQUE KEY (col_int_key, col_varchar_key),
                        KEY (col_int_key, col_int_nokey),
                        KEY(col_int_key,col_date_key),
                        KEY(col_int_key, col_time_key),
                        KEY(col_int_key, col_datetime_key),
                        UNIQUE
KEY(col_date_key,col_time_key,col_datetime_key),
                        UNIQUE KEY (col_varchar_key, col_varchar_nokey),
                        UNIQUE KEY (col_int_key, col_varchar_key,
col_date_key, col_time_key, col_datetime_key)
                )  AUTO_INCREMENT=10 ENGINE=INNODB;

INSERT /*! IGNORE */ INTO bb (
                                col_int_nokey,
                                col_date_nokey,
                                col_time_nokey,
                                col_datetime_nokey,
                                col_varchar_nokey
                        ) VALUES (0, '2003-08-04', '01:48:05.048577',
'2006-11-03 00:00:00', 'p'),(2, '2007-11-06', '00:00:00', '2009-11-26 19:28:11.005115', 'n');

CREATE TABLE cc (
                        pk INTEGER AUTO_INCREMENT,
                        col_int_nokey INTEGER /*! NULL */,
                        col_int_key INTEGER GENERATED ALWAYS AS
(col_int_nokey + col_int_nokey) VIRTUAL not null,

                        col_date_nokey DATE /*! NULL */,
                        col_date_key DATE GENERATED ALWAYS AS
(DATE_ADD(col_date_nokey,interval 30 day)) VIRTUAL not null,

                        col_datetime_nokey DATETIME /*! NULL */,
                        col_time_nokey TIME /*! NULL */,

                        col_datetime_key DATETIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,
                        col_time_key TIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,

                        col_varchar_nokey VARCHAR(1) /*! NULL */,
                        col_varchar_key VARCHAR(2) GENERATED ALWAYS AS
(CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,

                        PRIMARY KEY (pk),
                        UNIQUE KEY (col_int_key),
                        UNIQUE KEY (col_varchar_key),
                        UNIQUE KEY (col_date_key),
                        KEY (col_time_key),
                        KEY (col_datetime_key),
                        UNIQUE KEY (col_int_key, col_varchar_key),
                        KEY (col_int_key, col_int_nokey),
                        KEY(col_int_key,col_date_key),
                        KEY(col_int_key, col_time_key),
                        KEY(col_int_key, col_datetime_key),
                        UNIQUE
KEY(col_date_key,col_time_key,col_datetime_key),
                        UNIQUE KEY (col_varchar_key, col_varchar_nokey),
                        UNIQUE KEY (col_int_key, col_varchar_key,
col_date_key, col_time_key, col_datetime_key)
                )  AUTO_INCREMENT=10 ENGINE=INNODB;

INSERT /*! IGNORE */ INTO cc (
                                col_int_nokey,
                                col_date_nokey,
                                col_time_nokey,
                                col_datetime_nokey,
                                col_varchar_nokey
                        ) VALUES (172, '2009-04-23', '00:00:00', '2000-12-07 10:17:40.013275', 'h'),(NULL, '2002-10-06', '00:50:49.017545', NULL, 'm');

let $query=
SELECT
gp1 . col_datetime_key AS g1
FROM cc AS gp1 LEFT JOIN c AS gp2 ON ( gp2 . col_datetime_key <> gp1 .
col_time_nokey )
WHERE
gp1 . col_varchar_nokey IN
(
SELECT
DISTINCT p1 . col_varchar_key AS p1
FROM bb AS p1 LEFT JOIN bb AS p2
ON ( p1 . col_int_key = p2 . pk )
)
AND gp1 . col_varchar_nokey = 'b'
HAVING g1 > 6;

eval EXPLAIN $query;
eval $query;
DROP TABLE bb, c, cc;

--echo # Bug#21284646: Assertion !(table || table->read_set || bitmap_is_set())

CREATE TABLE c (
 pk INTEGER AUTO_INCREMENT,
 col_int_nokey INTEGER NOT NULL,
 col_int_key INTEGER GENERATED ALWAYS AS (col_int_nokey + col_int_nokey) VIRTUAL not null,
 col_date_nokey DATE NOT NULL,
 col_date_key DATE GENERATED ALWAYS AS (DATE_ADD(col_date_nokey,interval 30 day)) VIRTUAL not null,
 col_datetime_nokey DATETIME NOT NULL,
 col_time_nokey TIME NOT NULL,
 col_datetime_key DATETIME GENERATED ALWAYS AS (ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,
 col_time_key TIME GENERATED ALWAYS AS (ADDTIME(col_datetime_nokey, col_time_nokey)) VIRTUAL not null,
 col_varchar_nokey VARCHAR(1) NOT NULL,
 col_varchar_key VARCHAR(2) GENERATED ALWAYS AS (CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,
 PRIMARY KEY (pk,col_int_nokey),
 UNIQUE KEY (col_int_key),
 UNIQUE KEY (col_varchar_key),
 UNIQUE KEY (col_date_key),
 KEY (col_time_key),
 KEY (col_datetime_key),
 UNIQUE KEY (col_int_key, col_varchar_key),
 KEY (col_int_key, col_int_nokey),
 KEY(col_int_key,col_date_key),
 KEY(col_int_key, col_time_key),
 KEY(col_int_key, col_datetime_key),
 UNIQUE KEY (col_date_key,col_time_key,col_datetime_key),
 UNIQUE KEY (col_varchar_key, col_varchar_nokey),
 UNIQUE KEY (col_int_key, col_varchar_key, col_date_key, col_time_key, col_datetime_key)
)  ENGINE=INNODB;

INSERT INTO c (col_int_nokey, col_date_nokey, col_time_nokey, col_datetime_nokey, col_varchar_nokey) VALUES
(1, '2009-12-01', '00:21:38.058143', '2007-05-28 00:00:00', 'c'),
(8, '2004-12-17', '04:08:02.046897', '2009-07-25 09:21:20.064099', 'm'),
(9, '2000-03-14', '16:25:11.040240', '2002-01-16 00:00:00', 'd'),
(6, '2006-05-25', '19:47:59.011283', '2001-02-15 03:08:38.035426', 'y'),
(2, '2002-10-13', '00:00:00', '1900-01-01 00:00:00', 's'),
(4, '1900-01-01', '15:57:25.019666', '2005-08-15 00:00:00', 'r');

ANALYZE TABLE c;
let $query=
SELECT COUNT(DISTINCT col_varchar_key) AS x
FROM c
WHERE col_varchar_key IN ('rr', 'rr') OR
      col_int_nokey <> 9 AND
      pk >= 8
HAVING x > '2000-02-06'
ORDER BY col_time_nokey, pk;

eval explain $query;
eval $query;

DROP TABLE c;

--echo # Bug#21341044: Conditional jump at sort_param::make_sort_key

CREATE TABLE t1 (
 pk INTEGER AUTO_INCREMENT,
 col_int_nokey INTEGER /*! NULL */,
 col_int_key INTEGER GENERATED ALWAYS AS (col_int_nokey + col_int_nokey) VIRTUAL,
 col_blob_nokey BLOB /*! NULL */,
 col_blob_key BLOB GENERATED ALWAYS AS (REPEAT(col_blob_nokey,15)) VIRTUAL,
 col_longblob_nokey LONGBLOB /*! NULL */,
 col_longtext_nokey LONGTEXT /*! NULL */,
 col_longblob_key LONGBLOB GENERATED ALWAYS AS (REPEAT(col_longblob_nokey, 20)) VIRTUAL,
 col_longtext_key LONGTEXT GENERATED ALWAYS AS (REPEAT(col_longblob_nokey, 18)) VIRTUAL,
 col_text_nokey TEXT /*! NULL */,
 col_text_key TEXT GENERATED ALWAYS AS (REPEAT(col_text_nokey, 30)) VIRTUAL,
 PRIMARY KEY (pk),
 KEY (col_int_key),
 KEY (col_text_key(50)),
 KEY (col_blob_key(200)),
 KEY (col_longtext_key(200)),
 KEY (col_longblob_key(200)),
 KEY (col_int_key, col_text_key(100)),
 KEY (col_int_key, col_longtext_key(100)),
 KEY (col_int_key, col_blob_key(100)),
 KEY (col_int_key, col_longblob_key(100)),
 KEY (col_longtext_key(10), col_longblob_key(100)),
 KEY (col_int_key, col_text_key(10), col_blob_key(100), col_longtext_key(50), col_longblob_key(50))
) engine=innodb;

INSERT INTO t1 (col_int_nokey,col_blob_nokey,col_longtext_nokey,col_longblob_nokey,col_text_nokey)
VALUES
(0, 'ijcszxw', 'ijcszxw', 'ijcszxw', 'ijcszxw'),
(5, 'jcszxwb', 'jcszxwb', 'jcszxwb', 'jcszxwb'),
(4, 'cszxwbjjvv', 'cszxwbjjvv', 'cszxwbjjvv', 'cszxwbjjvv'),
(3, 'szxw', 'szxw', 'szxw', 'szxw'),
(7, 'zxwb', 'zxwb', 'zxwb', 'zxwb'),
(42, 'xwbjjvvky', 'xwbjjvvky', 'xwbjjvvky', 'xwbjjvvky'),
(142, 'wbjj', 'wbjj', 'wbjj', 'wbjj'),
(5, 'bjjv', 'bjjv', 'bjjv', 'bjjv'),
(0, 'jjvvkymalu', 'jjvvkymalu', 'jjvvkymalu', 'jjvvkymalu'),
(3, 'j', 'j', 'j', 'j');

SELECT alias1.pk AS field1
FROM t1 AS alias1 LEFT OUTER JOIN t1 AS alias2
     ON alias1.col_int_key = alias2.col_int_key
WHERE alias2.col_int_key BETWEEN 8 AND (8 + 1 ) OR
      alias2.col_int_key  BETWEEN 8 AND (8 + 5 ) AND
      alias2.col_int_key != 20 OR
      alias2.col_int_key IN (8, 5, 8) AND
      alias2.col_int_key >= 0 AND
      alias2.col_int_key <= ( 8 + 75 ) AND
      alias1.pk IS NOT NULL
ORDER BY field1;

DROP TABLE t1;
--echo # bug#21487651: gcols: memory leak after failed alter table
CREATE TABLE t(a int);
ALTER TABLE t ADD COLUMN b int GENERATED ALWAYS AS (
date_sub(a,interval a month)) VIRTUAL;
--error 1111
ALTER TABLE t ADD COLUMN c int GENERATED ALWAYS AS (sum(a));
DROP TABLE t;

--echo #
--echo # Bug#21628840: CRASH/MEMORY CORRUPTION ADDING INDEXES TO VIRTUAL COLUMN
--echo #               (II)
--echo #
CREATE TABLE t1( a INT ) ENGINE = INNODB;
INSERT INTO t1( a ) VALUES ( 1 ), ( 2 ), ( 3 ), ( 4 ), ( 5 );

ALTER TABLE t1 ADD COLUMN b INT GENERATED ALWAYS AS (a - 1) STORED;
ALTER TABLE t1 ADD COLUMN c INT GENERATED ALWAYS AS (b + 1) VIRTUAL;

--echo # Used to cause valgrind warning.
ALTER TABLE t1 ADD INDEX( c );

ANALYZE TABLE t1;

--echo # Make sure the index is correct. That's kinda important.
EXPLAIN
SELECT c FROM t1;
SELECT c FROM t1;

DROP TABLE t1;

--echo #
--echo # Bug#21797776 ASSERTION `BIT < MAP->N_BITS' FAILED.
--echo #

CREATE TABLE C (
col_int_1 INT,
col_int_2 INT GENERATED ALWAYS AS (col_int_1 + col_int_1) STORED,
col_int_3 INT GENERATED ALWAYS AS (col_int_2 + col_int_1) VIRTUAL
);

CREATE ALGORITHM=TEMPTABLE VIEW v1 AS
 SELECT
 col_int_2 AS field1, col_int_2 AS field2,
 col_int_3 AS field3, col_int_3 AS field4
 FROM C;

SELECT * FROM v1;

DROP TABLE C;
DROP VIEW v1;

--echo #
--echo # Bug#21613615 GCOLS: ASSERTION FAILED: !TABLE || (!TABLE->READ_SET || BITMAP_IS_SET
--echo #

CREATE TABLE t (a INT);
CREATE TABLE v (
a INT,
c INT,
b CHAR(2) GENERATED ALWAYS AS (a IN (1)) VIRTUAL,
KEY(c,b(1)));
INSERT INTO v (a,c) VALUES (1,1);

let $query=
SELECT 1 FROM t WHERE ( SELECT 1 FROM t ) >=ANY( SELECT c FROM v );
eval EXPLAIN $query;
eval $query;

# A similar one:
let $query=
SELECT (SELECT MAX(c) FROM v);
eval EXPLAIN $query;
eval $query;

DROP TABLE t, v;

CREATE TABLE v (
a INT,
c INT,
b CHAR(2) GENERATED ALWAYS AS (a IN (1)) VIRTUAL, KEY(c,b(1)));
INSERT INTO v (a,c) VALUES (1,1);
SELECT MAX(c), COUNT(b) FROM v;
DROP TABLE v;

# Using PK suffix of secondary index
CREATE TABLE v (
a INT PRIMARY KEY,
b INT, KEY(b));
INSERT INTO v (a,b) VALUES (1,1);
SELECT MAX(a) FROM v WHERE b=1;
DROP TABLE v;

--echo #
--echo # Bug#21824519: ASSERTION IN DROP TRIGGER WHEN TABLE HAS
--echo #               VIRTUAL GENERATED COLUMN
--echo #
CREATE TABLE t (a INT, b INT GENERATED ALWAYS AS (a) VIRTUAL);
CREATE TRIGGER tr BEFORE INSERT ON t FOR EACH ROW BEGIN END;
INSERT INTO t (a) VALUES (1);
SELECT * FROM t;
# DROP TRIGGER used to hit a DBUG_ASSERT.
DROP TRIGGER tr;
SELECT * FROM t;
CREATE FUNCTION f() RETURNS INT RETURN (SELECT COUNT(*) FROM t);
# And this function call hit the same DBUG_ASSERT.
SELECT f();
DROP FUNCTION f;
SELECT * FROM t;
DROP TABLE t;

--echo #
--echo # Bug#21833760 CALC_DAYNR: ASSERTION `DELSUM+(INT) Y/4-TEMP >= 0' FAILED.
--echo #

CREATE TABLE C(
c1 INT AUTO_INCREMENT,
c8 DATETIME,
c9 TIME,
c11 TIME GENERATED ALWAYS AS(ADDTIME(c8,c9)) VIRTUAL,
c13 TIME GENERATED ALWAYS AS(ADDTIME(c8,c11)) VIRTUAL,
PRIMARY KEY(c1),
UNIQUE KEY(c13)
);

INSERT INTO C (c8,c9) VALUES('1970-01-01',0),('1970-01-01',1);

CREATE VIEW view_C AS SELECT * FROM C;

--sorted_result
SELECT /*+ NO_BNL(t1) */ t1.c13 FROM C AS t2 STRAIGHT_JOIN C AS t1 FORCE INDEX(c13);
--sorted_result
SELECT DISTINCT t1.c13 FROM C AS t1, view_C AS t2;

DROP TABLE C;
DROP VIEW view_C;

--echo #
--echo # Bug #21808680: JSON + GENERATED COLUMN CORRUPTS TABLE CACHE
--echo #                MEMORY, CRASHES
--echo #
CREATE TABLE t (a INT, b JSON, c TEXT GENERATED ALWAYS AS (REPEAT(a=b, 2)));
INSERT INTO t (a, b) VALUES (1, '2'), (3, '3');
# The next statement used to crash.
SELECT * FROM t;
DROP TABLE t;

--echo #
--echo # Bug#21810529: CRASH IN ITEM_FUNC::WALK WHEN CODE JUMPS TO GARBAGE
--echo # LOCATION
--echo #
CREATE TABLE t (a TIME,b INT GENERATED ALWAYS AS (a=1) VIRTUAL);
--error ER_BAD_FIELD_ERROR 
ALTER TABLE t CHANGE COLUMN q w INT;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t CHANGE COLUMN q w INT;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t CHANGE COLUMN q w INT;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t CHANGE COLUMN q w INT;
DROP TABLE t;

--echo #
--echo # Bug#21940542 TOO MUCH SPAM: INNODB: COMPUTE VIRTUAL COLUMN VALUES FAILED
--echo #

CREATE TABLE t(b BLOB);
--error ER_GENERATED_COLUMN_ROW_VALUE
ALTER TABLE t ADD COLUMN c INT GENERATED ALWAYS AS ((1,1)) VIRTUAL;
DROP TABLE t;
--error ER_GENERATED_COLUMN_ROW_VALUE
CREATE TABLE t(b BLOB, c INT GENERATED ALWAYS AS ((1,1)) VIRTUAL);

--echo #
--echo # Bug#21929967 GCOLS: GCOL VALUE CHANGES WHEN SESSION CHANGES SQL_MODE
--echo #

CREATE TABLE t1(a CHAR(1), b CHAR(1), c CHAR(2) AS (a || b));
SHOW CREATE TABLE t1;
INSERT INTO t1 (a,b) VALUES('1','1');
SELECT * FROM t1;
SET SQL_MODE=PIPES_AS_CONCAT;
SELECT * FROM t1;
FLUSH TABLES;
SELECT * FROM t1;
DROP TABLE t1;
# The other way around:
CREATE TABLE t1(a CHAR(1), b CHAR(1), c CHAR(2) AS (a || b));
SHOW CREATE TABLE t1;
INSERT INTO t1 (a,b) VALUES('1','1');
SELECT * FROM t1;
SET SQL_MODE=DEFAULT;
SELECT * FROM t1;
FLUSH TABLES;
SELECT * FROM t1;
DROP TABLE t1;

--echo # Bug#22018999: gcols: assertion failed: !error

SET @save_old_sql_mode= @@sql_mode;
SET sql_mode="";

--error ER_TRUNCATED_WRONG_VALUE
CREATE TABLE t (a INTEGER AS (SUBSTR('','a',1))) engine=innodb;

CREATE TABLE t (a INTEGER) engine=innodb;

--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t ADD b INTEGER AS (SUBSTR('','a',1));

DROP TABLE t;

set sql_mode= @save_old_sql_mode;

--echo #
--echo # Bug#22157531 WITH NO MORE .FRM 64K LIMIT WE CAN CREATE MASSIVE TABLES,
--echo #              BUT TOO SLOWLY..
--echo #

set @s:=concat("CREATE TABLE t(a LONGBLOB GENERATED ALWAYS AS
('",REPEAT("a",1024*1024),"') STORED) ENGINE=INNODB;");
PREPARE r FROM @s;
EXECUTE r;
DEALLOCATE PREPARE r;

DROP TABLE t;

--echo #
--echo # Bug#22239803 WITH NO MORE .FRM 64K LIMIT WE CAN CREATE MASSIVE TABLES,
--echo #              BUT TOO SLOW (II)
--echo #

set @s:=concat("CREATE TABLE t(w INT, A INT GENERATED ALWAYS
AS('",REPEAT("\\0",1024*1024),"') STORED) ENGINE=INNODB;");
PREPARE r FROM @s;
EXECUTE r;
DEALLOCATE PREPARE r;

DROP TABLE t;

--echo # Bug#21875520 Problems with virtual column indexes

CREATE TABLE t(
  a TIMESTAMP,
  b BLOB,
  c TIMESTAMP GENERATED ALWAYS AS (GREATEST(a, '2000-01-01 00:00:00')) VIRTUAL,
  UNIQUE KEY(c)
);
INSERT INTO t(b) VALUES ('');
UPDATE t SET a='2001-01-01 00:00:00';
SELECT c FROM t;
SELECT c, a FROM t;
UPDATE t SET b='xyz';
DO (SELECT @c1:= c FROM t);
DO (SELECT (@c2:= c) - a FROM t);
SELECT @c2 - @c1;

DROP TABLE t;

--echo #
--echo # Bug#22133710 GCOLS: READ UNCOMMITTED: ASSERT !TABLE || (!TABLE->WRITE_SET || BITMAP_IS_SET(TA
--echo #

CREATE TABLE t (
  a INT,
  b INT GENERATED ALWAYS AS (1) VIRTUAL,
  c INT GENERATED ALWAYS AS (1) VIRTUAL,
  d INT GENERATED ALWAYS AS (1) VIRTUAL,
  KEY (b,d)
) ENGINE=INNODB;
INSERT INTO t VALUES();
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
SELECT 1 FROM t WHERE c GROUP BY b;
COMMIT;
DROP TABLE t;

--echo #
--echo # bug#21982792: TOO MUCH SPAM: 'GOT ERROR 1 WHEN READING TABLE'
--echo #
CREATE TABLE t (
  a INT GENERATED ALWAYS AS (1) VIRTUAL NOT NULL,
  b DATE GENERATED ALWAYS AS (1) VIRTUAL NOT NULL,
  KEY(b)
 );
SET @old_sql_mode=@@sql_mode;
SET sql_mode='';
INSERT INTO t VALUES();
SET sql_mode= STRICT_ALL_TABLES;
--error ER_TRUNCATED_WRONG_VALUE
DELETE d2 FROM t AS d1, t AS d2 WHERE d1.a = d2.b;
DROP TABLE t;
SET sql_mode=@old_sql_mode;

CREATE TABLE t (
  a INT,
  b INT GENERATED ALWAYS AS (1),
  KEY i(a,b)
  );
INSERT INTO t (a) VALUES(1), (2);
--error ER_SUBQUERY_NO_1_ROW
SELECT 1 FROM t a RIGHT JOIN t USING(b)
WHERE 1 NOT LIKE(SELECT a FROM t WHERE a.b);
DROP TABLE t;

--echo # Bug#22748217 gcols: assert in Item_func_in::resolve_type

SET @old_sql_mode= @@sql_mode;
SET sql_mode="";
CREATE TABLE t (a TIMESTAMP AS (0) VIRTUAL) engine=innodb;
--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t ADD COLUMN b JSON AS (a NOT IN (1,1)) STORED;
DROP TABLE t;
SET sql_mode= @old_sql_mode;


--echo #
--echo # Bug#22987899: ALTER TABLE MODIFY COLUMN DOES NOT SET
--echo #               ALTER_CHANGE_COLUMN_DEFAULT FLAG
--echo #

CREATE TABLE t1(
  a INTEGER DEFAULT 5,
  b INTEGER NOT NULL,
  gc1 INTEGER AS (a + DEFAULT(a)) VIRTUAL,
  gc2 INTEGER AS (a + DEFAULT(a)) STORED,
  KEY k1(gc1)
);

INSERT INTO t1(a, b) VALUES (1 ,1);
SELECT * FROM t1;
SELECT gc1 FROM t1;

# Test 1: Change the default value for a column, this should trigger rebuild

# Check how many rows are accessed: >0 = COPY
--enable_info
ALTER TABLE t1 MODIFY COLUMN a INT DEFAULT 6;
--disable_info
SELECT * FROM t1;
SELECT gc1 FROM t1;

# Test 2: Change the NULL property for a column, should not trigger rebuild

# Check how many rows are accessed: >0 = COPY
--enable_info
ALTER TABLE t1 MODIFY COLUMN b INTEGER NULL;
--disable_info
SELECT * FROM t1;
SELECT gc1 FROM t1;

DROP TABLE t1;

--echo #
--echo # Bug#22991924 GCOLS: UTF16 STRING OPERATIONS GIVE DOUBLED \0\0 STRINGS
--echo # ON EACH TABLE REBUILD
--echo #
CREATE TABLE t1 (
  a TEXT CHARSET utf16,
  b BLOB GENERATED ALWAYS AS ( concat( 'ABC', a ) ) VIRTUAL
);

--echo # Results change due to bug fix.
INSERT INTO t1 ( a ) VALUES ( 'abc' );

SHOW CREATE TABLE t1;
SELECT HEX(b) FROM t1;
OPTIMIZE TABLE t1;
SELECT HEX(b) FROM t1;
SHOW CREATE TABLE t1;


SELECT
  length( convert( b USING utf8 ) ),
  char_length ( convert( b USING utf8 ) )
FROM t1;

SELECT
  length( convert( b USING utf16 ) ),
  char_length ( convert( b USING utf16 ) )
FROM t1;

SELECT
  length( convert( b USING latin1 ) ),
  char_length ( convert( b USING latin1 ) )
FROM t1;

DROP TABLE t1;

--echo #
--echo # Bug#25615803: ASSERT IN SQL/FIELD.CC:...
--echo #               VIRTUAL STRING* FIELD_VARSTRING::VAL_STR
--echo #
CREATE TABLE t1 (
  a INT,
  b INT,
  c INT,
  d INT GENERATED ALWAYS AS ( b + 1 ) STORED
)
PARTITION BY RANGE( a ) ( PARTITION p0 VALUES LESS THAN (1) );

INSERT INTO t1 ( b ) VALUES ( 1 );
UPDATE t1 SET c = d;

DROP TABLE t1;

--echo #
--echo # Bug #25793677 INNODB: FAILING ASSERTION: CLUST_TEMPL_FOR_SEC || LEN ....
--echo #

CREATE TABLE v (
a INT,
c INT,
b CHAR(2) GENERATED ALWAYS AS (a IN (1)) VIRTUAL,
KEY(c,b(1))) charset utf8mb4;
INSERT INTO v (a,c) VALUES (1,1);
SELECT (SELECT MAX(c) FROM v);
DROP TABLE v;

--echo # Bug#23021693 gcol:assertion '!table->in_use->is_error()' failed

CREATE TABLE t1 (
 pk INTEGER AUTO_INCREMENT,
 c1 INTEGER,
 gc1 INTEGER GENERATED ALWAYS AS (c1+c1) VIRTUAL,
 gc2 INTEGER GENERATED ALWAYS AS (gc1 + c1) VIRTUAL,
 c2 VARCHAR(5),
 gc3 VARCHAR(10) GENERATED ALWAYS AS (CONCAT(c2, c2)) VIRTUAL,
 gc4 VARCHAR(10) GENERATED ALWAYS AS (CONCAT(gc3, 'x')) VIRTUAL,
 PRIMARY KEY (pk DESC),
 KEY(gc1),
 KEY(gc3),
 UNIQUE KEY (gc1, gc3),
 UNIQUE KEY (gc2, gc4)
)  ENGINE=InnoDB;

INSERT INTO t1 (c1, c2) VALUES (3, 'cek'),(3,'eks');

CREATE TABLE t2 (
 pk INTEGER AUTO_INCREMENT,
 c1 INTEGER,
 gc1 INTEGER GENERATED ALWAYS AS (c1 + c1) VIRTUAL,
 gc2 INTEGER GENERATED ALWAYS AS (gc1 + c1) VIRTUAL,
 c2 VARCHAR(5),
 gc3 VARCHAR(10) GENERATED ALWAYS AS (CONCAT(c2, c2)) VIRTUAL,
 gc4 VARCHAR(10) GENERATED ALWAYS AS (CONCAT(gc3, 'x')) VIRTUAL,
 PRIMARY KEY (pk DESC),
 KEY(gc1),
 KEY(gc3),
 UNIQUE KEY (gc1, gc3),
 UNIQUE KEY (gc2, gc4)
)  ENGINE=InnoDB;

INSERT INTO t2 (c1, c2) VALUES
 (3, 'ksa'), (6,'sate'), (3, 'a'), (NULL, 't'), (9, 'efq'),
 (NULL, 'f'), (6, 'qsdk'), (63, NULL), (3, 's'), (1,NULL);

--skip_if_hypergraph  # Chooses a different plan and does not evaluate the subquery.
--error ER_SUBQUERY_NO_1_ROW
DELETE outr1.*
FROM t2 AS outr1 INNER JOIN t1 AS outr2
     ON outr1.gc4 = outr2.gc4
WHERE outr1.pk > (SELECT innr1.gc2 AS y
                  FROM t1 AS innr1
                  WHERE innr1.pk = 5 OR outr2.pk <> 7
                 );

DROP TABLE t1, t2;

--echo #
--echo # Bug#23321196: GCOLS: ASSERTION FAILURE:
--echo #               DFIELD_IS_NULL(DFIELD2) || DFIELD2->DATA
--echo #
CREATE TABLE t(gc TEXT GENERATED ALWAYS AS (NULL) NOT NULL, KEY (gc(1)));
INSERT IGNORE INTO t VALUES ();
SELECT * FROM t;
DELETE FROM t;
SELECT * FROM t;
DROP TABLE t;

--echo #
--echo # Bug #27041382: ASSERTION `!TABLE->IN_USE->IS_ERROR()' FAILED.
--echo #

CREATE TABLE t1 (c1 VARCHAR(100),
                 c2 VARCHAR(400) GENERATED ALWAYS AS (CONCAT(c1,c1)));

CREATE TRIGGER trg1 BEFORE INSERT ON t1
 FOR EACH ROW INSERT/*!INTO*/t1 VALUES (1);

--error ER_PARSE_ERROR
INSERT INTO t1  VALUES (),();

--error ER_PARSE_ERROR
INSERT INTO t1(c1)  SELECT 1 FROM DUAL;

--error ER_PARSE_ERROR
LOAD DATA INFILE '../../std_data/loaddata5.dat'
 INTO TABLE t1 FIELDS TERMINATED BY '' ENCLOSED BY '' (c1) ;

DROP TABLE t1;

--echo #
--echo # Bug#27452082 ASSERTION FAILED: !TABLE->IN_USE->IS_ERROR() IN UPDATE_GENERATED_READ_FIELDS
--echo #

CREATE TABLE t (
  a INT,
  b INT GENERATED ALWAYS AS (MAKETIME(1,1,1)) STORED,
  KEY (a)
);
INSERT INTO t (a) VALUES (32767),(-1);
--error ER_DATA_OUT_OF_RANGE
SELECT * FROM t WHERE a>-19106 AND a-0x4d;
DROP TABLE t;

--echo #
--echo # Bug#27954073 ASSERTION FAILED: !TABLE || (!TABLE->WRITE_SET || BITMAP_IS_SET
--echo #

# Row-based binary logging adds all columns to TABLE::write_set,
# masking the problem, so we turn it off:

SET BINLOG_FORMAT=STATEMENT;

CREATE TABLE t(
 a INT,
 b INT GENERATED ALWAYS AS (0) VIRTUAL NOT NULL,
 KEY (a)
) ENGINE=INNODB PARTITION BY KEY(b) PARTITIONS 2;

INSERT INTO t(a) VALUES(1),(1),(1),(1);

# This used to cause the assertion failure:
DELETE FROM t WHERE a=1;

DROP TABLE t;

SET BINLOG_FORMAT=DEFAULT;

--echo #
--echo # Bug #28652826  THE CONTINUATION OF BUG 27968952 .. CRASH & CORRUPTION
--echo # WITH GCOLS
--echo #

CREATE TABLE t(
  a INT NOT NULL,
  b INT NOT NULL,
  c INT NOT NULL,
  g MEDIUMTEXT GENERATED ALWAYS AS((a <> b)) VIRTUAL,
  UNIQUE KEY i0000 (a),
  UNIQUE KEY i0001 (g(78))
) ENGINE=INNODB;
REPLACE INTO t(a, b, c) VALUES (1,8,9);
REPLACE INTO t(a, b, c) VALUES (0,0,10);
REPLACE INTO t(a, b, c) VALUES (4,4,11);
REPLACE INTO t(a, b, c) VALUES (0,7,12);
REPLACE INTO t(a, b, c) VALUES (0,0,13);
SELECT * FROM t;
DROP TABLE t;

--echo #
--echo # Bug #28772251 "SWAPPING COLUMN BY ALTER TABLE RENAME COLUMN BREAKS
--echo #                STORED GENERATED COLUMN".
--echo #

--echo #
--echo # 0) Original test case.
--echo #
CREATE TABLE t1 (a INT, b INT, gcol INT AS (a + 1) STORED);
SHOW CREATE TABLE t1;
INSERT INTO t1 (a, b) VALUES (1, 2);
SELECT * FROM t1;
--echo # We block renaming of columns on which generated columns depend.
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a;
--echo # However, it is OK to rename such column in dependent expression
--echo # is redefined in the same ALTER TABLE.
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, MODIFY gcol INT AS (a + 1) STORED;
SHOW CREATE TABLE t1;
--echo # Check that generated column value reflect the fact that columns
--echo # were swapped.
SELECT * FROM t1;
--echo # Similarly, we disallow replacement (via DROP + ADD) of columns on
--echo # which generated columns depend. Replacement is allowed if
--echo # dependent expression is updated within the same ALTER.
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 3;
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 3, MODIFY gcol INT AS (a + 1) STORED;
SHOW CREATE TABLE t1;
--echo # Check that generated column value reflect the fact that column
--echo # was replaced.
SELECT * FROM t1;
DROP TABLE t1;

--echo #
--echo # More systematic test coverage.
--echo #
--echo # 1) Renaming columns on which generated columns depend.
--echo #
--echo # 1.1) Renaming column on which generated column depends is
--echo #      prohibited (for both stored and virtual columns).
CREATE TABLE t1 (a INT, gcol INT AS (a + 1) STORED);
CREATE TABLE t2 (a INT, gcol INT AS (a + 1) VIRTUAL);
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 RENAME COLUMN a TO b;
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t2 RENAME COLUMN a TO b;
--echo # Cases when rename happens through CHANGE COLUMN are also detected.
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 CHANGE COLUMN a b INT;
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t2 CHANGE COLUMN a b INT;
--echo #
--echo # 1.2) It is OK to rename such columns if dependent generated column
--echo #      is dropped in the same ALTER.
ALTER TABLE t1 RENAME COLUMN a TO b, DROP COLUMN gcol;
ALTER TABLE t2 RENAME COLUMN a TO b, DROP COLUMN gcol;
--echo # This works even if dropped column comes earlier than renamed column.
ALTER TABLE t1 ADD gcol INT AS (b + 1) STORED FIRST;
ALTER TABLE t2 ADD gcol INT AS (b + 1) VIRTUAL FIRST;
ALTER TABLE t1 DROP COLUMN gcol, RENAME COLUMN b TO c;
ALTER TABLE t2 DROP COLUMN gcol, RENAME COLUMN b TO c;
--echo #
--echo # 1.3) It is also OK to rename such columns if dependent generated
--echo #      column expression is updated/redefined.
ALTER TABLE t1 ADD COLUMN gcol INT AS (c + 1) STORED;
ALTER TABLE t2 ADD COLUMN gcol INT AS (c + 1) VIRTUAL;
ALTER TABLE t1 RENAME COLUMN c TO d, MODIFY gcol INT AS (d + 1) STORED;
ALTER TABLE t2 RENAME COLUMN c TO d, MODIFY gcol INT AS (d + 1) VIRTUAL;
--echo # And again this works even if generated column comes earlier than
--echo # renamed column.
ALTER TABLE t1 DROP COLUMN gcol, ADD COLUMN gcol INT AS (d + 1) STORED FIRST;
ALTER TABLE t2 DROP COLUMN gcol, ADD COLUMN gcol INT AS (d + 1) VIRTUAL FIRST;
ALTER TABLE t1 MODIFY gcol INT AS (e + 1) STORED, RENAME COLUMN d TO e;
ALTER TABLE t2 MODIFY gcol INT AS (e + 1) VIRTUAL, RENAME COLUMN d TO e;
--echo # If updated expression uses wrong column name, error is reported.
--echo # Note that error code and message are different because technically
--echo # it is issue with new generation expression.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 MODIFY gcol INT AS (e + 1) STORED, RENAME COLUMN e TO f;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t2 MODIFY gcol INT AS (e + 1) VIRTUAL, RENAME COLUMN e TO f;
DROP TABLES t1, t2;
--echo #
--echo # 1.4) Complex case. Renaming of columns which causes generated
--echo #      column re-evaluation.
CREATE TABLE t1 (a INT, b INT, gcol INT AS (a + 10) STORED);
INSERT INTO t1 (a, b) VALUES (1, 2), (3, 4), (5, 6);
CREATE TABLE t2 (a INT, b INT, gcol INT AS (a + 10) VIRTUAL, KEY(gcol));
INSERT INTO t2 (a, b) VALUES (1, 2), (3, 4), (5, 6);
--echo # We block simple renaming of columns even if dependent generation
--echo # expression stays valid. This is intentional -- we want user to
--echo # realize and explicitly confirm what is done (in most cases such
--echo # rename is likely to be an error).
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a;
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t2 RENAME COLUMN a TO b, RENAME COLUMN b TO a;
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, MODIFY gcol INT AS (a + 10) STORED;
ALTER TABLE t2 RENAME COLUMN a TO b, RENAME COLUMN b TO a, MODIFY gcol INT AS (a + 10) VIRTUAL;
--echo # Contents of generated column should be updated accordingly.
SELECT * FROM t1;
SELECT * FROM t2;
SELECT * FROM t2 WHERE gcol = 14;
--echo # Such ALTER TABLEs are not inplace/instant due to generated
--echo # column re-evaluation.
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, MODIFY gcol INT AS (a + 10) STORED, ALGORITHM=INPLACE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t2 RENAME COLUMN a TO b, RENAME COLUMN b TO a, MODIFY gcol INT AS (a + 10) VIRTUAL, ALGORITHM=INPLACE;
DROP TABLES t1, t2;

--echo #
--echo # 2) Renaming columns on which generated default depends.
--echo #
--echo # 2.1) Renaming column on which generated default depends is
--echo #      prohibited.
CREATE TABLE t1 (a INT, def INT DEFAULT (a + 1));
--error ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE
ALTER TABLE t1 RENAME COLUMN a TO b;
--echo # Cases when rename happens through CHANGE COLUMN are also detected.
--error ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE
ALTER TABLE t1 CHANGE COLUMN a b INT;
--echo #
--echo # 2.2) It is OK to rename such columns if dependent generated default
--echo #      is dropped:
--echo #
--echo #      a) By dropping column
ALTER TABLE t1 RENAME COLUMN a TO b, DROP COLUMN def;
--echo #      b) By dropping default using DROP DEFAULT
ALTER TABLE t1 ADD COLUMN def INT DEFAULT (b + 1);
ALTER TABLE t1 RENAME COLUMN b TO c, ALTER COLUMN def DROP DEFAULT;
--echo #      c) By dropping default using CHANGE/MODIFY COLUMN
ALTER TABLE t1 MODIFY COLUMN def INT DEFAULT (c + 1);
ALTER TABLE t1 RENAME COLUMN c TO d, MODIFY COLUMN def INT;
--echo # This works even if column with generated default comes earlier than
--echo # renamed column.
ALTER TABLE t1 DROP COLUMN def, ADD COLUMN def INT DEFAULT (d + 1) FIRST;
ALTER TABLE t1 DROP COLUMN def, RENAME COLUMN d TO e;
ALTER TABLE t1 ADD COLUMN def INT DEFAULT (e + 1) FIRST;
ALTER TABLE t1 ALTER COLUMN def DROP DEFAULT, RENAME COLUMN e TO f;
ALTER TABLE t1 MODIFY COLUMN def INT DEFAULT (f + 1);
ALTER TABLE t1 MODIFY COLUMN def INT, RENAME COLUMN f TO g;
DROP TABLE t1;
--echo #
--echo # 2.3) It is also OK to rename such columns if dependent generated
--echo #      default value is updated/redefined:
--echo #
--echo #      a) Using SET DEFAULT
CREATE TABLE t1 (a INT, def INT DEFAULT (a + 1));
ALTER TABLE t1 RENAME COLUMN a TO b, ALTER COLUMN def SET DEFAULT (b + 1);
--echo #      b) Using MODIFY/CHANGE column
ALTER TABLE t1 RENAME COLUMN b TO c, MODIFY COLUMN def INT DEFAULT (c + 1);
--echo # And again this works even if generated default comes earlier than
--echo # renamed column.
ALTER TABLE t1 DROP COLUMN def, ADD COLUMN def INT DEFAULT (c + 1) FIRST;
ALTER TABLE t1 ALTER COLUMN def SET DEFAULT (d + 1), RENAME COLUMN c TO d;
ALTER TABLE t1 MODIFY COLUMN def INT DEFAULT (e + 1), RENAME COLUMN d TO e;
--echo # If updated expression uses wrong column name, error is reported.
--echo # Again, error code and message are different because technically
--echo # it is issue with new generated default.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 MODIFY def INT DEFAULT (e + 1), RENAME COLUMN e TO f;
DROP TABLES t1;
--echo #
--echo # 2.4) Complex case. Swapping of columns on which generated
--echo #      default depends.
CREATE TABLE t1 (a INT, b INT, def INT DEFAULT (a));
INSERT INTO t1 (a, b) VALUES (1, 2);
--echo # Similarly to the above we block simple renaming of columns even
--echo # if dependent default expression stays valid. This is intentional
--echo # -- we want user to realize and explicitly confirm what is done
--echo # (in most cases such rename is likely to be an error).
--error ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a;
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, ALTER COLUMN def SET DEFAULT (a);
--echo # Old rows should stay the same, new default will only affect new rows.
INSERT INTO t1 (a, b) VALUES (3, 4);
SELECT * FROM t1;
--echo # Unlike for generated columns case, such ALTER TABLE can be done
--echo # inplace, since it doesn't affect table data.
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, ALTER COLUMN def SET DEFAULT (a), ALGORITHM=INPLACE;
DROP TABLES t1;

--echo #
--echo # 3) Renaming columns on which functional index depends.
--echo #
--echo # 3.1) Renaming column on which functional index depends is
--echo #      prohibited.
CREATE TABLE t1 (a INT, KEY fi((a + 1)));
--error ER_DEPENDENT_BY_FUNCTIONAL_INDEX
ALTER TABLE t1 RENAME COLUMN a TO b;
--echo # Cases when rename happens through CHANGE COLUMN are also detected.
--error ER_DEPENDENT_BY_FUNCTIONAL_INDEX
ALTER TABLE t1 CHANGE COLUMN a b INT;
--echo #
--echo # 3.2) It is OK to rename such columns if dependent index is dropped.
ALTER TABLE t1 RENAME COLUMN a TO b, DROP KEY fi;
--echo # This works even if hidden column for functional index processed
--echo # earlier than renamed column.
ALTER TABLE t1 ADD KEY fi ((b + 1));
--echo # Move column 'b' to the table's end first.
ALTER TABLE t1 ADD c INT;
ALTER TABLE t1 MODIFY b INT AFTER c;
ALTER TABLE t1 DROP KEY fi, RENAME COLUMN b TO d;
--echo #
--echo # Note that the only way to update/redefine functional index is to
--echo # drop and re-create it. So the this section also covers the case
--echo # when functional index is updated/redefined along with rename.
--echo # Let us check such scenario for completeness.
ALTER TABLE t1 ADD KEY fi ((d + 1));
ALTER TABLE t1 RENAME COLUMN d TO e, DROP KEY fi, ADD KEY fi ((e + 1));
--echo # If updated expression uses wrong column name, error is reported.
--echo # Again, error code and message are different because technically
--echo # it is issue with new functional index.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 RENAME COLUMN e TO f, DROP KEY fi, ADD KEY fi ((e + 1));
DROP TABLE t1;
--echo #
--echo # 3.3) Complex case. Swapping of columns on which functional index
--echo #      depends.
CREATE TABLE t1 (a INT, b INT, KEY fi ((a + 10)));
INSERT INTO t1 (a, b) VALUES (1, 2), (3, 4), (5, 6);
SELECT * FROM t1 WHERE a + 10 = 13;
--echo # We block simple renaming of columns even if dependent functional
--echo # index stays valid. This is intentional -- we want user to realize
--echo # and explicitly confirm what is done (in most cases such rename is
--echo # likely to be an error).
--error ER_DEPENDENT_BY_FUNCTIONAL_INDEX
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a;
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, DROP KEY fi, ADD KEY fi((a + 10));
--echo # Contents of functional index/hidden generated column should be
--echo # updated accordingly.
SELECT * FROM t1 WHERE a + 10 = 14;
--echo # Such ALTER TABLEs are not inplace/instant due to re-evaluation
--echo # (and other reasons).
--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 RENAME COLUMN a TO b, RENAME COLUMN b TO a, DROP KEY fi, ADD KEY fi((a + 10)), ALGORITHM=INPLACE;
DROP TABLES t1;

--echo #
--echo # 4) Dropping columns on which generated columns depend.
--echo #
--echo # 4.1) Dropping column on which generated column depends is
--echo #      prohibited (for both stored and virtual columns).
CREATE TABLE t1 (a INT, b INT, gcol INT AS (a + 1) STORED);
CREATE TABLE t2 (a INT, b INT, gcol INT AS (a + 1) VIRTUAL);
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 DROP COLUMN a;
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t2 DROP COLUMN a;
--echo #
--echo # 4.2) It is OK to drop such columns if dependent generated column
--echo #      is dropped in the same ALTER.
ALTER TABLE t1 DROP COLUMN a, DROP COLUMN gcol;
ALTER TABLE t2 DROP COLUMN a, DROP COLUMN gcol;
--echo # This works even if generated column is processed earlier than
--echo # base column.
ALTER TABLE t1 ADD gcol INT AS (a + 1) STORED FIRST, ADD COLUMN a INT;
ALTER TABLE t1 DROP COLUMN gcol, DROP COLUMN a;
# Disabled until bug #29501324 "ADD VIRTUAL FIRST + ADD COLUMN CAUSES
# ASSERTION FAILURE" is fixed.
# ALTER TABLE t2 ADD gcol INT AS (a + 1) VIRTUAL FIRST, ADD COLUMN a INT;
# ALTER TABLE t2 DROP COLUMN gcol, DROP COLUMN a;
--echo #
--echo # 4.3) It is also OK to drop such columns if dependent generated
--echo #      column expression is updated/redefined.
ALTER TABLE t1 ADD COLUMN gcol INT AS (a + 1) STORED, ADD COLUMN a INT;
ALTER TABLE t2 ADD COLUMN gcol INT AS (a + 1) VIRTUAL, ADD COLUMN a INT;
ALTER TABLE t1 DROP COLUMN a, MODIFY gcol INT AS (b + 1) STORED;
ALTER TABLE t2 DROP COLUMN a, MODIFY gcol INT AS (b + 1) VIRTUAL;
--echo # And again this works even if generated column is processed earlier
--echo # than base  column.
ALTER TABLE t1 DROP COLUMN gcol, ADD COLUMN gcol INT AS (a + 1) STORED FIRST, ADD COLUMN a INT;
ALTER TABLE t1 MODIFY gcol INT AS (b + 1) STORED, DROP COLUMN a;
ALTER TABLE t2 DROP COLUMN gcol, ADD COLUMN gcol INT AS (a + 1) VIRTUAL FIRST, ADD COLUMN a INT;
ALTER TABLE t2 MODIFY gcol INT AS (b + 1) VIRTUAL, DROP COLUMN a;
--echo # If updated expression uses wrong column name, error is reported.
--echo # Note that error code and message are different because technically
--echo # it is issue with new generation expression.
ALTER TABLE t1 ADD COLUMN c INT;
ALTER TABLE t2 ADD COLUMN c INT;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 MODIFY gcol INT AS (e + 1) STORED, DROP COLUMN b;
--error ER_BAD_FIELD_ERROR
ALTER TABLE t2 MODIFY gcol INT AS (e + 1) VIRTUAL, DROP COLUMN b;
DROP TABLES t1, t2;
--echo #
--echo # 4.4) Complex case. Replacement (dropping and addition) of columns
--echo #      which causes generated column re-evaluation.
CREATE TABLE t1 (a INT, b INT, gcol INT AS (a + 10) STORED);
INSERT INTO t1 (a, b) VALUES (1, 2), (3, 4), (5, 6);
CREATE TABLE t2 (a INT, b INT, gcol INT AS (a + 10) VIRTUAL, KEY(gcol));
INSERT INTO t2 (a, b) VALUES (1, 2), (3, 4), (5, 6);
--echo # We block simple replacement of columns even if dependent generation
--echo # expression stays valid. This is intentional -- we want user to
--echo # realize and explicitly confirm what is done (in most cases this
--echo # is likely to be an error).
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0;
--error ER_DEPENDENT_BY_GENERATED_COLUMN
ALTER TABLE t2 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0;
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, MODIFY gcol INT AS (a + 10) STORED;
ALTER TABLE t2 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, MODIFY gcol INT AS (a + 10) VIRTUAL;
--echo # Contents of generated column should be updated accordingly.
SELECT * FROM t1;
SELECT * FROM t2;
SELECT * FROM t2 WHERE gcol = 10;
--echo # Such ALTER TABLEs are not inplace/instant due to generated
--echo # column re-evaluation.
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, MODIFY gcol INT AS (a + 10) STORED, ALGORITHM=INPLACE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t2 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, MODIFY gcol INT AS (a + 10) VIRTUAL, ALGORITHM=INPLACE;
DROP TABLES t1, t2;

--echo #
--echo # 5) Dropping column on which generated default depends.
--echo #
--echo # 5.1) Dropping column on which generated default depends is
--echo #      prohibited.
CREATE TABLE t1 (a INT, b INT, def INT DEFAULT (a + 1));
--error ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE
ALTER TABLE t1 DROP COLUMN a;
--echo #
--echo # 5.2) It is OK to drop such columns if dependent generated default
--echo #      is dropped:
--echo #
--echo #      a) By dropping column
ALTER TABLE t1 DROP COLUMN a, DROP COLUMN def;
--echo #      b) By dropping default using DROP DEFAULT
ALTER TABLE t1 ADD COLUMN a INT, ADD COLUMN def INT DEFAULT (a + 1);
ALTER TABLE t1 DROP COLUMN a, ALTER COLUMN def DROP DEFAULT;
--echo #      c) By dropping default using CHANGE/MODIFY COLUMN
ALTER TABLE t1 ADD COLUMN a INT, MODIFY COLUMN def INT DEFAULT (a + 1);
ALTER TABLE t1 DROP COLUMN a, MODIFY COLUMN def INT;
--echo # This works even if column with generated default comes earlier than
--echo # dropped column.
ALTER TABLE t1 DROP COLUMN def, ADD COLUMN def INT DEFAULT (a + 1) FIRST, ADD COLUMN a INT;
ALTER TABLE t1 DROP COLUMN def, DROP COLUMN a;
ALTER TABLE t1 ADD COLUMN def INT DEFAULT (a + 1) FIRST, ADD COLUMN a INT;
ALTER TABLE t1 ALTER COLUMN def DROP DEFAULT, DROP COLUMN a;
ALTER TABLE t1 MODIFY COLUMN def INT DEFAULT (a + 1), ADD COLUMN a INT;
ALTER TABLE t1 MODIFY COLUMN def INT, DROP COLUMN a;
DROP TABLE t1;
--echo #
--echo # 5.3) It is also OK to drop such columns if dependent generated
--echo #      default value is updated/redefined:
--echo #
--echo #      a) Using SET DEFAULT
CREATE TABLE t1 (a INT, b INT, c INT, d INT, def INT DEFAULT (a + 1));
ALTER TABLE t1 DROP COLUMN a, ALTER COLUMN def SET DEFAULT (b + 1);
--echo #      b) Using MODIFY/CHANGE column
ALTER TABLE t1 DROP COLUMN b, MODIFY COLUMN def INT DEFAULT (c + 1);
--echo # And again this works even if generated default comes earlier than
--echo # dropped column.
ALTER TABLE t1 DROP COLUMN def, ADD COLUMN def INT DEFAULT (a + 1) FIRST, ADD COLUMN a INT, ADD COLUMN b INT;
ALTER TABLE t1 ALTER COLUMN def SET DEFAULT (b + 1), DROP COLUMN a;
ALTER TABLE t1 MODIFY COLUMN def INT DEFAULT (c + 1), DROP COLUMN b;
--echo # If updated expression uses wrong column name, error is reported.
--echo # Again, error code and message are different because technically
--echo # it is issue with new generated default.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 MODIFY def INT DEFAULT (e + 1), DROP COLUMN c;
DROP TABLES t1;
--echo #
--echo # 5.4) Complex case. Replacement of column on which generated
--echo #      default depends.
CREATE TABLE t1 (a INT, b INT, def INT DEFAULT (a));
INSERT INTO t1 (a, b) VALUES (1, 2);
--echo # Similarly to the above we block simple replacement of columns even
--echo # if dependent default expression stays valid. This is intentional
--echo # -- we want user to realize and explicitly confirm what is done
--echo # (in most cases such replacement is likely to be an error).
--error ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT;
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 10, ALTER COLUMN def SET DEFAULT (a);
--echo # Old rows should stay the same, new generated default will only affect new rows.
INSERT INTO t1 (a, b) VALUES (3, 4);
SELECT * FROM t1;
--echo # Unlike for generated columns case, such ALTER TABLE can be done
--echo # inplace, since it doesn't affect table data.
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 42, ALTER COLUMN def SET DEFAULT (a), ALGORITHM=INPLACE;
DROP TABLES t1;

--echo #
--echo # 6) Dropping column on which functional index depends.
--echo #
--echo # 6.1) Dropping column on which functional index depends is
--echo #      prohibited.
CREATE TABLE t1 (a INT, b INT, KEY fi((a + 1)));
--error ER_DEPENDENT_BY_FUNCTIONAL_INDEX
ALTER TABLE t1 DROP COLUMN a;
--echo #
--echo # 6.2) It is OK to drop such column if dependent index is dropped.
ALTER TABLE t1 DROP COLUMN a, DROP KEY fi;
--echo # This works even if hidden column for functional index processed
--echo # earlier than dropped column.
ALTER TABLE t1 ADD KEY fi ((b + 1));
--echo # Move column 'b' to the table's end first.
ALTER TABLE t1 ADD c INT;
ALTER TABLE t1 MODIFY b INT AFTER c;
ALTER TABLE t1 DROP KEY fi, DROP COLUMN b;
--echo #
--echo # Note that the only way to update/redefine functional index is to
--echo # drop and re-create it. So the this section also covers the case
--echo # when functional index is updated/redefined along with drop of
--echo # base column. Let us check such scenario for completeness.
ALTER TABLE t1 ADD KEY fi ((c + 1)), ADD COLUMN d INT, ADD COLUMN e INT;
ALTER TABLE t1 DROP COLUMN c, DROP KEY fi, ADD KEY fi ((d + 1));
--echo # If updated expression uses wrong column name, error is reported.
--echo # Again, error code and message are different because technically
--echo # it is issue with new functional index.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 DROP COLUMN d, DROP KEY fi, ADD KEY fi ((f + 1));
DROP TABLE t1;
--echo #
--echo # 6.3) Complex case. Replacing column on which functional index
--echo #      depends.
CREATE TABLE t1 (a INT, b INT, KEY fi ((a + 10)));
INSERT INTO t1 (a, b) VALUES (1, 2), (3, 4), (5, 6);
SELECT * FROM t1 WHERE a + 10 = 13;
--echo # We block simple replacement of column even if dependent functional
--echo # index stays valid. This is intentional -- we want user to realize
--echo # and explicitly confirm what is done (in most cases such replacement
--echo # is likely to be an error).
--error ER_DEPENDENT_BY_FUNCTIONAL_INDEX
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0;
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, DROP KEY fi, ADD KEY fi((a + 10));
--echo # Contents of functional index/hidden generated column should be
--echo # updated accordingly.
SELECT * FROM t1 WHERE a + 10 = 10;
--echo # Such ALTER TABLEs are not inplace/instant due to re-evaluation
--echo # (and other reasons).
--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN a INT DEFAULT 0, DROP KEY fi, ADD KEY fi((a + 10)), ALGORITHM=INPLACE;
DROP TABLES t1;

--echo #
--echo # Bug #30417361: MAKE THE SORTING CODE INDEPENDENT OF QEP_TABS
--echo #

# Test that we can order by a generated virtual column that is not otherwise
# mentioned in the query.
CREATE TABLE t1 (i INTEGER, a INTEGER, vgc INTEGER GENERATED ALWAYS AS (-a) VIRTUAL);
INSERT INTO t1 (i, a) VALUES (1, 1), (2, 2);
SELECT i FROM t1 ORDER BY vgc;
DROP TABLE t1;
--echo #
--echo # Bug #30664660 GCOLS, CRASH AND CORRUPTIONS WITH DELETE IGNORE + JSON
--echo #

CREATE TABLE t (
  a JSON NOT NULL,
  b TIMESTAMP GENERATED ALWAYS AS (a) VIRTUAL NOT NULL,
  KEY (b)
) ENGINE=INNODB;
INSERT IGNORE INTO t(a) VALUES ('{}');
DELETE IGNORE FROM t;
CHECK TABLE t;
DROP TABLE t;

--echo #
--echo # Bug #31463511: NATURAL JOIN RETURNS WRONG RESULT WHEN EXPRESSION INDEX IS USED
--echo #

CREATE TABLE t1 (a INTEGER);
CREATE TABLE t2 (a INTEGER);
CREATE INDEX idx ON t1 ((a+1));
CREATE INDEX idx ON t2 ((a+2));
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1);

# Verify that the generated (a+1) and (a+2) columns don't participate in the join;
# if they did, the answer would be empty.
SELECT * FROM t1 NATURAL JOIN t2;

DROP TABLE t1, t2;

--echo #
--echo # Bug#31982292: ITEM_JSON_FUNC.CC:1406: BOOL SQL_SCALAR_TO_JSON(ITEM*,
--echo # CONST CHAR*, STRING*, STR
--echo #

CREATE TABLE t(x VARCHAR(10),
               y INT GENERATED ALWAYS AS (x),
               z JSON GENERATED ALWAYS AS (JSON_ARRAY(x, y)));
--error ER_TRUNCATED_WRONG_VALUE_FOR_FIELD
INSERT INTO t (x) VALUES ('abc');
DROP TABLE t;

CREATE TABLE t(x VARCHAR(10));
INSERT INTO t VALUES ('');
ALTER TABLE t
  ADD COLUMN g1 JSON GENERATED ALWAYS AS (x),
  ADD COLUMN g2 JSON GENERATED ALWAYS AS (JSON_ARRAY(x));
--error ER_INVALID_JSON_TEXT
SELECT * FROM t;
DROP TABLE t;

--echo #
--echo # Bug#32234773: UPDATE_GENERATED_READ_FIELDS:
--echo #               ASSERTION `!TABLE->IN_USE->IS_ERROR()' FAILED
--echo #

CREATE TABLE t (
  id INT PRIMARY KEY AUTO_INCREMENT,
  i INT,
  gc INT GENERATED ALWAYS AS (1) STORED,
  KEY (i)
);
INSERT INTO t(i) VALUES (5853267), (32766);
--error ER_DATA_OUT_OF_RANGE
SELECT * FROM t WHERE i > 123 AND i * FROM_UNIXTIME(1536999224);
DROP TABLE t;

--echo # Bug#32824978: Generated columns inconsistency

CREATE TABLE t1 (
  id INTEGER NOT NULL,
  mac BIGINT UNSIGNED DEFAULT NULL,
  str CHAR(12) AS (LPAD(CONVERT(HEX(mac) USING utf8mb4), 12,_utf8mb4'0')) VIRTUAL,
  separated CHAR(17) AS (INSERT(INSERT(INSERT(INSERT(INSERT(str, 11, 0, _utf8mb4':'), 9, 0, _utf8mb4':'), 7, 0, _utf8mb4':'), 5, 0, _utf8mb4':'), 3, 0, _utf8mb4':')) VIRTUAL,
  PRIMARY KEY (id)
);

INSERT INTO t1 (id, mac) VALUES
 (1, 10), (2, 564685488), (3, NULL), (4, 684756486);

SELECT * FROM t1;

DROP TABLE t1;


--echo # Bug#32427727: Functional index ignored by SELECT query from
--echo #               within stored function

CREATE TABLE t1
 (pk BIGINT AUTO_INCREMENT PRIMARY KEY,
  n1 varchar(30),
  n2 varchar(30),
  n3 varchar(30),
  index n12((concat(n1, n2)))
);

ANALYZE TABLE t1;

DELIMITER |;

CREATE PROCEDURE p1 (str VARCHAR(60))
BEGIN
  EXPLAIN
  SELECT n3, COUNT(*) as 'count'
  FROM t1
  WHERE CONCAT(n1,n2) = str
  GROUP BY n3;
  SELECT n3, COUNT(*) as 'count'
  FROM t1
  WHERE CONCAT(n1,n2) = str
  GROUP BY n3;
END |

DELIMITER ;|

CALL p1('str');

DROP PROCEDURE p1;
DROP TABLE t1;

--echo
--echo # VARBINARY as primary key
--echo

CREATE TABLE t1 (
  doc JSON,
  id VARBINARY(32) GENERATED ALWAYS AS
    (JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id'))) STORED PRIMARY KEY);
INSERT INTO t1 (doc) VALUES
 (JSON_OBJECT('id','1','name','foo')),(JSON_OBJECT('id','2','name','bar'));
ANALYZE TABLE t1;

SET @a = '2';
SET @num = 2;

let q1p = SELECT * FROM t1 WHERE JSON_EXTRACT(doc, '$.id') = ?;
let q1r = SELECT * FROM t1 WHERE JSON_EXTRACT(doc, '$.id') = '2';
let q1n = SELECT * FROM t1 WHERE JSON_EXTRACT(doc, '$.id') = 2;
let q2p = SELECT * FROM t1 WHERE JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id')) = ?;
let q2r = SELECT * FROM t1 WHERE JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id')) = '2';
let q2n = SELECT * FROM t1 WHERE JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id')) = 2;
let q3p = SELECT * FROM t1 WHERE id = ?;
let q3r = SELECT * FROM t1 WHERE id = '2';
let q3n = SELECT * FROM t1 WHERE id = 2;

eval $q1r;
eval explain $q1r;
eval $q2r;
eval explain $q2r;
eval $q3r;
eval explain $q3r;
eval PREPARE s11 FROM "$q1p";
--echo # Not using index, resulting JSON comparison delivers empty result.
--echo # This deviates from the result when the GC is not indexed.
EXECUTE s11 USING @a;
eval PREPARE s12 FROM "explain $q1p";
EXECUTE s12 USING @a;
eval PREPARE s21 FROM "$q2p";
EXECUTE s21 USING @a;
eval PREPARE s22 FROM "explain $q2p";
EXECUTE s22 USING @a;
eval PREPARE s31 FROM "$q3p";
EXECUTE s31 USING @a;
eval PREPARE s32 FROM "explain $q3p";
EXECUTE s32 USING @a;

DROP TABLE t1;

--echo
--echo # VARCHAR as primary key
--echo

CREATE TABLE t1 (
  doc JSON,
  id VARCHAR(32) COLLATE utf8mb4_bin GENERATED ALWAYS AS
    (JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id'))) STORED PRIMARY KEY);
INSERT INTO t1 (doc) VALUES
 (JSON_OBJECT('id','1','name','foo')),(JSON_OBJECT('id','2','name','bar'));
ANALYZE TABLE t1;

eval $q1r;
eval explain $q1r;
eval $q2r;
eval explain $q2r;
eval $q3r;
eval explain $q3r;
eval PREPARE s11 FROM "$q1p";
--echo # Not using index, resulting JSON comparison delivers expected row
EXECUTE s11 USING @a;
eval PREPARE s12 FROM "explain $q1p";
EXECUTE s12 USING @a;
eval PREPARE s21 FROM "$q2p";
EXECUTE s21 USING @a;
eval PREPARE s22 FROM "explain $q2p";
EXECUTE s22 USING @a;
eval PREPARE s31 FROM "$q3p";
EXECUTE s31 USING @a;
eval PREPARE s32 FROM "explain $q3p";
EXECUTE s32 USING @a;

DROP TABLE t1;

--echo
--echo # BIGINT as primary key
--echo

CREATE TABLE t1 (
  doc JSON,
  id BIGINT GENERATED ALWAYS AS
    (JSON_UNQUOTE(JSON_EXTRACT(doc, '$.id'))) STORED PRIMARY KEY);
INSERT INTO t1 (doc) VALUES
 (JSON_OBJECT('id','1','name','foo')),(JSON_OBJECT('id','2','name','bar'));
ANALYZE TABLE t1;

eval $q1r;
eval explain $q1r;
eval $q2r;
eval explain $q2r;
eval $q2n;
eval explain $q2n;
eval $q3r;
eval explain $q3r;
eval PREPARE s11 FROM "$q1p";
EXECUTE s11 USING @a;
eval PREPARE s12 FROM "explain $q1p";
EXECUTE s12 USING @a;
eval PREPARE s21 FROM "$q2p";
EXECUTE s21 USING @a;
eval PREPARE s22 FROM "explain $q2p";
EXECUTE s22 USING @a;
eval PREPARE s31 FROM "$q3p";
EXECUTE s31 USING @a;
eval PREPARE s32 FROM "explain $q3p";
EXECUTE s32 USING @a;
eval PREPARE s11 FROM "$q1p";
EXECUTE s11 USING @num;
eval PREPARE s21 FROM "$q1p";
EXECUTE s11 USING @num;
eval PREPARE s12 FROM "explain $q1p";
EXECUTE s12 USING @num;
eval PREPARE s21 FROM "$q2p";
EXECUTE s21 USING @num;
eval PREPARE s22 FROM "explain $q2p";
EXECUTE s22 USING @num;
eval PREPARE s31 FROM "$q3p";
EXECUTE s31 USING @num;
eval PREPARE s32 FROM "explain $q3p";
EXECUTE s32 USING @num;

DROP TABLE t1;

--echo # Bug#33142135: Assert for fields not marked as READ
--error ER_GENERATED_COLUMN_REF_AUTO_INC
CREATE TABLE v1(v2 INT SERIAL DEFAULT VALUE, v3 INT AS (DEFAULT(v2)/1 IS NULL));
CREATE TABLE v1(v2 INT DEFAULT 10, v3 INT AS (DEFAULT(v2)/1 IS NULL));
SHOW CREATE TABLE v1;
DROP TABLE v1;
