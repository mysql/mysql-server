SET @@session.default_storage_engine = 'InnoDB';
#            - UNIQUE KEY
#            - INDEX
#            - FULLTEXT INDEX
#            - SPATIAL INDEX (not supported)
#            - FOREIGN INDEX (partially supported)
#            - CHECK (allowed but not used)
# UNIQUE
create table t1 (a int, b int generated always as (a*2) virtual unique);
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) VIRTUAL,
  UNIQUE KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	UNI	NULL	VIRTUAL GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored unique);
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) STORED,
  UNIQUE KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	UNI	NULL	STORED GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) virtual, unique key (b));
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) VIRTUAL,
  UNIQUE KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	UNI	NULL	VIRTUAL GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored, unique (b));
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) STORED,
  UNIQUE KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	UNI	NULL	STORED GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) virtual);
alter table t1 add unique key (b);
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored);
alter table t1 add unique key (b);
drop table t1;
# Testing data manipulation operations involving UNIQUE keys
# on generated columns can be found in:
#  - gcol_ins_upd.inc
#  - gcol_select.inc
#
# INDEX
create table t1 (a int, b int generated always as (a*2) virtual, index (b));
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) VIRTUAL,
  KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	MUL	NULL	VIRTUAL GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) virtual, index (a,b));
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored, index (b));
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) STORED,
  KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES		NULL	
b	int(11)	YES	MUL	NULL	STORED GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored, index (a,b));
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) DEFAULT NULL,
  `b` int(11) GENERATED ALWAYS AS ((`a` * 2)) STORED,
  KEY `a` (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
describe t1;
Field	Type	Null	Key	Default	Extra
a	int(11)	YES	MUL	NULL	
b	int(11)	YES		NULL	STORED GENERATED
drop table t1;
create table t1 (a int, b int generated always as (a*2) virtual);
alter table t1 add index (b);
alter table t1 add index (a,b);
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored);
alter table t1 add index (b);
drop table t1;
create table t1 (a int, b int generated always as (a*2) stored);
alter table t1 add index (a,b);
create table t2 like t1;
drop table t2;
drop table t1;
# Testing data manipulation operations involving INDEX
# on generated columns can be found in:
#  - gcol_select.inc
#
# TODO: FULLTEXT INDEX
# SPATIAL INDEX
# FOREIGN KEY
# Rejected FK options.
create table t1 (a int, b int generated always as (a+1) stored,
foreign key (b) references t2(a) on update set null);
ERROR HY000: Cannot define foreign key with ON UPDATE SET NULL clause on a generated column.
create table t1 (a int, b int generated always as (a+1) stored,
foreign key (b) references t2(a) on update cascade);
ERROR HY000: Cannot define foreign key with ON UPDATE CASCADE clause on a generated column.
create table t1 (a int, b int generated always as (a+1) stored,
foreign key (b) references t2(a) on delete set null);
ERROR HY000: Cannot define foreign key with ON DELETE SET NULL clause on a generated column.
create table t1 (a int, b int generated always as (a+1) stored);
alter table t1 add foreign key (b) references t2(a) on update set null;
ERROR HY000: Cannot define foreign key with ON UPDATE SET NULL clause on a generated column.
alter table t1 add foreign key (b) references t2(a) on update cascade;
ERROR HY000: Cannot define foreign key with ON UPDATE CASCADE clause on a generated column.
alter table t1 add foreign key (b) references t2(a) on delete set null;
ERROR HY000: Cannot define foreign key with ON DELETE SET NULL clause on a generated column.
drop table t1;
create table t2 (a int primary key);
create table t1 (a int, b int generated always as (a+1) virtual,
foreign key (b) references t2(a));
ERROR HY000: Foreign key 't1_ibfk_1' uses virtual column 'b' which is not supported.
create table t1 (a int, b int generated always as (a+1) virtual);
alter table t1 add foreign key (b) references t2(a);
ERROR HY000: Foreign key 't1_ibfk_1' uses virtual column 'b' which is not supported.
drop table t1, t2;
# Allowed FK options.
create table t2 (a int primary key, b char(5));
create table t1 (a int, b int generated always as (a % 10) stored,
foreign key (b) references t2(a) on update restrict);
drop table t1;
create table t1 (a int, b int generated always as (a % 10) stored,
foreign key (b) references t2(a) on update no action);
drop table t1;
create table t1 (a int, b int generated always as (a % 10) stored,
foreign key (b) references t2(a) on delete restrict);
drop table t1;
create table t1 (a int, b int generated always as (a % 10) stored,
foreign key (b) references t2(a) on delete cascade);
drop table t1;
create table t1 (a int, b int generated always as (a % 10) stored,
foreign key (b) references t2(a) on delete no action);
drop table t1,t2;
#
# Bug#20553262: WL8149: ASSERTION `DELSUM+(INT) Y/4-TEMP >= 0' FAILED
#
CREATE TABLE c (
pk integer AUTO_INCREMENT,
col_datetime_nokey DATETIME /*! NULL */,
col_time_nokey TIME /*! NULL */,
col_datetime_key DATETIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)),
col_time_key TIME GENERATED ALWAYS AS
(ADDTIME(col_datetime_nokey, col_time_nokey)),
col_varchar_nokey VARCHAR(1) /*! NULL */,
PRIMARY KEY (pk),
KEY (col_time_key),
KEY (col_datetime_key));
INSERT INTO c ( col_time_nokey,col_datetime_nokey,col_varchar_nokey) values
('14:03:03.042673','2001-11-28 00:50:27.051028', 'c'),
('01:46:09.016386','2007-10-09 19:53:04.008332', NULL),
('16:21:18.052408','2001-11-08 21:02:12.009395', 'x'),
('18:56:33.027423','2003-04-01 00:00:00', 'i');
EXPLAIN SELECT
outr.col_time_key AS x
FROM c as outr
WHERE
outr.col_varchar_nokey in ('c', 'x', 'i')
AND (outr.col_time_key IS NULL OR
outr.col_datetime_key = '2009-09-27');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	outr	NULL	index_merge	col_time_key,col_datetime_key	col_time_key,col_datetime_key	4,6	NULL	x	x	Using sort_union(col_time_key,col_datetime_key); Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`outr`.`col_time_key` AS `x` from `test`.`c` `outr` where ((`test`.`outr`.`col_varchar_nokey` in ('c','x','i')) and (isnull(`test`.`outr`.`col_time_key`) or (`test`.`outr`.`col_datetime_key` = '2009-09-27')))
SELECT
outr.col_time_key AS x
FROM c AS outr
WHERE
outr.col_varchar_nokey in ('c', 'x', 'i')
AND (outr.col_time_key IS NULL OR
outr.col_datetime_key = '2009-09-27');
x
DROP TABLE c;
#
# Bug#20913803: WL8149: SIG 11 IN DFIELD_DUP |
# INNOBASE/INCLUDE/DATA0DATA.IC:253
#
CREATE TABLE A (
col_varchar_nokey TEXT ,
col_varchar_key TEXT GENERATED ALWAYS AS (REPEAT(col_varchar_nokey, 1000)),
KEY (col_varchar_key(50))
);
INSERT INTO A (col_varchar_nokey) VALUES ('');
CREATE TABLE D (
pk INTEGER AUTO_INCREMENT,
col_date_nokey BLOB,
col_date_key BLOB GENERATED ALWAYS AS (REPEAT(col_date_nokey,1000)) VIRTUAL,
col_datetime_nokey LONGBLOB,
col_time_nokey LONGTEXT,
col_datetime_key LONGBLOB GENERATED ALWAYS AS (REPEAT(col_datetime_nokey, 1000)),
col_time_key LONGTEXT GENERATED ALWAYS AS (REPEAT(col_datetime_nokey, 1000)),
col_varchar_nokey TEXT,
col_varchar_key TEXT GENERATED ALWAYS AS (REPEAT(col_varchar_nokey, 1000)),
PRIMARY KEY (pk),
KEY (col_varchar_key(50)),
KEY (col_date_key(20)),
KEY (col_time_key(20)),
KEY (col_datetime_key(20)),
KEY (col_varchar_key(10), col_date_key(10), col_time_key(5), col_datetime_key(5))
);
INSERT INTO D (
col_date_nokey,
col_time_nokey,
col_datetime_nokey,
col_varchar_nokey
) VALUES ('', '', '', ''),('', '', '', '');
DELETE FROM OUTR1.* USING D AS OUTR1 RIGHT JOIN A AS OUTR2 ON 
( OUTR1 . `col_varchar_nokey` = OUTR2 . `col_varchar_nokey` );
DROP TABLE IF EXISTS A,D;
#
# Bug#21024896: SIG 11 INNOBASE_ADD_ONE_VIRTUAL |
# INNOBASE/HANDLER/HANDLER0ALTER.CC
#
CREATE TABLE t1 (
col1 int(11) DEFAULT NULL,
col2 int(11) DEFAULT NULL,
col3 int(11) NOT NULL,
col4 int(11) DEFAULT NULL,
col5 int(11) GENERATED ALWAYS AS (col2 / col2) VIRTUAL,
col7 int(11) GENERATED ALWAYS AS (col5 + col5) VIRTUAL,
col8 int(11) GENERATED ALWAYS AS (col5 * col5) VIRTUAL,
col9 text,
col6 int(11) DEFAULT NULL,
PRIMARY KEY (`col3`),
UNIQUE KEY uidx (`col2`),
KEY idx (`col5`)
);
INSERT INTO t1(col1,col2,col3,col4,col9,col6)
VALUES(1,1,0,1,REPEAT(col1,1000),0), (3,2,1,1,REPEAT(col1,1000),NULL);
ALTER TABLE t1 ADD COLUMN extra INT;
DROP TABLE t1;
#
# Bug#21316860: WL8149:INNODB: FAILING ASSERTION:
# TEMPL->CLUST_REC_FIELD_NO != ULINT_UNDEFINED
#
CREATE TABLE t1 (
pk int(11) NOT NULL,
col_int_nokey int(11),
col_int_key int(11) GENERATED ALWAYS AS (col_int_nokey) VIRTUAL NOT NULL,
col_date_nokey date,
col_date_key date GENERATED ALWAYS AS (col_date_nokey) VIRTUAL NOT NULL,
PRIMARY KEY (pk),
UNIQUE KEY col_int_key (col_int_key)
);
ALTER TABLE t1 DROP COLUMN pk;
DROP TABLE t1;
# Remove the impact on PK choose by index on virtual generated column
CREATE TABLE t1 (
pk int(11) NOT NULL,
col_int_nokey int(11) DEFAULT NULL,
col_int_key int(11) GENERATED ALWAYS AS (col_int_nokey) VIRTUAL NOT NULL,
UNIQUE KEY col_int_key (col_int_key)
);
ALTER TABLE t1 add unique index idx(pk), algorithm=inplace;
DESC t1;
Field	Type	Null	Key	Default	Extra
pk	int(11)	NO	PRI	NULL	
col_int_nokey	int(11)	YES		NULL	
col_int_key	int(11)	NO	UNI	NULL	VIRTUAL GENERATED
DROP TABLE t1;
#
# Bug#21346132: WL8149:INNODB: FAILING ASSERTION:
# PRIMARY_KEY_NO == -1 || PRIMARY_KEY_NO == 0
#
CREATE TABLE t1 (
col_int_nokey int(11) NOT NULL,
col_int_key int(11) GENERATED ALWAYS AS (col_int_nokey) NOT NULL,
col_varchar_nokey varchar(1) NOT NULL,
col_varchar_key varchar(2) GENERATED ALWAYS AS (col_varchar_nokey) NOT NULL,
UNIQUE KEY col_int_key (col_int_key),
UNIQUE KEY col_varchar_key (col_varchar_key),
UNIQUE KEY col_int_key_2 (col_int_key,col_varchar_key),
UNIQUE KEY col_varchar_key_2 (col_varchar_key,col_varchar_nokey),
KEY col_int_key_3 (col_int_key,col_int_nokey)
);
ALTER TABLE t1 DROP COLUMN col_varchar_key;
Warnings:
Warning	1831	Duplicate index 'col_int_key_2' defined on the table 'test.t1'. This is deprecated and will be disallowed in a future release.
DROP TABLE t1;
#
# Bug#21320151 WL8149: WRONG RESULT WITH INDEX SCAN
#
CREATE TABLE t1 (
id INTEGER NOT NULL,
b INTEGER GENERATED ALWAYS AS (id+1) VIRTUAL NOT NULL,
UNIQUE KEY (b)
);
INSERT INTO t1 (id) VALUES (2),(3),(4),(5),(6),(7),(8),(9),(10);
EXPLAIN SELECT b FROM t1 FORCE INDEX(b);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	b	4	NULL	9	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`b` AS `b` from `test`.`t1` FORCE INDEX (`b`)
SELECT b FROM t1 FORCE INDEX(b);
b
3
4
5
6
7
8
9
10
11
EXPLAIN SELECT b FROM t1 FORCE INDEX(b) WHERE b BETWEEN 1 AND 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	b	b	4	NULL	3	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`b` AS `b` from `test`.`t1` FORCE INDEX (`b`) where (`test`.`t1`.`b` between 1 and 5)
SELECT b FROM t1 FORCE INDEX(b) WHERE b BETWEEN 1 AND 5;
b
3
4
5
DROP TABLE t1;

# Testing data manipulation operations involving FOREIGN KEY
# on generated columns can be found in:
#  - gcol_ins_upd.inc
#  - gcol_select.inc
#
# TODO: CHECK
#
# Test how optimizer picks indexes defined on a GC
#
SET optimizer_trace_max_mem_size=1048576;
SET optimizer_trace="enabled=on,one_line=off";
SET end_markers_in_json="on";
CREATE TABLE t1 (f1 int, gc int AS (f1 + 1) STORED PRIMARY KEY);
INSERT INTO t1(f1) VALUES (1),(2),(0),(9),(3),(4),(8),(7),(5),(6);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
# Should use index
SELECT * FROM t1 WHERE f1 + 1 > 7;
f1	gc
7	8
8	9
9	10
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 > 7;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` > 7)
SELECT * FROM information_schema.OPTIMIZER_TRACE;
QUERY	TRACE	MISSING_BYTES_BEYOND_MAX_MEM_SIZE	INSUFFICIENT_PRIVILEGES
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 > 7	{
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `t1`.`f1` AS `f1`,`t1`.`gc` AS `gc` from `t1` where ((`t1`.`f1` + 1) > 7)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "((`t1`.`f1` + 1) > 7)",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "((`t1`.`f1` + 1) > 7)"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "((`t1`.`f1` + 1) > 7)"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "((`t1`.`f1` + 1) > 7)"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": {
              "resulting_condition": "(`t1`.`gc` > 7)"
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`t1`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`t1`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 10,
                    "cost": 3.35
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": true,
                      "key_parts": [
                        "gc"
                      ] /* key_parts */
                    }
                  ] /* potential_range_indexes */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "PRIMARY",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "PRIMARY",
                        "ranges": [
                          "7 < gc"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 3,
                        "cost": 0.5606,
                        "chosen": true
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "PRIMARY",
                      "rows": 3,
                      "ranges": [
                        "7 < gc"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 3,
                    "cost_for_plan": 0.5606,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`t1`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 3,
                      "filtering_effect": [
                      ] /* filtering_effect */,
                      "final_filtering_effect": 1,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "PRIMARY"
                      } /* range_details */,
                      "resulting_rows": 3,
                      "cost": 0.8606,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 3,
                "cost_for_plan": 0.8606,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "(`t1`.`gc` > 7)",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`t1`",
                  "attached": "(`t1`.`gc` > 7)"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "refine_plan": [
              {
                "table": "`t1`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_explain": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_explain */
    }
  ] /* steps */
}	0	0
SELECT * FROM t1 WHERE f1 + 1 = 7;
f1	gc
6	7
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 = 7;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '6' AS `f1`,'7' AS `gc` from `test`.`t1` where ('7' = 7)
SELECT * FROM t1 WHERE f1 + 1 IN (7,5);
f1	gc
4	5
6	7
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 IN(7,5);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` in (7,5))
SELECT * FROM t1 WHERE f1 + 1 BETWEEN 5 AND 7;
f1	gc
4	5
5	6
6	7
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 BETWEEN 5 AND 7;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` between 5 and 7)
# Check that expression isn't transformed for a disabled key
SELECT * FROM t1 IGNORE KEY FOR JOIN(PRIMARY) WHERE f1 + 1 BETWEEN 5 AND 7;
f1	gc
4	5
5	6
6	7
EXPLAIN SELECT * FROM t1 IGNORE KEY FOR JOIN(PRIMARY) WHERE f1 + 1 BETWEEN 5 AND 7;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` IGNORE INDEX FOR JOIN (PRIMARY) where ((`test`.`t1`.`f1` + 1) between 5 and 7)
# Check that ORDER BY could be optimized
SELECT * FROM t1 ORDER BY f1 + 1;
f1	gc
0	1
1	2
2	3
3	4
4	5
5	6
6	7
7	8
8	9
9	10
EXPLAIN SELECT * FROM t1 ORDER BY f1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	10	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` order by `test`.`t1`.`gc`
SELECT * FROM information_schema.OPTIMIZER_TRACE;
QUERY	TRACE	MISSING_BYTES_BEYOND_MAX_MEM_SIZE	INSUFFICIENT_PRIVILEGES
EXPLAIN SELECT * FROM t1 ORDER BY f1 + 1	{
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `t1`.`f1` AS `f1`,`t1`.`gc` AS `gc` from `t1` order by (`t1`.`f1` + 1)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "substitute_generated_columns": {
              "resulting_ORDER_BY": "`t1`.`gc`"
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`t1`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "rows_estimation": [
              {
                "table": "`t1`",
                "table_scan": {
                  "rows": 10,
                  "cost": 0.25
                } /* table_scan */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`t1`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 10,
                      "filtering_effect": [
                      ] /* filtering_effect */,
                      "final_filtering_effect": 1,
                      "access_type": "scan",
                      "resulting_rows": 10,
                      "cost": 1.25,
                      "chosen": true,
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 10,
                "cost_for_plan": 1.25,
                "sort_cost": 10,
                "new_cost_for_plan": 11.25,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": null,
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`t1`",
                  "attached": null
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "optimizing_distinct_group_by_order_by": {
              "simplifying_order_by": {
                "original_clause": "`t1`.`gc`",
                "items": [
                  {
                    "item": "`t1`.`gc`"
                  }
                ] /* items */,
                "resulting_clause_is_simple": true,
                "resulting_clause": "`t1`.`gc`"
              } /* simplifying_order_by */
            } /* optimizing_distinct_group_by_order_by */
          },
          {
            "reconsidering_access_paths_for_index_ordering": {
              "clause": "ORDER BY",
              "index_order_summary": {
                "table": "`t1`",
                "index_provides_order": true,
                "order_direction": "asc",
                "index": "PRIMARY",
                "plan_changed": true,
                "access_type": "index"
              } /* index_order_summary */
            } /* reconsidering_access_paths_for_index_ordering */
          },
          {
            "refine_plan": [
              {
                "table": "`t1`"
              }
            ] /* refine_plan */
          },
          {
            "considering_tmp_tables": [
            ] /* considering_tmp_tables */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_explain": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_explain */
    }
  ] /* steps */
}	0	0
EXPLAIN SELECT * FROM t1 IGNORE KEY FOR ORDER BY(PRIMARY) ORDER BY f1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` IGNORE INDEX FOR ORDER BY (PRIMARY) order by (`test`.`t1`.`f1` + 1)
# Check that GROUP BY could be optimized
SELECT f1 + 1, MAX(GC) FROM t1 GROUP BY f1 + 1;
f1 + 1	MAX(GC)
1	1
10	10
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
EXPLAIN SELECT f1 + 1, MAX(GC) FROM t1 GROUP BY f1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	10	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`f1` + 1) AS `f1 + 1`,max(`test`.`t1`.`gc`) AS `MAX(GC)` from `test`.`t1` group by `test`.`t1`.`gc`
SELECT * FROM information_schema.OPTIMIZER_TRACE;
QUERY	TRACE	MISSING_BYTES_BEYOND_MAX_MEM_SIZE	INSUFFICIENT_PRIVILEGES
EXPLAIN SELECT f1 + 1, MAX(GC) FROM t1 GROUP BY f1 + 1	{
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select (`t1`.`f1` + 1) AS `f1 + 1`,max(`t1`.`gc`) AS `MAX(GC)` from `t1` group by (`t1`.`f1` + 1)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "substitute_generated_columns": {
              "resulting_GROUP_BY": "`t1`.`gc`"
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`t1`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "rows_estimation": [
              {
                "table": "`t1`",
                "const_keys_added": {
                  "keys": [
                    "PRIMARY"
                  ] /* keys */,
                  "cause": "group_by"
                } /* const_keys_added */,
                "range_analysis": {
                  "table_scan": {
                    "rows": 10,
                    "cost": 3.35
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": true,
                      "key_parts": [
                        "gc"
                      ] /* key_parts */
                    }
                  ] /* potential_range_indexes */,
                  "group_index_range": {
                    "potential_group_range_indexes": [
                      {
                        "index": "PRIMARY",
                        "usable": false,
                        "cause": "not_covering"
                      }
                    ] /* potential_group_range_indexes */
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "chosen": false,
                    "cause": "has_group_by"
                  } /* skip_scan_range */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`t1`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 10,
                      "filtering_effect": [
                      ] /* filtering_effect */,
                      "final_filtering_effect": 1,
                      "access_type": "scan",
                      "resulting_rows": 10,
                      "cost": 1.25,
                      "chosen": true,
                      "use_tmp_table": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 10,
                "cost_for_plan": 1.25,
                "sort_cost": 10,
                "new_cost_for_plan": 11.25,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": null,
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`t1`",
                  "attached": null
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "optimizing_distinct_group_by_order_by": {
              "simplifying_group_by": {
                "original_clause": "`t1`.`gc`",
                "items": [
                  {
                    "item": "`t1`.`gc`"
                  }
                ] /* items */,
                "resulting_clause_is_simple": true,
                "resulting_clause": "`t1`.`gc`"
              } /* simplifying_group_by */
            } /* optimizing_distinct_group_by_order_by */
          },
          {
            "reconsidering_access_paths_for_index_ordering": {
              "clause": "GROUP BY",
              "index_order_summary": {
                "table": "`t1`",
                "index_provides_order": true,
                "order_direction": "asc",
                "index": "PRIMARY",
                "plan_changed": true,
                "access_type": "index"
              } /* index_order_summary */
            } /* reconsidering_access_paths_for_index_ordering */
          },
          {
            "refine_plan": [
              {
                "table": "`t1`"
              }
            ] /* refine_plan */
          },
          {
            "considering_tmp_tables": [
            ] /* considering_tmp_tables */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_explain": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_explain */
    }
  ] /* steps */
}	0	0
EXPLAIN SELECT f1 + 1, MAX(GC)
FROM t1 IGNORE KEY FOR GROUP BY(PRIMARY) GROUP BY f1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`f1` + 1) AS `f1 + 1`,max(`test`.`t1`.`gc`) AS `MAX(GC)` from `test`.`t1` IGNORE INDEX FOR GROUP BY (PRIMARY) group by (`test`.`t1`.`f1` + 1)
# Shouldn't use index
SELECT * FROM t1 WHERE f1 + 1 > 7.0;
f1	gc
7	8
8	9
9	10
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 > 7.0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc` AS `gc` from `test`.`t1` where ((`test`.`t1`.`f1` + 1) > 7.0)
DROP TABLE t1;
# Pick index with proper type
CREATE TABLE t1 (f1 int,
gc_int int AS (f1 + 1) STORED,
gc_date DATE AS (f1 + 1) STORED,
KEY gc_int_idx(gc_int),
KEY gc_date_idx(gc_date));
INSERT INTO t1(f1) VALUES
(030303),(040404),
(050505),(060606),
(010101),(020202),
(030303),(040404),
(050505),(060606),
(010101),(020202),
(090909),(101010),
(010101),(020202),
(070707),(080808);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT * FROM t1 WHERE f1 + 1 > 070707;
f1	gc_int	gc_date
101010	101011	2010-10-11
70707	70708	2007-07-08
80808	80809	2008-08-09
90909	90910	2009-09-10
# INT column & index should be picked
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 > 070707;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc_int_idx	gc_int_idx	5	NULL	4	100.00	Using index condition
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc_int` AS `gc_int`,`test`.`t1`.`gc_date` AS `gc_date` from `test`.`t1` where (`test`.`t1`.`gc_int` > 70707)
SELECT * FROM t1 WHERE f1 + 1 > CAST(070707 AS DATE);
f1	gc_int	gc_date
101010	101011	2010-10-11
70707	70708	2007-07-08
80808	80809	2008-08-09
90909	90910	2009-09-10
# DATE column & index should be picked
EXPLAIN SELECT * FROM t1 WHERE f1 + 1 > CAST(070707 AS DATE);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc_date_idx	gc_date_idx	4	NULL	4	100.00	Using index condition
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc_int` AS `gc_int`,`test`.`t1`.`gc_date` AS `gc_date` from `test`.`t1` where (`test`.`t1`.`gc_date` > <cache>(cast(70707 as date)))
DROP TABLE t1;
#
# BUG#21229846: WL8170: SIGNAL 11 IN JOIN::MAKE_SUM_FUNC_LIST
#
CREATE TABLE t1 (
pk int primary key auto_increment,
col_int_key INTEGER ,
col_int_gc_key INT GENERATED ALWAYS AS (col_int_key + 1) STORED,
KEY col_int_gc_key(col_int_gc_key)
);
INSERT INTO t1 ( col_int_key) VALUES (7);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT  table1.col_int_key + 1 AS field1, table2.col_int_key AS field2
FROM (t1 AS table1  JOIN t1 AS table2 ON (table2.pk = table1.pk))
ORDER BY field1, field2;
field1	field2
8	7
EXPLAIN SELECT  table1.col_int_key + 1 AS field1, table2.col_int_key AS field2
FROM (t1 AS table1  JOIN t1 AS table2 ON (table2.pk = table1.pk))
ORDER BY field1, field2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	table1	NULL	ALL	PRIMARY	NULL	NULL	NULL	1	100.00	Using temporary; Using filesort
1	SIMPLE	table2	NULL	eq_ref	PRIMARY	PRIMARY	4	test.table1.pk	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`table1`.`col_int_key` + 1) AS `field1`,`test`.`table2`.`col_int_key` AS `field2` from `test`.`t1` `table1` join `test`.`t1` `table2` where (`test`.`table2`.`pk` = `test`.`table1`.`pk`) order by `col_int_gc_key`,`field2`
SELECT  table1.col_int_key + 1 AS field1, table2.col_int_key AS field2
FROM (t1 AS table1  JOIN t1 AS table2 ON (table2.pk = table1.pk))
GROUP BY field1, field2;
field1	field2
8	7
EXPLAIN SELECT  table1.col_int_key + 1 AS field1, table2.col_int_key AS field2
FROM (t1 AS table1  JOIN t1 AS table2 ON (table2.pk = table1.pk))
GROUP BY field1, field2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	table1	NULL	ALL	PRIMARY	NULL	NULL	NULL	1	100.00	Using temporary
1	SIMPLE	table2	NULL	eq_ref	PRIMARY	PRIMARY	4	test.table1.pk	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`table1`.`col_int_key` + 1) AS `field1`,`test`.`table2`.`col_int_key` AS `field2` from `test`.`t1` `table1` join `test`.`t1` `table2` where (`test`.`table2`.`pk` = `test`.`table1`.`pk`) group by `col_int_gc_key`,`field2`
DROP TABLE t1;
#
# Bug#21391781 ASSERT WHEN RUNNING ALTER TABLE ON A TABLE WITH INDEX
#              ON VIRTUAL COLUMN
#
CREATE TABLE t1 (
col1 INTEGER NOT NULL,
col2 INTEGER NOT NULL,
gcol1 INTEGER GENERATED ALWAYS AS (col1 + col2) VIRTUAL,
col3 INTEGER NOT NULL,
col4 INTEGER NOT NULL,
col5 INTEGER DEFAULT NULL,
col6 INTEGER DEFAULT NULL,
col7 INTEGER DEFAULT NULL,
col8 INTEGER DEFAULT NULL,
col9 INTEGER DEFAULT NULL,
col10 INTEGER DEFAULT NULL,
col11 INTEGER DEFAULT NULL,
col12 INTEGER DEFAULT NULL,
col13 INTEGER DEFAULT NULL,
col14 INTEGER DEFAULT NULL,
col15 INTEGER DEFAULT NULL,
col16 INTEGER DEFAULT NULL,
col17 INTEGER DEFAULT NULL,
col18 INTEGER DEFAULT NULL,
col19 INTEGER DEFAULT NULL,
col20 INTEGER DEFAULT NULL,
col21 INTEGER DEFAULT NULL,
col22 INTEGER DEFAULT NULL,
col23 INTEGER DEFAULT NULL,
col24 INTEGER DEFAULT NULL,
col25 INTEGER DEFAULT NULL,
col26 INTEGER DEFAULT NULL,
col27 INTEGER DEFAULT NULL,
col28 INTEGER DEFAULT NULL,
col29 INTEGER DEFAULT NULL,
col30 INTEGER DEFAULT NULL,
col31 INTEGER DEFAULT NULL,
col32 INTEGER DEFAULT NULL,
col33 INTEGER DEFAULT NULL,
col34 INTEGER DEFAULT NULL,
col35 INTEGER DEFAULT NULL,
col36 INTEGER DEFAULT NULL,
col37 INTEGER DEFAULT NULL,
col38 INTEGER DEFAULT NULL,
col39 INTEGER DEFAULT NULL,
col40 INTEGER DEFAULT NULL,
col41 INTEGER DEFAULT NULL,
col42 INTEGER DEFAULT NULL,
col43 INTEGER DEFAULT NULL,
col44 INTEGER DEFAULT NULL,
col45 INTEGER DEFAULT NULL,
col46 INTEGER DEFAULT NULL,
col47 INTEGER DEFAULT NULL,
col48 INTEGER DEFAULT NULL,
col49 INTEGER DEFAULT NULL,
col50 INTEGER DEFAULT NULL,
col51 INTEGER DEFAULT NULL,
col52 INTEGER DEFAULT NULL,
col53 INTEGER DEFAULT NULL,
col54 INTEGER DEFAULT NULL,
col55 INTEGER DEFAULT NULL,
col56 INTEGER DEFAULT NULL,
col57 INTEGER DEFAULT NULL,
col58 INTEGER DEFAULT NULL,
col59 INTEGER DEFAULT NULL,
col60 INTEGER DEFAULT NULL,
col61 INTEGER DEFAULT NULL,
col62 INTEGER DEFAULT NULL,
col63 INTEGER DEFAULT NULL,
col64 INTEGER DEFAULT NULL,
col65 INTEGER DEFAULT NULL,
gcol2 INTEGER GENERATED ALWAYS AS (col3 / col4) VIRTUAL,
KEY idx1 (gcol1)
);
INSERT INTO t1 (col1, col2, col3, col4)
VALUES (1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4), (5,5,5,5);
ALTER TABLE t1 ADD COLUMN extra INTEGER;
SELECT gcol1 FROM t1 FORCE INDEX(idx1);
gcol1
2
4
6
8
10
DROP TABLE t1;
CREATE TABLE t1 (
col1 INTEGER NOT NULL,
col2 INTEGER NOT NULL,
gcol1 INTEGER GENERATED ALWAYS AS (col1 + col2) VIRTUAL,
col3 INTEGER NOT NULL,
col4 INTEGER NOT NULL,
col5 INTEGER DEFAULT NULL,
col6 INTEGER DEFAULT NULL,
col7 INTEGER DEFAULT NULL,
col8 INTEGER DEFAULT NULL,
col9 INTEGER DEFAULT NULL,
col10 INTEGER DEFAULT NULL,
col11 INTEGER DEFAULT NULL,
col12 INTEGER DEFAULT NULL,
col13 INTEGER DEFAULT NULL,
col14 INTEGER DEFAULT NULL,
col15 INTEGER DEFAULT NULL,
col16 INTEGER DEFAULT NULL,
col17 INTEGER DEFAULT NULL,
col18 INTEGER DEFAULT NULL,
col19 INTEGER DEFAULT NULL,
col20 INTEGER DEFAULT NULL,
col21 INTEGER DEFAULT NULL,
col22 INTEGER DEFAULT NULL,
col23 INTEGER DEFAULT NULL,
col24 INTEGER DEFAULT NULL,
col25 INTEGER DEFAULT NULL,
col26 INTEGER DEFAULT NULL,
col27 INTEGER DEFAULT NULL,
col28 INTEGER DEFAULT NULL,
col29 INTEGER DEFAULT NULL,
col30 INTEGER DEFAULT NULL,
col31 INTEGER DEFAULT NULL,
col32 INTEGER DEFAULT NULL,
col33 INTEGER DEFAULT NULL,
col34 INTEGER DEFAULT NULL,
col35 INTEGER DEFAULT NULL,
col36 INTEGER DEFAULT NULL,
col37 INTEGER DEFAULT NULL,
col38 INTEGER DEFAULT NULL,
col39 INTEGER DEFAULT NULL,
col40 INTEGER DEFAULT NULL,
col41 INTEGER DEFAULT NULL,
col42 INTEGER DEFAULT NULL,
col43 INTEGER DEFAULT NULL,
col44 INTEGER DEFAULT NULL,
col45 INTEGER DEFAULT NULL,
col46 INTEGER DEFAULT NULL,
col47 INTEGER DEFAULT NULL,
col48 INTEGER DEFAULT NULL,
col49 INTEGER DEFAULT NULL,
col50 INTEGER DEFAULT NULL,
col51 INTEGER DEFAULT NULL,
col52 INTEGER DEFAULT NULL,
col53 INTEGER DEFAULT NULL,
col54 INTEGER DEFAULT NULL,
col55 INTEGER DEFAULT NULL,
col56 INTEGER DEFAULT NULL,
col57 INTEGER DEFAULT NULL,
col58 INTEGER DEFAULT NULL,
col59 INTEGER DEFAULT NULL,
col60 INTEGER DEFAULT NULL,
col61 INTEGER DEFAULT NULL,
col62 INTEGER DEFAULT NULL,
col63 INTEGER DEFAULT NULL,
col64 INTEGER DEFAULT NULL,
col65 INTEGER DEFAULT NULL,
gcol2 INTEGER GENERATED ALWAYS AS (col3 / col4) VIRTUAL,
KEY idx1 (gcol2)
);
INSERT INTO t1 (col1, col2, col3, col4)
VALUES (1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4), (5,5,5,5);
ALTER TABLE t1 ADD COLUMN extra INTEGER;
SELECT gcol2 FROM t1 FORCE INDEX(idx1);
gcol2
1
1
1
1
1
DROP TABLE t1;
#
# Bug#21628161 CRASH/MEMORY CORRUPTION ADDING INDEXES TO VIRTUAL COLUMN
#
Warnings:
Warning	3135	'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode. They will be merged with strict mode in a future release.
CREATE TABLE t (a INT,
b BOOLEAN GENERATED ALWAYS AS (a+10000) VIRTUAL,
c BLOB GENERATED ALWAYS AS (b=2) VIRTUAL);
INSERT INTO t(a) VALUES (1);
Warnings:
Warning	1264	Out of range value for column 'b' at row 1
SELECT * FROM t WHERE c = '0';
a	b	c
1	127	0
ALTER TABLE t ADD UNIQUE INDEX (c(1));
Warnings:
Warning	1264	Out of range value for column 'b' at row 1
SELECT * FROM t WHERE c = '0';
a	b	c
1	127	0
DROP TABLE t;
#
# Bug#21688115 VIRTUAL COLUMN COMPUTATION SAVE_IN_FIELD()
#              DID NOT RETURN TRUE WITH DIVIDE 0
#
CREATE TABLE t (a INT, b INT, h VARCHAR(10));
INSERT INTO t VALUES (12, 3, "ss");
INSERT INTO t VALUES (13, 4, "ss");
INSERT INTO t VALUES (14, 0, "ss");
ALTER TABLE t ADD c INT GENERATED ALWAYS AS (a/b) VIRTUAL;
CREATE INDEX idx ON t(c);
ERROR 22012: Division by 0
CALL mtr.add_suppression("\\[Warning\\] \\[[^]]*\\] InnoDB: Compute virtual column values failed");
DROP TABLE t;
#
# Bug#21770798 OPTIMIZER DOES NOT USE INDEX FOR GENERATED EXPRESSIONS
#              WITH LOGICAL OPERATORS
#
CREATE TABLE t (a INT, b INT,
gc_and INT GENERATED ALWAYS AS (a AND b) STORED,
gc_or INT GENERATED ALWAYS AS (a OR b) STORED,
gc_xor INT GENERATED ALWAYS AS (a XOR b) STORED,
gc_not INT GENERATED ALWAYS AS (NOT a) STORED,
gc_case INT GENERATED ALWAYS AS
(CASE WHEN (a AND b) THEN a ELSE b END) STORED,
INDEX(gc_and), INDEX(gc_or), INDEX(gc_xor), INDEX(gc_not),
INDEX(gc_case));
INSERT INTO t (a, b) VALUES (0, 0), (0, 1), (1, 0), (1, 1);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN SELECT a, b FROM t WHERE (a AND b) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_and	gc_and	5	const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (`test`.`t`.`gc_and` = 1)
SELECT a, b FROM t WHERE (a AND b) = 1;
a	b
1	1
EXPLAIN SELECT a, b FROM t WHERE 1 = (a AND b);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_and	gc_and	5	const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (1 = `test`.`t`.`gc_and`)
SELECT a, b FROM t WHERE 1 = (a AND b);
a	b
1	1
EXPLAIN SELECT a, b FROM t WHERE (a AND b) IN (1, 2, 3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	range	gc_and	gc_and	5	NULL	3	100.00	Using index condition
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (`test`.`t`.`gc_and` in (1,2,3))
SELECT a, b FROM t WHERE (a AND b) IN (1, 2, 3);
a	b
1	1
EXPLAIN SELECT a, b FROM t WHERE (a OR b) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_or	gc_or	5	const	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (`test`.`t`.`gc_or` = 1)
SELECT a, b FROM t WHERE (a OR b) = 1;
a	b
0	1
1	0
1	1
EXPLAIN SELECT a, b FROM t WHERE (a OR b) BETWEEN 1 AND 10;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	range	gc_or	gc_or	5	NULL	3	100.00	Using index condition
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (`test`.`t`.`gc_or` between 1 and 10)
SELECT a, b FROM t WHERE (a OR b) BETWEEN 1 AND 10;
a	b
0	1
1	0
1	1
EXPLAIN SELECT a, b FROM t WHERE (a XOR b) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_xor	gc_xor	5	const	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (`test`.`t`.`gc_xor` = 1)
SELECT a, b FROM t WHERE (a XOR b) = 1;
a	b
0	1
1	0
EXPLAIN SELECT a FROM t WHERE (NOT a) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_not	gc_not	5	const	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a` from `test`.`t` where (`test`.`t`.`gc_not` = 1)
SELECT a FROM t WHERE (NOT a) = 1;
a
0
0
EXPLAIN SELECT a FROM t WHERE (CASE WHEN (a AND b) THEN a ELSE b END) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc_case	gc_case	5	const	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a` from `test`.`t` where (`test`.`t`.`gc_case` = 1)
SELECT a FROM t WHERE (CASE WHEN (a AND b) THEN a ELSE b END) = 1;
a
0
1
EXPLAIN SELECT a, b FROM t WHERE 1 = (b AND a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (1 = (`test`.`t`.`b` and `test`.`t`.`a`))
SELECT a, b FROM t WHERE 1 = (b AND a);
a	b
1	1
EXPLAIN SELECT a, b FROM t WHERE 1 = (b OR a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
Note	1003	/* select#1 */ select `test`.`t`.`a` AS `a`,`test`.`t`.`b` AS `b` from `test`.`t` where (1 = (`test`.`t`.`b` or `test`.`t`.`a`))
Warnings:
SELECT a, b FROM t WHERE 1 = (b OR a);
a	b
0	1
1	0
1	1
DROP TABLE t;
#
# Bug#21854241: QUERY USING JSON_EXTRACT() RETURNS WRONG RESULT
#               AFTER ADDING VIRTUAL INDEX
#
CREATE TABLE employees (
data JSON,
name1 VARCHAR(30) AS (JSON_EXTRACT(data, "$.name")) STORED,
name2 VARCHAR(30) AS (JSON_UNQUOTE(JSON_EXTRACT(data, "$.name"))) STORED
);
INSERT INTO employees (data) VALUES('{"id": 1, "name": "Jane"}');
INSERT INTO employees (data) VALUES('{"id": 2, "name": "Joe"}');
ANALYZE TABLE employees;
Table	Op	Msg_type	Msg_text
test.employees	analyze	status	OK
EXPLAIN SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	employees	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`employees`.`data` AS `data`,`test`.`employees`.`name1` AS `name1`,`test`.`employees`.`name2` AS `name2` from `test`.`employees` where (json_extract(`test`.`employees`.`data`,'$.name') = 'Jane')
SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
data	name1	name2
{"id": 1, "name": "Jane"}	"Jane"	Jane
ALTER TABLE employees ADD INDEX name_idx1(name1);
ANALYZE TABLE employees;
Table	Op	Msg_type	Msg_text
test.employees	analyze	status	OK
EXPLAIN SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	employees	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`employees`.`data` AS `data`,`test`.`employees`.`name1` AS `name1`,`test`.`employees`.`name2` AS `name2` from `test`.`employees` where (json_extract(`test`.`employees`.`data`,'$.name') = 'Jane')
SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
data	name1	name2
{"id": 1, "name": "Jane"}	"Jane"	Jane
ALTER TABLE employees ADD INDEX name_idx2(name2);
ANALYZE TABLE employees;
Table	Op	Msg_type	Msg_text
test.employees	analyze	status	OK
EXPLAIN SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	employees	NULL	ref	name_idx2	name_idx2	123	const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`employees`.`data` AS `data`,`test`.`employees`.`name1` AS `name1`,`test`.`employees`.`name2` AS `name2` from `test`.`employees` where (`test`.`employees`.`name2` = 'Jane')
SELECT * FROM employees WHERE JSON_EXTRACT(data, '$.name') = 'Jane';
data	name1	name2
{"id": 1, "name": "Jane"}	"Jane"	Jane
DROP TABLE employees;
#
# Bug#22077611 UPDATE .. WHERE JSON_EXTRACT(..) = '..' NOT USING
#              VIRTUAL COL INDEX
#
CREATE TABLE t(a INT, b INT, gc INT GENERATED ALWAYS AS (a+1) STORED, KEY(gc));
INSERT INTO t(a) VALUES (1), (2), (3), (4), (5), (1), (2), (3), (4), (5);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN UPDATE t SET b = 10 WHERE (a+1) = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	UPDATE	t	NULL	range	gc	gc	5	const	2	100.00	Using where
Warnings:
Note	1003	update `test`.`t` set `test`.`t`.`b` = 10 where (`test`.`t`.`gc` = 3)
UPDATE t SET b = 10 WHERE (a+1) = 3;
SELECT * FROM t ORDER BY a, b;
a	b	gc
1	NULL	2
1	NULL	2
2	10	3
2	10	3
3	NULL	4
3	NULL	4
4	NULL	5
4	NULL	5
5	NULL	6
5	NULL	6
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN UPDATE t SET b = 9 ORDER BY (a+1) LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	UPDATE	t	NULL	index	NULL	gc	5	NULL	1	100.00	Using temporary
Warnings:
Note	1003	update `test`.`t` set `test`.`t`.`b` = 9 order by `test`.`t`.`gc` limit 1
UPDATE t SET b = 9 ORDER BY (a+1) LIMIT 1;
SELECT * FROM t ORDER BY a, b;
a	b	gc
1	NULL	2
1	9	2
2	10	3
2	10	3
3	NULL	4
3	NULL	4
4	NULL	5
4	NULL	5
5	NULL	6
5	NULL	6
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN DELETE FROM t WHERE (a+1) = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	DELETE	t	NULL	range	gc	gc	5	const	2	100.00	Using where
Warnings:
Note	1003	delete from `test`.`t` where (`test`.`t`.`gc` = 2)
DELETE FROM t WHERE (a+1) = 2;
SELECT * FROM t ORDER BY a, b;
a	b	gc
2	10	3
2	10	3
3	NULL	4
3	NULL	4
4	NULL	5
4	NULL	5
5	NULL	6
5	NULL	6
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN DELETE FROM t ORDER BY (a+1) LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	DELETE	t	NULL	index	NULL	gc	5	NULL	1	100.00	NULL
Warnings:
Note	1003	delete from `test`.`t` order by `test`.`t`.`gc` limit 1
DELETE FROM t ORDER BY (a+1) LIMIT 1;
SELECT * FROM t ORDER BY a, b;
a	b	gc
2	10	3
3	NULL	4
3	NULL	4
4	NULL	5
4	NULL	5
5	NULL	6
5	NULL	6
DROP TABLE t;
#
# Bug#22095783: ALTER TABLE ADD COLUMN FAILS WITH OUT
#               OF RANGE VALUE ERROR
CREATE TABLE c1(doc JSON,_id VARCHAR(32) GENERATED ALWAYS
AS (JSON_UNQUOTE(JSON_EXTRACT(doc, '$._id'))) STORED NOT NULL UNIQUE);
INSERT INTO c1(doc) VALUES('{"X":10,"_id":9}');
ALTER TABLE c1 ADD COLUMN vc1 DOUBLE(4, 3) GENERATED
ALWAYS AS (JSON_EXTRACT(doc, '$.X')) VIRTUAL , ADD INDEX IX1 (vc1);
ERROR 22003: Out of range value for column 'vc1' at row 1
ALTER TABLE c1 ADD vc2 INT(11);
ALTER TABLE c1 ADD COLUMN vc3 INT(11) GENERATED ALWAYS AS
(JSON_EXTRACT(doc, '$.X')) VIRTUAL , ADD UNIQUE INDEX IX2 (vc3);
ALTER TABLE c1 drop vc2;
ALTER TABLE c1 ADD vc4 INT(11);
DROP TABLE c1;
#
# Bug#22810883: ASSERTION FAILED:
#               !(USED_TABS & (~READ_TABLES & ~FILTER_FOR_TABLE))
#
CREATE TABLE t1 (a1 INTEGER GENERATED ALWAYS AS (1 AND 0) STORED,
a2 INTEGER, KEY (a1));
INSERT INTO t1 VALUES ();
CREATE TABLE t2 (b INTEGER);
INSERT INTO t2 VALUES (1);
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
# Used to choose the index on a1 and get wrong results.
EXPLAIN SELECT * FROM t1 WHERE (a2 AND a2) = 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a1` AS `a1`,`test`.`t1`.`a2` AS `a2` from `test`.`t1` where ((`test`.`t1`.`a2` and `test`.`t1`.`a2`) = 0)
SELECT * FROM t1 WHERE (a2 AND a2) = 0;
a1	a2
# Used to get assertion or wrong results.
EXPLAIN SELECT * FROM t1 STRAIGHT_JOIN t2 ON b WHERE (b AND b) = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a1` AS `a1`,`test`.`t1`.`a2` AS `a2`,`test`.`t2`.`b` AS `b` from `test`.`t1` straight_join `test`.`t2` where (((`test`.`t2`.`b` and `test`.`t2`.`b`) = 1) and `test`.`t2`.`b`)
SELECT * FROM t1 STRAIGHT_JOIN t2 ON b WHERE (b AND b) = 1;
a1	a2	b
0	NULL	1
DROP TABLE t1, t2;
#
# Bug#24345509: WRONG RESULTS WHEN GCOL INDEX IS USED
#
CREATE TABLE t1 (
pk INT PRIMARY KEY AUTO_INCREMENT,
i INT,
vc VARCHAR(7),
gc1 VARCHAR(14) GENERATED ALWAYS AS (concat(vc, vc)) VIRTUAL NOT NULL,
gc2 VARCHAR(14) GENERATED ALWAYS AS (concat(gc1, 'x')) VIRTUAL NOT NULL,
KEY gc2_key (gc2),
KEY gc2_key_prefix (gc2(5))
);
INSERT INTO t1 (i, vc) VALUES
(7, 'xcek'), (3, 'ceksat'), (3, 'eksate'), (3, 'ksatef'), (6, 's');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT i FROM t1 WHERE gc2 <= 'ksatefksatefx';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc2_key,gc2_key_prefix	gc2_key	58	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i` from `test`.`t1` where (`test`.`t1`.`gc2` <= 'ksatefksatefx')
SELECT i FROM t1 WHERE gc2 <= 'ksatefksatefx';
i
3
3
3
EXPLAIN SELECT i FROM t1 FORCE INDEX (gc2_key_prefix)
WHERE gc2 <= 'ksatefksatefx';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc2_key_prefix	gc2_key_prefix	22	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i` from `test`.`t1` FORCE INDEX (`gc2_key_prefix`) where (`test`.`t1`.`gc2` <= 'ksatefksatefx')
SELECT i FROM t1 FORCE INDEX (gc2_key_prefix)
WHERE gc2 <= 'ksatefksatefx';
i
3
3
3
EXPLAIN SELECT COUNT(*) FROM t1 WHERE gc2 <= 'ksatefksatefx';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc2_key,gc2_key_prefix	gc2_key	58	NULL	3	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t1` where (`test`.`t1`.`gc2` <= 'ksatefksatefx')
SELECT COUNT(*) FROM t1 WHERE gc2 <= 'ksatefksatefx';
COUNT(*)
3
EXPLAIN SELECT COUNT(*) FROM t1 FORCE INDEX (gc2_key_prefix)
WHERE gc2 <= 'ksatefksatefx';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	gc2_key_prefix	gc2_key_prefix	22	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t1` FORCE INDEX (`gc2_key_prefix`) where (`test`.`t1`.`gc2` <= 'ksatefksatefx')
SELECT COUNT(*) FROM t1 FORCE INDEX (gc2_key_prefix)
WHERE gc2 <= 'ksatefksatefx';
COUNT(*)
3
CREATE TABLE t2 (
i INT NOT NULL,
gc INT GENERATED ALWAYS AS (i) VIRTUAL NOT NULL,
KEY (gc)
);
INSERT INTO t2 (i) VALUES (-1), (0), (1), (2);
BEGIN;
SELECT i FROM t2 FORCE INDEX (gc) WHERE gc <= -1;
i
-1
SELECT gc FROM t2 FORCE INDEX (gc) WHERE gc <= -1;
gc
-1
COMMIT;
DROP TABLE t1, t2;
#
# Bug#27010089: ASSERTION FAILURE:
# ROW0SEL.CC:2846:TEMPL->MYSQL_COL_LEN == LEN
#
CREATE TABLE t (
pk INTEGER AUTO_INCREMENT PRIMARY KEY,
col_int_key INTEGER GENERATED ALWAYS AS (1) VIRTUAL,
col_varchar VARCHAR(7) ,
col_varchar_key VARCHAR(14) GENERATED ALWAYS AS ('abc') VIRTUAL,
KEY (col_varchar_key(5), col_int_key),
KEY (col_int_key, col_varchar_key));
INSERT INTO t VALUES (), ();
SELECT 1 FROM t AS alias1
WHERE EXISTS
(SELECT SQ2_alias1.col_int_key AS SQ2_field1
FROM t AS SQ2_alias1 JOIN t AS SQ2_alias2
ON (SQ2_alias2.col_varchar_key = SQ2_alias1.col_varchar_key)
WHERE SQ2_alias1.col_varchar <> alias1.col_varchar AND
SQ2_alias1.col_int_key >= SQ2_alias2.pk);
1
DROP TABLE t;
#
# Bug#27403367: GENERATED COLUMN EXPRESSIONS IGNORED WITH PREFIX INDEX
#
CREATE TABLE t (vc VARCHAR(100),
gc VARCHAR(100) GENERATED ALWAYS AS (REVERSE(vc)) STORED,
KEY (gc(3)));
INSERT INTO t(vc) VALUES ('a'), ('abc'), ('abcabc'), ('abcdef');
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN SELECT * FROM t WHERE REVERSE(vc) = 'cba';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc	gc	15	const	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`vc` AS `vc`,`test`.`t`.`gc` AS `gc` from `test`.`t` where (`test`.`t`.`gc` = 'cba')
SELECT * FROM t WHERE REVERSE(vc) = 'cba';
vc	gc
abc	cba
EXPLAIN SELECT * FROM t WHERE REVERSE(vc) = 'cbacba';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	ref	gc	gc	15	const	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`vc` AS `vc`,`test`.`t`.`gc` AS `gc` from `test`.`t` where (`test`.`t`.`gc` = 'cbacba')
SELECT * FROM t WHERE REVERSE(vc) = 'cbacba';
vc	gc
abcabc	cbacba
EXPLAIN SELECT * FROM t WHERE REVERSE(vc) BETWEEN 'c' AND 'e';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t	NULL	range	gc	gc	15	NULL	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`vc` AS `vc`,`test`.`t`.`gc` AS `gc` from `test`.`t` where (`test`.`t`.`gc` between 'c' and 'e')
SELECT * FROM t WHERE REVERSE(vc) BETWEEN 'c' AND 'e';
vc	gc
abc	cba
abcabc	cbacba
DROP TABLE t;
#
#
# BUG#21365158 WL8149:ASSERTION `!TABLE || (!TABLE->WRITE_SET 
#
CREATE TABLE t1 (
pk INTEGER AUTO_INCREMENT,
col_int_nokey INTEGER NOT NULL,
col_varchar_nokey VARCHAR(1) NOT NULL,
col_varchar_key VARCHAR(2) GENERATED ALWAYS AS
(CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,
PRIMARY KEY (pk)
);
INSERT INTO t1 ( col_int_nokey, col_varchar_nokey)
VALUES (4, 'b'),(9, 'o'),(4, 'k'),(5, 'a'),(5, 'f'),
(9, 't'),(3, 'c'),(8, 'c'),(0, 'r'),(98, 'k');
CREATE TABLE t2 (
pk INTEGER AUTO_INCREMENT,
col_int_nokey INTEGER NOT NULL,
col_varchar_nokey VARCHAR(1) NOT NULL,
col_varchar_key VARCHAR(2) GENERATED ALWAYS AS
(CONCAT(col_varchar_nokey, col_varchar_nokey)) VIRTUAL not null,
PRIMARY KEY (pk),
UNIQUE KEY (col_varchar_key)
);
INSERT INTO t2 ( col_int_nokey, col_varchar_nokey)
VALUES (1, 'c'),(8, 'm'),(9, 'd'), (6, 'y'),(1, 't'),
(2, 's'),(4, 'r');
SELECT
CONCAT( t2.col_varchar_nokey , t2.col_varchar_nokey ) AS f2,
t1.col_varchar_key AS f5
FROM
t2 LEFT JOIN t1 ON t2.col_int_nokey > t1.col_int_nokey
ORDER BY f2, f5;
f2	f5
cc	rr
dd	aa
dd	bb
dd	cc
dd	cc
dd	ff
dd	kk
dd	rr
mm	aa
mm	bb
mm	cc
mm	ff
mm	kk
mm	rr
rr	cc
rr	rr
ss	rr
tt	rr
yy	aa
yy	bb
yy	cc
yy	ff
yy	kk
yy	rr
DROP TABLE t1,t2;
#
DROP VIEW  IF EXISTS v1,v2;
DROP TABLE IF EXISTS t1,t2,t3;
DROP PROCEDURE IF EXISTS p1;
DROP FUNCTION IF EXISTS f1;
DROP TRIGGER IF EXISTS trg1;
DROP TRIGGER IF EXISTS trg2;
set sql_warnings = 0;
