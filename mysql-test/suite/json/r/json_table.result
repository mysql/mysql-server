# 
# WL#8867: Add JSON_TABLE table function
# 
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b')
) as tt;
id	jpath	jexst
1	3	0
2	2	0
3	NULL	1
4	0	0
explain select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b')
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`jexst` AS `jexst` from json_table('[{"a":"3"},{"a":2},{"b":1},{"a":0}]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a', jexst int exists path '$.b')) `tt`
select * from
json_table(
'[{"x":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a' default '[99]' on error,
jexst int exists path '$.b')
) as tt;
ERROR 42000: Invalid default value for 'jpath'
select * from
json_table(
'[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a'
                default '33' on empty
default '66' on error,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	jpath	jsn_path	jexst
1	33	{"x": 33}	0
2	2	2	0
3	33	{"x": 33}	1
4	0	0	0
5	66	[1, 2]	0
explain select * from
json_table(
'[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a'
                default '33' on empty
default '66' on error,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`jsn_path` AS `jsn_path`,`tt`.`jexst` AS `jexst` from json_table('[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a' default '33' on empty default '66' on error, jsn_path json path '$.a' default '{"x":33}' on empty, jexst int exists path '$.b')) `tt`
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0.33},{"a":"asd"}]',
'$[*]' columns (id for ordinality,
jpath_i int path '$.a'
                default '33' on empty
default '66' on error,
jpath_r real(10,2) path '$.a'
                default '33.3' on empty
default '77.7' on error,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	jpath_i	jpath_r	jsn_path	jexst
1	3	3.00	"3"	0
2	2	2.00	2	0
3	33	33.30	{"x": 33}	1
4	0	0.33	0.33	0
5	66	77.70	"asd"	0
Warnings:
Warning	3156	Invalid JSON value for CAST to INTEGER from column jpath_i at row 1
Warning	3156	Invalid JSON value for CAST to DOUBLE from column jpath_r at row 1
explain select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0.33},{"a":"asd"}]',
'$[*]' columns (id for ordinality,
jpath_i int path '$.a'
                default '33' on empty
default '66' on error,
jpath_r real(10,2) path '$.a'
                default '33.3' on empty
default '77.7' on error,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath_i` AS `jpath_i`,`tt`.`jpath_r` AS `jpath_r`,`tt`.`jsn_path` AS `jsn_path`,`tt`.`jexst` AS `jexst` from json_table('[{"a":"3"},{"a":2},{"b":1},{"a":0.33},{"a":"asd"}]', '$[*]' columns (id for ordinality, jpath_i int path '$.a' default '33' on empty default '66' on error, jpath_r double path '$.a' default '33.3' on empty default '77.7' on error, jsn_path json path '$.a' default '{"x":33}' on empty, jexst int exists path '$.b')) `tt`
select * from
json_table(
'[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a'
                default '66' on error
default '33' on empty,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	jpath	jsn_path	jexst
1	33	{"x": 33}	0
2	2	2	0
3	33	{"x": 33}	1
4	0	0	0
5	66	[1, 2]	0
explain  select * from
json_table(
'[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a'
                default '66' on error
default '33' on empty,
jsn_path json path '$.a' default '{"x":33}' on empty,
jexst int exists path '$.b')
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`jsn_path` AS `jsn_path`,`tt`.`jexst` AS `jexst` from json_table('[{"x":"3"},{"a":2},{"b":1},{"a":0},{"a":[1,2]}]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a' default '33' on empty default '66' on error, jsn_path json path '$.a' default '{"x":33}' on empty, jexst int exists path '$.b')) `tt`
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
json_path json path '$.a',
jexst int exists path '$.b')
) as tt;
id	jpath	json_path	jexst
1	3	"3"	0
2	2	2	0
3	NULL	NULL	1
4	0	0	0
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
json_path json path '$.a',
jexst int exists path '$.b')
) as tt
where id = 3;
id	jpath	json_path	jexst
3	NULL	NULL	1
explain  select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
json_path json path '$.a',
jexst int exists path '$.b')
) as tt
where id = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ref	<auto_key0>	<auto_key0>	9	const	1	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`json_path` AS `json_path`,`tt`.`jexst` AS `jexst` from json_table('[{"a":"3"},{"a":2},{"b":1},{"a":0}]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a', json_path json path '$.a', jexst int exists path '$.b')) `tt` where (`tt`.`id` = 3)
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a' error on empty,
jexst int exists path '$.b')
) as tt;
ERROR 22035: Missing value for JSON_TABLE column 'jpath'
select * from
json_table(
'[{"a":"3"},{"a":2},{"a":1},{"a":[0,1]}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a' error on error,
jexst int exists path '$.b')
) as tt;
ERROR 2203F: Can't store an array or an object in the scalar JSON_TABLE column 'jpath'
select * from
json_table(
'!#@$!@#$',
'$[*]' columns (id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b')
) as tt;
ERROR 22032: Invalid JSON text in argument 1 to function json_table: "Invalid value." at position 0.
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
"!@#$!@#$" columns (id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b')
) as tt;
ERROR 42000: Invalid JSON path expression. The error is around character position 1.
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
jpath varchar(100) path "!@#$!@#$",
jexst int exists path '$.b')
) as tt;
ERROR 42000: Invalid JSON path expression. The error is around character position 1.
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
id for ordinality)
) as tt;
ERROR 42S21: Duplicate column name 'id'
select * from
json_table(
'[{"a":"3"},{"a":2},{"b":1},{"a":0}]',
'$[*]' columns (id for ordinality,
_id for ordinality)
) as tt;
id	_id
1	1
2	2
3	3
4	4
select * from
json_table(
'[
      {"a":"3", "n": { "l": 1}},
      {"a":2, "n": { "l": 1}},
      {"b":1, "n": { "l": 1}},
      {"a":0, "n": { "l": 1}}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n' columns (
id_n for ordinality,
jpath_n varchar(50) path '$.l')
)
) as tt;
id	jpath	jexst	id_n	jpath_n
1	3	0	1	1
2	2	0	1	1
3	NULL	1	1	1
4	0	0	1	1
explain select * from
json_table(
'[
      {"a":"3", "n": { "l": 1}},
      {"a":2, "n": { "l": 1}},
      {"b":1, "n": { "l": 1}},
      {"a":0, "n": { "l": 1}}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n' columns (
id_n for ordinality,
jpath_n varchar(50) path '$.l')
)
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`jexst` AS `jexst`,`tt`.`id_n` AS `id_n`,`tt`.`jpath_n` AS `jpath_n` from json_table('[\n      {"a":"3", "n": { "l": 1}},\n      {"a":2, "n": { "l": 1}},\n      {"b":1, "n": { "l": 1}},\n      {"a":0, "n": { "l": 1}}\n    ]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a', jexst int exists path '$.b', nested path '$.n' columns (id_n for ordinality, jpath_n varchar(50) path '$.l'))) `tt`
explain format=json select * from
json_table(
'[
      {"a":"3", "n": { "l": 1}},
      {"a":2, "n": { "l": 1}},
      {"b":1, "n": { "l": 1}},
      {"a":0, "n": { "l": 1}}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n' columns (
id_n for ordinality,
jpath_n varchar(50) path '$.l')
)
) as tt;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "2.72"
    },
    "table": {
      "table_name": "tt",
      "access_type": "ALL",
      "rows_examined_per_scan": 2,
      "rows_produced_per_join": 2,
      "filtered": "100.00",
      "table_function": "json_table",
      "using_temporary_table": true,
      "cost_info": {
        "read_cost": "2.52",
        "eval_cost": "0.20",
        "prefix_cost": "2.73",
        "data_read_per_join": "1K"
      },
      "used_columns": [
        "id",
        "jpath",
        "jexst",
        "id_n",
        "jpath_n"
      ]
    }
  }
}
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`jexst` AS `jexst`,`tt`.`id_n` AS `id_n`,`tt`.`jpath_n` AS `jpath_n` from json_table('[\n      {"a":"3", "n": { "l": 1}},\n      {"a":2, "n": { "l": 1}},\n      {"b":1, "n": { "l": 1}},\n      {"a":0, "n": { "l": 1}}\n    ]', '$[*]' columns (id for ordinality, jpath varchar(100) path '$.a', jexst int exists path '$.b', nested path '$.n' columns (id_n for ordinality, jpath_n varchar(50) path '$.l'))) `tt`
select * from
json_table(
'[
      {"a":2, "n": [{ "l": 1}, {"l": 11}]},
      {"a":1, "n": [{ "l": 2}, {"l": 22}]}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(50) path '$.a',
nested path '$.n[*]' columns (
id_n for ordinality,
jpath_n varchar(50) path '$.l'),
nested path '$.n[*]' columns (
id_m for ordinality,
jpath_m varchar(50) path '$.l')
)
) as tt;
id	jpath	id_n	jpath_n	id_m	jpath_m
1	2	1	1	NULL	NULL
1	2	2	11	NULL	NULL
1	2	NULL	NULL	1	1
1	2	NULL	NULL	2	11
2	1	1	2	NULL	NULL
2	1	2	22	NULL	NULL
2	1	NULL	NULL	1	2
2	1	NULL	NULL	2	22
explain select * from
json_table(
'[
      {"a":2, "n": [{ "l": 1}, {"l": 11}]},
      {"a":1, "n": [{ "l": 2}, {"l": 22}]}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(50) path '$.a',
nested path '$.n[*]' columns (
id_n for ordinality,
jpath_n varchar(50) path '$.l'),
nested path '$.n[*]' columns (
id_m for ordinality,
jpath_m varchar(50) path '$.l')
)
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id` AS `id`,`tt`.`jpath` AS `jpath`,`tt`.`id_n` AS `id_n`,`tt`.`jpath_n` AS `jpath_n`,`tt`.`id_m` AS `id_m`,`tt`.`jpath_m` AS `jpath_m` from json_table('[\n      {"a":2, "n": [{ "l": 1}, {"l": 11}]},\n      {"a":1, "n": [{ "l": 2}, {"l": 22}]}\n    ]', '$[*]' columns (id for ordinality, jpath varchar(50) path '$.a', nested path '$.n[*]' columns (id_n for ordinality, jpath_n varchar(50) path '$.l'), nested path '$.n[*]' columns (id_m for ordinality, jpath_m varchar(50) path '$.l'))) `tt`
select * from   json_table(
'[
    {"a":"3", "n": ["b","a","c"]},
    {"a":2, "n": [1,2]},
    {"b":1, "n": ["zzz"]},
    {"a":0, "n": [0.1, 0.02]}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n[*]' columns (
id_n for ordinality,
jpath_n varchar(50) path '$')
)
) as tt;
id	jpath	jexst	id_n	jpath_n
1	3	0	1	b
1	3	0	2	a
1	3	0	3	c
2	2	0	1	1
2	2	0	2	2
3	NULL	1	1	zzz
4	0	0	1	0.1
4	0	0	2	0.02
select * from   json_table(
'[
    {"a":"3", "n": ["b","a","c"]},
    {"a":2, "n": [1,2]},
    {"b":1, "n": ["zzz"]},
    {"a":0, "n": [0.1, 0.02]}
    ]',
'$[*]' columns (
id for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n[*]' columns (
id_n1 for ordinality,
jpath_n1 varchar(50) path '$') ,
nested path '$.n[*]' columns (
id_n2 for ordinality,
jpath_n2 varchar(50) path '$')
)
) as tt;
id	jpath	jexst	id_n1	jpath_n1	id_n2	jpath_n2
1	3	0	1	b	NULL	NULL
1	3	0	2	a	NULL	NULL
1	3	0	3	c	NULL	NULL
1	3	0	NULL	NULL	1	b
1	3	0	NULL	NULL	2	a
1	3	0	NULL	NULL	3	c
2	2	0	1	1	NULL	NULL
2	2	0	2	2	NULL	NULL
2	2	0	NULL	NULL	1	1
2	2	0	NULL	NULL	2	2
3	NULL	1	1	zzz	NULL	NULL
3	NULL	1	NULL	NULL	1	zzz
4	0	0	1	0.1	NULL	NULL
4	0	0	2	0.02	NULL	NULL
4	0	0	NULL	NULL	1	0.1
4	0	0	NULL	NULL	2	0.02
select * from   json_table(
'[
    {"a":"3", "n": [ {"ll":["b1","b2","b3"]}, {"ll": ["a1","a2"]},
    {"ll":["c"]} ]},
    {"a":2, "n": [{"ll":[1,11,111]},{"ll":[2]}]},
    {"b":1, "n": [{"ll":["zzz"]}]},
    {"a":0, "n": [{"ll":[0.1,0.01]}, {"ll":[0.02,0.002,0.0002]}]}
    ]',
'$[*]' columns (
id1 for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n[*]' columns (
id2 for ordinality,
nested path '$.ll[*]' columns (
id3 for ordinality,
jpath_3 varchar(50) path '$')
),
nested path '$.n[*]' columns (
id4 for ordinality,
jpath_4 json path '$')
)
) as tt;
id1	jpath	jexst	id2	id3	jpath_3	id4	jpath_4
1	3	0	1	1	b1	NULL	NULL
1	3	0	1	2	b2	NULL	NULL
1	3	0	1	3	b3	NULL	NULL
1	3	0	2	1	a1	NULL	NULL
1	3	0	2	2	a2	NULL	NULL
1	3	0	3	1	c	NULL	NULL
1	3	0	NULL	NULL	NULL	1	{"ll": ["b1", "b2", "b3"]}
1	3	0	NULL	NULL	NULL	2	{"ll": ["a1", "a2"]}
1	3	0	NULL	NULL	NULL	3	{"ll": ["c"]}
2	2	0	1	1	1	NULL	NULL
2	2	0	1	2	11	NULL	NULL
2	2	0	1	3	111	NULL	NULL
2	2	0	2	1	2	NULL	NULL
2	2	0	NULL	NULL	NULL	1	{"ll": [1, 11, 111]}
2	2	0	NULL	NULL	NULL	2	{"ll": [2]}
3	NULL	1	1	1	zzz	NULL	NULL
3	NULL	1	NULL	NULL	NULL	1	{"ll": ["zzz"]}
4	0	0	1	1	0.1	NULL	NULL
4	0	0	1	2	0.01	NULL	NULL
4	0	0	2	1	0.02	NULL	NULL
4	0	0	2	2	0.002	NULL	NULL
4	0	0	2	3	0.0002	NULL	NULL
4	0	0	NULL	NULL	NULL	1	{"ll": [0.1, 0.01]}
4	0	0	NULL	NULL	NULL	2	{"ll": [0.02, 0.002, 0.0002]}
explain select * from   json_table(
'[
    {"a":"3", "n": [ {"ll":["b1","b2","b3"]}, {"ll": ["a1","a2"]},
    {"ll":["c"]} ]},
    {"a":2, "n": [{"ll":[1,11,111]},{"ll":[2]}]},
    {"b":1, "n": [{"ll":["zzz"]}]},
    {"a":0, "n": [{"ll":[0.1,0.01]}, {"ll":[0.02,0.002,0.0002]}]}
    ]',
'$[*]' columns (
id1 for ordinality,
jpath varchar(100) path '$.a',
jexst int exists path '$.b',
nested path '$.n[*]' columns (
id2 for ordinality,
nested path '$.ll[*]' columns (
id3 for ordinality,
jpath_3 varchar(50) path '$')
),
nested path '$.n[*]' columns (
id4 for ordinality,
jpath_4 json path '$')
)
) as tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`id1` AS `id1`,`tt`.`jpath` AS `jpath`,`tt`.`jexst` AS `jexst`,`tt`.`id2` AS `id2`,`tt`.`id3` AS `id3`,`tt`.`jpath_3` AS `jpath_3`,`tt`.`id4` AS `id4`,`tt`.`jpath_4` AS `jpath_4` from json_table('[\n    {"a":"3", "n": [ {"ll":["b1","b2","b3"]}, {"ll": ["a1","a2"]},\n    {"ll":["c"]} ]},\n    {"a":2, "n": [{"ll":[1,11,111]},{"ll":[2]}]},\n    {"b":1, "n": [{"ll":["zzz"]}]},\n    {"a":0, "n": [{"ll":[0.1,0.01]}, {"ll":[0.02,0.002,0.0002]}]}\n    ]', '$[*]' columns (id1 for ordinality, jpath varchar(100) path '$.a', jexst int exists path '$.b', nested path '$.n[*]' columns (id2 for ordinality, nested path '$.ll[*]' columns (id3 for ordinality, jpath_3 varchar(50) path '$')), nested path '$.n[*]' columns (id4 for ordinality, jpath_4 json path '$'))) `tt`
ord should be 1,1,1,2, which tells that first two values of 'l' are
from the same object, and next two are from different objects
SELECT *
FROM JSON_TABLE(
'[{"a": "a_val",
   "b": [
          {"c": "c_val",
           "l": [1,2]}
        ]
    }, {"a": "a_val",
     "b": [
            {"c": "c_val",
             "l": [11]},
            {"c": "c_val",
             "l": [22]}
           ]
    }]',
'$[*]' COLUMNS (
apath VARCHAR(10) PATH '$.a',
NESTED PATH '$.b[*]' COLUMNS (
bpath VARCHAR(10) PATH '$.c',
ord FOR ORDINALITY,
NESTED PATH '$.l[*]' COLUMNS (
lpath varchar(10) PATH '$'
        )
)
)) as jt;
apath	bpath	ord	lpath
a_val	c_val	1	1
a_val	c_val	1	2
a_val	c_val	1	11
a_val	c_val	2	22
explain SELECT *
FROM JSON_TABLE(
'[{"a": "a_val",
   "b": [
          {"c": "c_val",
           "l": [1,2]}
        ]
    }, {"a": "a_val",
     "b": [
            {"c": "c_val",
             "l": [11]},
            {"c": "c_val",
             "l": [22]}
           ]
    }]',
'$[*]' COLUMNS (
apath VARCHAR(10) PATH '$.a',
NESTED PATH '$.b[*]' COLUMNS (
bpath VARCHAR(10) PATH '$.c',
ord FOR ORDINALITY,
NESTED PATH '$.l[*]' COLUMNS (
lpath varchar(10) PATH '$'
        )
)
)) as jt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `jt`.`apath` AS `apath`,`jt`.`bpath` AS `bpath`,`jt`.`ord` AS `ord`,`jt`.`lpath` AS `lpath` from json_table('[{"a": "a_val",\n   "b": [\n          {"c": "c_val",\n           "l": [1,2]}\n        ]\n    }, {"a": "a_val",\n     "b": [\n            {"c": "c_val",\n             "l": [11]},\n            {"c": "c_val",\n             "l": [22]}\n           ]\n    }]', '$[*]' columns (apath varchar(10) path '$.a', nested path '$.b[*]' columns (bpath varchar(10) path '$.c', ord for ordinality, nested path '$.l[*]' columns (lpath varchar(10) path '$')))) `jt`
CREATE TABLE jt( i JSON );
SELECT * FROM jt, JSON_TABLE(jt.i, '$' COLUMNS (a INT PATH '$')) AS tt
WHERE a=1;
i	a
EXPLAIN SELECT * FROM jt, JSON_TABLE(jt.i, '$' COLUMNS (a INT PATH '$')) AS tt
WHERE a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	tt	NULL	ref	<auto_key0>	<auto_key0>	5	const	1	100.00	Table function: json_table; Using temporary; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`jt`.`i` AS `i`,`tt`.`a` AS `a` from `test`.`jt` join json_table(`test`.`jt`.`i`, '$' columns (a int path '$')) `tt` where (`tt`.`a` = 1)
SELECT * FROM (
SELECT * FROM jt, JSON_TABLE(jt.i, '$' COLUMNS (a INT PATH '$')) AS tt
WHERE a=1) AS ttt;
i	a
EXPLAIN SELECT * FROM (
SELECT * FROM jt, JSON_TABLE(jt.i, '$' COLUMNS (a INT PATH '$')) AS tt
WHERE a=1) AS ttt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	tt	NULL	ref	<auto_key0>	<auto_key0>	5	const	1	100.00	Table function: json_table; Using temporary; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`jt`.`i` AS `i`,`tt`.`a` AS `a` from `test`.`jt` join json_table(`test`.`jt`.`i`, '$' columns (a int path '$')) `tt` where (`tt`.`a` = 1)
DROP TABLE jt;
SELECT * FROM JSON_TABLE(CAST(CAST("11:22:33" AS TIME) AS JSON),
'$' COLUMNS (dt DATE PATH '$')) as tt;
dt
NULL
Warnings:
Warning	1292	Incorrect date value: '11:22:33.000000' for column 'dt' at row 1
SELECT * FROM JSON_TABLE(CAST(CAST("11:22:33" AS TIME) AS JSON),
'$' COLUMNS (dt TIME PATH '$')) as tt;
dt
11:22:33
SELECT * FROM JSON_TABLE(CAST(CAST("2001.02.03" AS DATE) AS JSON),
'$' COLUMNS (dt DATE PATH '$')) as tt;
dt
2001-02-03
CREATE VIEW v AS 
SELECT * FROM JSON_TABLE('[1,2,3]',
'$[*]' COLUMNS (num INT PATH '$.a'
                                           DEFAULT '123' ON EMPTY 
DEFAULT '456' ON ERROR)) AS jt;
SELECT * FROM v;
num
123
123
123
SHOW CREATE VIEW v;
View	Create View	character_set_client	collation_connection
v	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v` AS select `jt`.`num` AS `num` from json_table('[1,2,3]', '$[*]' columns (num int path '$.a' default '123' on empty default '456' on error)) `jt`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v;
SELECT * FROM JSON_TABLE('"asdf"',
'$' COLUMNS (a INT PATH '$' ERROR ON ERROR)) AS jt;
ERROR 22018: Invalid JSON value for CAST to INTEGER from column a at row 1
SELECT * FROM
JSON_TABLE('[{"a":1},{"a":2}]',
'$' COLUMNS (a INT PATH '$[*].a' ERROR ON ERROR)) AS jt;
ERROR 2203F: Can't store an array or an object in the scalar JSON_TABLE column 'a'
SELECT * FROM
JSON_TABLE('[{"a":1},{"a":2}]',
'$' COLUMNS (a JSON PATH '$[*].a' ERROR ON ERROR)) AS jt;
a
[1, 2]
SELECT * FROM
JSON_TABLE('123.456', '$' COLUMNS (a DECIMAL(2,1) PATH '$' ERROR ON ERROR)) AS jt;
ERROR 22003: Value is out of range for JSON_TABLE's column 'a'
SELECT * FROM
JSON_TABLE('123.456', '$' COLUMNS (a DECIMAL(2,1) PATH '$')) AS jt;
a
NULL
Warnings:
Warning	1264	Out of range value for column 'a' at row 1
SELECT * FROM
JSON_TABLE('{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{"a":1,"b":{}}}}}}}}}}}}}}}}}}}',
'$' COLUMNS (i0 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i1 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i2 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i3 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i4 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i5 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i6 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i7 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i8 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i9 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i10 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i11 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i12 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i13 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i14 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i15 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i16 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i17 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i18 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i19 INT PATH '$.a',
NESTED PATH '$.b' COLUMNS (i20 INT PATH '$.a'
              )))))))))))))))))))))) jt;
ERROR 42000: More than supported 16 NESTED PATHs were found in JSON_TABLE 'jt'
CREATE TABLE t1(id int, jd JSON);
INSERT INTO t1 values (1, '[1,3,5]'),(2,'[2,4,6]');
SELECT id, jt.* FROM t1,
JSON_TABLE(jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt;
id	jid	val
1	1	1
1	2	3
1	3	5
2	1	2
2	2	4
2	3	6
SELECT /*+ JOIN_ORDER(jt, t1) */ id, jt.*
FROM t1,
JSON_TABLE(jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt;
id	jid	val
1	1	1
1	2	3
1	3	5
2	1	2
2	2	4
2	3	6
EXPLAIN SELECT /*+ JOIN_ORDER(jt, t1) */ id, jt.*
FROM t1,
JSON_TABLE(jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`jt`.`jid` AS `jid`,`jt`.`val` AS `val` from `test`.`t1` join json_table(`test`.`t1`.`jd`, '$[*]' columns (jid for ordinality, val int path '$')) `jt`
SELECT /*+ JOIN_ORDER(t2,jt) */ t1.id, t2.id, jt.*
FROM t1,
JSON_TABLE(t1.jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt,
t1 AS t2;
id	id	jid	val
1	1	1	1
1	1	2	3
1	1	3	5
2	1	1	2
2	1	2	4
2	1	3	6
1	2	1	1
1	2	2	3
1	2	3	5
2	2	1	2
2	2	2	4
2	2	3	6
EXPLAIN SELECT t1.id, t2.id, jt.*
FROM t1,
JSON_TABLE(t1.jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt,
t1 AS t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t2`.`id` AS `id`,`jt`.`jid` AS `jid`,`jt`.`val` AS `val` from `test`.`t1` join json_table(`test`.`t1`.`jd`, '$[*]' columns (jid for ordinality, val int path '$')) `jt` join `test`.`t1` `t2`
EXPLAIN SELECT /*+ JOIN_ORDER(t2,jt) */ t1.id, t2.id, jt.*
FROM t1,
JSON_TABLE(t1.jd, '$[*]' COLUMNS (jid FOR ORDINALITY,
val INT PATH '$')) AS jt,
t1 AS t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select /*+ JOIN_ORDER(@`select#1` `t2`,`jt`) */ `test`.`t1`.`id` AS `id`,`test`.`t2`.`id` AS `id`,`jt`.`jid` AS `jid`,`jt`.`val` AS `val` from `test`.`t1` join json_table(`test`.`t1`.`jd`, '$[*]' columns (jid for ordinality, val int path '$')) `jt` join `test`.`t1` `t2`
SELECT * FROM t1 WHERE id IN
(SELECT * FROM JSON_TABLE('[1,2]', '$[*]' COLUMNS
(id INT PATH '$')) AS jt);
id	jd
1	[1, 3, 5]
2	[2, 4, 6]
EXPLAIN SELECT * FROM t1 WHERE id IN
(SELECT * FROM JSON_TABLE('[1,2]', '$[*]' COLUMNS
(id INT PATH '$')) AS jt);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	jt	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.id	2	100.00	Table function: json_table; Using temporary; Using index; FirstMatch(t1)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`jd` AS `jd` from `test`.`t1` semi join (json_table('[1,2]', '$[*]' columns (id int path '$')) `jt`) where (`jt`.`id` = `test`.`t1`.`id`)
SELECT * FROM t1 WHERE id IN
(SELECT * FROM JSON_TABLE(t1.jd, '$[*]' COLUMNS
(id INT PATH '$')) AS jt);
id	jd
1	[1, 3, 5]
2	[2, 4, 6]
EXPLAIN SELECT * FROM t1 WHERE id IN
(SELECT * FROM JSON_TABLE(t1.jd, '$[*]' COLUMNS
(id INT PATH '$')) AS jt);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	jt	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.id	2	100.00	Table function: json_table; Using temporary; Using index; FirstMatch(t1)
Warnings:
Note	1276	Field or reference 'test.t1.jd' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`jd` AS `jd` from `test`.`t1` semi join (json_table(`test`.`t1`.`jd`, '$[*]' columns (id int path '$')) `jt`) where (`jt`.`id` = `test`.`t1`.`id`)
SELECT id, jt1.*, jt2.*
FROM t1, JSON_TABLE(jd, '$' COLUMNS (data1 JSON PATH '$')) AS jt1,
JSON_TABLE(data1, '$[*]' COLUMNS (id2 INT PATH '$')) AS jt2;
id	data1	id2
1	[1, 3, 5]	1
1	[1, 3, 5]	3
1	[1, 3, 5]	5
2	[2, 4, 6]	2
2	[2, 4, 6]	4
2	[2, 4, 6]	6
EXPLAIN SELECT id, jt1.*, jt2.*
FROM t1, JSON_TABLE(jd, '$' COLUMNS (data1 JSON PATH '$')) AS jt1,
JSON_TABLE(data1, '$[*]' COLUMNS (id2 INT PATH '$')) AS jt2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	jt1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
1	SIMPLE	jt2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`jt1`.`data1` AS `data1`,`jt2`.`id2` AS `id2` from `test`.`t1` join json_table(`test`.`t1`.`jd`, '$' columns (data1 json path '$')) `jt1` join json_table(`jt1`.`data1`, '$[*]' columns (id2 int path '$')) `jt2`
DROP TABLE t1;
SELECT * FROM JSON_TABLE ('"asdf"', '$' COLUMNS(
tm TIME PATH '$',
dt DATE PATH '$',
i INT PATH '$',
f FLOAT PATH '$',
d DECIMAL PATH '$')) AS jt;
tm	dt	i	f	d
NULL	NULL	NULL	NULL	NULL
Warnings:
Warning	1292	Incorrect time value: 'asdf' for column 'tm' at row 1
Warning	1292	Incorrect date value: 'asdf' for column 'dt' at row 1
Warning	3156	Invalid JSON value for CAST to INTEGER from column i at row 1
Warning	3156	Invalid JSON value for CAST to DOUBLE from column f at row 1
Warning	3156	Invalid JSON value for CAST to DECIMAL from column d at row 1
#
# Bug#25413069: SIG11 IN CHECK_COLUMN_GRANT_IN_TABLE_REF
#
SELECT a FROM JSON_TABLE(abc, '$[*]' COLUMNS ( a int path '$.a')) AS jt;
ERROR 42S22: Unknown column 'abc' in 'a table function argument'
#
# Bug#25420680: ASSERTION `THD->IS_ERROR()' FAILED IN SQL/SQL_SELECT.CC
#
SELECT * FROM JSON_TABLE('{"a":"2017-11-1"}',
'$'  COLUMNS (jpath DATE PATH '$.a')) AS jt;
jpath
2017-11-01
#
# Bug#25413826: ASSERTION `TABLE_LIST->ALIAS' FAILED
#
SELECT * FROM JSON_TABLE('[{"a": 1, "b": 2}]',
'$[*]' COLUMNS ( a int path '$.b'));
ERROR 42000: Every table function must have an alias
#
# Bug#25421464: ASSERTION `!STRCMP(TABLE_REF->TABLE_NAME, ...
#
CREATE VIEW v1 AS
SELECT * FROM JSON_TABLE('[{"a": 1, "b": 2}]',
'$[*]' COLUMNS ( a INT PATH '$.b')) AS jt;
SELECT * FROM v1;
a
2
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `jt`.`a` AS `a` from json_table('[{"a": 1, "b": 2}]', '$[*]' columns (a int path '$.b')) `jt`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
#
# Bug#25427457: ASSERTION `!((*REG_FIELD)->FLAGS & 16)' 
#
SELECT * FROM JSON_TABLE('{"a":"1"}',
'$' COLUMNS (jpath JSON PATH '$.a',
o FOR ORDINALITY)) AS jt
WHERE o = 1;
jpath	o
"1"	1
#
# Bug#25427982: ASSERTION `DERIVED' FAILED IN SQL/TABLE.H
#
SELECT je,o FROM JSON_TABLE('{"a":"1"}',
'$' COLUMNS (o FOR ORDINALITY,
je BIGINT EXISTS PATH '$.a')) AS jt
GROUP BY je;
ERROR 42000: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'jt.o' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT je,COUNT(o) FROM JSON_TABLE('{"a":"1"}',
'$' COLUMNS (o FOR ORDINALITY,
je BIGINT EXISTS PATH '$.a')) AS jt
GROUP BY je;
je	COUNT(o)
1	1
#
# Bug#25413194: ASSERTION `!(WANT_PRIVILEGE & ~(GRANT->WANT_PRIVILEGE
#
CREATE TABLE t1 (j JSON);
SELECT * FROM t1,JSON_TABLE(t1.j, '$[*]' COLUMNS ( a int path '$.b')) AS jt;
j	a
DROP TABLE t1;
#
# Bug#25460537:SIG 11 IN NEXT_FAST AT SQL/SQL_LIST.H
#
PREPARE STMT FROM 
"SELECT * FROM   JSON_TABLE(
    \'[{\"a\":\"3\"},{\"a\":2},{\"b\":1},{\"a\":0}]\',
    \'$[*]\' COLUMNS (id
      FOR ORDINALITY,
      jpath VARCHAR(100) PATH \'$.a\',
      jexst INT EXISTS PATH \'$.b\')
    ) as tt";
EXECUTE STMT;
id	jpath	jexst
1	3	0
2	2	0
3	NULL	1
4	0	0
EXECUTE STMT;
id	jpath	jexst
1	3	0
2	2	0
3	NULL	1
4	0	0
DEALLOCATE PREPARE stmt;
#
# Bug#25522353: SIG 11 IN JOIN::MAKE_JOIN_PLAN | SQL/SQL_OPTIMIZER.CC
#
CREATE TABLE t1 (id INT, jc JSON);
SELECT * FROM t1 RIGHT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
SELECT * FROM JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt LEFT JOIN t1 ON t1.jc=jt.id;
ERROR 42S02: Unknown table 't1' in a table function argument
SELECT * FROM JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt RIGHT JOIN t1 ON t1.jc=jt.id;
ERROR 42S02: Unknown table 't1' in a table function argument
SELECT * FROM t1 LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id;
id	jc	id
EXPLAIN SELECT * FROM t1 LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary; Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`jc` AS `jc`,`jt`.`id` AS `id` from `test`.`t1` left join json_table(`test`.`t1`.`jc`, '$' columns (id for ordinality)) `jt` on((`test`.`t1`.`jc` = `jt`.`id`)) where 1
SELECT * FROM t1 t1o RIGHT JOIN t1 ON t1o.id=t1.id
LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id;
id	jc	id	jc	id
EXPLAIN SELECT * FROM t1 t1o RIGHT JOIN t1 ON t1o.id=t1.id
LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	t1o	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary; Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1o`.`id` AS `id`,`test`.`t1o`.`jc` AS `jc`,`test`.`t1`.`id` AS `id`,`test`.`t1`.`jc` AS `jc`,`jt`.`id` AS `id` from `test`.`t1` left join `test`.`t1` `t1o` on((`test`.`t1o`.`id` = `test`.`t1`.`id`)) left join json_table(`test`.`t1`.`jc`, '$' columns (id for ordinality)) `jt` on((`test`.`t1`.`jc` = `jt`.`id`)) where 1
SELECT * FROM t1 AS t1o RIGHT JOIN
(t1 AS t1i JOIN JSON_TABLE(t1o.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1i.jc=jt.id)
ON t1o.id=t1i.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
SELECT * FROM t1 AS t1o RIGHT JOIN
(t1 AS t1i RIGHT JOIN JSON_TABLE(t1o.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1i.jc=jt.id)
ON t1o.id=t1i.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
WITH qn AS
(SELECT jt.* FROM t1 RIGHT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id)
SELECT * from qn;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
WITH qn AS
(SELECT 1 UNION
SELECT jt.id FROM t1 RIGHT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1.jc=jt.id)
SELECT * from qn;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
SELECT * FROM t1 AS t1o RIGHT JOIN
(t1 AS t1i JOIN JSON_TABLE(t1o.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1i.jc=jt.id)
ON t1o.id=t1i.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
SELECT * FROM t1 AS t1o RIGHT JOIN
(t1 AS t1i RIGHT JOIN JSON_TABLE(t1o.jc, '$' COLUMNS
(id FOR ORDINALITY)) as jt ON t1i.jc=jt.id)
ON t1o.id=t1i.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt' table function's LATERAL reference
INSERT INTO t1 VALUES(1,"1"),(2,"4"),(3,"3");
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT * FROM t1 LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id INT PATH '$')) as jt ON t1.id=jt.id;
id	jc	id
1	1	1
2	4	NULL
3	3	3
EXPLAIN SELECT * FROM t1 LEFT JOIN JSON_TABLE(t1.jc, '$' COLUMNS
(id INT PATH '$')) as jt ON t1.id=jt.id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	jt	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.id	2	100.00	Table function: json_table; Using temporary; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`jc` AS `jc`,`jt`.`id` AS `id` from `test`.`t1` left join json_table(`test`.`t1`.`jc`, '$' columns (id int path '$')) `jt` on((`jt`.`id` = `test`.`t1`.`id`)) where 1
SELECT * FROM t1 
LEFT JOIN
JSON_TABLE(t1.jc, '$' COLUMNS (id FOR ORDINALITY)) as jt ON t1.jc=jt.id
RIGHT JOIN
JSON_TABLE(jt.id, '$' COLUMNS (id FOR ORDINALITY)) as jt1 ON jt.id=jt1.id;
ERROR HY000: INNER or LEFT JOIN must be used for 'jt1' table function's LATERAL reference
DROP TABLE t1;
set @save_mem_se= @@internal_tmp_mem_storage_engine;
set @@internal_tmp_mem_storage_engine=MEMORY;
set @save_heap_size= @@max_heap_table_size;
set @@max_heap_table_size= 16384;
FLUSH STATUS;
SELECT * FROM JSON_TABLE(
'[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]',
'$[*]' COLUMNS (
c1 CHAR(255) PATH '$',
c2 CHAR(255) PATH '$',
c3 CHAR(255) PATH '$',
c4 CHAR(255) PATH '$',
c5 CHAR(255) PATH '$',
c6 CHAR(255) PATH '$',
c7 CHAR(255) PATH '$',
c8 CHAR(255) PATH '$')) AS jt;
c1	c2	c3	c4	c5	c6	c7	c8
1	1	1	1	1	1	1	1
2	2	2	2	2	2	2	2
3	3	3	3	3	3	3	3
4	4	4	4	4	4	4	4
5	5	5	5	5	5	5	5
6	6	6	6	6	6	6	6
7	7	7	7	7	7	7	7
8	8	8	8	8	8	8	8
9	9	9	9	9	9	9	9
10	10	10	10	10	10	10	10
11	11	11	11	11	11	11	11
12	12	12	12	12	12	12	12
13	13	13	13	13	13	13	13
14	14	14	14	14	14	14	14
15	15	15	15	15	15	15	15
16	16	16	16	16	16	16	16
17	17	17	17	17	17	17	17
18	18	18	18	18	18	18	18
19	19	19	19	19	19	19	19
20	20	20	20	20	20	20	20
SHOW STATUS LIKE '%tmp%';
Variable_name	Value
Created_tmp_disk_tables	1
Created_tmp_files	0
Created_tmp_tables	1
set @@max_heap_table_size= @save_heap_size;
set @@internal_tmp_mem_storage_engine= @save_mem_se;
#
# Bug#25504063: EXPLAIN OF JSON_TABLE QUERY USES INTERNAL TEMP TABLES
#
FLUSH STATUS;
SELECT * FROM
JSON_TABLE(
'[{"a":"3"}]',
'$[*]' COLUMNS (id FOR ORDINALITY)
) AS tt;
id
1
SHOW STATUS LIKE '%tmp%';
Variable_name	Value
Created_tmp_disk_tables	0
Created_tmp_files	0
Created_tmp_tables	1
#
# Bug#25525409: ASSERTION `TABLE_LIST->TABLE' FAILED IN SQL/SQL_BASE.CC
#
SELECT * FROM JSON_TABLE ( ( SELECT a ) , '$.*' COLUMNS (col1 FOR ORDINALITY) )
AS alias1;
ERROR 42S22: Unknown column 'a' in 'field list'
SELECT * FROM JSON_TABLE ( ( SELECT 1 ) , '$.*' COLUMNS (col1 FOR ORDINALITY) )
AS alias1;
ERROR HY000: Incorrect arguments to JSON_TABLE
SELECT * FROM JSON_TABLE ( ( SUM(1) ) , '$.*' COLUMNS (col1 FOR ORDINALITY) )
AS alias1;
ERROR HY000: Invalid use of group function
#
# Bug# #25472875: ERROR SHOULD BE THROWN FOR INCORRECT VALUES
#
SELECT *
FROM JSON_TABLE('{"a":"1993-01-01"}',
'$' COLUMNS (jp DATE PATH '$.b' DEFAULT '1000' ON EMPTY))
AS jt;
ERROR 42000: Invalid default value for 'jp'
#
# Bug#25532429: INVALID JSON ERROR NOT THROWN WITH EMPTY TABLES JOIN
#
CREATE TABLE t1(j JSON);
SELECT * FROM t1,
JSON_TABLE( 'dqwfjqjf'  , '$[*]' COLUMNS (col5 FOR ORDINALITY) ) AS alias7;
ERROR 22032: Invalid JSON text in argument 1 to function json_table: "Invalid value." at position 0.
DROP TABLE t1;
#
# Bug#25540370: SIG 11 IN SHOW_SQL_TYPE|SQL/SQL_SHOW.CC:7063
#
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 CHAR(70) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 char(70) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 CHAR(70) PATH '$')
) AS alias2;
col18
3.14159
# Too short field causes truncation, error and triggers ON ERROR clause
EXPLAIN SELECT * FROM
JSON_TABLE ('["3.14159"]',
'$[*]' COLUMNS (col18 CHAR(6) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('["3.14159"]', '$[*]' columns (col18 char(6) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('["3.14159"]',
'$[*]' COLUMNS (col18 CHAR(6) PATH '$')
) AS alias2;
col18
NULL
Warnings:
Warning	1406	Data too long for column 'col18' at row 1
#Truncated space doesn't trigger ON ERROR
EXPLAIN SELECT * FROM
JSON_TABLE ('["3.14159 "]',
'$[*]' COLUMNS (col18 CHAR(7) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('["3.14159 "]', '$[*]' columns (col18 char(7) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('["3.14159 "]',
'$[*]' COLUMNS (col18 CHAR(7) PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 CHAR(255) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 char(255) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 CHAR(255) PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 VARCHAR(70) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 varchar(70) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 VARCHAR(70) PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 VARCHAR(255) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 varchar(255) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 VARCHAR(255) PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 FLOAT PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 float path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 FLOAT PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 DOUBLE PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 double path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 DOUBLE PATH '$')
) AS alias2;
col18
3.14159
EXPLAIN SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 DECIMAL(3,3) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[3.14159]', '$[*]' columns (col18 decimal(3,3) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 DECIMAL(3,3) PATH '$')
) AS alias2;
col18
NULL
Warnings:
Warning	1264	Out of range value for column 'col18' at row 1
SELECT * FROM
JSON_TABLE ('[3.14159]',
'$[*]' COLUMNS (col18 DECIMAL(3,3) PATH '$' ERROR ON ERROR)
) AS alias2;
ERROR 22003: Value is out of range for JSON_TABLE's column 'col18'
EXPLAIN SELECT * FROM
JSON_TABLE ('[0.9]',
'$[*]' COLUMNS (col18 DECIMAL(3,3) PATH '$')
) AS alias2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias2`.`col18` AS `col18` from json_table('[0.9]', '$[*]' columns (col18 decimal(3,3) path '$')) `alias2`
SELECT * FROM
JSON_TABLE ('[0.9]',
'$[*]' COLUMNS (col18 DECIMAL(3,3) PATH '$')
) AS alias2;
col18
0.900
SELECT * FROM
JSON_TABLE ('["asdf","ghjk"]',
'$[*]' COLUMNS (col18 DECIMAL(4,3) PATH '$' 
DEFAULT "3.14159" ON ERROR)
) AS alias2;
col18
3.142
3.142
Warnings:
Note	1265	Data truncated for column 'col18' at row 1
Warning	3156	Invalid JSON value for CAST to DECIMAL from column col18 at row 1
Warning	3156	Invalid JSON value for CAST to DECIMAL from column col18 at row 1
CREATE TABLE t1(jd JSON);
INSERT INTO t1 VALUES('["asdf"]'),('["ghjk"]');
SELECT * FROM t1,
JSON_TABLE (jd,
'$[*]' COLUMNS (col18 DECIMAL(4,3) PATH '$' 
DEFAULT "3.14159" ON ERROR)
) AS alias2;
jd	col18
["asdf"]	3.142
["ghjk"]	3.142
Warnings:
Note	1265	Data truncated for column 'col18' at row 1
Warning	3156	Invalid JSON value for CAST to DECIMAL from column col18 at row 1
Warning	3156	Invalid JSON value for CAST to DECIMAL from column col18 at row 2
DROP TABLE t1;
#
# Bug#25540027: SIG 11 IN FIND_FIELD_IN_TABLE | SQL/SQL_BASE.CC
#
CREATE TABLE t1(c1 JSON);
UPDATE t1, JSON_TABLE(t1.c1,'$[*]' COLUMNS (a INT PATH '$.a')) AS jt1
SET jt1.a=1;
ERROR HY000: The target table jt1 of the UPDATE is not updatable
DELETE JSON_TABLE(t1.c1,'$[*]' COLUMNS (a INT PATH '$.a')) AS jt1
FROM t1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'JSON_TABLE(t1.c1,'$[*]' COLUMNS (a INT PATH '$.a')) AS jt1
FROM t1' at line 1
DELETE t1, JSON_TABLE(t1.c1,'$[*]' COLUMNS (a INT PATH '$.a')) AS jt1
USING t1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'JSON_TABLE(t1.c1,'$[*]' COLUMNS (a INT PATH '$.a')) AS jt1
USING t1' at line 1
DROP TABLE t1;
#
# Bug#25547244: ASSERTION `!TABLE || (!TABLE->READ_SET || BITMAP_IS_SET(
#
CREATE TABLE t1(i INT);
INSERT INTO t1 VALUES(1);
WITH cte_query AS
(SELECT * FROM t1, JSON_TABLE ( JSON_OBJECT('ISSKF',i) ,
'$[*]' COLUMNS (jtcol1 INT EXISTS PATH '$[*]') ) AS alias2)
SELECT jtcol1 AS field1 FROM cte_query;
field1
DROP TABLE t1;
#
# Bug#25540675: ASSERTION `!COL->CHILD_JDS->PRODUCING_RECORDS' FAILED
#
CREATE TABLE j1(j JSON);
INSERT INTO j1 VALUES('[1,2,3]'),('[1,2,4]');
SELECT * FROM j1, 
JSON_TABLE ( JSON_OBJECT('key1', j) ,
'$.*' COLUMNS (NESTED PATH '$.*' COLUMNS (col11 FOR ORDINALITY))) AS alias2;
j	col11
[1, 2, 3]	NULL
[1, 2, 4]	NULL
DROP TABLE j1;
#
# Bug#25584335: SIG 11 IN TABLE_LIST::FETCH_NUMBER_OF_ROWS
#
CREATE TABLE t1(i INT);
PREPARE stmt FROM "SELECT alias1.i AS field1 FROM (
  t1 AS alias1,
  (SELECT   * FROM
    JSON_TABLE ('[1,2,3]' ,
                '$[*]' COLUMNS (`col_varchar` FOR ORDINALITY)) AS SQ1_alias1
  ) AS alias2 )";
EXECUTE stmt;
field1
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
#
# Bug#25604048: COLUMN NAMES WITH SAME 33-CHAR PREFIX ARE EQUAL
#
SELECT * FROM JSON_TABLE( '{"key1": "test"}' , '$' COLUMNS(
column_name_is_thirty_four_or_more VARCHAR(17) PATH '$.key1',
column_name_is_thirty_four_or_more_yes_indeed VARCHAR(17) PATH '$.key1'
) ) AS alias1;
column_name_is_thirty_four_or_more	column_name_is_thirty_four_or_more_yes_indeed
test	test
SELECT * FROM JSON_TABLE( '{"key1": "test"}' , '$' COLUMNS(
`column_name_is_thirty_four_or_more ` VARCHAR(17) PATH '$.key1'
) ) AS alias1;
ERROR 42000: Incorrect column name 'column_name_is_thirty_four_or_more '
#
# Bug#25604404: JSON_TABLE MORE RESTRICTIVE WITH IDENTIFIERS THAN
#               CREATE TABLE
#
SELECT * FROM JSON_TABLE( '[1, 2]', '$' COLUMNS(
one INT PATH '$[0]', two INT PATH '$[1]'
)) AS jt;
one	two
1	2
#
# Bug#25588450: SIG 6 IN JSON_WRAPPER::SEEK|SQL/JSON_DOM.CC
#
CREATE TABLE t1(c VARCHAR(10)) ENGINE=MEMORY;
INSERT INTO t1 VALUES('fiheife');
SELECT * FROM `t1` AS alias1, JSON_TABLE ( `c` , '$[*]' COLUMNS (jtcol1 JSON
PATH '$.*')) AS alias2 WHERE  jtcol1 <= 'kjfh';
ERROR 22032: Invalid JSON text in argument 1 to function json_table: "Invalid value." at position 1.
DROP TABLE t1;
#
# Bug#25587754: ASSERTION `FIXED == 0 || BASIC_CONST_ITEM()' FAILED
#
PREPARE stmt FROM 
"SELECT * FROM JSON_TABLE ( '[1,2]', '$[*]' 
    COLUMNS (jtcol1 JSON PATH '$.*')) AS alias2";
EXECUTE stmt;
jtcol1
NULL
NULL
DEALLOCATE PREPARE stmt;
#
# Bug#25584593: UNABLE TO USE JSON_TABLE() ON TEXT/BLOB JSON DATA
#
SELECT * FROM JSON_TABLE (NULL, '$.k' COLUMNS (id FOR ORDINALITY)) AS aLias;
id
SELECT * FROM JSON_TABLE (@myjson, '$.k' COLUMNS (id FOR ORDINALITY)) AS alias;
id
SET @myjson = '{"k": 42}';
SELECT * FROM JSON_TABLE (@myjson, '$.k' COLUMNS (id FOR ORDINALITY)) AS alias;
id
1
CREATE TABLE t1(
txt TEXT, ty TINYTEXT, tm MEDIUMTEXT, tl LONGTEXT);
INSERT INTO t1 values (
'{"k": "text"}','{"k": "tinytext"}','{"k": "mediumtext"}','{"k": "longtext"}');
SELECT alias.* FROM t1, JSON_TABLE (t1.txt,'$.k' COLUMNS (id VARCHAR(10) PATH '$')) AS alias;
id
text
SELECT alias.* FROM t1, JSON_TABLE (t1.ty, '$.k' COLUMNS (id VARCHAR(10) PATH '$')) AS alias;
id
tinytext
SELECT alias.* FROM t1, JSON_TABLE (t1.tm, '$.k' COLUMNS (id VARCHAR(10) PATH '$')) AS alias;
id
mediumtext
SELECT alias.* FROM t1, JSON_TABLE (t1.tl, '$.k' COLUMNS (id VARCHAR(10) PATH '$')) AS alias;
id
longtext
SELECT alias.* FROM t1, JSON_TABLE (t1.txt,'$.k' COLUMNS (id TEXT PATH '$')) AS alias;
id
text
SELECT alias.* FROM t1, JSON_TABLE (t1.txt,'$.k' COLUMNS (id TINYTEXT PATH '$')) AS alias;
id
text
SELECT alias.* FROM t1, JSON_TABLE (t1.txt,'$.k' COLUMNS (id MEDIUMTEXT PATH '$')) AS alias;
id
text
SELECT alias.* FROM t1, JSON_TABLE (t1.txt,'$.k' COLUMNS (id LONGTEXT PATH '$')) AS alias;
id
text
SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb BLOB PATH '$')) as alias;
blb
asd123
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb BLOB PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb blob path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb TINYBLOB PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb tinyblob path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb MEDIUMBLOB PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb mediumblob path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb LONGBLOB PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb longblob path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb TEXT PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb text path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb TINYTEXT PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb tinytext path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb MEDIUMTEXT PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb mediumtext path '$')) `alias`
EXPLAIN SELECT alias.* FROM JSON_TABLE ('"asd123"', '$' COLUMNS (blb LONGTEXT PATH '$')) as alias;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `alias`.`blb` AS `blb` from json_table('"asd123"', '$' columns (blb longtext path '$')) `alias`
SELECT * FROM 
(SELECT CAST(blb AS JSON) jf FROM
JSON_TABLE ('"asd123"', '$' COLUMNS (blb BLOB PATH '$')) AS jti) AS dt,
JSON_TABLE (jf, '$' COLUMNS (blb BLOB PATH '$')) AS jto;
ERROR HY000: Incorrect arguments to JSON_TABLE
DROP TABLE t1;
#
# Bug#26500384: ASSERT FAILURE IN QUERY WITH WINDOW FUNCTION AND
#               JSON_TABLE
#
CREATE TABLE t (x INT);
INSERT INTO t VALUES (1), (2), (3);
SELECT MAX(t.x) OVER () m, jt.* FROM t,
JSON_TABLE(JSON_ARRAY(m), '$[*]' COLUMNS (i INT PATH '$')) jt;
ERROR 42S22: Unknown column 'm' in 'a table function argument'
DROP TABLE t;
#
# Bug#26583283: ASSERTION `!THD->IS_ERROR()' FAILED IN SQL_RESOLVER.CC
#
EXPLAIN SELECT * FROM JSON_TABLE('null', '$' COLUMNS(AA DECIMAL PATH '$')) tt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `tt`.`AA` AS `AA` from json_table('null', '$' columns (AA decimal(10,0) path '$')) `tt`
CREATE VIEW v1 AS SELECT * FROM
JSON_TABLE ( 'null', '$' COLUMNS (c1 DECIMAL PATH '$' ) ) AS jt;
SELECT * FROM v1;
c1
NULL
Warnings:
Warning	3156	Invalid JSON value for CAST to DECIMAL from column c1 at row 1
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jt	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `jt`.`c1` AS `c1` from json_table('null', '$' columns (c1 decimal(10,0) path '$')) `jt`
DROP VIEW v1;
#
# Bug#25822408: ASSERTION `!COL->CHILD_JDS->PRODUCING_RECORDS' FAILED
#
PREPARE stmt FROM "SELECT * FROM
  JSON_TABLE('{\"a\":1}','$' COLUMNS (c1 CHAR(20) PATH '$.b' ERROR ON EMPTY)) jt";
EXECUTE stmt;
ERROR 22035: Missing value for JSON_TABLE column 'c1'
EXECUTE stmt;
ERROR 22035: Missing value for JSON_TABLE column 'c1'
#
# Bug#25594571: CRASH AT ITEM::CONST_ITEM|SQL/ITEM.H
#
CREATE TABLE t1 (i INT);
INSERT INTO t1 VALUES(1),(2),(3),(4),(5),(6),(7);
PREPARE stmt FROM "SELECT * FROM  t1 AS alias1  LEFT  JOIN t1 AS alias2
LEFT  JOIN JSON_TABLE('[1,2,3]', '$[*]' COLUMNS (i FOR ORDINALITY )) AS
alias3 ON  alias2 . `i` =  alias3 . `i`  ON  alias1 . `i` =  alias2 . `i`";
EXECUTE stmt;
i	i	i
1	1	1
2	2	2
3	3	3
4	4	NULL
5	5	NULL
6	6	NULL
7	7	NULL
EXECUTE stmt;
i	i	i
1	1	1
2	2	2
3	3	3
4	4	NULL
5	5	NULL
6	6	NULL
7	7	NULL
DROP TABLE t1;
#
# Bug#26648617: ASSERTION `IS_VIEW_OR_DERIVED() && 
#               USES_MATERIALIZATION()' FAILED.
#
CREATE TABLE t1 (
col_varchar_key varchar(1) DEFAULT NULL
) ENGINE=InnoDB;
INSERT INTO t1 VALUES(1),(4);
SELECT * FROM t1 WHERE col_varchar_key NOT IN (
SELECT col_varchar_key FROM JSON_TABLE(
'[{"col_key": 1},{"col_key": 2}]', "$[*]" COLUMNS
(col_varchar_key VARCHAR(10) PATH "$.col_key")) AS innr1);
col_varchar_key
4
EXPLAIN SELECT * FROM t1 WHERE col_varchar_key NOT IN (
SELECT col_varchar_key FROM JSON_TABLE(
'[{"col_key": 1},{"col_key": 2}]', "$[*]" COLUMNS
(col_varchar_key VARCHAR(10) PATH "$.col_key")) AS innr1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
2	DEPENDENT SUBQUERY	innr1	NULL	index_subquery	<auto_key0>	<auto_key0>	43	func	4	100.00	Table function: json_table; Using temporary; Using where; Using index; Full scan on NULL key
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`col_varchar_key` AS `col_varchar_key` from `test`.`t1` where (not(<in_optimizer>(`test`.`t1`.`col_varchar_key`,<exists>(<index_lookup>(<cache>(`test`.`t1`.`col_varchar_key`) in innr1 on <auto_key0> checking NULL where <if>(outer_field_is_not_null, ((<cache>(`test`.`t1`.`col_varchar_key`) = `innr1`.`col_varchar_key`) or isnull(`innr1`.`col_varchar_key`)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`innr1`.`col_varchar_key`), true))))))
SELECT * FROM t1 WHERE col_varchar_key IN (
SELECT col_varchar_key FROM JSON_TABLE(
'[{"col_key": 1},{"col_key": 2}]', "$[*]" COLUMNS
(col_varchar_key VARCHAR(10) PATH "$.col_key")) AS innr1);
col_varchar_key
1
EXPLAIN SELECT * FROM t1 WHERE col_varchar_key IN (
SELECT col_varchar_key FROM JSON_TABLE(
'[{"col_key": 1},{"col_key": 2}]', "$[*]" COLUMNS
(col_varchar_key VARCHAR(10) PATH "$.col_key")) AS innr1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	innr1	NULL	ref	<auto_key0>	<auto_key0>	43	test.t1.col_varchar_key	2	100.00	Table function: json_table; Using temporary; Using where; Using index; FirstMatch(t1)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`col_varchar_key` AS `col_varchar_key` from `test`.`t1` semi join (json_table('[{"col_key": 1},{"col_key": 2}]', '$[*]' columns (col_varchar_key varchar(10) path '$.col_key')) `innr1`) where (`test`.`t1`.`col_varchar_key` = `innr1`.`col_varchar_key`)
DROP TABLE t1;
#
# Bug#26711551: WL8867:CONDITIONAL JUMP IN JSON_TABLE_COLUMN::CLEANUP
#
CREATE TABLE t(x int, y int);
INSERT INTO t(x) VALUES (1);
UPDATE t t1, JSON_TABLE('[2]', '$[*]' COLUMNS (x INT PATH '$')) t2
SET t1.y = t2.x;
SELECT * FROM t;
x	y
1	2
DROP TABLE t;
#
# Bug#26679671: SIG 11 IN JSON_BINARY::PARSE_BINARY()
#
CREATE TABLE t1(id INT, f1 JSON);
INSERT INTO t1 VALUES (1, '{\"1\": 1}'), (2, '{\"1\": 2}'), (3, '{\"1\": 3}'),
(4, '{\"1\": 4}'), (5, '{\"1\": 5}'), (6, '{\"1\": 6}');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT * FROM t1 as jj1,
(SELECT tt2.* FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (id FOR ORDINALITY)) AS tbl) dt;
id	f1	id	f1
1	{"1": 1}	1	{"1": 1}
2	{"1": 2}	1	{"1": 1}
3	{"1": 3}	1	{"1": 1}
4	{"1": 4}	1	{"1": 1}
5	{"1": 5}	1	{"1": 1}
6	{"1": 6}	1	{"1": 1}
1	{"1": 1}	2	{"1": 2}
2	{"1": 2}	2	{"1": 2}
3	{"1": 3}	2	{"1": 2}
4	{"1": 4}	2	{"1": 2}
5	{"1": 5}	2	{"1": 2}
6	{"1": 6}	2	{"1": 2}
1	{"1": 1}	3	{"1": 3}
2	{"1": 2}	3	{"1": 3}
3	{"1": 3}	3	{"1": 3}
4	{"1": 4}	3	{"1": 3}
5	{"1": 5}	3	{"1": 3}
6	{"1": 6}	3	{"1": 3}
1	{"1": 1}	4	{"1": 4}
2	{"1": 2}	4	{"1": 4}
3	{"1": 3}	4	{"1": 4}
4	{"1": 4}	4	{"1": 4}
5	{"1": 5}	4	{"1": 4}
6	{"1": 6}	4	{"1": 4}
1	{"1": 1}	5	{"1": 5}
2	{"1": 2}	5	{"1": 5}
3	{"1": 3}	5	{"1": 5}
4	{"1": 4}	5	{"1": 5}
5	{"1": 5}	5	{"1": 5}
6	{"1": 6}	5	{"1": 5}
1	{"1": 1}	6	{"1": 6}
2	{"1": 2}	6	{"1": 6}
3	{"1": 3}	6	{"1": 6}
4	{"1": 4}	6	{"1": 6}
5	{"1": 5}	6	{"1": 6}
6	{"1": 6}	6	{"1": 6}
EXPLAIN SELECT * FROM t1 as jj1,
(SELECT tt2.* FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (id FOR ORDINALITY)) AS tbl) dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jj1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
1	SIMPLE	tt2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	tbl	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`jj1`.`id` AS `id`,`test`.`jj1`.`f1` AS `f1`,`test`.`tt2`.`id` AS `id`,`test`.`tt2`.`f1` AS `f1` from `test`.`t1` `jj1` join `test`.`t1` `tt2` join json_table(`test`.`tt2`.`f1`, '$' columns (id for ordinality)) `tbl`
SELECT * FROM t1 as jj1,
(SELECT tt2.* FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (id FOR ORDINALITY)) AS tbl STRAIGHT_JOIN 
t1 AS tt3) dt ORDER BY 1,3 LIMIT 10;
id	f1	id	f1
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	1	{"1": 1}
1	{"1": 1}	2	{"1": 2}
1	{"1": 1}	2	{"1": 2}
1	{"1": 1}	2	{"1": 2}
1	{"1": 1}	2	{"1": 2}
EXPLAIN SELECT * FROM t1 as jj1,
(SELECT tt2.* FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (id FOR ORDINALITY)) AS tbl STRAIGHT_JOIN 
t1 AS tt3) dt ORDER BY 1,3 LIMIT 11;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	jj1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using temporary; Using filesort
1	SIMPLE	tt2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	tbl	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary
1	SIMPLE	tt3	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`jj1`.`id` AS `id`,`test`.`jj1`.`f1` AS `f1`,`test`.`tt2`.`id` AS `id`,`test`.`tt2`.`f1` AS `f1` from `test`.`t1` `jj1` join `test`.`t1` `tt2` join json_table(`test`.`tt2`.`f1`, '$' columns (id for ordinality)) `tbl` straight_join `test`.`t1` `tt3` order by `test`.`jj1`.`id`,`test`.`tt2`.`id` limit 11
SELECT * FROM t1 WHERE id IN
(SELECT id FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (jf FOR ORDINALITY)) AS tbl);
id	f1
1	{"1": 1}
2	{"1": 2}
3	{"1": 3}
4	{"1": 4}
5	{"1": 5}
6	{"1": 6}
EXPLAIN SELECT * FROM t1 WHERE id IN
(SELECT id FROM t1 as tt2,
JSON_TABLE (f1, "$" COLUMNS (jf FOR ORDINALITY)) AS tbl);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tt2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	16.67	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tbl	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Table function: json_table; Using temporary; End temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id`,`test`.`t1`.`f1` AS `f1` from `test`.`t1` semi join (`test`.`t1` `tt2` join json_table(`test`.`tt2`.`f1`, '$' columns (jf for ordinality)) `tbl`) where (`test`.`t1`.`id` = `test`.`tt2`.`id`)
DROP TABLE t1;
#
# Bug#26760811: WL#8867: MEMORY LEAK REPORTED BY ASAN AND VALGRIND
#
CREATE TABLE t (j JSON);
INSERT INTO t VALUES
('[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]'),
('[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]');
SELECT COUNT(*) FROM t, JSON_TABLE(j, '$[*]' COLUMNS (i INT PATH '$')) AS jt;
COUNT(*)
34
PREPARE ps FROM
'SELECT COUNT(*) FROM t, JSON_TABLE(j, ''$[*]'' COLUMNS (i INT PATH ''$'')) AS jt';
EXECUTE ps;
COUNT(*)
34
EXECUTE ps;
COUNT(*)
34
DROP PREPARE ps;
DROP TABLE t;
#
# Bug #26781759: NON-UNIQUE ALIAS ERROR NOT BEING THROWN
#
SELECT * FROM JSON_TABLE(NULL, '$' COLUMNS(j1 FOR ORDINALITY)) AS jalias,
JSON_TABLE(NULL, '$' COLUMNS(j1 FOR ORDINALITY)) AS jalias;
ERROR 42000: Not unique table/alias: 'jalias'
#
# Bug #26761470: WL#8867: JOIN::MAKE_JOIN_PLAN():
#                ASSERTION `SELECT_LEX->IS_RECURSIVE()' FAILED
#
CREATE TABLE t1 (x INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (j JSON);
INSERT INTO t2 (j) VALUES ('[1,2,3]');
SELECT * FROM t1 RIGHT JOIN
(SELECT o FROM t2, JSON_TABLE(j, '$[*]' COLUMNS (o FOR ORDINALITY)) AS jt) AS t3
ON (t3.o = t1.x);
x	o
1	1
NULL	2
NULL	3
DROP TABLE t1, t2;
#
# Bug#27152428 JSON_TABLE + PREPARED STATEMENT + VIEW HAS PROBLEM IN DURING RESOLUTION
#
CREATE TABLE t1 (a INT, b INT);
CREATE VIEW v2 AS SELECT * FROM t1 LIMIT 2;
SELECT b
FROM (SELECT * FROM v2) vq1,
JSON_TABLE(CONCAT(vq1.b,'[{\"a\":\"3\"}]'),
'$[*]' COLUMNS (id FOR ORDINALITY,
jpath VARCHAR(100) PATH '$.a',
JEXST INT EXISTS PATH '$.b')
) AS dt;
b
DROP TABLE t1;
DROP VIEW v2;
#
# Bug#27189940: CREATE VIEW FAILS ON JSON_TABLE() IN SCHEMA-LESS CONNECTIONS
# BUG#27217897: JSON_TABLE() FAILS IF NO DATABASE SELECTED
#
CREATE VIEW test.v AS SELECT * FROM JSON_TABLE('[1,2,3]', '$[*]' COLUMNS (num INT PATH '$[0]')) AS jt;
SELECT * FROM JSON_TABLE('[1,2,3]', '$[*]' COLUMNS (num INT PATH '$[0]')) AS jt;
num
1
2
3
use test;
SHOW CREATE VIEW test.v;
View	Create View	character_set_client	collation_connection
v	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v` AS select `jt`.`num` AS `num` from json_table('[1,2,3]', '$[*]' columns (num int path '$[0]')) `jt`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM test.v;
num
1
2
3
DROP VIEW test.v;
#
# Bug#27729112 JSON_TABLE SHOULD DECODE BASE64-ENCODED STRINGS
#
SELECT v
FROM JSON_TABLE(JSON_OBJECT('foo', _binary'bar'), '$'
     COLUMNS(v VARCHAR(255) PATH '$.foo')) tbl;
v
bar
CREATE TABLE t1 (col1 VARCHAR(255) CHARACTER SET ucs2,
col2 VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_as_cs);
INSERT INTO t1 VALUES ("", ""), ("", ""), ("", ""), ("@", "");
ANALYZE TABLE t1 UPDATE HISTOGRAM ON col1, col2;
Table	Op	Msg_type	Msg_text
test.t1	histogram	status	Histogram statistics created for column 'col1'.
test.t1	histogram	status	Histogram statistics created for column 'col2'.
SELECT v value, c cumulfreq
FROM INFORMATION_SCHEMA.COLUMN_STATISTICS,
JSON_TABLE(histogram->'$.buckets', '$[*]'
     COLUMNS(v VARCHAR(255) CHARACTER SET ucs2 PATH '$[0]',
c double PATH '$[1]')) hist
WHERE column_name = "col1";
value	cumulfreq
@	0.25
	0.5
	0.75
	1
SELECT v value, c cumulfreq
FROM INFORMATION_SCHEMA.COLUMN_STATISTICS,
JSON_TABLE(histogram->'$.buckets', '$[*]'
     COLUMNS(v VARCHAR(255) CHARACTER SET utf8mb4 PATH '$[0]',
c double PATH '$[1]')) hist
WHERE column_name = "col2";
value	cumulfreq
	0.25
	0.5
	0.75
	1
DROP TABLE t1;
#
# Bug#28254268: JSON_TABLE() FUNCTION REJECTS SELECT PERMISSIONS
#
CREATE DATABASE db2;
USE db2;
CREATE TABLE t1 (c JSON);
INSERT INTO t1 VALUES('[1,2,3]');
CREATE USER user1@localhost;
GRANT SELECT ON db2.t1 TO user1@localhost;
USE db2;
SELECT t1.c FROM t1;
c
[1, 2, 3]
SELECT jt.* FROM t1, JSON_TABLE(t1.c, '$[*]' COLUMNS (num INT PATH '$[0]'))
AS jt;
num
1
2
3
DROP USER user1@localhost;
DROP DATABASE db2;
