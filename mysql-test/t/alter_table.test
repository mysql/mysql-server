# The include statement below is a temp one for tests that are yet to
#be ported to run with InnoDB,
#but needs to be kept for tests that would need MyISAM in future.
--source include/force_myisam_default.inc

#
# Test of alter table
#
--disable_warnings
drop table if exists t1,t2;
drop database if exists mysqltest;
--enable_warnings

SET sql_mode = 'NO_ENGINE_SUBSTITUTION,NO_AUTO_CREATE_USER';

create table t1 (
col1 int not null auto_increment primary key,
col2 varchar(30) not null,
col3 varchar (20) not null,
col4 varchar(4) not null,
col5 enum('PENDING', 'ACTIVE', 'DISABLED') not null,
col6 int not null, to_be_deleted int);
insert into t1 values (2,4,3,5,"PENDING",1,7);
alter table t1
add column col4_5 varchar(20) not null after col4,
add column col7 varchar(30) not null after col5,
add column col8 datetime not null, drop column to_be_deleted,
change column col2 fourth varchar(30) not null after col3,
modify column col6 int not null first;
select * from t1;
drop table t1;

create table t1 (bandID MEDIUMINT UNSIGNED NOT NULL PRIMARY KEY, payoutID SMALLINT UNSIGNED NOT NULL);
insert into t1 (bandID,payoutID) VALUES (1,6),(2,6),(3,4),(4,9),(5,10),(6,1),(7,12),(8,12);
alter table t1 add column new_col int, order by payoutid,bandid;
select * from t1;
alter table t1 order by bandid,payoutid;
select * from t1;
drop table t1;

# Check that pack_keys and dynamic length rows are not forced. 

CREATE TABLE t1 (
GROUP_ID int(10) unsigned DEFAULT '0' NOT NULL,
LANG_ID smallint(5) unsigned DEFAULT '0' NOT NULL,
NAME varchar(80) DEFAULT '' NOT NULL,
PRIMARY KEY (GROUP_ID,LANG_ID),
KEY NAME (NAME));
#show table status like "t1";
ALTER TABLE t1 CHANGE NAME NAME CHAR(80) not null;
--replace_column 8 #
SHOW FULL COLUMNS FROM t1;
DROP TABLE t1;

#
# Test of ALTER TABLE ... ORDER BY
#

create table t1 (n int);
insert into t1 values(9),(3),(12),(10);
alter table t1 order by n;
select * from t1;
drop table t1;

CREATE TABLE t1 (
  id int(11) unsigned NOT NULL default '0',
  category_id tinyint(4) unsigned NOT NULL default '0',
  type_id tinyint(4) unsigned NOT NULL default '0',
  body text NOT NULL,
  user_id int(11) unsigned NOT NULL default '0',
  status enum('new','old') NOT NULL default 'new',
  PRIMARY KEY (id)
) ENGINE=MyISAM;

ALTER TABLE t1 ORDER BY t1.id, t1.status, t1.type_id, t1.user_id, t1.body;
DROP TABLE t1;

#
# The following combination found a hang-bug in MyISAM
#

CREATE TABLE t1 (AnamneseId int(10) unsigned NOT NULL auto_increment,B BLOB,PRIMARY KEY (AnamneseId)) engine=myisam;
insert into t1 values (null,"hello");
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD Column new_col int not null;
UNLOCK TABLES;
OPTIMIZE TABLE t1;
DROP TABLE t1;

#
# Drop and add an auto_increment column
#

create table t1 (i int unsigned not null auto_increment primary key);
insert into t1 values (null),(null),(null),(null);
alter table t1 drop i,add i int unsigned not null auto_increment, drop primary key, add primary key (i);
select * from t1;
drop table t1;

#
# Bug #2628: 'alter table t1 rename mysqltest.t1' silently drops mysqltest.t1 
# if it exists
#
create table t1 (name char(15));
insert into t1 (name) values ("current");
create database mysqltest;
create table mysqltest.t1 (name char(15));
insert into mysqltest.t1 (name) values ("mysqltest");
select * from t1;
select * from mysqltest.t1;
--error ER_TABLE_EXISTS_ERROR
alter table t1 rename mysqltest.t1;
select * from t1;
select * from mysqltest.t1;
drop table t1;
drop database mysqltest;

#
# ALTER TABLE ... ENABLE/DISABLE KEYS

create table t1 (n1 int not null, n2 int, n3 int, n4 float,
                unique(n1),
                key (n1, n2, n3, n4),
                key (n2, n3, n4, n1),
                key (n3, n4, n1, n2),
                key (n4, n1, n2, n3) );
alter table t1 disable keys;
show keys from t1;
#let $1=10000;
let $1=10;
while ($1)
{
 eval insert into t1 values($1,RAND()*1000,RAND()*1000,RAND());
 dec $1;
}
alter table t1 enable keys;
show keys from t1;
drop table t1;

#
# Alter table and rename
#

create table t1 (i int unsigned not null auto_increment primary key);
alter table t1 rename t2;
alter table t2 rename t1, add c char(10) comment "no comment";
show columns from t1;
drop table t1;

# implicit analyze

create table t1 (a int, b int);
let $1=100;
while ($1)
{
 eval insert into t1 values(1,$1), (2,$1), (3, $1);
 dec $1;
}
alter table t1 add unique (a,b), add key (b);
show keys from t1;
analyze table t1;
show keys from t1;
drop table t1;

#
# Test ALTER TABLE ENABLE/DISABLE keys when things are locked
#

CREATE TABLE t1 (
  Host varchar(16) binary NOT NULL default '',
  User varchar(16) binary NOT NULL default '',
  PRIMARY KEY  (Host,User)
) ENGINE=MyISAM;

ALTER TABLE t1 DISABLE KEYS;
LOCK TABLES t1 WRITE;
INSERT INTO t1 VALUES ('localhost','root'),('localhost',''),('games','monty');
SHOW INDEX FROM t1;
ALTER TABLE t1 ENABLE KEYS;
UNLOCK TABLES;
CHECK TABLES t1;
DROP TABLE t1;

#
# Test with two keys
#

CREATE TABLE t1 (
  Host varchar(16) binary NOT NULL default '',
  User varchar(16) binary NOT NULL default '',
  PRIMARY KEY  (Host,User),
  KEY  (Host)
) ENGINE=MyISAM;

ALTER TABLE t1 DISABLE KEYS;
SHOW INDEX FROM t1;
LOCK TABLES t1 WRITE;
INSERT INTO t1 VALUES ('localhost','root'),('localhost','');
SHOW INDEX FROM t1;
ALTER TABLE t1 ENABLE KEYS;
SHOW INDEX FROM t1;
UNLOCK TABLES;
CHECK TABLES t1;

# Test RENAME with LOCK TABLES
LOCK TABLES t1 WRITE;
ALTER TABLE t1 RENAME t2;
UNLOCK TABLES;
select * from t2;
DROP TABLE t2;

#
# Test disable keys with locking
#
CREATE TABLE t1 (
  Host varchar(16) binary NOT NULL default '',
  User varchar(16) binary NOT NULL default '',
  PRIMARY KEY  (Host,User),
  KEY  (Host)
) ENGINE=MyISAM;

LOCK TABLES t1 WRITE;
ALTER TABLE t1 DISABLE KEYS;
SHOW INDEX FROM t1;
DROP TABLE t1;

#
# BUG#4717 - check for valid table names
#
create table t1 (a int);
--error ER_WRONG_TABLE_NAME
alter table t1 rename to ``;
--error ER_WRONG_TABLE_NAME
rename table t1 to ``;
drop table t1;

#
# BUG#6236 - ALTER TABLE MODIFY should set implicit NOT NULL on PK columns
#
drop table if exists t1, t2;
create table t1 ( a varchar(10) not null primary key ) engine=myisam;
create table t2 ( a varchar(10) not null primary key ) engine=merge union=(t1);
flush tables;
alter table t1 modify a varchar(10);
show create table t2;
flush tables;
alter table t1 modify a varchar(10) not null;
show create table t2;
drop table if exists t1, t2;

# The following is also part of bug #6236 (CREATE TABLE didn't properly count
# not null columns for primary keys)

create table t1 (a int, b int, c int, d int, e int, f int, g int, h int,i int, primary key (a,b,c,d,e,f,g,i,h)) engine=MyISAM;
insert into t1 (a) values(1);
--replace_column 7 X 8 X 9 X 10 X 11 X 12 X 13 X 14 X
show table status like 't1';
alter table t1 modify a int;
--replace_column 7 X 8 X 9 X 10 X 11 X 12 X 13 X 14 X
show table status like 't1';
drop table t1;
create table t1 (a int not null, b int not null, c int not null, d int not null, e int not null, f int not null, g int not null, h int not null,i int not null, primary key (a,b,c,d,e,f,g,i,h)) engine=MyISAM;
insert into t1 (a) values(1);
--replace_column 7 X 8 X 9 X 10 X 11 X 12 X 13 X 14 X
show table status like 't1';
drop table t1;

#
# Test that data get converted when character set is changed
# Test that data doesn't get converted when src or dst is BINARY/BLOB
#
set names koi8r;
create table t1 (a char(10) character set koi8r);
insert into t1 values ('тест');
select a,hex(a) from t1;
alter table t1 change a a char(10) character set cp1251;
select a,hex(a) from t1;
alter table t1 change a a binary(4);
select a,hex(a) from t1;
alter table t1 change a a char(10) character set cp1251;
select a,hex(a) from t1;
alter table t1 change a a char(10) character set koi8r;
select a,hex(a) from t1;
alter table t1 change a a varchar(10) character set cp1251;
select a,hex(a) from t1;
alter table t1 change a a char(10) character set koi8r;
select a,hex(a) from t1;
alter table t1 change a a text character set cp1251;
select a,hex(a) from t1;
alter table t1 change a a char(10) character set koi8r;
select a,hex(a) from t1;
delete from t1;

#
# Test ALTER TABLE .. CHARACTER SET ..
#
show create table t1;
alter table t1 DEFAULT CHARACTER SET latin1;
show create table t1;
alter table t1 CONVERT TO CHARACTER SET latin1;
show create table t1;
alter table t1 DEFAULT CHARACTER SET cp1251;
show create table t1;

drop table t1;

#
# Bug#2821
# Test that table CHARACTER SET does not affect blobs
#
create table t1 (myblob longblob,mytext longtext) 
default charset latin1 collate latin1_general_cs;
show create table t1;
alter table t1 character set latin2;
show create table t1;
drop table t1;

#
# Bug 2361 (Don't drop UNIQUE with DROP PRIMARY KEY)
#

CREATE TABLE t1 (a int PRIMARY KEY, b INT UNIQUE);
ALTER TABLE t1 DROP PRIMARY KEY;
SHOW CREATE TABLE t1;
--error ER_CANT_DROP_FIELD_OR_KEY
ALTER TABLE t1 DROP PRIMARY KEY;
DROP TABLE t1;

# BUG#3899
create table t1 (a int, b int, key(a));
insert into t1 values (1,1), (2,2);
--error ER_CANT_DROP_FIELD_OR_KEY
alter table t1 drop key no_such_key;
alter table t1 drop key a;
drop table t1;

#
# BUG 12207 alter table ... discard table space on MyISAM table causes ERROR 2013 (HY000)
#
# Some platforms (Mac OS X, Windows) will send the error message using small letters.
CREATE TABLE T12207(a int) ENGINE=MYISAM;
--replace_result t12207 T12207
--error ER_ILLEGAL_HA
ALTER TABLE T12207 DISCARD TABLESPACE;
DROP TABLE T12207;

#
# Bug #6479  ALTER TABLE ... changing charset fails for TEXT columns
#
# The column's character set was changed but the actual data was not
# modified. In other words, the values were reinterpreted
# as UTF8 instead of being converted.
create table t1 (a text) character set koi8r;
insert into t1 values (_koi8r'тест');
select hex(a) from t1;
alter table t1 convert to character set cp1251;
select hex(a) from t1;
drop table t1;

#
# Test for bug #7884 "Able to add invalid unique index on TIMESTAMP prefix"
# MySQL should not think that packed field with non-zero decimals is
# geometry field and allow to create prefix index which is
# shorter than packed field length.
#
create table t1 ( a timestamp );
--error ER_WRONG_SUB_KEY
alter table t1 add unique ( a(1) );
drop table t1;

#
# Bug #24395: ALTER TABLE DISABLE KEYS doesn't work when modifying the table
#
# This problem happens if the data change is compatible.
# Changing to the same type is compatible for example.
#
--disable_warnings
drop table if exists t1;
--enable_warnings
create table t1 (a int, key(a));
show indexes from t1;
--echo "this used not to disable the index"
alter table t1 modify a int, disable keys;
show indexes from t1;

alter table t1 enable keys;
show indexes from t1;

alter table t1 modify a bigint, disable keys;
show indexes from t1;

alter table t1 enable keys;
show indexes from t1;

alter table t1 add b char(10), disable keys;
show indexes from t1;

alter table t1 add c decimal(10,2), enable keys;
show indexes from t1;

--echo "this however did"
alter table t1 disable keys;
show indexes from t1;

desc t1;

alter table t1 add d decimal(15,5);
--echo "The key should still be disabled"
show indexes from t1;

drop table t1;

--echo "Now will test with one unique index"
create table t1(a int, b char(10), unique(a));
show indexes from t1;
alter table t1 disable keys;
show indexes from t1;
alter table t1 enable keys;

--echo "If no copy on noop change, this won't touch the data file"
--echo "Unique index, no change"
alter table t1 modify a int, disable keys;
show indexes from t1;

--echo "Change the type implying data copy"
--echo "Unique index, no change"
alter table t1 modify a bigint, disable keys;
show indexes from t1;

alter table t1 modify a bigint;
show indexes from t1;

alter table t1 modify a int;
show indexes from t1;

drop table t1;

--echo "Now will test with one unique and one non-unique index"
create table t1(a int, b char(10), unique(a), key(b));
show indexes from t1;
alter table t1 disable keys;
show indexes from t1;
alter table t1 enable keys;


--echo "If no copy on noop change, this won't touch the data file"
--echo "The non-unique index will be disabled"
alter table t1 modify a int, disable keys;
show indexes from t1;
alter table t1 enable keys;
show indexes from t1;

--echo "Change the type implying data copy"
--echo "The non-unique index will be disabled"
alter table t1 modify a bigint, disable keys;
show indexes from t1;

--echo "Change again the type, but leave the indexes as_is"
alter table t1 modify a int;
show indexes from t1;
--echo "Try the same. When data is no copied on similar tables, this is noop"
alter table t1 modify a int;
show indexes from t1;

drop table t1;


#
# Bug#11493 - Alter table rename to default database does not work without
#             db name qualifying
#
create database mysqltest;
create table t1 (c1 int);
# Move table to other database.
alter table t1 rename mysqltest.t1;
# Assure that it has moved.
--error ER_BAD_TABLE_ERROR
drop table t1;
# Move table back.
alter table mysqltest.t1 rename t1;
# Assure that it is back.
drop table t1;
# Now test for correct message if no database is selected.
# Create t1 in 'test'.
create table t1 (c1 int);
# Change to other db.
use mysqltest;
# Drop the current db. This de-selects any db.
drop database mysqltest;
# Now test for correct message.
--error ER_NO_DB_ERROR
alter table test.t1 rename t1;
# Check that explicit qualifying works even with no selected db.
alter table test.t1 rename test.t1;
# Go back to standard 'test' db.
use test;
drop table t1;

#
# BUG#23404 - ROW_FORMAT=FIXED option is lost is an index is added to the
# table
#
CREATE TABLE t1(a INT) ROW_FORMAT=FIXED;
CREATE INDEX i1 ON t1(a);
SHOW CREATE TABLE t1;
DROP INDEX i1 ON t1;
SHOW CREATE TABLE t1;
DROP TABLE t1;

#
# Bug#24219 - ALTER TABLE ... RENAME TO ... , DISABLE KEYS leads to crash
#
--disable_warnings
DROP TABLE IF EXISTS bug24219;
DROP TABLE IF EXISTS bug24219_2;
--enable_warnings

CREATE TABLE bug24219 (a INT, INDEX(a));

SHOW INDEX FROM bug24219;

ALTER TABLE bug24219 RENAME TO bug24219_2, DISABLE KEYS;

SHOW INDEX FROM bug24219_2;

DROP TABLE bug24219_2;

#
# Bug#24562 (ALTER TABLE ... ORDER BY ... with complex expression asserts)
#

--disable_warnings
drop table if exists table_24562;
--enable_warnings

create table table_24562(
  section int,
  subsection int,
  title varchar(50));

insert into table_24562 values
(1, 0, "Introduction"),
(1, 1, "Authors"),
(1, 2, "Acknowledgements"),
(2, 0, "Basics"),
(2, 1, "Syntax"),
(2, 2, "Client"),
(2, 3, "Server"),
(3, 0, "Intermediate"),
(3, 1, "Complex queries"),
(3, 2, "Stored Procedures"),
(3, 3, "Stored Functions"),
(4, 0, "Advanced"),
(4, 1, "Replication"),
(4, 2, "Load balancing"),
(4, 3, "High availability"),
(5, 0, "Conclusion");

select * from table_24562;

alter table table_24562 add column reviewer varchar(20),
order by title;

select * from table_24562;

update table_24562 set reviewer="Me" where section=2;
update table_24562 set reviewer="You" where section=3;

alter table table_24562
order by section ASC, subsection DESC;

select * from table_24562;

alter table table_24562
order by table_24562.subsection ASC, table_24562.section DESC;

select * from table_24562;

--error ER_PARSE_ERROR
alter table table_24562 order by 12;
--error ER_PARSE_ERROR
alter table table_24562 order by (section + 12);
--error ER_PARSE_ERROR
alter table table_24562 order by length(title);
--error ER_PARSE_ERROR
alter table table_24562 order by (select 12 from dual);

--error ER_BAD_FIELD_ERROR
alter table table_24562 order by no_such_col;

drop table table_24562;

# End of 4.1 tests

#
# Bug #14693 (ALTER SET DEFAULT doesn't work)
#

create table t1 (mycol int(10) not null);
alter table t1 alter column mycol set default 0;
desc t1;
drop table t1;

#
# Bug#25262 Auto Increment lost when changing Engine type
#

create table t1(id int(8) primary key auto_increment) engine=heap;

insert into t1 values (null);
insert into t1 values (null);

select * from t1;

# Set auto increment to 50
alter table t1 auto_increment = 50;

# Alter to myisam
alter table t1 engine = myisam;

# This insert should get id 50
insert into t1 values (null);
select * from t1;

# Alter to heap again
alter table t1 engine = heap;
insert into t1 values (null);
select * from t1;

drop table t1;

#
# Bug#27507: Wrong DATETIME value was allowed by ALTER TABLE in the
#            NO_ZERO_DATE mode.
#
set sql_mode= default;
create table t1(f1 int);
alter table t1 add column f2 datetime not null, add column f21 date not null;
insert into t1 values(1,'2000-01-01','2000-01-01');
--error 1292
alter table t1 add column f3 datetime not null;
--error 1292
alter table t1 add column f3 date not null;
--error 1292
alter table t1 add column f4 datetime not null default '2002-02-02',
  add column f41 date not null;
alter table t1 add column f4 datetime not null default '2002-02-02',
  add column f41 date not null default '2002-02-02';
select * from t1;
drop table t1;

#
# Some additional tests for new, faster alter table.  Note that most of the
# whole alter table code is being tested all around the test suite already.
#

create table t1 (v varchar(32));
insert into t1 values ('def'),('abc'),('hij'),('3r4f');
select * from t1;
# Fast alter, no copy performed
alter table t1 change v v2 varchar(32);
select * from t1;
# Fast alter, no copy performed
alter table t1 change v2 v varchar(64);
select * from t1;
update t1 set v = 'lmn' where v = 'hij';
select * from t1;
# Regular alter table
alter table t1 add i int auto_increment not null primary key first;
select * from t1;
update t1 set i=5 where i=3;
select * from t1;
alter table t1 change i i bigint;
select * from t1;
alter table t1 add unique key (i, v);
select * from t1 where i between 2 and 4 and v in ('def','3r4f','lmn');
drop table t1;

#
# Bug#6073 "ALTER table minor glich": ALTER TABLE complains that an index
# without # prefix is not allowed for TEXT columns, while index
# is defined with prefix.
# 
create table t1 (t varchar(255) default null, key t (t(80)))
engine=myisam default charset=latin1;
alter table t1 change t t text;
drop table t1;

#
# Bug #26794: Adding an index with a prefix on a SPATIAL type breaks ALTER
# TABLE
#
CREATE TABLE t1 (a varchar(500));

ALTER TABLE t1 ADD b GEOMETRY NOT NULL, ADD SPATIAL INDEX(b);
SHOW CREATE TABLE t1;
ALTER TABLE t1 ADD KEY(b(50));
SHOW CREATE TABLE t1;

ALTER TABLE t1 ADD c POINT;
SHOW CREATE TABLE t1;

--error ER_WRONG_SUB_KEY
CREATE TABLE t2 (a INT, KEY (a(20)));

ALTER TABLE t1 ADD d INT;
--error ER_WRONG_SUB_KEY
ALTER TABLE t1 ADD KEY (d(20));

# the 5.1 part of the test
--error ER_WRONG_SUB_KEY
ALTER TABLE t1 ADD e GEOMETRY NOT NULL, ADD SPATIAL KEY (e(30));

DROP TABLE t1;

#
# Bug#18038  MySQL server corrupts binary columns data
#

CREATE TABLE t1 (s CHAR(8) BINARY);
INSERT INTO t1 VALUES ('test');
SELECT LENGTH(s) FROM t1;
ALTER TABLE t1 MODIFY s CHAR(10) BINARY;
SELECT LENGTH(s) FROM t1;
DROP TABLE t1;

CREATE TABLE t1 (s BINARY(8));
INSERT INTO t1 VALUES ('test');
SELECT LENGTH(s) FROM t1;
SELECT HEX(s) FROM t1;
ALTER TABLE t1 MODIFY s BINARY(10);
SELECT HEX(s) FROM t1;
SELECT LENGTH(s) FROM t1;
DROP TABLE t1;

#
# Bug#19386: Multiple alter causes crashed table
# The trailing column would get corrupted data, or server could not even read
# it.
#

CREATE TABLE t1 (v VARCHAR(3), b INT);
INSERT INTO t1 VALUES ('abc', 5);
SELECT * FROM t1;
ALTER TABLE t1 MODIFY COLUMN v VARCHAR(4);
SELECT * FROM t1;
DROP TABLE t1;


#
# Bug#31291 ALTER TABLE CONVERT TO CHARACTER SET does not change some data types
#
create table t1 (a tinytext character set latin1);
alter table t1 convert to character set utf8;
show create table t1;
drop table t1;
create table t1 (a mediumtext character set latin1);
alter table t1 convert to character set utf8;
show create table t1;
drop table t1;

--echo End of 5.0 tests

#
# Extended test coverage for ALTER TABLE behaviour under LOCK TABLES
# It should be consistent across all platforms and for all engines
# (Before 5.1 this was not true as behavior was different between 
# Unix/Windows and transactional/non-transactional tables).
# See also innodb_mysql.test
#
--disable_warnings
drop table if exists t1, t2, t3;
--enable_warnings
create table t1 (i int);
create table t3 (j int);
insert into t1 values ();
insert into t3 values ();
# Table which is altered under LOCK TABLES it should stay in list of locked
# tables and be available after alter takes place unless ALTER contains RENAME
# clause. We should see the new definition of table, of course.
lock table t1 write, t3 read;
# Example of so-called 'fast' ALTER TABLE
alter table t1 modify i int default 1;
insert into t1 values ();
select * from t1;
# And now full-blown ALTER TABLE
alter table t1 change i c char(10) default "Two";
insert into t1 values ();
select * from t1;
# If table is renamed then it should be removed from the list
# of locked tables. 'Fast' ALTER TABLE with RENAME clause:
alter table t1 modify c char(10) default "Three", rename to t2;
--error ER_TABLE_NOT_LOCKED
select * from t1;
--error ER_TABLE_NOT_LOCKED
select * from t2;
select * from t3;
unlock tables;
insert into t2 values ();
select * from t2;
lock table t2 write, t3 read;
# Full ALTER TABLE with RENAME
alter table t2 change c vc varchar(100) default "Four", rename to t1;
--error ER_TABLE_NOT_LOCKED
select * from t1;
--error ER_TABLE_NOT_LOCKED
select * from t2;
select * from t3;
unlock tables;
insert into t1 values ();
select * from t1;
drop tables t1, t3;


#
# Bug#18775 - Temporary table from alter table visible to other threads
#
# Check if special characters work and duplicates are detected.
--disable_warnings
DROP TABLE IF EXISTS `t+1`, `t+2`;
--enable_warnings
CREATE TABLE `t+1` (c1 INT);
ALTER TABLE  `t+1` RENAME `t+2`;
CREATE TABLE `t+1` (c1 INT);
--error ER_TABLE_EXISTS_ERROR
ALTER TABLE  `t+1` RENAME `t+2`;
DROP TABLE   `t+1`, `t+2`;
#
# Same for temporary tables though these names do not become file names.
CREATE TEMPORARY TABLE `tt+1` (c1 INT);
ALTER TABLE  `tt+1` RENAME `tt+2`;
CREATE TEMPORARY TABLE `tt+1` (c1 INT);
--error ER_TABLE_EXISTS_ERROR
ALTER TABLE  `tt+1` RENAME `tt+2`;
SHOW CREATE TABLE `tt+1`;
SHOW CREATE TABLE `tt+2`;
DROP TABLE   `tt+1`, `tt+2`;
#
# Check if special characters as in tmp_file_prefix work.
CREATE TABLE `#sql1` (c1 INT);
CREATE TABLE `@0023sql2` (c1 INT);
SHOW TABLES;
RENAME TABLE `#sql1`     TO `@0023sql1`;
RENAME TABLE `@0023sql2` TO `#sql2`;
SHOW TABLES;
ALTER TABLE `@0023sql1`  RENAME `#sql-1`;
ALTER TABLE `#sql2`      RENAME `@0023sql-2`;
SHOW TABLES;
INSERT INTO `#sql-1`     VALUES (1);
INSERT INTO `@0023sql-2` VALUES (2);
DROP TABLE `#sql-1`, `@0023sql-2`;
#
# Same for temporary tables though these names do not become file names.
CREATE TEMPORARY TABLE `#sql1` (c1 INT);
CREATE TEMPORARY TABLE `@0023sql2` (c1 INT);
SHOW TABLES;
ALTER TABLE `#sql1`      RENAME `@0023sql1`;
ALTER TABLE `@0023sql2`  RENAME `#sql2`;
SHOW TABLES;
INSERT INTO `#sql2`      VALUES (1);
INSERT INTO `@0023sql1`  VALUES (2);
SHOW CREATE TABLE `#sql2`;
SHOW CREATE TABLE `@0023sql1`;
DROP TABLE `#sql2`, `@0023sql1`;

#
# Bug #22369: Alter table rename combined with other alterations causes lost tables
#
# This problem happens if the data change is compatible.
# Changing to the same type is compatible for example.
#
--disable_warnings
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;
--enable_warnings
CREATE TABLE t1 (
  int_field INTEGER UNSIGNED NOT NULL,
  char_field CHAR(10),
  INDEX(`int_field`)
);

DESCRIBE t1;

SHOW INDEXES FROM t1;

INSERT INTO t1 VALUES (1, "edno"), (1, "edno"), (2, "dve"), (3, "tri"), (5, "pet"); 
--echo "Non-copy data change - new frm, but old data and index files"
ALTER TABLE t1
  CHANGE int_field unsigned_int_field INTEGER UNSIGNED NOT NULL,
  RENAME t2;

--error ER_NO_SUCH_TABLE
SELECT * FROM t1 ORDER BY int_field;
SELECT * FROM t2 ORDER BY unsigned_int_field;
DESCRIBE t2;
DESCRIBE t2;
ALTER TABLE t2 MODIFY unsigned_int_field BIGINT UNSIGNED NOT NULL;
DESCRIBE t2;

DROP TABLE t2;

#
# Bug#28427: Columns were renamed instead of moving by ALTER TABLE.
#
CREATE TABLE t1 (f1 INT, f2 INT, f3 INT);
INSERT INTO t1 VALUES (1, 2, NULL);
SELECT * FROM t1;
ALTER TABLE t1 MODIFY COLUMN f3 INT AFTER f1;
SELECT * FROM t1;
ALTER TABLE t1 MODIFY COLUMN f3 INT AFTER f2;
SELECT * FROM t1;
DROP TABLE t1;

#
# BUG#29957 - alter_table.test fails
#
create table t1 (c char(10) default "Two");
lock table t1 write;
insert into t1 values ();
alter table t1 modify c char(10) default "Three";
unlock tables;
select * from t1;
check table t1;
drop table t1;

#
# Bug#33873: Fast ALTER TABLE doesn't work with multibyte character sets
#

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
CREATE TABLE t1 (id int, c int) character set latin1;
INSERT INTO t1 VALUES (1,1);
--enable_info
ALTER TABLE t1 CHANGE c d int;
ALTER TABLE t1 CHANGE d c int;
ALTER TABLE t1 MODIFY c VARCHAR(10);
ALTER TABLE t1 CHANGE c d varchar(10);
ALTER TABLE t1 CHANGE d c varchar(10);
--disable_info
DROP TABLE t1;

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
CREATE TABLE t1 (id int, c int) character set utf8;
INSERT INTO t1 VALUES (1,1);
--enable_info
ALTER TABLE t1 CHANGE c d int;
ALTER TABLE t1 CHANGE d c int;
ALTER TABLE t1 MODIFY c VARCHAR(10);
ALTER TABLE t1 CHANGE c d varchar(10);
ALTER TABLE t1 CHANGE d c varchar(10);
--disable_info
DROP TABLE t1;

#
# Bug#39372 "Smart" ALTER TABLE not so smart after all.
#
create table t1(f1 int not null, f2 int not null, key  (f1), key (f2));
let $count= 50;
--disable_query_log
while ($count)
{
  EVAL insert into t1 values (1,1),(1,1),(1,1),(1,1),(1,1);
  EVAL insert into t1 values (2,2),(2,2),(2,2),(2,2),(2,2);
  dec $count ;
}
--enable_query_log

select index_length into @unpaked_keys_size from
information_schema.tables where table_name='t1';
alter table t1 pack_keys=1;
select index_length into @paked_keys_size from
information_schema.tables where table_name='t1';
select (@unpaked_keys_size > @paked_keys_size);

select max_data_length into @orig_max_data_length from
information_schema.tables where table_name='t1';
alter table t1 max_rows=100;
select max_data_length into @changed_max_data_length from
information_schema.tables where table_name='t1';
select (@orig_max_data_length > @changed_max_data_length);

drop table t1;

#
# Bug #23113: Different behavior on altering ENUM fields between 5.0 and 5.1
#
CREATE TABLE t1(a INT AUTO_INCREMENT PRIMARY KEY, 
  b ENUM('a', 'b', 'c') NOT NULL);
INSERT INTO t1 (b) VALUES ('a'), ('c'), ('b'), ('b'), ('a');
ALTER TABLE t1 MODIFY b ENUM('a', 'z', 'b', 'c') NOT NULL;
SELECT * FROM t1;
DROP TABLE t1;

--echo #
--echo # Bug#45567: Fast ALTER TABLE broken for enum and set
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TABLE t1 (a ENUM('a1','a2'));
INSERT INTO t1 VALUES ('a1'),('a2');
--enable_info
--echo # No copy: No modification
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2');
--echo # No copy: Add new enumeration to the end
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2','a3');
--echo # Copy: Modify and add new to the end
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2','xx','a5');
--echo # Copy: Remove from the end
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2','xx');
--echo # Copy: Add new enumeration
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2','a0','xx');
--echo # No copy: Add new enumerations to the end
ALTER TABLE t1 MODIFY COLUMN a ENUM('a1','a2','a0','xx','a5','a6');
--disable_info
DROP TABLE t1;

CREATE TABLE t1 (a SET('a1','a2'));
INSERT INTO t1 VALUES ('a1'),('a2');
--enable_info
--echo # No copy: No modification
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2');
--echo # No copy: Add new to the end
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','a3');
--echo # Copy: Modify and add new to the end
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','xx','a5');
--echo # Copy: Remove from the end
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','xx');
--echo # Copy: Add new member
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','a0','xx');
--echo # No copy: Add new to the end
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','a0','xx','a5','a6');
--echo # Copy: Numerical incrase (pack lenght)
ALTER TABLE t1 MODIFY COLUMN a SET('a1','a2','a0','xx','a5','a6','a7','a8','a9','a10');
--disable_info
DROP TABLE t1;

#
# Bug#43508: Renaming timestamp or date column triggers table copy
#

CREATE TABLE t1 (f1 TIMESTAMP NULL DEFAULT NULL,
                 f2 INT(11) DEFAULT NULL) ENGINE=MYISAM DEFAULT CHARSET=utf8;

INSERT INTO t1 VALUES (NULL, NULL), ("2009-10-09 11:46:19", 2);

--echo this should affect no rows as there is no real change
--enable_info
ALTER TABLE t1 CHANGE COLUMN f1 f1_no_real_change TIMESTAMP NULL DEFAULT NULL;
--disable_info
DROP TABLE t1;


--echo #
--echo # Bug #31145: ALTER TABLE DROP COLUMN, ADD COLUMN crashes (linux) 
--echo #   or freezes (win) the server
--echo #

CREATE TABLE t1 (a TEXT, id INT, b INT);
ALTER TABLE t1 DROP COLUMN a, ADD COLUMN c TEXT FIRST;

DROP TABLE t1;


--echo #
--echo # Test for bug #12652385 - "61493: REORDERING COLUMNS TO POSITION
--echo #                           FIRST CAN CAUSE DATA TO BE CORRUPTED".
--echo #
--disable_warnings
drop table if exists t1;
--enable_warnings
--echo # Use MyISAM engine as the fact that InnoDB doesn't support
--echo # in-place ALTER TABLE in cases when columns are being renamed
--echo # hides some bugs.
create table t1 (i int, j int) engine=myisam;
insert into t1 value (1, 2);
--echo # First, test for original problem described in the bug report.
select * from t1;
--echo # Change of column order by the below ALTER TABLE statement should
--echo # affect both column names and column contents.
alter table t1 modify column j int first;
select * from t1;
--echo # Now test for similar problem with the same root.
--echo # The below ALTER TABLE should change not only the name but
--echo # also the value for the last column of the table.
alter table t1 drop column i, add column k int default 0;
select * from t1;
--echo # Clean-up.
drop table t1;


--echo End of 5.1 tests

#
# Bug #31031 ALTER TABLE regression in 5.0
#
#  The ALTER TABLE operation failed with 
#  ERROR 1089 (HY000): Incorrect sub part key; ...
#
CREATE TABLE t1(c CHAR(10), 
  i INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY);
INSERT INTO t1 VALUES('a',2),('b',4),('c',6);
ALTER TABLE t1
  DROP i,
  ADD i INT UNSIGNED NOT NULL AUTO_INCREMENT,
  AUTO_INCREMENT = 1;
DROP TABLE t1;


#
# Bug#50542 5.5.x doesn't check length of key prefixes: 
#           corruption and crash results
#
# This case is related to Bug#31031 (above)
# A statement where the index key is larger/wider than
# the column type, should cause an error
#
--error ER_WRONG_SUB_KEY
CREATE TABLE t1 (a CHAR(1), PRIMARY KEY (a(255)));

# Test other variants of creating indices
CREATE TABLE t1 (a CHAR(1));
#  ALTER TABLE
--error ER_WRONG_SUB_KEY
ALTER TABLE t1 ADD PRIMARY KEY (a(20));
--error ER_WRONG_SUB_KEY
ALTER TABLE t1 ADD KEY (a(20));
#  CREATE INDEX
--error ER_WRONG_SUB_KEY
CREATE UNIQUE INDEX i1 ON t1 (a(20));
--error ER_WRONG_SUB_KEY
CREATE INDEX i2 ON t1 (a(20));
# cleanup
DROP TABLE t1;


#
# Bug #45052    ALTER TABLE ADD COLUMN crashes server with multiple foreign key columns
#   The alter table fails if 2 or more new fields added and
#   also added a key with these fields
#
CREATE TABLE t1 (id int);
INSERT INTO t1 VALUES (1), (2);
ALTER TABLE t1 ADD COLUMN (f1 INT), ADD COLUMN (f2 INT), ADD KEY f2k(f2);
DROP TABLE t1;


--echo #
--echo # Test for bug #53820 "ALTER a MEDIUMINT column table causes full
--echo #                      table copy".
--echo #
--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
CREATE TABLE t1 (a INT, b MEDIUMINT);
INSERT INTO t1 VALUES (1, 1), (2, 2);
--echo # The below ALTER should not copy table and so no rows should
--echo # be shown as affected.
--enable_info
ALTER TABLE t1 CHANGE a id INT;
--disable_info
DROP TABLE t1;


--echo #
--echo # Bug#11754461 CANNOT ALTER TABLE WHEN KEY PREFIX TOO LONG
--echo #

--disable_warnings
DROP DATABASE IF EXISTS db1;
--enable_warnings

CREATE DATABASE db1 CHARACTER SET utf8;
--error ER_TOO_LONG_KEY
CREATE TABLE db1.t1 (bar TINYTEXT, KEY (bar(100)));
CREATE TABLE db1.t1 (bar TINYTEXT, KEY (bar(85)));
ALTER TABLE db1.t1 ADD baz INT;

DROP DATABASE db1;


--echo # Additional coverage for refactoring which is made as part
--echo # of fix for bug #27480 "Extend CREATE TEMPORARY TABLES privilege
--echo # to allow temp table operations".
--echo #
--echo # At some point the below test case failed on assertion.

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TEMPORARY TABLE t1 (i int) ENGINE=MyISAM;

--error ER_ILLEGAL_HA
ALTER TABLE t1 DISCARD TABLESPACE;

DROP TABLE t1;


--echo #
--echo # Bug#11938039 RE-EXECUTION OF FRM-ONLY ALTER TABLE WITH RENAME
--echo #              CLAUSE FAILS OR ABORTS SERVER.
--echo #
--disable_warnings
drop table if exists t1;
--enable_warnings
create table t1 (a int);
prepare stmt1 from 'alter table t1 alter column a set default 1, rename to t2';
execute stmt1;
rename table t2 to t1;
--echo # The below statement should succeed and not emit error or abort server.
execute stmt1;
deallocate prepare stmt1;
drop table t2;


--echo # Bug#11748057 (formerly known as 34972): ALTER TABLE statement doesn't
--echo #                                         identify correct column name.
--echo #

CREATE TABLE t1 (c1 int unsigned , c2 char(100) not null default '');
ALTER TABLE t1 ADD c3 char(16) NOT NULL DEFAULT '' AFTER c2,
               MODIFY c2 char(100) NOT NULL DEFAULT '' AFTER c1;
SHOW CREATE TABLE t1;
DROP TABLE t1;


--echo #
--echo # WL#5534 Online ALTER, Phase 1
--echo #

--echo # Single thread tests.
--echo # See innodb_mysql_sync.test for multi thread tests.

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TABLE t1(a INT PRIMARY KEY, b INT) engine=InnoDB;
CREATE TABLE m1(a INT PRIMARY KEY, b INT) engine=MyISAM;
INSERT INTO t1 VALUES (1,1), (2,2);
INSERT INTO m1 VALUES (1,1), (2,2);

--echo #
--echo # 1: Test ALGORITHM keyword
--echo #

--echo # --enable_info allows us to see how many rows were updated
--echo # by ALTER TABLE. in-place will show 0 rows, while copy > 0.

--enable_info
ALTER TABLE t1 ADD INDEX i1(b);
ALTER TABLE t1 ADD INDEX i2(b), ALGORITHM= DEFAULT;
ALTER TABLE t1 ADD INDEX i3(b), ALGORITHM= COPY;
ALTER TABLE t1 ADD INDEX i4(b), ALGORITHM= INPLACE;
--error ER_UNKNOWN_ALTER_ALGORITHM
ALTER TABLE t1 ADD INDEX i5(b), ALGORITHM= INVALID;

ALTER TABLE m1 ENABLE KEYS;
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= DEFAULT;
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= COPY;
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= INPLACE;
--disable_info

ALTER TABLE t1 DROP INDEX i1, DROP INDEX i2, DROP INDEX i3, DROP INDEX i4;

--echo #
--echo # 2: Test ALGORITHM + old_alter_table
--echo #

--enable_info
SET SESSION old_alter_table= 1;
ALTER TABLE t1 ADD INDEX i1(b);
ALTER TABLE t1 ADD INDEX i2(b), ALGORITHM= DEFAULT;
ALTER TABLE t1 ADD INDEX i3(b), ALGORITHM= COPY;
ALTER TABLE t1 ADD INDEX i4(b), ALGORITHM= INPLACE;
SET SESSION old_alter_table= 0;
--disable_info

ALTER TABLE t1 DROP INDEX i1, DROP INDEX i2, DROP INDEX i3, DROP INDEX i4;

--echo #
--echo # 3: Test unsupported in-place operation
--echo #

ALTER TABLE t1 ADD COLUMN (c1 INT);
ALTER TABLE t1 ADD COLUMN (c2 INT), ALGORITHM= DEFAULT;
ALTER TABLE t1 ADD COLUMN (c3 INT), ALGORITHM= COPY;
ALTER TABLE t1 ADD COLUMN (c4 INT), ALGORITHM= INPLACE;

ALTER TABLE t1 DROP COLUMN c1, DROP COLUMN c2, DROP COLUMN c3, DROP COLUMN c4;

--echo #
--echo # 4: Test LOCK keyword
--echo #

--enable_info
ALTER TABLE t1 ADD INDEX i1(b), LOCK= DEFAULT;
ALTER TABLE t1 ADD INDEX i2(b), LOCK= NONE;
ALTER TABLE t1 ADD INDEX i3(b), LOCK= SHARED;
ALTER TABLE t1 ADD INDEX i4(b), LOCK= EXCLUSIVE;
--error ER_UNKNOWN_ALTER_LOCK
ALTER TABLE t1 ADD INDEX i5(b), LOCK= INVALID;
--disable_info

ALTER TABLE m1 ENABLE KEYS, LOCK= DEFAULT;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE m1 ENABLE KEYS, LOCK= NONE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE m1 ENABLE KEYS, LOCK= SHARED;
ALTER TABLE m1 ENABLE KEYS, LOCK= EXCLUSIVE;

ALTER TABLE t1 DROP INDEX i1, DROP INDEX i2, DROP INDEX i3, DROP INDEX i4;

--echo #
--echo # 5: Test ALGORITHM + LOCK
--echo #

--enable_info
ALTER TABLE t1 ADD INDEX i1(b), ALGORITHM= INPLACE, LOCK= NONE;
ALTER TABLE t1 ADD INDEX i2(b), ALGORITHM= INPLACE, LOCK= SHARED;
ALTER TABLE t1 ADD INDEX i3(b), ALGORITHM= INPLACE, LOCK= EXCLUSIVE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 ADD INDEX i4(b), ALGORITHM= COPY, LOCK= NONE;
ALTER TABLE t1 ADD INDEX i5(b), ALGORITHM= COPY, LOCK= SHARED;
ALTER TABLE t1 ADD INDEX i6(b), ALGORITHM= COPY, LOCK= EXCLUSIVE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= INPLACE, LOCK= NONE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= INPLACE, LOCK= SHARED;
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= INPLACE, LOCK= EXCLUSIVE;
--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= COPY, LOCK= NONE;
# This works because the lock will be SNW for the copy phase.
# It will still require exclusive lock for actually enabling keys.
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= COPY, LOCK= SHARED;
ALTER TABLE m1 ENABLE KEYS, ALGORITHM= COPY, LOCK= EXCLUSIVE;
--disable_info

DROP TABLE t1, m1;

--echo #
--echo # 6: Possible deadlock involving thr_lock.c
--echo #

CREATE TABLE t1(a INT PRIMARY KEY, b INT);
INSERT INTO t1 VALUES (1,1), (2,2);

START TRANSACTION;
INSERT INTO t1 VALUES (3,3);

--echo # Connection con1
connect (con1, localhost, root);
--echo # Sending:
--send ALTER TABLE t1 DISABLE KEYS

--echo # Connection default
connection default;
--echo # Waiting until ALTER TABLE is blocked.
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE state = "Waiting for table metadata lock" AND
        info = "ALTER TABLE t1 DISABLE KEYS";
--source include/wait_condition.inc
UPDATE t1 SET b = 4;
COMMIT;

--echo # Connection con1
connection con1;
--echo # Reaping: ALTER TABLE t1 DISABLE KEYS
--reap
disconnect con1;
--source include/wait_until_disconnected.inc

--echo # Connection default
connection default;
DROP TABLE t1;

--echo #
--echo # 7: Which operations require copy and which can be done in-place?
--echo #
--echo # Test which ALTER TABLE operations are done in-place and
--echo # which operations are done using temporary table copy.
--echo #
--echo # --enable_info allows us to see how many rows were updated
--echo # by ALTER TABLE. in-place will show 0 rows, while copy > 0.
--echo #

--disable_warnings
DROP TABLE IF EXISTS ti1, ti2, ti3, tm1, tm2, tm3;
--enable_warnings

--echo # Single operation tests

CREATE TABLE ti1(a INT NOT NULL, b INT, c INT) engine=InnoDB;
CREATE TABLE tm1(a INT NOT NULL, b INT, c INT) engine=MyISAM;
CREATE TABLE ti2(a INT PRIMARY KEY AUTO_INCREMENT, b INT, c INT) engine=InnoDB;
CREATE TABLE tm2(a INT PRIMARY KEY AUTO_INCREMENT, b INT, c INT) engine=MyISAM;
INSERT INTO ti1 VALUES (1,1,1), (2,2,2);
INSERT INTO ti2 VALUES (1,1,1), (2,2,2);
INSERT INTO tm1 VALUES (1,1,1), (2,2,2);
INSERT INTO tm2 VALUES (1,1,1), (2,2,2);

--enable_info
ALTER TABLE ti1;
ALTER TABLE tm1;

ALTER TABLE ti1 ADD COLUMN d VARCHAR(200);
ALTER TABLE tm1 ADD COLUMN d VARCHAR(200);
ALTER TABLE ti1 ADD COLUMN d2 VARCHAR(200);
ALTER TABLE tm1 ADD COLUMN d2 VARCHAR(200);
ALTER TABLE ti1 ADD COLUMN e ENUM('a', 'b') FIRST;
ALTER TABLE tm1 ADD COLUMN e ENUM('a', 'b') FIRST;
ALTER TABLE ti1 ADD COLUMN f INT AFTER a;
ALTER TABLE tm1 ADD COLUMN f INT AFTER a;

ALTER TABLE ti1 ADD INDEX ii1(b);
ALTER TABLE tm1 ADD INDEX im1(b);
ALTER TABLE ti1 ADD UNIQUE INDEX ii2 (c);
ALTER TABLE tm1 ADD UNIQUE INDEX im2 (c);
ALTER TABLE ti1 ADD FULLTEXT INDEX ii3 (d);
ALTER TABLE tm1 ADD FULLTEXT INDEX im3 (d);
ALTER TABLE ti1 ADD FULLTEXT INDEX ii4 (d2);
ALTER TABLE tm1 ADD FULLTEXT INDEX im4 (d2);

# Bug#14140038 INCONSISTENT HANDLING OF FULLTEXT INDEXES IN ALTER TABLE
--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE ti1 ADD PRIMARY KEY(a), ALGORITHM=INPLACE;
ALTER TABLE ti1 ADD PRIMARY KEY(a);
ALTER TABLE tm1 ADD PRIMARY KEY(a);

ALTER TABLE ti1 DROP INDEX ii3;
ALTER TABLE tm1 DROP INDEX im3;

ALTER TABLE ti1 DROP COLUMN d2;
ALTER TABLE tm1 DROP COLUMN d2;

ALTER TABLE ti1 ADD CONSTRAINT fi1 FOREIGN KEY (b) REFERENCES ti2(a);
ALTER TABLE tm1 ADD CONSTRAINT fm1 FOREIGN KEY (b) REFERENCES tm2(a);

ALTER TABLE ti1 ALTER COLUMN b SET DEFAULT 1;
ALTER TABLE tm1 ALTER COLUMN b SET DEFAULT 1;
ALTER TABLE ti1 ALTER COLUMN b DROP DEFAULT;
ALTER TABLE tm1 ALTER COLUMN b DROP DEFAULT;

# This will set both ALTER_COLUMN_NAME and COLUMN_DEFAULT_VALUE
ALTER TABLE ti1 CHANGE COLUMN f g INT;
ALTER TABLE tm1 CHANGE COLUMN f g INT;
ALTER TABLE ti1 CHANGE COLUMN g h VARCHAR(20);
ALTER TABLE tm1 CHANGE COLUMN g h VARCHAR(20);
ALTER TABLE ti1 MODIFY COLUMN e ENUM('a', 'b', 'c');
ALTER TABLE tm1 MODIFY COLUMN e ENUM('a', 'b', 'c');
ALTER TABLE ti1 MODIFY COLUMN e INT;
ALTER TABLE tm1 MODIFY COLUMN e INT;
# This will set both ALTER_COLUMN_ORDER and COLUMN_DEFAULT_VALUE
ALTER TABLE ti1 MODIFY COLUMN e INT AFTER h;
ALTER TABLE tm1 MODIFY COLUMN e INT AFTER h;
ALTER TABLE ti1 MODIFY COLUMN e INT FIRST;
ALTER TABLE tm1 MODIFY COLUMN e INT FIRST;
# This will set both ALTER_COLUMN_NOT_NULLABLE and COLUMN_DEFAULT_VALUE
ALTER TABLE ti1 MODIFY COLUMN c INT NOT NULL;
ALTER TABLE tm1 MODIFY COLUMN c INT NOT NULL;
# This will set both ALTER_COLUMN_NULLABLE and COLUMN_DEFAULT_VALUE
ALTER TABLE ti1 MODIFY COLUMN c INT NULL;
ALTER TABLE tm1 MODIFY COLUMN c INT NULL;
# This will set both ALTER_COLUMN_EQUAL_PACK_LENGTH and COLUMN_DEFAULT_VALUE
ALTER TABLE ti1 MODIFY COLUMN h VARCHAR(30);
ALTER TABLE tm1 MODIFY COLUMN h VARCHAR(30);
ALTER TABLE ti1 MODIFY COLUMN h VARCHAR(30) AFTER d;
ALTER TABLE tm1 MODIFY COLUMN h VARCHAR(30) AFTER d;

ALTER TABLE ti1 DROP COLUMN h;
ALTER TABLE tm1 DROP COLUMN h;

ALTER TABLE ti1 DROP INDEX ii2;
ALTER TABLE tm1 DROP INDEX im2;
ALTER TABLE ti1 DROP PRIMARY KEY;
ALTER TABLE tm1 DROP PRIMARY KEY;

ALTER TABLE ti1 DROP FOREIGN KEY fi1;
ALTER TABLE tm1 DROP FOREIGN KEY fm1;

ALTER TABLE ti1 RENAME TO ti3;
ALTER TABLE tm1 RENAME TO tm3;
ALTER TABLE ti3 RENAME TO ti1;
ALTER TABLE tm3 RENAME TO tm1;

ALTER TABLE ti1 ORDER BY b;
ALTER TABLE tm1 ORDER BY b;

ALTER TABLE ti1 CONVERT TO CHARACTER SET utf16;
ALTER TABLE tm1 CONVERT TO CHARACTER SET utf16;
ALTER TABLE ti1 DEFAULT CHARACTER SET utf8;
ALTER TABLE tm1 DEFAULT CHARACTER SET utf8;

ALTER TABLE ti1 FORCE;
ALTER TABLE tm1 FORCE;

ALTER TABLE ti1 AUTO_INCREMENT 3;
ALTER TABLE tm1 AUTO_INCREMENT 3;
ALTER TABLE ti1 AVG_ROW_LENGTH 10;
ALTER TABLE tm1 AVG_ROW_LENGTH 10;
ALTER TABLE ti1 CHECKSUM 1;
ALTER TABLE tm1 CHECKSUM 1;
ALTER TABLE ti1 COMMENT 'test';
ALTER TABLE tm1 COMMENT 'test';
ALTER TABLE ti1 MAX_ROWS 100;
ALTER TABLE tm1 MAX_ROWS 100;
ALTER TABLE ti1 MIN_ROWS 1;
ALTER TABLE tm1 MIN_ROWS 1;
ALTER TABLE ti1 PACK_KEYS 1;
ALTER TABLE tm1 PACK_KEYS 1;

--disable_info
DROP TABLE ti1, ti2, tm1, tm2;

--echo # Tests of >1 operation (InnoDB)

CREATE TABLE ti1(a INT PRIMARY KEY AUTO_INCREMENT, b INT) engine=InnoDB;
INSERT INTO ti1(b) VALUES (1), (2);

--enable_info
ALTER TABLE ti1 RENAME TO ti3, ADD INDEX ii1(b);

ALTER TABLE ti3 DROP INDEX ii1, AUTO_INCREMENT 5;
--disable_info
INSERT INTO ti3(b) VALUES (5);
--enable_info
ALTER TABLE ti3 ADD INDEX ii1(b), AUTO_INCREMENT 7;
--disable_info
INSERT INTO ti3(b) VALUES (7);
SELECT * FROM ti3;

DROP TABLE ti3;

--echo #
--echo # 8: Scenario in which ALTER TABLE was returning an unwarranted
--echo #    ER_ILLEGAL_HA error at some point during work on this WL.
--echo #

CREATE TABLE tm1(i INT DEFAULT 1) engine=MyISAM;
ALTER TABLE tm1 ADD INDEX ii1(i), ALTER COLUMN i DROP DEFAULT;
DROP TABLE tm1;

--echo #
--echo # Bug#11815557 60269: MYSQL SHOULD REJECT ATTEMPTS TO CREATE SYSTEM
--echo #                     TABLES IN INCORRECT ENGINE
--echo #
--echo # Note: This test assumes that only MyISAM and InnoDB supports system tables.
--echo #       If other engines are made to support system tables,
--echo #       then this test needs to be updated
--echo #

use mysql;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE db ENGINE=innodb;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE user ENGINE=memory;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE proc ENGINE=heap;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE func ENGINE=csv;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE event ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE servers ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE procs_priv ENGINE=memory;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE tables_priv ENGINE=heap;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE columns_priv ENGINE=csv;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE time_zone ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
ALTER TABLE help_topic ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE db (dummy int) ENGINE=innodb;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE user (dummy int) ENGINE=memory;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE proc (dummy int) ENGINE=heap;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE func (dummy int) ENGINE=csv;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE event (dummy int) ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE servers (dummy int) ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE procs_priv (dummy int) ENGINE=memory;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE tables_priv (dummy int) ENGINE=heap;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE columns_priv (dummy int) ENGINE=csv;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE time_zone (dummy int) ENGINE=merge;
--error ER_UNSUPPORTED_ENGINE
CREATE TABLE help_topic (dummy int) ENGINE=merge;
use test;
--echo # End of Bug#11815557


--echo #
--echo # Tests for WL#6555 "Online rename index".
--echo #

--echo #
--echo # 1) Tests for syntax and semantics of ALTER TABLE RENAME
--echo #    KEY/INDEX result.
--echo #
--echo # 1.a) Both RENAME KEY and RENAME INDEX variants should be
--echo #      allowed and produce expected results.
create table t1 (pk int primary key, i int, j int, key a(i));
alter table t1 rename key a to b;
show create table t1;
alter table t1 rename index b to c;
show create table t1;

--echo # 1.b) It should be impossible to rename index that doesn't
--echo #      exists, dropped or added within the same ALTER TABLE.
--error ER_KEY_DOES_NOT_EXITS 
alter table t1 rename key d to e;
show create table t1;
--error ER_KEY_DOES_NOT_EXITS 
alter table t1 drop key c, rename key c to d;
show create table t1;
--error ER_KEY_DOES_NOT_EXITS 
alter table t1 add key d(j), rename key d to e; 
show create table t1;

--echo # 1.c) It should be impossible to rename index to a name
--echo #      which is already used by another index, or is used
--echo #      by index which is added within the same ALTER TABLE.
alter table t1 add key d(j);
--error ER_DUP_KEYNAME
alter table t1 rename key c to d;
show create table t1;
alter table t1 drop key d;
--error ER_DUP_KEYNAME
alter table t1 add key d(j), rename key c to d;
show create table t1;

--echo # 1.d) It should be possible to rename index to a name
--echo #      which belongs to index which is dropped within the
--echo #      same ALTER TABLE.
alter table t1 add key d(j);
alter table t1 drop key c, rename key d to c;
show create table t1;

--echo # 1.e) We disallow renaming from/to PRIMARY as it might
--echo #      lead to some other key becoming "primary" internally,
--echo #      which will be interpreted as dropping/addition of
--echo #      primary key.
--error ER_PARSE_ERROR
alter table t1 rename key primary to d;
show create table t1;
--echo # Even using 'funny' syntax.
--error ER_WRONG_NAME_FOR_INDEX
alter table t1 rename key t1.primary to d;
show create table t1;
--error ER_PARSE_ERROR
alter table t1 rename key c to primary;
show create table t1;
--error ER_WRONG_NAME_FOR_INDEX
alter table t1 rename key c to t1.primary;
show create table t1;
drop table t1;


--echo #
--echo # 2) More complex tests for semantics of ALTER TABLE.
--echo #
--echo # 2.a) Check that standalone RENAME KEY works as expected
--echo #      for unique and non-unique indexes.
create table t1 (a int, unique u(a), b int, key k(b));
alter table t1 rename key u to uu;
show create table t1;
alter table t1 rename key k to kk;
show create table t1;

--echo # 2.b) Check how that this clause can be mixed with other
--echo #      clauses which don't affect key or its columns.
alter table t1 rename key kk to kkk, add column c int;
show create table t1;
alter table t1 rename key uu to uuu, add key c(c);
show create table t1;
alter table t1 rename key kkk to k, drop key uuu;
show create table t1;
alter table t1 rename key k to kk, rename to t2;
show create table t2;

--echo # 2.c) Check that this clause properly works even in case
--echo #      when it is mixed with clauses affecting columns in
--echo #      the key renamed.
alter table t2 rename key c to cc, modify column c bigint not null first;
show create table t2;
--echo # Create multi-component key for next example.
alter table t2 add unique u (a, b, c);
show create table t2;
alter table t2 rename key u to uu, drop column b;
show create table t2;
drop table t2;


--echo #
--echo # 3) Test coverage for handling of RENAME INDEX clause in
--echo #    various storage engines and using different ALTER
--echo #    algorithm.
--echo #
--echo # 3.a) Test coverage for simple storage engines (MyISAM/Heap).
create table t1 (i int, key k(i)) engine=myisam;
insert into t1 values (1);
create table t2 (i int, key k(i)) engine=memory;
insert into t2 values (1);
--echo # MyISAM and Heap should be able to handle key renaming in-place.
alter table t1 algorithm=inplace, rename key k to kk;
alter table t2 algorithm=inplace, rename key k to kk;
show create table t1;
show create table t2;
--echo # So by default in-place algorithm should be chosen.
--echo # (ALTER TABLE should report 0 rows affected).
--enable_info
alter table t1 rename key kk to kkk;
alter table t2 rename key kk to kkk;
--disable_info
show create table t1;
show create table t2;
--echo # Copy algorithm should work as well.
alter table t1 algorithm=copy, rename key kkk to kkkk;
alter table t2 algorithm=copy, rename key kkk to kkkk;
show create table t1;
show create table t2;
--echo # When renaming is combined with other in-place operation
--echo # it still works as expected (i.e. works in-place).
alter table t1 algorithm=inplace, rename key kkkk to k, alter column i set default 100;
alter table t2 algorithm=inplace, rename key kkkk to k, alter column i set default 100;
show create table t1;
show create table t2;
--echo # Combining with non-inplace operation results in the whole ALTER
--echo # becoming non-inplace. 
--error ER_ALTER_OPERATION_NOT_SUPPORTED
alter table t1 algorithm=inplace, rename key k to kk, add column j int;
--error ER_ALTER_OPERATION_NOT_SUPPORTED
alter table t2 algorithm=inplace, rename key k to kk, add column j int;
drop table t1, t2;

--echo # 3.b) Basic tests for InnoDB. More tests can be found in
--echo #      innodb.innodb_rename_index*
create table t1 (i int, key k(i)) engine=innodb;
insert into t1 values (1);
--echo # Basic rename, inplace algorithm should be chosen
--enable_info
alter table t1 algorithm=inplace, rename key k to kk;
--disable_info
show create table t1;
--echo # copy algorithm should work as well.
--enable_info
alter table t1 algorithm=copy, rename key kk to kkk;
--disable_info
show create table t1;
drop table t1;

--echo #
--echo # 4) Additional coverage for complex cases in which code
--echo #    in ALTER TABLE comparing old and new table version
--echo #    got confused.
--echo #
--echo # Once InnoDB starts to support in-place index renaming the result
--echo # of below statements should stay the same. Information about
--echo # indexes returned by SHOW CREATE TABLE (from .FRM) and by
--echo # InnoDB (from InnoDB data-dictionary) should be consistent.
--echo #
create table t1 ( a int, b int, c int, d int,
                  primary key (a), index i1 (b), index i2 (c) ) engine=innodb;
alter table t1 add index i1 (d), rename index i1 to x;
show create table t1;
select i.name as k, f.name as c from information_schema.innodb_sys_tables as t,
                                     information_schema.innodb_sys_indexes as i,
                                     information_schema.innodb_sys_fields as f
where t.name='test/t1' and t.table_id = i.table_id and i.index_id = f.index_id
order by k, c;
drop table t1;
create table t1 (a int, b int, c int, d int,
                 primary key (a), index i1 (b), index i2 (c)) engine=innodb;
alter table t1 add index i1 (d), rename index i1 to i2, drop index i2;
show create table t1;
select i.name as k, f.name as c from information_schema.innodb_sys_tables as t,
                                     information_schema.innodb_sys_indexes as i,
                                     information_schema.innodb_sys_fields as f
where t.name='test/t1' and t.table_id = i.table_id and i.index_id = f.index_id
order by k, c;
drop table t1;
--echo #
--echo # The below ALTER TABLE statement should either drop and recreate key
--echo # under new name, or simply rename it. It should not bring .FRM and
--echo # InnoDB data-dictionary out of sync thus causing asserts.
--echo #
create table t1 (i int, key x(i)) engine=InnoDB;
alter table t1 drop key x, add key X(i), alter column i set default 10;
drop table t1;


--echo #
--echo # Coverage for changes to ALTER TABLE ... IMPORT/DISCARD TABLESPACE
--echo # code introduced by WL#6671 "Improve scalability by not using
--echo # thr_lock.c locks for InnoDB tables".
--echo #
--echo # Check that ALTER TABLE ... IMPORT/DISCARD TABLESPACE acquires X
--echo # metadata lock on the table even when executed under LOCK TABLES.
--echo #

--enable_connect_log
--echo # Suppress error messages which will be generated by IMPORT TABLESPACE
call mtr.add_suppression("InnoDB: Trying to import a tablespace, but could not open the tablespace file");
call mtr.add_suppression("InnoDB: Operating system error number 2 in a file operation.");
call mtr.add_suppression("InnoDB: The error means the system cannot find the path specified.");

CREATE TABLE t1 (i INT) ENGINE=InnoDB;

--echo #
--echo # 1) Check that ALTER TABLE ... IMPORT/DISCARD TABLESPACE on
--echo #    base table acquire X lock (when not under LOCK TABLES).
--echo # 

connect(con1, localhost, root);
--echo # Acquire S lock on table 't1'.
HANDLER t1 OPEN;

connect(con2, localhost, root);
--echo # Sending:
--send ALTER TABLE t1 DISCARD TABLESPACE

connection default;
--echo # Wait until ALTER TABLE is blocked since it tries to acquire X lock.
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE state = "Waiting for table metadata lock" AND
        info = "ALTER TABLE t1 DISCARD TABLESPACE";
--source include/wait_condition.inc

connection con1;
--echo # Unblock ALTER TABLE DISCARD
HANDLER t1 CLOSE;

connection con2;
--echo # Reaping ALTER TABLE DISCARD
--reap

connection con1;
--echo # Acquire S lock on table 't1'.
HANDLER t1 OPEN;

connection con2;
--echo # Sending:
--send ALTER TABLE t1 IMPORT TABLESPACE

connection default;
--echo # Wait until ALTER TABLE is blocked since it tries to acquire X lock.
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE state = "Waiting for table metadata lock" AND
        info = "ALTER TABLE t1 IMPORT TABLESPACE";
--source include/wait_condition.inc

connection con1;
--echo # Unblock ALTER TABLE IMPORT
HANDLER t1 CLOSE;

connection con2;
--echo # Reaping ALTER TABLE IMPORT
--echo # It should fail as no tablespace was copied after DISCARD.
--error ER_TABLESPACE_MISSING
--reap

connection default;
DROP TABLE t1;

--echo #
--echo # 2) ALTER TABLE ... IMPORT/DISCARD TABLESPACE on temporary table
--echo #    should not try to acquire X metadata lock on base table.
--echo #

CREATE TABLE t1 (i INT) ENGINE=InnoDB;

connection con1;
--echo # Acquire S lock on table 't1'.
HANDLER t1 OPEN;

connection con2;
CREATE TEMPORARY TABLE t1 (j INT) ENGINE=InnoDB;

--echo # Both DISCARD and IMPORT on temporary table should fail without
--echo # acquiring any locks and blocking.
--error ER_CANNOT_DISCARD_TEMPORARY_TABLE
ALTER TABLE t1 DISCARD TABLESPACE;
--error ER_CANNOT_DISCARD_TEMPORARY_TABLE
ALTER TABLE t1 IMPORT TABLESPACE;

DROP TEMPORARY TABLE t1;

--echo #
--echo # 3) Check that ALTER TABLE ... IMPORT/DISCARD TABLESPACE on
--echo #    base table under LOCK TABLES acquire X lock.
--echo # 

connection con2;
LOCK TABLES t1 WRITE;
--echo # Sending:
--send ALTER TABLE t1 DISCARD TABLESPACE

connection default;
--echo # Wait until ALTER TABLE is blocked since it tries to acquire X lock.
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE state = "Waiting for table metadata lock" AND
        info = "ALTER TABLE t1 DISCARD TABLESPACE";
--source include/wait_condition.inc

connection con1;
--echo # Unblock ALTER TABLE DISCARD
HANDLER t1 CLOSE;

connection con2;
--echo # Reaping ALTER TABLE DISCARD
--reap

connection con1;
--echo # Acquire S lock on table 't1'.
HANDLER t1 OPEN;

connection con2;
--echo # Sending:
--send ALTER TABLE t1 IMPORT TABLESPACE

connection default;
--echo # Wait until ALTER TABLE is blocked since it tries to acquire X lock.
let $wait_condition=
  SELECT COUNT(*) = 1 FROM information_schema.processlist
  WHERE state = "Waiting for table metadata lock" AND
        info = "ALTER TABLE t1 IMPORT TABLESPACE";
--source include/wait_condition.inc

connection con1;
--echo # Unblock ALTER TABLE IMPORT
HANDLER t1 CLOSE;

connection con2;
--echo # Reaping ALTER TABLE IMPORT
--echo # It should fail as no tablespace was copied after DISCARD.
--error ER_TABLESPACE_MISSING
--reap

UNLOCK TABLES;

connection default;
DROP TABLE t1;

--echo #
--echo # 4) Under LOCK TABLES, ALTER TABLE ... IMPORT/DISCARD TABLESPACE on
--echo #    temporary table should not try to acquire X metadata lock on base
--echo #    table.
--echo #

CREATE TABLE t1 (i INT) ENGINE=InnoDB;

connection con1;
--echo # Acquire S lock on table 't1'.
HANDLER t1 OPEN;

connection con2;
CREATE TEMPORARY TABLE t1 (j INT) ENGINE=InnoDB;
LOCK TABLES t1 WRITE;

--echo # Both DISCARD and IMPORT on temporary table should fail without
--echo # acquiring any locks and blocking.
--error ER_CANNOT_DISCARD_TEMPORARY_TABLE
ALTER TABLE t1 DISCARD TABLESPACE;
--error ER_CANNOT_DISCARD_TEMPORARY_TABLE
ALTER TABLE t1 IMPORT TABLESPACE;

UNLOCK TABLES;
DROP TEMPORARY TABLE t1;

connection con1;
HANDLER t1 CLOSE;

--echo #
--echo # Clean-up.
--echo #
disconnect con1;
--source include/wait_until_disconnected.inc
disconnect con2;
--source include/wait_until_disconnected.inc
connection default;
--disable_connect_log
DROP TABLE t1;
SET sql_mode = default;


--echo #
--echo # BUG 19779365: INDEX COMMENT IN ADD INDEX IS IGNORED.
--echo #

--echo # After the patch, the alter table reflects the new
--echo # index comment or the lack of comment for the indexes.
CREATE TABLE t1(fld1 int, key key1(fld1));
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'test';
SHOW INDEX FROM t1;
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'test');
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1);
SHOW INDEX FROM t1;
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'test');
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'success';
SHOW INDEX FROM t1;
DROP TABLE t1;

# Alter the comment, but keep the same comment length
CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'old comment');
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'new comment';
SHOW INDEX FROM t1;
DROP TABLE t1; 


--echo #
--echo # Bug#19635706
--echo # Verify that it is possible to add a unique key to a not-NULL POINT 
--echo # column and that this key is promoted to primary key
--echo # 

CREATE TABLE t1(a INT NOT NULL, b POINT NOT NULL) ENGINE=INNODB;
SHOW CREATE TABLE t1;
ALTER TABLE t1 ADD UNIQUE INDEX (b);

--echo # Note that SHOW CREATE TABLE does not list b as a primary key, 
--echo # even though it was promoted. This appears to be the case also 
--echo # for other column types.
SHOW CREATE TABLE t1;

ALTER TABLE t1 ADD UNIQUE INDEX (a);
SHOW CREATE TABLE t1;

--echo # Verify that the expected indices have been created by Innodb
SELECT T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME, 
       CASE I.TYPE 
            WHEN 0 THEN 'Secondary' 
            WHEN 1 THEN 'Clustered' 
            WHEN 2 THEN 'Unique' 
            WHEN 3 THEN 'Primary' 
            WHEN 32 THEN 'Full text' 
            WHEN 64 THEN 'Spatial' 
            ELSE 'Unknown' 
       END AS INDEX_TYPE, 
       F.NAME AS FIELD_NAME, F.POS AS FIELD_POS FROM 
              INFORMATION_SCHEMA.INNODB_SYS_TABLES AS T JOIN 
              INFORMATION_SCHEMA.INNODB_SYS_INDEXES AS I JOIN 
              INFORMATION_SCHEMA.INNODB_SYS_FIELDS AS F 
              ON I.INDEX_ID = F.INDEX_ID AND I.TABLE_ID = T.TABLE_ID 
       WHERE T.NAME = 'test/t1';

DROP TABLE t1;


--echo #
--echo # BUG#16886196 - ALTER TABLE FAILS TO CONVERT TO PREFIX INDEX IN
--echo #                ALTER_COLUMN_EQUAL_PACK_LENGTH


SET @orig_sql_mode = @@sql_mode;
SET sql_mode= '';

--echo # Test with '767' as index size limit.
SET GLOBAL innodb_large_prefix=OFF;
CREATE TABLE t1(fld1 VARCHAR(767), KEY a(fld1)) ENGINE= INNODB;
INSERT INTO t1 VALUES('a');
ALTER TABLE t1 CHANGE fld1 fld1 VARCHAR(768), ALGORITHM= INPLACE;

--echo # Without patch, the below statement will assert in a debug build.
SELECT COUNT(*) FROM t1 WHERE fld1= 'a';

--echo # Cleanup.
DROP TABLE t1;
SET GLOBAL innodb_large_prefix=default;

--echo # Test with innodb large prefix indexes(Upto 3072).

CREATE TABLE t1(fld1 VARCHAR(3072), KEY a(fld1)) ENGINE= INNODB
ROW_FORMAT= DYNAMIC;
INSERT INTO t1 VALUES('a');
ALTER TABLE t1 CHANGE fld1 fld1 VARCHAR(3073), ALGORITHM= INPLACE;

--echo # Without patch, the below statement will assert in a debug build.
SELECT COUNT(*) FROM t1 WHERE fld1= 'a';

--echo # Cleanup.
DROP TABLE t1;
SET sql_mode= @orig_sql_mode;

--echo # BUG#17246318 - ALTER TABLE SHOULD NOT ALLOW CREATION OF TABLES
--echo #                WITH BOTH 5.5 AND 5.6 TEMPORALS
--echo #

--echo # BUG 18985760 -"FAST" ALTER TABLE CHANGE ON ENUM COLUMN 
--echo #                TRIGGERS FULL TABLE REBUILD.
--echo # Test for the case where 'avoid_temporal_upgrade' is set
--echo # to the DEFAULT value(OFF).

let $MYSQLD_DATADIR= `select @@datadir`;
--copy_file std_data/55_temporal.frm $MYSQLD_DATADIR/test/t1.frm
--copy_file std_data/55_temporal.MYD $MYSQLD_DATADIR/test/t1.MYD
--copy_file std_data/55_temporal.MYI $MYSQLD_DATADIR/test/t1.MYI

ALTER TABLE t1 ENGINE= INNODB;

--echo #ALTER operations using INPLACE algorithm is disallowed
--echo #since the table contains old temporal type.

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111',
ALGORITHM= INPLACE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 ADD COLUMN fld4 TIMESTAMP FIRST, ALGORITHM= INPLACE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= INPLACE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 CHANGE COLUMN f_time fld4 TIMESTAMP, ALGORITHM= INPLACE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 MODIFY f_datetime TIME, ALGORITHM= INPLACE;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 ADD INDEX index1(f_datetime), ALGORITHM= INPLACE;

--echo #ALTER operations using COPY algorithm is allowed
--echo #when the table contains old temporal type.

--echo #Note: Timestamp encoding remains the same for the non-fractional part
--echo #even in the 5.6 format. Hence there is no change in the display before
--echo #and after upgrade.

--echo #ADD COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD COLUMN FIRST upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP FIRST, ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD COLUMN AFTER upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #CHANGE COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 CHANGE COLUMN f_timestamp fld4 TIMESTAMP, ALGORITHM= COPY;
SELECT f_time, f_datetime, fld4, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(fld4)) FROM t2;
DROP TABLE t2;

--echo #MODIFY COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 MODIFY f_timestamp TIME, ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD INDEX upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD INDEX index1(f_timestamp), ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ALTER operations using DEFAULT algorithm is allowed
--echo #when the table contains old temporal type.

--echo #ADD COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD COLUMN FIRST upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP FIRST, ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD COLUMN AFTER upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #CHANGE COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 CHANGE COLUMN f_timestamp fld4 DATETIME, ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, fld4, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(fld4)) FROM t2;
DROP TABLE t2;

--echo #MODIFY COLUMN upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 MODIFY f_timestamp TIME, ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ADD INDEX upgrades the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD INDEX index1(f_timestamp), ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ALTER TABLE FORCE upgrades the old temporal types.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
              HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 FORCE;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
              HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #Examples where the NOT NULL/NULL FLAG and DEFAULT values are retained
--echo #after upgrade.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

--echo #Before upgrade.
SHOW CREATE TABLE t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= COPY;
--echo #After upgrade.
SHOW CREATE TABLE t2;

--echo #Examples of the Alter operation which does not upgrade
--echo #the temporal formats. 

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t1;

ALTER TABLE t1 DROP COLUMN f_timestamp;
SELECT f_time, f_datetime, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)) FROM t1;

RENAME TABLE t1 to t3;
SELECT f_time, f_datetime, HEX(WEIGHT_STRING(f_time)),
              HEX(WEIGHT_STRING(f_datetime)) FROM t3;

--echo #Once the old temporal type is upgraded to new temporal type,
--echo #ADD/CHANGE COLUMN, ADD INDEX operations succeed using INPLACE
--echo #ALGORITHM.

ALTER TABLE t2 ADD COLUMN fld5 INT, ALGORITHM= INPLACE;

ALTER TABLE t2 ADD INDEX index2(fld5), ALGORITHM= INPLACE;

ALTER TABLE t2 CHANGE fld5 fld6 INT, ALGORITHM= INPLACE;

ALTER TABLE t2 MODIFY fld6 INT, ALGORITHM= INPLACE;

--echo #Cleanup
DROP TABLE t2, t3;


--echo #
--echo # BUG 18985760 -"FAST" ALTER TABLE CHANGE ON ENUM COLUMN 
--echo #                TRIGGERS FULL TABLE REBUILD.
--echo #   


let $MYSQLD_DATADIR= `select @@datadir`;
--copy_file std_data/55_temporal.frm $MYSQLD_DATADIR/test/t1.frm
--copy_file std_data/55_temporal.MYD $MYSQLD_DATADIR/test/t1.MYD
--copy_file std_data/55_temporal.MYI $MYSQLD_DATADIR/test/t1.MYI

--echo # To support INPLACE ALTER table operations later in the test.
ALTER TABLE t1 ENGINE= INNODB;

--echo #Test cases with the global variable 'avoid_temporal_upgrade'
--echo #enabled.

SET @save_avoid_temporal_upgrade= @@global.avoid_temporal_upgrade;
SET GLOBAL avoid_temporal_upgrade= ON;

--echo #ALTER operations using INPLACE algorithm are allowed
--echo #when the table contains old temporal type since
--echo #the global variable 'avoid_temporal_upgrade' is
--echo #enabled. The old temporal types are not upgraded. 

CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= INPLACE;
SELECT f_time, f_datetime, f_timestamp, fld4, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)),
       HEX(WEIGHT_STRING(fld4)) FROM t2;

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld5 TIME DEFAULT '101010' FIRST, ALGORITHM= INPLACE;
SELECT f_time, f_datetime, f_timestamp, fld5, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)),
       HEX(WEIGHT_STRING(fld5)) FROM t2;

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld6 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= INPLACE;
SELECT f_time, f_datetime, f_timestamp, fld6, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)),
       HEX(WEIGHT_STRING(fld6)) FROM t2;

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD INDEX index1(f_datetime), ALGORITHM= INPLACE;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ALTER operations using COPY algorithm are allowed
--echo #when the table contains old temporal type and 
--echo #does not upgrade the old temporal types.

--echo #ADD COLUMN does not upgrade the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD COLUMN FIRST does not upgrade the old temporal type.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld5 TIMESTAMP FIRST, ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD COLUMN AFTER does not upgrade the old temporal type.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld6 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= COPY;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #CHANGE COLUMN upgrades the old temporal type only for the column which
--echo #is changed.
#Setup table having old temporal type.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 CHANGE COLUMN f_datetime fld7 DATETIME, ALGORITHM= COPY;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
              HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #MODIFY COLUMN upgrades the old temporal type only for the column
--echo #modified.
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 MODIFY f_timestamp DATETIME, ALGORITHM= COPY;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD INDEX does not upgrade the old temporal type.
#Setup table having old temporal type.
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD INDEX index1(f_time), ALGORITHM= COPY;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ALTER operations using DEFAULT algorithm are allowed
--echo #when the table contains old temporal type and does not
--echo #upgrade the old temporal types.

--echo #ADD COLUMN does not upgrade the old temporal type.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld4 TIMESTAMP DEFAULT '201211111', ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD COLUMN FIRST does not upgrade the old temporal type.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld5 TIMESTAMP FIRST, ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD COLUMN AFTER does not upgrade the old temporal type.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD COLUMN fld6 TIMESTAMP DEFAULT '201211111' AFTER f_timestamp,
ALGORITHM= DEFAULT;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #CHANGE COLUMN upgrades the old temporal type only for the column which
--echo #is changed.
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 CHANGE COLUMN f_datetime fld7 DATETIME, ALGORITHM= DEFAULT;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #MODIFY COLUMN upgrades the old temporal type only for the column
--echo #modified.
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 MODIFY f_timestamp DATETIME, ALGORITHM= DEFAULT;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;

--echo #ADD INDEX does not upgrade the old temporal type.
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 ADD INDEX index1(f_time), ALGORITHM= DEFAULT;
SELECT f_time, fld7, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(fld7)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

--echo #ALTER TABLE FORCE does not upgrade the old temporal types.
#Setup table having old temporal type.
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES ('22:22:22','2011-11-21 22:22:22','2011-11-21 22:22:22');

SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
ALTER TABLE t2 FORCE;
SELECT f_time, f_datetime, f_timestamp, HEX(WEIGHT_STRING(f_time)),
       HEX(WEIGHT_STRING(f_datetime)), HEX(WEIGHT_STRING(f_timestamp)) FROM t2;
DROP TABLE t2;

SET @@global.avoid_temporal_upgrade= @save_avoid_temporal_upgrade;

--echo #Test cases with the session variable 'show_old_temporals'
--echo #enabled.

--echo #Setup
CREATE TABLE t2(fld1 time, fld2 datetime, fld3 timestamp);
SET @save_show_old_temporals= @@session.show_old_temporals;
SET SESSION show_old_temporals= ON;

--echo #Displays a comment to indicate that the columns are of 5.5
--echo #binary format
SHOW CREATE TABLE t1;
SELECT COLUMN_TYPE FROM information_schema.columns WHERE table_name='t1';

--echo #Since the temporal types are in new format, no comment is 
--echo #displayed
SHOW CREATE TABLE t2;
SELECT COLUMN_TYPE FROM information_schema.columns WHERE table_name='t2';

--echo #Does not display the comment for table with old temporal types 
--echo #since the session variable 'show_old_temporals' is OFF.
SET SESSION show_old_temporals= OFF;
SHOW CREATE TABLE t1;
SELECT COLUMN_TYPE FROM information_schema.columns WHERE table_name='t1';

--echo #Cleanup
SET @@session.show_old_temporals= @save_show_old_temporals;
DROP TABLE t1, t2;


--echo #
--echo #BUG#20106553: ALTER TABLE WHICH CHANGES INDEX COMMENT IS NOT
--echo #              LONGER INPLACE/FAST OPERATION.

--echo #Without the patch, the ALTER TABLE to change the index
--echo #comment using INPLACE algorithm reports an error.
CREATE TABLE t1(fld1 int, key key1(fld1)) ENGINE= INNODB;
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'test',
ALGORITHM= INPLACE;
SHOW INDEX FROM t1;
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'test') ENGINE= MyISAM;
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1), ALGORITHM=INPLACE;
SHOW INDEX FROM t1;
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'test') ENGINE= INNODB;
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'success',
ALGORITHM= INPLACE;
SHOW INDEX FROM t1;
DROP TABLE t1;

# Alter the comment, but keep the same comment length
CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'old comment') ENGINE=MyISAM;
SHOW INDEX FROM t1;
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT 'new comment',
ALGORITHM= INPLACE;
SHOW INDEX FROM t1;
DROP TABLE t1;

--echo #Test cases with merge threshold specified in the index comment.

CREATE TABLE t1(fld1 int, key key1(fld1)) ENGINE=INNODB;
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT
'MERGE_THRESHOLD=45';
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'MERGE_THRESHOLD=40') 
ENGINE=INNODB;
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1);
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
DROP TABLE t1;

CREATE TABLE t1(fld1 int, key key1(fld1) COMMENT 'MERGE_THRESHOLD=40')
ENGINE=INNODB;
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
ALTER TABLE t1 DROP INDEX key1, ADD INDEX key1(fld1) COMMENT
'MERGE_THRESHOLD=45';
SHOW INDEX FROM t1;
SELECT MERGE_THRESHOLD from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE NAME='key1';
DROP TABLE t1;

--echo #
--echo # Bug#20748660 THD->MDL_CONTEXT.OWNS_EQUAL_OR_STRONGER_LOCK | CREATE_INFO->TABLESPACE
--echo #
--echo # A failing DISCARD/IMPORT TABLESPACE may leave the flag THD::tablespace_op
--echo # in an incorrect state, causing a succeeding statement to fail.
--echo
--echo # Create a tablespace with a table.
CREATE TABLESPACE s ADD DATAFILE 's.ibd' ENGINE InnoDB;
CREATE TABLE t (i int) TABLESPACE s ENGINE InnoDB;

--echo # The following statent will fail because the table is not partitioned.
--echo # Without the fix, the THD::tablespace_op flag will be left set.
--error ER_PARTITION_MGMT_ON_NONPARTITIONED
ALTER TABLE t DISCARD PARTITION p TABLESPACE;

--echo # Without the patch, this statement will inherit the tablespace_op flag
--echo # from the previous statement, causing the statement below to fail due
--echo # to not acquiring the required MDL lock.
ALTER TABLE t TABLESPACE s;

--echo # Drop table and tablespace.
DROP TABLE t;
DROP TABLESPACE s ENGINE InnoDB;


--echo #
--echo # BUG#20106837: ALTER TABLE WHICH DROPS AND ADDS THE SAME FULLTEXT
--echo #               INDEX IS NOT INPLACE/FAST.

CREATE TABLE t1(fld1 varchar(200), FULLTEXT(fld1)) ENGINE=MyISAM;
INSERT INTO t1 VALUES('ABCD');

--enable_info
--echo #Without patch, it was not fast a INPLACE ALTER.
ALTER TABLE t1 DROP INDEX fld1, ADD FULLTEXT INDEX fld1(fld1);
--disable_info

--echo #Without patch, reports an error 'ER_ALTER_OPERATION_NOT_SUPPORTED'.
ALTER TABLE t1 ALGORITHM=INPLACE, DROP INDEX fld1,
ADD FULLTEXT INDEX fld1(fld1);
DROP TABLE t1;

--echo #Test with InnoDB engine.
CREATE TABLE t1(fld1 varchar(200), FULLTEXT(fld1)) ENGINE=INNODB;
INSERT INTO t1 VALUES('ABCD');

--enable_info
--echo #Without patch, it was not fast a INPLACE ALTER.
ALTER TABLE t1 DROP INDEX fld1, ADD FULLTEXT INDEX fld1(fld1);
--disable_info

--echo #Without patch, reports an error 'ER_ALTER_OPERATION_NOT_SUPPORTED'.
ALTER TABLE t1 ALGORITHM=INPLACE, DROP INDEX fld1,
ADD FULLTEXT INDEX fld1(fld1);
DROP TABLE t1;


--echo #
--echo # Bug#20146455: FIND_KEY_CI RETURNS NULL, CAUSES CRASH IN
--echo #               FILL_ALTER_INPLACE_INFO
--echo #

CREATE TABLE t1 (a INT PRIMARY KEY, b INT,
                 FOREIGN KEY (b) REFERENCES t1(a)) ENGINE= MyISAM;
ALTER TABLE t1 RENAME INDEX b TO w, ADD FOREIGN KEY (b) REFERENCES t1(a);
SHOW CREATE TABLE t1;
DROP TABLE t1;

CREATE TABLE t1 (a INT PRIMARY KEY, b INT,
                 FOREIGN KEY (b) REFERENCES t1(a)) ENGINE= InnoDB;
ALTER TABLE t1 RENAME INDEX b TO w, ADD FOREIGN KEY (b) REFERENCES t1(a);
SHOW CREATE TABLE t1;
DROP TABLE t1;


--echo #
--echo # Bug#22017616: ASSERTION FAILED: TABLE_SHARE->IS_MISSING_PRIMARY_KEY()
--echo # == M_PREBUILT->CLUST_IND
--echo #
--echo # Ensure that adding indexes with virtual columns are not promoted to
--echo # primary keys
--echo #
--echo # Base line with normal column - should be promoted
CREATE TABLE t0(a INT NOT NULL) ENGINE=INNODB;
ALTER TABLE t0 ADD UNIQUE INDEX (a);

--echo # Case a: Create table with virtual unique not null column
CREATE TABLE t1(a POINT GENERATED ALWAYS AS (POINT(1,1)) VIRTUAL UNIQUE NOT NULL) ENGINE=INNODB;
SELECT * FROM t1;

--echo # Case b: Create table with index on virtual point column
CREATE TABLE t2(a POINT GENERATED ALWAYS AS (POINT(1,1)) VIRTUAL NOT NULL, UNIQUE INDEX no_pk(a(1))) ENGINE=INNODB;
SELECT * FROM t2;

--echo # Case c: Add unique index on virtual point column
CREATE TABLE t3(a POINT GENERATED ALWAYS AS (POINT(1,1)) VIRTUAL NOT NULL)
ENGINE=INNODB;
ALTER TABLE t3 ADD UNIQUE INDEX (a(1));
SELECT * FROM t3;

--echo # Case d: Add unique index on virtual blob column
CREATE TABLE t4 (a BLOB, b BLOB GENERATED ALWAYS AS (a) VIRTUAL NOT NULL) ENGINE=INNODB;
ALTER TABLE t4 ADD UNIQUE INDEX (b(1));
SELECT * FROM t4;

--echo # Query I_S to verify that 'a' is promoted to pk only when it
--echo # isn't virtual
SELECT T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME,
       CASE (I.TYPE & 3)
            WHEN 3 THEN "yes"
            ELSE "no" END AS IS_PRIMARY_KEY,
       F.NAME AS FIELD_NAME, F.POS AS FIELD_POS FROM
              INFORMATION_SCHEMA.INNODB_SYS_TABLES AS T JOIN
              INFORMATION_SCHEMA.INNODB_SYS_INDEXES AS I JOIN
              INFORMATION_SCHEMA.INNODB_SYS_FIELDS AS F
              ON I.INDEX_ID = F.INDEX_ID AND I.TABLE_ID = T.TABLE_ID
       WHERE T.NAME LIKE 'test/%';


DROP TABLE t0;
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;
DROP TABLE t4;


--echo #
--echo # Bug#21345391: ALTER TABLE ... CONVERT TO CHARACTER SET NOT EFFECT
--echo #               AND REMAIN A TEMP TABLE

CREATE TABLE t1 (fld1 INT PRIMARY KEY) ENGINE = INNODB CHARACTER SET gbk;
ALTER TABLE t1 CONVERT TO CHARACTER SET UTF8, ALGORITHM = INPLACE;

--echo # Without fix, the CHARSET SET for table remains gbk.
SHOW CREATE TABLE t1;

let $test_dir =
    `SELECT CONCAT(variable_value, 'test/') FROM
     INFORMATION_SCHEMA.GLOBAL_VARIABLES
     WHERE LOWER(variable_name) = 'datadir'`;

--echo # Without fix, the temporary .frm file is not cleaned up.
--list_files $test_dir `#sql-*.frm`

DROP TABLE t1;

--echo # Test cases added for coverage.

--echo # Reports an error for tables containing datatypes supporting
--echo # characters.

CREATE TABLE t1 (fld1 CHAR(10) PRIMARY KEY) ENGINE = INNODB CHARACTER SET gbk;

--error ER_ALTER_OPERATION_NOT_SUPPORTED_REASON
ALTER TABLE t1 CONVERT TO CHARACTER SET UTF8, ALGORITHM = INPLACE;

DROP TABLE t1;

--echo # ALTER TABLE, CHARACTER SET operation.

CREATE TABLE t1 (fld1 INT PRIMARY KEY, fld2 CHAR(10)) ENGINE = INNODB
CHARACTER SET gbk;
ALTER TABLE t1 CHARACTER SET UTF8, ALGORITHM = INPLACE;

SHOW CREATE TABLE t1;

let $test_dir =
    `SELECT CONCAT(variable_value, 'test/') FROM
     INFORMATION_SCHEMA.GLOBAL_VARIABLES
     WHERE LOWER(variable_name) = 'datadir'`;

--list_files $test_dir `#sql-*.frm`

DROP TABLE t1;

--echo #
--echo # Bug#22740093: ERROR 1071 (42000): SPECIFIED KEY WAS TOO LONG
--echo #               ERROR WHILE DROPPING INDEX IN 5.7
--echo #

# Before you were allowed to create a prefix key for TEXT columns
# which were larger than the column length. The column length
# for TINYBLOB is 255 bytes, while prefix length is in characters.
--error ER_TOO_LONG_KEY
CREATE TABLE t1(id INT PRIMARY KEY,
                name TINYTEXT,
                KEY nameloc (name(64))
) DEFAULT CHARSET=utf8mb4;

# 63 characters of 4 bytes each fit in 255 bytes.
CREATE TABLE t1(id INT PRIMARY KEY,
                name TINYTEXT,
                KEY nameloc (name(63))
) DEFAULT CHARSET=utf8mb4;

# Check that we can rebuild the table without issue
ALTER TABLE t1 FORCE;

# Also check ALTER TABLE
--error ER_TOO_LONG_KEY
ALTER TABLE t1 ADD INDEX idx (name(64), id);
ALTER TABLE t1 ADD INDEX idx (name(63), id);
DROP TABLE t1;

# Check that we can create a table with a prefix index of
# 64 4-byte characters for a TEXT column.

# 64 characters of 4 bytes each fit in 65535 bytes.
CREATE TABLE t1(id INT PRIMARY KEY,
                name TEXT,
                KEY nameloc (name(64))
) DEFAULT CHARSET=utf8mb4;

# Check ALTER TABLE where we change the type of the
# base column, reducing max field length, keeping the
# length of the prefix key the same.
--error ER_TOO_LONG_KEY
ALTER TABLE t1 MODIFY COLUMN name TINYTEXT;
DROP TABLE t1;


--echo #
--echo # BUG#16888677: OUT OF RANGE VALUE ACCEPTED FOR DATETIME COLUMN IN
--echo #               ALTER TABLE...ADD COLUMN

SET @saved_sql_mode = @@session.sql_mode;

--echo # Test case with no SQL_MODE enabled.
SET SESSION sql_mode= '';
CREATE TABLE t1(fld1 DATE NOT NULL) ENGINE= INNODB;
INSERT INTO t1 VALUES('2000-01-01');

--echo # No warnings or error is reported
ALTER TABLE t1 ADD COLUMN fld2 DATETIME NOT NULL, ALGORITHM=INPLACE;
ALTER TABLE t1 ADD COLUMN fld3 DATETIME NOT NULL, ALGORITHM=COPY;

DROP TABLE t1;

--echo # Test case with strict mode enabled.

SET SESSION sql_mode= 'STRICT_ALL_TABLES';
CREATE TABLE t1(fld1 DATE NOT NULL) ENGINE= INNODB;
INSERT INTO t1 VALUES('2000-01-01');

--echo # No warnings or error is reported
ALTER TABLE t1 ADD COLUMN fld2 DATETIME NOT NULL, ALGORITHM=INPLACE;
ALTER TABLE t1 ADD COLUMN fld3 DATETIME NOT NULL, ALGORITHM=COPY;

DROP TABLE t1;

--echo # Test case with 'NO_ZERO_DATE' enabled.

SET SESSION sql_mode= 'NO_ZERO_DATE';
CREATE TABLE t1(fld1 DATE NOT NULL) ENGINE= INNODB;
INSERT INTO t1 VALUES('2000-01-01');

--echo # Warnings are reported after patch.
ALTER TABLE t1 ADD COLUMN fld2 DATETIME NOT NULL, ALGORITHM=INPLACE;
ALTER TABLE t1 ADD COLUMN fld3 DATETIME NOT NULL, ALGORITHM=COPY;

DROP TABLE t1;

--echo # Test case with both 'NO_ZERO_DATE and strict mode' enabled.

SET SESSION sql_mode= @saved_sql_mode;

CREATE TABLE t1(fld1 DATE NOT NULL) ENGINE= INNODB;
INSERT INTO t1 VALUES('2000-01-01');

--echo # Without patch, the following statement succeeds.
--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t1 ADD COLUMN fld2 DATETIME NOT NULL, ALGORITHM=INPLACE;
--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t1 ADD COLUMN fld2 DATETIME NOT NULL, ALGORITHM=COPY;

TRUNCATE TABLE t1;
--echo # Operation below succeeds, since the table has no records.
ALTER TABLE t1 ADD COLUMN fld4 DATETIME NOT NULL, ALGORITHM=INPLACE;
DROP TABLE t1;


--echo #
--echo # BUG#25385334: MYSQL 5.7 ERROR WITH ALTER TABLE MODIFY SYNTAX
--echo #               AND DATETIME TYPE.

SET @saved_sql_mode = @@session.sql_mode;

--echo # Test case with both strict mode and 'NO_ZERO_DATE' enabled.
CREATE TABLE t1 (fld1 INT, fld2 DATETIME NOT NULL) ENGINE= INNODB;
CREATE TABLE t2 (fld1 INT, fld2 POINT NOT NULL) ENGINE= INNODB;

INSERT INTO t1 VALUES(1, '2000-01-01');
INSERT INTO t2 values(1,  ST_PointFromText('POINT(10 10)'));

--echo # Without patch, the following statments report error.
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1;

--echo # Without patch, the following statments report error.
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL FIRST, ALGORITHM= COPY;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL FIRST, ALGORITHM= COPY;

--echo # Tests added for coverage.
--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1,
               ADD COLUMN fld3 DATETIME NOT NULL;
--error ER_INVALID_USE_OF_NULL
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1,
               ADD COLUMN fld3 MULTIPOINT NOT NULL;

--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1,
               ADD COLUMN fld3 DATETIME NOT NULL, ALGORITHM= COPY;
--error ER_INVALID_USE_OF_NULL
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1,
               ADD COLUMN fld3 MULTIPOINT NOT NULL, ALGORITHM= COPY;

TRUNCATE TABLE t1;
TRUNCATE TABLE t2;

--echo # Without patch, the following statments report error.
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1;

--echo # Without patch, the following statments report error.
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL FIRST, ALGORITHM= COPY;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL FIRST, ALGORITHM= COPY;

--echo # Tests added for coverage.
ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1,
               ADD COLUMN fld3 DATETIME NOT NULL;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1,
               ADD COLUMN fld3 MULTIPOINT NOT NULL;

ALTER TABLE t1 MODIFY fld2 DATETIME NOT NULL AFTER fld1,
               ADD COLUMN fld4 DATETIME NOT NULL, ALGORITHM= COPY;
ALTER TABLE t2 MODIFY fld2 POINT NOT NULL AFTER fld1,
               ADD COLUMN fld4 MULTIPOINT NOT NULL, ALGORITHM= COPY;

DROP TABLE t1, t2;

--echo # Test case when a non date column is converted to datetime column.

--echo # Test case without any sql mode enabled.
SET SESSION sql_mode= '';
CREATE TABLE t1 (fld1 char(25)) ENGINE= INNODB;
INSERT INTO t1 VALUES('0000-00-00');

--echo # No error or warning is reported.
ALTER TABLE t1 MODIFY fld1 DATETIME NOT NULL;

DROP TABLE t1;

--echo # Test case with only 'NO_ZERO_DATE' enabled.
SET SESSION sql_mode= 'NO_ZERO_DATE';
CREATE TABLE t1 (fld1 char(25)) ENGINE= INNODB;
INSERT INTO t1 VALUES('0000-00-00');

--echo # Reports only a warning.
ALTER TABLE t1 MODIFY fld1 DATETIME NOT NULL;

DROP TABLE t1;

SET SESSION sql_mode= 'STRICT_ALL_TABLES';
CREATE TABLE t1 (fld1 char(25)) ENGINE= INNODB;
INSERT INTO t1 VALUES('0000-00-00');

--echo # No error or warning is reported.
ALTER TABLE t1 MODIFY fld1 DATETIME NOT NULL;

DROP TABLE t1;

--echo # Test case with both STRICT MODE and 'NO_ZERO_DATE' enabled.
SET SESSION sql_mode= @saved_sql_mode;
CREATE TABLE t1 (fld1 char(25)) ENGINE= INNODB;
INSERT INTO t1 VALUES('0000-00-00');

--echo # Reports an error.
--error ER_TRUNCATED_WRONG_VALUE
ALTER TABLE t1 MODIFY fld1 DATETIME NOT NULL;

DROP TABLE t1;

--echo # Test case when a NULL column is converted to NOT NULL column
CREATE TABLE t1 (fld0 DATETIME, fld1 INT, fld2 DATETIME NOT NULL) ENGINE= INNODB;
CREATE TABLE t2 (fld0 POINT, fld1 INT, fld2 POINT NOT NULL) ENGINE= INNODB;
INSERT INTO t1 VALUES('2000-01-01', 1, '2000-01-01');
INSERT INTO t2 values(ST_PointFromText('POINT(10 10)'), 1,
                      ST_PointFromText('POINT(10 10)'));

--echo # Reports an error without patch.
ALTER TABLE t1 MODIFY fld0 DATETIME NOT NULL AFTER fld2;

--echo # Reports an error without patch
ALTER TABLE t2 MODIFY fld0 POINT NOT NULL AFTER fld2;

DROP TABLE t1, t2;

--echo # Test case demonstrating the NULL constraint check done by SE.
CREATE TABLE t1 (fld0 DATETIME, fld1 INT, fld2 DATETIME NOT NULL) ENGINE= INNODB;
CREATE TABLE t2 (fld0 POINT, fld1 INT, fld2 POINT NOT NULL) ENGINE= INNODB;

INSERT INTO t1 VALUES(NULL, 1, '2000-01-01');
INSERT INTO t2 values(NULL, 1, ST_PointFromText('POINT(10 10)'));

--error ER_INVALID_USE_OF_NULL
ALTER TABLE t1 MODIFY fld0 DATETIME NOT NULL;

--error ER_INVALID_USE_OF_NULL
ALTER TABLE t2 MODIFY fld0 POINT NOT NULL;

DROP TABLE t1, t2;


--echo #
--echo # BUG#26848813: INDEXED COLUMN CAN'T BE CHANGED FROM VARCHAR(15)
--echo #               TO VARCHAR(40) INSTANTANEOUSLY

SET @orig_sql_mode= @@sql_mode;
SET @orig_innodb_large_prefix= @@global.innodb_large_prefix;

SET GLOBAL innodb_large_prefix= ON;

--echo # Tests where an error is reported under strict mode when the index
--echo # limit exceeds the maximum supported length by SE.

--error ER_TOO_LONG_KEY
CREATE TABLE t1 (fld1 VARCHAR(768), KEY(fld1)) CHARSET latin1 ENGINE =InnoDB
ROW_FORMAT= COMPACT;

--error ER_TOO_LONG_KEY
CREATE TABLE t2 (fld1 VARCHAR(3073), KEY(fld1)) CHARSET latin1 ENGINE= InnoDB;

--echo # Test with innodb prefix indexes where the index limit is 767 bytes
CREATE TABLE t1 (fld1 VARCHAR(767), KEY(fld1)) CHARSET latin1 ENGINE=INNODB
ROW_FORMAT=COMPACT;

--error ER_TOO_LONG_KEY
ALTER TABLE t1 MODIFY fld1 VARCHAR(768), ALGORITHM= INPLACE;

--error ER_TOO_LONG_KEY
ALTER TABLE t1 MODIFY fld1 VARCHAR(768), ALGORITHM= COPY;

--echo # Test with innodb prefix indexes where the index limit is 3072 bytes
CREATE TABLE t2 (fld1 VARCHAR(3072), KEY(fld1)) CHARSET latin1 ENGINE=INNODB
ROW_FORMAT=DYNAMIC;

--error ER_TOO_LONG_KEY
ALTER TABLE t2 MODIFY fld1 VARCHAR(3073), ALGORITHM= INPLACE;

--error ER_TOO_LONG_KEY
ALTER TABLE t2 MODIFY fld1 VARCHAR(3073), ALGORITHM= COPY;

--echo # Tests with innodb_large_prefix disabled and strict mode.
SET GLOBAL innodb_large_prefix= OFF;
--error ER_TOO_LONG_KEY
CREATE TABLE t3 (fld1 VARCHAR(3072), KEY(fld1)) CHARSET latin1 ENGINE= InnoDB;

DROP TABLE t1, t2;

SET sql_mode= '';
SET GLOBAL innodb_large_prefix= ON;

--enable_warnings

--echo # Test where the indexes are truncated to fit the index limit and
--echo # a warning is reported under non-strict mode when the index exceeds
--echo # the SE limit.
CREATE TABLE t1 (fld1 VARCHAR(768), KEY(fld1)) ENGINE= InnoDB
ROW_FORMAT=COMPACT;
CREATE TABLE t2 (fld1 VARCHAR(3073), KEY(fld1)) ENGINE= InnoDB;

--echo # Test with innodb prefix indexes where the index limit is 767 bytes.
CREATE TABLE t3 (fld1 VARCHAR(767), KEY(fld1))ENGINE=INNODB ROW_FORMAT=COMPACT;

ALTER TABLE t3 MODIFY fld1 VARCHAR(768), ALGORITHM= INPLACE;

ALTER TABLE t3 MODIFY fld1 VARCHAR(800), ALGORITHM= COPY;

--echo # Test with innodb prefix indexes where the index limit is 3072 bytes.
CREATE TABLE t4 (fld1 VARCHAR(3072), KEY(fld1))ENGINE=INNODB
ROW_FORMAT=DYNAMIC;

ALTER TABLE t4 MODIFY fld1 VARCHAR(3073), ALGORITHM= INPLACE;

ALTER TABLE t4 MODIFY fld1 VARCHAR(3074), ALGORITHM= COPY;

--echo # For unique and primary keys, an error is reported even in non-strict
--echo # mode.

--error ER_TOO_LONG_KEY
CREATE TABLE t5(fld1 VARCHAR(768) PRIMARY KEY) ENGINE= InnoDB
ROW_FORMAT=COMPACT;

--error ER_TOO_LONG_KEY
CREATE TABLE t5(fld1 VARCHAR(3073), UNIQUE KEY(fld1)) ENGINE= InnoDB;

--echo # Tests with innodb_large_prefix disabled and strict mode.
SET GLOBAL innodb_large_prefix= OFF;
CREATE TABLE t5 (fld1 VARCHAR(3072), KEY(fld1)) CHARSET latin1 ENGINE= InnoDB;

--disable_warnings
DROP TABLE t1, t2, t3, t4, t5;

SET sql_mode= @orig_sql_mode;
SET GLOBAL innodb_large_prefix= ON;

--echo # Tests added for coverage.
CREATE TABLE t1(fld1 VARCHAR(3), KEY(fld1)) ENGINE=MYISAM;

--echo # Conversion of unpacked keys to packed keys reports
--echo # error for INPLACE Alter.
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 MODIFY fld1 VARCHAR(10), ALGORITHM=INPLACE;

--echo # Succeeds with index rebuild.
ALTER TABLE t1 MODIFY fld1 VARCHAR(10), ALGORITHM=COPY;

--echo # Succeeds since the row format is dynamic.
CREATE TABLE t2(fld1 VARCHAR(768), KEY(fld1)) ENGINE= InnoDB ROW_FORMAT= DYNAMIC;

--echo # An error is reported when the index exceeds the column size
--echo # in both strict and non-strict mode.
--error ER_WRONG_SUB_KEY
ALTER TABLE t2 ADD INDEX idx1(fld1(769));

SET sql_mode= '';

--error ER_WRONG_SUB_KEY
ALTER TABLE t2 ADD INDEX idx1(fld1(769));

--echo # Cleanup.
DROP TABLE t1, t2;
SET sql_mode= @orig_sql_mode;
SET GLOBAL innodb_large_prefix= @orig_innodb_large_prefix;

--echo #
--echo # BUG#27788685: NO WARNING WHEN TRUNCATING A STRING WITH DATA LOSS
--echo #

--enable_warnings
SET GLOBAL max_allowed_packet=17825792;

--connect(con1, localhost, root,,)
CREATE TABLE t1 (t1_fld1 TEXT) ENGINE=InnoDB;
CREATE TABLE t2 (t2_fld1 MEDIUMTEXT) ENGINE=InnoDB;
CREATE TABLE t3 (t3_fld1 LONGTEXT) ENGINE=InnoDB;

INSERT INTO t1 VALUES (REPEAT('a',300));
INSERT INTO t2 VALUES (REPEAT('b',65680));
INSERT INTO t3 VALUES (REPEAT('c',16777300));

SELECT LENGTH(t1_fld1) FROM t1;
SELECT LENGTH(t2_fld1) FROM t2;
SELECT LENGTH(t3_fld1) FROM t3;

--echo # With strict mode
SET SQL_MODE='STRICT_ALL_TABLES';

--error ER_DATA_TOO_LONG
ALTER TABLE t1 CHANGE `t1_fld1` `my_t1_fld1` TINYTEXT;
--error ER_DATA_TOO_LONG
ALTER TABLE t2 CHANGE `t2_fld1` `my_t2_fld1` TEXT;
--error ER_DATA_TOO_LONG
ALTER TABLE t3 CHANGE `t3_fld1` `my_t3_fld1` MEDIUMTEXT;

--echo # With non-strict mode
SET SQL_MODE='';

ALTER TABLE t1 CHANGE `t1_fld1` `my_t1_fld1` TINYTEXT;
ALTER TABLE t2 CHANGE `t2_fld1` `my_t2_fld1` TEXT;
ALTER TABLE t3 CHANGE `t3_fld1` `my_t3_fld1` MEDIUMTEXT;

SELECT LENGTH(my_t1_fld1) FROM t1;
SELECT LENGTH(my_t2_fld1) FROM t2;
SELECT LENGTH(my_t3_fld1) FROM t3;

# Cleanup
--disconnect con1
--source include/wait_until_disconnected.inc

--connection default
DROP TABLE t1, t2, t3;

SET SQL_MODE=default;
SET GLOBAL max_allowed_packet=default;
