-- source include/have_log_bin.inc

# This test should work in embedded server after mysqltest is fixed
-- source include/not_embedded.inc

# This test uses chmod, can't be run with root permissions
-- source include/not_as_root.inc

# Save the initial number of concurrent sessions
--source include/count_sessions.inc

# ============================================================================
#
# Test of mysqltest itself
#
# There are three rules that determines what belong to each command
# 1. A normal command is delimited by the <delimiter> which by default is
#    set to ';'
#
#   ex: | select *
#       |   from t1;
#       |
#   Command: "select * from t1"
#
# 2. Special case is a line that starts with "--", this is a comment
#    ended when the new line character is reached. But the first word
#    in the comment may contain a valid command, which then will be
#    executed. This can be useful when sending commands that
#    contains <delimiter>
#
# 3. Special case is also a line that starts with '#' which is treated
#     as a comment and will be ended by new line character
#
# ============================================================================

# ----------------------------------------------------------------------------
# $mysql_errno contains the return code of the last command
# sent to the server.
# ----------------------------------------------------------------------------
# get $mysql_errno before the first statement
#     $mysql_errno should be -1
eval select $mysql_errno as "before_use_test" ;


# ----------------------------------------------------------------------------
# Positive case(statement)
# ----------------------------------------------------------------------------

select otto from (select 1 as otto) as t1;
# expectation = response
--error 0
select otto from (select 1 as otto) as t1;

# ----------------------------------------------------------------------------
# Negative case(statement):
# The derived table t1 does not contain a column named 'friedrich' .
# --> ERROR 42S22: Unknown column 'friedrich' in 'field list and
# --> 1054: Unknown column 'friedrich' in 'field list'
# ----------------------------------------------------------------------------

# expectation <> response
#--error 0
#select friedrich from (select 1 as otto) as t1
--error 1
--exec echo "select friedrich from (select 1 as otto) as t1;" | $MYSQL_TEST  2>&1

# expectation = response
--error ER_BAD_FIELD_ERROR

select friedrich from (select 1 as otto) as t1;

# The following unmasked unsuccessful statement must give
# 1. mysqltest gives a 'failed'
# 2. does not produce a r/<test case>.reject file !!!
# PLEASE uncomment it and check its effect
#select friedrich from (select 1 as otto) as t1;


# ----------------------------------------------------------------------------
# Tests for the new feature - SQLSTATE error code matching
# Positive case(statement)
# ----------------------------------------------------------------------------

# This syntax not allowed anymore, use --error S00000, see below
# expectation = response
#!S00000 select otto from (select 1 as otto) as t1;

--error S00000
select otto from (select 1 as otto) as t1;

# expectation <> response
#!S42S22 select otto from (select 1 as otto) as t1;
#--error S42S22
#select otto from (select 1 as otto) as t1;
--error 1
--exec echo "error S42S22; select otto from (select 1 as otto) as t1;" | $MYSQL_TEST  2>&1

# expecting a SQL-state for a command that can't give one should fail
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "error S00000; remove_file $MYSQLTEST_VARDIR/tmp/test_nonexistent.tmp;" | $MYSQL_TEST  2>&1


# ----------------------------------------------------------------------------
# Negative case(statement)
# ----------------------------------------------------------------------------

# This syntax not allowed anymore, use --error S42S22, see below
# expectation = response
#!S42S22 select friedrich from (select 1 as otto) as t1;
--error S42S22
select friedrich from (select 1 as otto) as t1;

# expectation !=response
#!S00000 select friedrich from (select 1 as otto) as t1;
#--error S00000
#select friedrich from (select 1 as otto) as t1;
--error 1
--exec echo "error S00000; select friedrich from (select 1 as otto) as t1;" | $MYSQL_TEST  2>&1

# ----------------------------------------------------------------------------
# test cases for $mysql_errno
#
# $mysql_errno is a builtin variable of mysqltest and contains the return code
# of the last command sent to the server.
#
#      The following test cases often initialize $mysql_errno to 1064 by
#      a command with wrong syntax.
#      Example: --error 1064      To prevent the abort after the error.
#               garbage ;
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# check mysql_errno = 0 after successful statement
# ----------------------------------------------------------------------------
select otto from (select 1 as otto) as t1;
eval select $mysql_errno as "after_successful_stmt_errno" ;

#----------------------------------------------------------------------------
# check mysql_errno = 1064 after statement with wrong syntax
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
eval select $mysql_errno as "after_wrong_syntax_errno" ;

# ----------------------------------------------------------------------------
# check if let $my_var= 'abc' ; affects $mysql_errno
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
let $my_var= 'abc' ;
eval select $mysql_errno as "after_let_var_equal_value" ;

# ----------------------------------------------------------------------------
# check if set @my_var= 'abc' ; affects $mysql_errno
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
set @my_var= 'abc' ;
eval select $mysql_errno as "after_set_var_equal_value" ;

# ----------------------------------------------------------------------------
#  check if the setting of --disable-warnings itself affects $mysql_errno
#  (May be --<whatever> modifies $mysql_errno.)
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
--disable_warnings
eval select $mysql_errno as "after_disable_warnings_command" ;

# ----------------------------------------------------------------------------
# check if --disable-warnings + command with warning affects the errno
# stored within $mysql_errno
# (May be disabled warnings affect $mysql_errno.)
# ----------------------------------------------------------------------------
drop table if exists t1 ;
--error ER_PARSE_ERROR

garbage ;
drop table if exists t1 ;
eval select $mysql_errno as "after_disable_warnings" ;
--enable_warnings

# ----------------------------------------------------------------------------
# check if masked errors affect $mysql_errno
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
--error ER_NO_SUCH_TABLE

select 3 from t1 ;
eval select $mysql_errno as "after_minus_masked" ;
--error ER_PARSE_ERROR

garbage ;
--error ER_NO_SUCH_TABLE

select 3 from t1 ;
eval select $mysql_errno as "after_!_masked" ;

# ----------------------------------------------------------------------------
# Will manipulations of $mysql_errno be possible and visible ?
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
let $mysql_errno= -1;
eval select $mysql_errno as "after_let_errno_equal_value" ;

# ----------------------------------------------------------------------------
# How affect actions on prepared statements $mysql_errno ?
# ----------------------------------------------------------------------------
# failing prepare
--error ER_PARSE_ERROR

garbage ;
--error ER_NO_SUCH_TABLE

prepare stmt from "select 3 from t1" ;
eval select $mysql_errno as "after_failing_prepare" ;
create table t1 ( f1 char(10));

# successful prepare
--error ER_PARSE_ERROR

garbage ;
prepare stmt from "select 3 from t1" ;
eval select $mysql_errno as "after_successful_prepare" ;

# successful execute
--error ER_PARSE_ERROR

garbage ;
execute stmt;
eval select $mysql_errno as "after_successful_execute" ;

# failing execute (table has been dropped)
drop table t1;
--error ER_PARSE_ERROR

garbage ;
--error ER_NO_SUCH_TABLE

execute stmt;
eval select $mysql_errno as "after_failing_execute" ;

# failing execute (unknown statement)
--error ER_PARSE_ERROR

garbage ;
--error ER_UNKNOWN_STMT_HANDLER

execute __stmt_;
eval select $mysql_errno as "after_failing_execute" ;

# successful deallocate
--error ER_PARSE_ERROR

garbage ;
deallocate prepare stmt;
eval select $mysql_errno as "after_successful_deallocate" ;

# failing deallocate ( statement handle does not exist )
--error ER_PARSE_ERROR

garbage ;
--error ER_UNKNOWN_STMT_HANDLER

deallocate prepare __stmt_;
eval select $mysql_errno as "after_failing_deallocate" ;


# ----------------------------------------------------------------------------
# test cases for "--disable_abort_on_error"
#
# "--disable_abort_on_error" switches off the abort of mysqltest
# after "unmasked" failing statements.
#
# The default is "--enable_abort_on_error".
#
# "Maskings" are
#   --error <error number>  and  --error <error number>
# in the line before the failing statement.
#
# There are some additional test cases for $mysql_errno
# because "--disable_abort_on_error" enables a new situation.
# Example: "unmasked" statement fails + analysis of $mysql_errno
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Switch off the abort on error and check the effect on $mysql_errno
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
--disable_abort_on_error
eval select $mysql_errno as "after_--disable_abort_on_error" ;

# ----------------------------------------------------------------------------
# "unmasked" failing statement should not cause an abort
# ----------------------------------------------------------------------------
select 3 from t1 ;

# ----------------------------------------------------------------------------
# masked failing statements
# ----------------------------------------------------------------------------
# expected error = response
--error ER_NO_SUCH_TABLE

select 3 from t1 ;
--error ER_NO_SUCH_TABLE

select 3 from t1 ;
eval select $mysql_errno as "after_!errno_masked_error" ;
# expected error <> response
# --error 1000
# select 3 from t1 ;
# --error 1000
# select 3 from t1 ;
--error 1
--exec echo "disable_abort_on_error; error 1000; select 3 from t1; error 1000; select 3 from t1;" | $MYSQL_TEST  2>&1

# ----------------------------------------------------------------------------
# Check some non-query statements that would fail
# ----------------------------------------------------------------------------
--exec illegal_command
--cat_file does_not_exist
--perl
  exit(2);
EOF

# ----------------------------------------------------------------------------
# Check backtick and query_get_value, result should be empty
# ----------------------------------------------------------------------------
let $empty= `garbage`;
echo $empty is empty;
let $empty= query_get_value(nonsense, blabla, 1);
echo $empty is empty;

# ----------------------------------------------------------------------------
# Switch the abort on error on and check the effect on $mysql_errno
# ----------------------------------------------------------------------------
--error ER_PARSE_ERROR

garbage ;
--enable_abort_on_error
eval select $mysql_errno as "after_--enable_abort_on_error" ;

# ----------------------------------------------------------------------------
# masked failing statements
# ----------------------------------------------------------------------------
# expected error = response
--error ER_NO_SUCH_TABLE

select 3 from t1 ;

# ----------------------------------------------------------------------------
# check that the old default behaviour is not changed
# Please remove the '#' to get the abort on error
# ----------------------------------------------------------------------------
#--error 1064
#select 3 from t1 ;
#
#select 3 from t1 ;

--error 1
--exec echo "disable_abort_on_error; enable_abort_on_error; error 1064; select 3 from t1; select 3 from t1;" | $MYSQL_TEST  2>&1


# ----------------------------------------------------------------------------
# Test --error with backtick operator or query_get_value
# ----------------------------------------------------------------------------

--error 0,ER_NO_SUCH_TABLE
let $empty= `SELECT foo from bar`;
echo $empty is empty;

--error 0,ER_BAD_FIELD_ERROR
let $empty= query_get_value(SELECT bar as foo, baz, 1);
echo $empty is empty;

--error 0,ER_NO_SUCH_TABLE
if (!`SELECT foo from bar`) {
  echo "Yes it's empty";
}

# ----------------------------------------------------------------------------
# Test comments
# ----------------------------------------------------------------------------

# This is a comment
# This is a ;  comment
# This is a -- comment
# -- This is also a comment
# -- # This is also a comment
# -- This is also a ; comment

# ----------------------------------------------------------------------------
# Test comments with embedded command
# ----------------------------------------------------------------------------

--echo hello
--     echo hello
--    echo ;;;;;;;;

--echo # MySQL: -- The

# ----------------------------------------------------------------------------
# Test detect end of line "junk"
# Most likely caused by a missing delimiter
# ----------------------------------------------------------------------------

# Too many parameters to function
--error 1
--exec echo "sleep 5 6;" | $MYSQL_TEST 2>&1

# Too many parameters to function
--error 1
--exec echo "--sleep 5 6" | $MYSQL_TEST 2>&1

#
# Missing delimiter
# The comment will be "sucked into" the sleep command since
# delimiter is missing until after "show status"
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
sleep 4
# A comment
show status;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Missing delimiter until eof
# The comment will be "sucked into" the sleep command since
# delimiter is missing
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
sleep 7
# Another comment
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Missing delimiter until "disable_query_log"
#
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disconnect default

#
# comment
# comment 3
disable_query_log;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Missing delimiter until "disable_query_log"
#
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disconnect default

#
# comment

# comment 3
disable_query_log;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Missing delimiter until eof
#
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disconnect default

#
# comment
# comment2

# comment 3
--disable_query_log
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Missing delimiter until eof
#
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
disconnect default # comment
# comment part2

# comment 3
--disable_query_log
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

#
# Extra delimiter
#
--error 1
--exec echo "--sleep 4;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--disable_query_log;" | $MYSQL_TEST 2>&1

#
# Extra text after ``
#
# Cannot use exec echo here as ` may or may not need to be escaped
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
let $x= `select 1` BOO ;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
--let $x= `select 1`;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
# Missing ; in next line should be detected and cause failure
let $x= `select 1`
let $x= 2;
echo $x;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;


# Allow trailing # comment
--sleep 1 # Wait for insert delayed to be executed.
--sleep 1        # Wait for insert delayed to be executed.

# ----------------------------------------------------------------------------
# Test error
# ----------------------------------------------------------------------------

# Missing argument
--error 1
--exec echo "error;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--error" | $MYSQL_TEST 2>&1

# First char must be uppercase 'S' or 'E' or [0-9]
--error 1
--exec echo "--error s99999" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--error e99999" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--error 9eeeee" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--error 1sssss" | $MYSQL_TEST 2>&1

# First char 'S' but too long
--error 1
--exec echo "--error S999999" | $MYSQL_TEST 2>&1

# First char 'S' but lowercase char found
--error 1
--exec echo "--error S99a99" | $MYSQL_TEST 2>&1

# First char 'S' but too short
--error 1
--exec echo "--error S9999" | $MYSQL_TEST 2>&1

# First char 'E' but not found in error array
--error 1
--exec echo "--error E9999" | $MYSQL_TEST 2>&1

# First char [0-9] but contains chars
--error 1
--exec echo "--error 999e9" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--error 9b" | $MYSQL_TEST 2>&1

# Multiple errorcodes separated by ','
--error 1,1,1,1
#--error 9,ER_PARSE_ERROR
#--error ER_PARSE_ERROR
#--error 9,ER_PARSE_ERROR,9,ER_PARSE_ERROR
#--error 9, ER_PARSE_ERROR,  9,   ER_PARSE_ERROR
#--error 9,S00000,9,ER_PARSE_ERROR
#--error 9,S00000,9,ER_PARSE_ERROR,ER_PARSE_ERROR,ER_PARSE_ERROR,9,10,11,12
--error 9,S00000,9
--error 9,S00000,9,9,10,11,12
--error 9 ,10
--error 9 , 10
--error    9   ,   10
--error    9   ,   10

# Too many errorcodes specified
--error 1
--exec echo "--error 1,2,3,4,5,6,7,8,9,10,11" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# Test echo command
# ----------------------------------------------------------------------------

echo MySQL;
echo "MySQL";
echo MySQL: The world''s most popular open source database;
echo "MySQL: The world's most popular open source database";

echo MySQL: The world''s
     most popular open
     source database;

echo # MySQL: The world''s
# most popular open
# source database;

echo - MySQL: The world''s
- most popular open
- source database;

echo - MySQL: The world''s
-- most popular
-- open source database;

echo # MySQL: The
--world''s
# most popular
-- open
- source database;

echo "MySQL: The world's most popular; open source database";
echo "MySQL: The world's most popular ; open source database";
echo "MySQL: The world's most popular ;open source database";
echo echo message echo message;


echo ;

# Illegal use of echo

#--error 1
#--exec echo "echo \$;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# Test exec command
# ----------------------------------------------------------------------------

# Illegal use of exec
--error 1
--exec echo "--exec " | $MYSQL_TEST 2>&1

# Multi-line exec
exec $MYSQL
    test -e "select 1";
exec $MYSQL test -e "select
    2";
let $query = select 3
    as X;
exec $MYSQL test -e "$query";

# ----------------------------------------------------------------------------
# Test let command
# ----------------------------------------------------------------------------

let $message=MySQL;
echo $message;

let $message="MySQL";
echo $message;

let $message= MySQL: The
 world''s most
 popular open
 source database;
echo $message;

let $message= # MySQL: The
# world''s most
# popular open
# source database;
echo $message;

let $message=  -- MySQL: The
-- world''s most
-- popular
-- open source database;
echo $message;

let $message=  # MySQL: The
- world''s most
-- popular open
# source database;
echo $message;

echo '$message';
echo "$message";

let $1=hej;
echo $1;

let   $1   =hej ;
echo $1;

let $1 = hej;
echo $1;

let $1=1;
let $2=$1;
echo $2;
let $5=$6;
echo $5;
echo $6;

let $where=a long variable content;
echo $where;

let $where2= $where;
echo $where2;

let $where3=a long $where variable content;
echo $where3;

let $where3=a long \\\$where variable content;
echo $where3;

let $novar1= $novar2;
echo $novar1;

let $cat=na;
let $cat=ba$cat$cat;
echo banana = $cat;

# ba\$cat\$cat should have been sufficient.
# ba\\\$cat\\\$cat -> ba\$cat\$cat -> ba$cat$cat -> banana
# Magnus' upcoming patch will fix the missing second interpretation.
let $cat=ba\\\$cat\\\$cat;
echo Not a banana: $cat;

# Bug #55413 would cause this to fail
let $escape= with\`some\"escaped\'quotes;
echo $escape;

--let $escape= with\`some\"escaped\'quotes
echo $escape;

# This only works with "--let" syntax
--let $tick= single'tick`backtick
echo $tick;

# Test illegal uses of let

--error 1
--exec echo "let ;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "let \$=hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let \$1 hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let \$m hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let \$hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let \$ hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let =hi;" | $MYSQL_TEST  2>&1

--error 1
--exec echo "let hi;" | $MYSQL_TEST  2>&1

# More advanced test for Bug#17280
let $success= 1;
--echo # Execute: --echo # <whatever> success: \$success
--echo # <whatever> success: $success
--echo # Execute: echo # <whatever> success: \$success ;
echo # <whatever> success: $success ;

--echo # The next two variants work fine and expand the content of \$success
--echo # Execute: --echo \$success
--echo $success
--echo # Execute: echo \$success ;
echo $success ;


# ----------------------------------------------------------------------------
# Test to assign let from variable
# let $<var_name>=$<var_name>;
# ----------------------------------------------------------------------------

--echo # Check if let \$B = \$A is an assignment per value.

# Basic preparations:
--echo let \$A = initial value of A;
let $A = initial value of A;
# --echo # Content of \$A is: $A
--echo let \$B = initial value of B;
let $B = initial value of B;
# --echo # Content of \$B is: $B

# Assign $B to $A:
--echo let \$B = \$A
let $A = $B;
--echo # Content of \$A is: $A

# Changes of $B must NOT affect $A and Changes of $A must NOT affect $B !
--echo let \$A = changed value of A;
let $A = changed value of A;
--echo # Content of \$B is: $B

--echo let \$B = changed value of B;
let $B = changed value of B;
--echo # Content of \$A is: $A

# ----------------------------------------------------------------------------
# Test let from query with $variable
# let $<var_name>=`<query with $variable>`;
# ----------------------------------------------------------------------------

let $var1=content of variable 1;
let $var2= `select "$var1"`;
let $var3= `select concat("$var1", " ", "$var2")`;
echo var2: $var2;
echo var3: $var3;
if (`select length("$var3") > 0`)
{
  echo length of var3 is longer than 0;
}

# ----------------------------------------------------------------------------
# Test to assign let from query
# let $<var_name>=`<query>`;
# ----------------------------------------------------------------------------
echo var1;
let $var1= `select "hi" as "Col", 1 as "Column1", "hi there" as Col3`;
echo $var1;

echo var2;
let $var2= `select 2 as "Column num 2"`;
echo $var2;

echo var2 again;
let $var2= `select 2 as "Column num 2"`;
echo $var2;

echo var3 two columns with same name;
let $var3= `select 1 as "Col", 2 as "Col", 3 as "var3"`;
echo $var3;

echo var4 from query that returns NULL;
let $var4= `select NULL`;

echo var5 from query that returns no row;
let $var5= `SHOW VARIABLES LIKE "nonexisting_variable"`;

echo failing query in let;
--write_file $MYSQLTEST_VARDIR/tmp/let.sql
let $var2= `failing query`;
echo $var2;
EOF

create table t1 (a varchar(100));
insert into t1 values ('`select 42`');
let $a= `select * from t1`;
# This should output `select 42`, not evaluate it again to 42
echo $a;
insert into t1 values ('$dollar');
# These should also output the string without evaluating it.
let $a= query_get_value(select * from t1 order by a, a, 1);
echo $a;
let $a= query_get_value(select * from t1 order by a, a, 2);
echo $a;
drop table t1;

--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/let.sql 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/let.sql;


# ----------------------------------------------------------------------------
# Test source command
# ----------------------------------------------------------------------------

# Test illegal uses of source

--error 1
--exec echo "source ;" | $MYSQL_TEST 2>&1

# Fix win paths
--replace_result \\ /
# Source a nonexisting file
--error 1
--exec echo "source non_existingFile;" | $MYSQL_TEST 2>&1

# Too many source
--exec echo "source $MYSQLTEST_VARDIR/tmp/recursive.sql;" > $MYSQLTEST_VARDIR/tmp/recursive.sql
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "source $MYSQLTEST_VARDIR/tmp/recursive.sql;" | $MYSQL_TEST 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/recursive.sql;

# Source a file with error
--exec echo "garbage ;" > $MYSQLTEST_VARDIR/tmp/error.sql
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "source $MYSQLTEST_VARDIR/tmp/error.sql;" | $MYSQL_TEST 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/error.sql;

# Test execution of source in a while loop
--write_file $MYSQLTEST_VARDIR/tmp/sourced.inc
echo here is the sourced script;
EOF
--disable_query_log
let $outer= 2; # Number of outer loops
while ($outer)
{
  eval SELECT '$outer = outer loop variable after while' AS "";

  --source $MYSQLTEST_VARDIR/tmp/sourced.inc

  eval SELECT '$outer = outer loop variable before dec' AS "";
  dec $outer;
  eval SELECT '$outer = outer loop variable after dec' AS "";
}

# Test source in an if in a while which is false on 1st iteration
# Also test --error and --disable_abort_on_error in same context
let $outer= 2; # Number of outer loops
let $ifval= 0; # false 1st time
while ($outer)
{
  echo outer=$outer ifval=$ifval;

  if ($ifval) {
    --source $MYSQLTEST_VARDIR/tmp/sourced.inc
    --error ER_NO_SUCH_TABLE
    SELECT * from nowhere;
    --disable_abort_on_error
# Statement giving a different error, to make sure we don't mask it
    SELECT * FROM nowhere else;
    --enable_abort_on_error
  }
  dec $outer;
  inc $ifval;
}


# Test execution of source in a while loop
--disable_abort_on_error
# Sourcing of a file within while loop, sourced file will
# source other file
let $num= 9;
while ($num)
{
   SELECT 'In loop' AS "";
   --source $MYSQLTEST_VARDIR/tmp/sourced.inc
   dec $num;
}
--enable_abort_on_error
--enable_query_log

# Test source $variable/<filename>
--source $MYSQLTEST_VARDIR/tmp/sourced.inc

--remove_file $MYSQLTEST_VARDIR/tmp/sourced.inc

--write_file $MYSQLTEST_VARDIR/tmp/sourced.inc
echo "hello";
EOF

let $x= sourced;
source $MYSQLTEST_VARDIR/tmp/$x.inc;

let $x= $MYSQLTEST_VARDIR;
source $x/tmp/sourced.inc;

--remove_file $MYSQLTEST_VARDIR/tmp/sourced.inc


# ----------------------------------------------------------------------------
# Test sleep command
# ----------------------------------------------------------------------------

sleep 0.5;
sleep 1;
real_sleep 1;

# Parameter from variable, legal and illegal
let $sleep_var= 0.1;
sleep $sleep_var;
let $sleep_var= 1;
--real_sleep $sleep_var

--write_file $MYSQL_TMP_DIR/sleep.inc
let $sleep_var= xyz;
--sleep $sleep_var
EOF
--error 1
--exec $MYSQL_TEST < $MYSQL_TMP_DIR/sleep.inc 2>&1
--remove_file $MYSQL_TMP_DIR/sleep.inc

--write_file $MYSQL_TMP_DIR/sleep.inc
let $sleep_var= xyz;
real_sleep $sleep_var;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQL_TMP_DIR/sleep.inc 2>&1
--remove_file $MYSQL_TMP_DIR/sleep.inc

# Missing parameter
--error 1
--exec echo "sleep ;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "real_sleep ;" | $MYSQL_TEST 2>&1

# Illegal parameter
--error 1
--exec echo "sleep abc;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "real_sleep abc;" | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# Test inc
# ----------------------------------------------------------------------------
inc $i;
echo $i;
inc $i;
echo $i;
let $i=100;
inc $i;
echo $i;

let $i=hej;
echo $i;
inc $i;
echo $i;

--error 1
--exec echo "inc;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "inc i;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "let \$i=100; inc \$i 1000; echo \$i;" | $MYSQL_TEST 2>&1

inc $i; inc $i; inc $i; --echo $i
echo $i;


# ----------------------------------------------------------------------------
# Test dec
# ----------------------------------------------------------------------------

dec $d;
echo $d;
dec $d;
echo $d;
let $d=100;
dec $d;
echo $d;

let $d=hej;
echo $d;
dec $d;
echo $d;

--error 1
--exec echo "dec;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "dec i;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "let \$i=100; dec \$i 1000; echo \$i;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# Test system
# ----------------------------------------------------------------------------
#system ls > /dev/null;
system echo "hej" > /dev/null;
#--system ls > /dev/null
--system echo "hej" > /dev/null;

--error 1
--exec echo "system;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "system $NONEXISTSINFVAREABLI;" | $MYSQL_TEST 2>&1

--disable_abort_on_error
system NonExistsinfComamdn 2> /dev/null;
--enable_abort_on_error


# ----------------------------------------------------------------------------
# Test delimiter
# ----------------------------------------------------------------------------

delimiter stop;
echo teststop
delimiter ;stop
echo test2;
--delimiter stop
echo test3stop
--delimiter ;
echo test4;

# ----------------------------------------------------------------------------
# Test that delimiter within if() works in in various combinations
# ----------------------------------------------------------------------------

if (0)
{
  delimiter ||;
  echo false-inner||
  if (0)
  {
    delimiter *||
    echo false-innerer*
    delimiter ||*
  }
  echo false-inner again||
}
echo outer;
if (1)
{
  delimiter /;
  echo true-inner/
  if (0)
  {
    delimiter %/
    echo true-innerer%
  }
  echo true-inner again/
}
echo true-outer/
delimiter ;/


# ----------------------------------------------------------------------------
# Test if
# ----------------------------------------------------------------------------

let $counter=10;
if ($counter)
{
  echo Counter is greater than 0, (counter=10);
}
if (!$counter)
{
  echo Counter is not 0, (counter=10);
}
if (! $counter)
{
  let $counter=5;
}
echo Counter should still be 10, is $counter;
let $counter=0;
if($counter)
{
  echo Counter is greater than 0, (counter=0);
}
if (!$counter)
{
  echo Counter is not 0, (counter=0);
}
if (! $counter)
{
  echo Not space var works;
}

# ----------------------------------------------------------------------------
# Test if with some non-numerics
# ----------------------------------------------------------------------------

let $counter=alpha;
if ($counter)
{
  echo Counter is true, (counter=alpha);
}
let $counter=   ;
if ($counter)
{
  echo oops, space is true;
}
let $counter=-0;
if ($counter)
{
  echo oops, -0 is true;
}
if (beta)
{
  echo Beta is true;
}
let $counter=gamma;
while ($counter)
{
  echo while with string, only once;
  let $counter=000;
}

# ----------------------------------------------------------------------------
# Test while, { and }
# ----------------------------------------------------------------------------

let $i=1;
while ($i)
{
  echo $i;
  dec $i;
}
# One liner
#let $i=1;while ($i){echo $i;dec $i;}

let $i=0;
while (!$i)
{
  echo Testing while with not;
  inc $i;
}

# Exceed max nesting level
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest_while.inc
let $1 = 10;
while ($1)
{
while ($1)
{
while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
 while ($1)
{
  echo $1;
  dec $1;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
EOF
# Fix win path
--replace_result \\ / $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "source $MYSQLTEST_VARDIR/tmp/mysqltest_while.inc;" | $MYSQL_TEST 2>&1
--remove_file $MYSQLTEST_VARDIR/tmp/mysqltest_while.inc
--error 1
--exec echo "while \$i;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "while (\$i;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "let \$i=1; while (\$i) dec \$i;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "};" | $MYSQL_TEST 2>&1
--error 1
--exec echo "end;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "{;" | $MYSQL_TEST 2>&1

--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
while (0)
echo hej;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
while (0)
{echo hej;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
while (0){
 echo hej;
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

# ----------------------------------------------------------------------------
# Test error messages returned from comments starting with a command
# ----------------------------------------------------------------------------
--error 1
--exec echo "--if the other server is down" | $MYSQL_TEST 2>&1

--error 1
--exec echo "-- end when ..." | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# Test replace
# ----------------------------------------------------------------------------
--replace_result a b
select "a" as col1, "c" as col2;

--replace_result a b c d
select "a" as col1, "c" as col2;

--error 1
--exec echo "--replace_result a" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_result a;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_result a;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_result a ;" | $MYSQL_TEST 2>&1
--exec echo "replace_result a b; echo OK; exit;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_result a b c" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_result a b c ;" | $MYSQL_TEST 2>&1


--replace_column 1 b
select "a" as col1, "c" as col2;

--replace_column 1 b 2 d
select "a" as col1, "c" as col2;

--error 1
--exec echo "--replace_column a" | $MYSQL_TEST 2>&1

--error 1
--exec echo "--replace_column 1" | $MYSQL_TEST 2>&1

--error 1
--exec echo "--replace_column a b" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_column a 1" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_column 1 b c " | $MYSQL_TEST 2>&1

let $long_rep= 1234567890123456789012345678901234567890;
let $long_rep= $long_rep,$long_rep;
let $long_rep= $long_rep,$long_rep;
let $long_rep= $long_rep,$long_rep;
let $long_rep= $long_rep,$long_rep;
let $long_rep= $long_rep,$long_rep;

# This tests from strings > 1024 (here 1311)

--replace_result $long_rep LONG_STRING
eval select "$long_rep" as x;

# ----------------------------------------------------------------------------
# Test sync_with_master
# ----------------------------------------------------------------------------
--error 1
--exec echo "sync_with_master 10!;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "sync_with_master a;" | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# Test connect
# ----------------------------------------------------------------------------

--error 1
--exec echo "connect;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect ();" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect (con2);" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect (con2,);" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect (con2,localhost,root,,illegal_db);" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect (con1,localhost,root,,,illegal_port,);" | $MYSQL_TEST 2>&1
--error 1
--exec echo "connect (con1,localhost,root,,,,,SMTP POP);" | $MYSQL_TEST 2>&1

# Repeat connect/disconnect
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
let $i=200;
while ($i)
{
 connect (test_con1,localhost,root,,);
 disconnect test_con1;
 dec $i;
}
echo 200 connects succeeded;
EOF
--exec echo "source $MYSQLTEST_VARDIR/tmp/mysqltest.sql;" | $MYSQL_TEST 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

# Select disconnected connection
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
connect (test_con1,localhost,root,,);
disconnect test_con1;
connection test_con1;
EOF
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "source $MYSQLTEST_VARDIR/tmp/mysqltest.sql;" | $MYSQL_TEST 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

# Connection name already used
--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
connect (test_con1,localhost,root,,);
connect (test_con1,localhost,root,,);
EOF
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "source $MYSQLTEST_VARDIR/tmp/mysqltest.sql;" | $MYSQL_TEST 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;

# connect when "disable_abort_on_error" caused "connection not found"
--disable_abort_on_error
connect (con1,localhost,root,,);
connection default;
connection con1;
disconnect con1;
--enable_abort_on_error

# Test connect without a database
connect (con2,localhost,root,,*NO-ONE*);
--error ER_NO_DB_ERROR
show tables;
disconnect con2;
connection default;

# Test enable_connect_log
--enable_connect_log
connect (con1,localhost,root,,);
connection default;
connection con1;
--disable_query_log
# These should not be logged
connect (con2,localhost,root,,*NO-ONE*);
connection con2;
disconnect con2;
connection con1;
--enable_query_log
disconnect con1;
connection default;
--disable_connect_log

# ----------------------------------------------------------------------------
# Test mysqltest arguments
# ----------------------------------------------------------------------------

# -x <file_name>, use the file specified after -x as the test file
--exec $MYSQL_TEST < $MYSQL_TEST_DIR/include/mysqltest-x.inc
--exec $MYSQL_TEST -x $MYSQL_TEST_DIR/include/mysqltest-x.inc
--exec $MYSQL_TEST --test_file=$MYSQL_TEST_DIR/include/mysqltest-x.inc
# Fix Win paths
--replace_result \\ /
--error 1
--exec $MYSQL_TEST -x non_existing_file.inc 2>&1


# ----------------------------------------------------------------------------
# TODO Test queries, especially their errormessages... so it's easy to debug
# new scripts and diagnose errors
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Test Bug#12386
# ----------------------------------------------------------------------------
let $num= 2;
while ($num)
{
   --error ER_PARSE_ERROR

   failing_statement;

   dec $num;
}

SELECT 1 as a;


#
# Bug#10251 Identifiers containing quotes not handled correctly
#
select 1 as `a'b`, 2 as `a"b`;

# Test escaping of quotes
select 'aaa\\','aa''a',"aa""a";

#
# Check of include/show_msg.inc and include/show_msg80.inc
#

# The message contains in most cases a string with the default character set
let $message= Here comes a message;
--source include/show_msg.inc

# The message could also contain a string with character set utf8
let $message= `SELECT USER()`;
--source include/show_msg.inc

# The message contains more then 80 characters on multiple lines
# and is kept between double quotes.
let $message=
"Here comes a very very long message that
    - is longer then 80 characters    and
    - consists of several lines";
--source include/show_msg80.inc

# The message contains more then 80 characters on multiple lines
# and uses the auxiliary character "." at the beginning of the message lines.
let $message= . Here comes a very very long message that
              .      - is longer then 80 characters    and
              .      - consists of several lines;
--source include/show_msg80.inc

#
# Test --enable_parsing / disable_parsing
#
--disable_query_log
--disable_parsing
# The following will not enable query logging
--enable_query_log
select "this will not be executed";
--enable_parsing
select "this will be executed";
--enable_query_log

#
# Test zero length result file. Should not pass
#
--exec echo '' > $MYSQLTEST_VARDIR/tmp/zero_length_file.result
--exec echo "echo ok;" > $MYSQLTEST_VARDIR/tmp/query.sql
--error 1
--exec $MYSQL_TEST -x $MYSQLTEST_VARDIR/tmp/query.sql -R $MYSQLTEST_VARDIR/tmp/zero_length_file.result  > /dev/null 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.result;
--error 0,1
remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.reject;
--error 0,1
remove_file $MYSQLTEST_VARDIR/tmp/zero_length_file.log;
--error 0,1
remove_file $MYSQL_TEST_DIR/r/zero_length_file.reject;

#
# Test that a test file that does not generate any output fails.
#
--exec echo "let \$i= 1;" > $MYSQLTEST_VARDIR/tmp/query.sql
--error 1
--exec $MYSQL_TEST -x $MYSQLTEST_VARDIR/tmp/query.sql  2>&1

remove_file $MYSQLTEST_VARDIR/tmp/query.sql;

#
# Test that mysqltest fails when there are no queries executed
# but a result file exists
# NOTE! This will never happen as long as it's not allowed to have
# test files that produce no output
#--exec echo "something" > $MYSQLTEST_VARDIR/tmp/result_file.result
#--exec echo "let \$i= 1;" > $MYSQLTEST_VARDIR/tmp/query.sql
#--error 1
#--exec $MYSQL_TEST -x $MYSQLTEST_VARDIR/tmp/query.sql -R $MYSQLTEST_VARDIR/tmp/result_file.result 2>&1

#
# Bug#11731 mysqltest in multi-statement queries ignores errors in
#           non-1st queries
#

echo Failing multi statement query;
# PS does not support multi statement
--exec echo "--disable_ps_protocol"                    > $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "delimiter ||||;"                         >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "create table t1 (a int primary key);"    >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "insert into t1 values (1);"              >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "select 'select-me';"                     >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "insertz 'error query'||||"               >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "delimiter ;||||"                         >> $MYSQLTEST_VARDIR/tmp/bug11731.sql

--error 1
--exec $MYSQL_TEST -x $MYSQLTEST_VARDIR/tmp/bug11731.sql 2>&1
drop table t1;

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec $MYSQL_TEST --record -x $MYSQLTEST_VARDIR/tmp/bug11731.sql -R $MYSQLTEST_VARDIR/tmp/bug11731.out 2>&1
# The .out file should be non existent
--error 1
--file_exists $MYSQLTEST_VARDIR/tmp/bug11731.out
drop table t1;


echo Multi statement using expected error;
# PS does not support multi statement
--exec echo "--disable_ps_protocol"                    > $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "delimiter ||||;"                         >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "--error 1064"                            >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "create table t1 (a int primary key);"    >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "insert into t1 values (1);"              >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "select 'select-me';"                     >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "insertz "error query"||||"               >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "delimiter ;||||"                         >> $MYSQLTEST_VARDIR/tmp/bug11731.sql
--exec echo "exit;"                                   >> $MYSQLTEST_VARDIR/tmp/bug11731.sql

# These two should work since the error is expected
--exec $MYSQL_TEST -x $MYSQLTEST_VARDIR/tmp/bug11731.sql  2>&1
drop table t1;

--exec $MYSQL_TEST --record -x $MYSQLTEST_VARDIR/tmp/bug11731.sql -R $MYSQLTEST_VARDIR/tmp/bug11731.out 2>&1
# The .out file should exist
--file_exists $MYSQLTEST_VARDIR/tmp/bug11731.out
drop table t1;
remove_file $MYSQLTEST_VARDIR/tmp/bug11731.out;
remove_file $MYSQLTEST_VARDIR/log/bug11731.log;
remove_file $MYSQLTEST_VARDIR/tmp/bug11731.sql;

#
# Bug#19890 mysqltest "query" command is broken
#

# It should be possible to use the command "query" to force mysqltest to
# send the command to the server although it's a builtin mysqltest command.
--error ER_PARSE_ERROR

query sleep;

--error ER_PARSE_ERROR

--query sleep

# Just an empty query command
--error ER_EMPTY_QUERY

query ;

# test for replace_regex
--replace_regex /at/b/
select "at" as col1, "c" as col2;

--replace_regex /at/b/i
select "at" as col1, "AT" as col2, "c" as col3;

--replace_regex /a/b/ /ct/d/
select "a" as col1, "ct" as col2;

--replace_regex /(strawberry)/raspberry and \1/ /blueberry/blackberry/ /potato/tomato/;
select "strawberry","blueberry","potato";

--error 1
--exec echo "--replace_regex a" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_regex a;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_regex a;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_regex a ;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_regex a b; echo OK;" | $MYSQL_TEST 2>&1
--error 1
--exec echo "--replace_regex /a b c" | $MYSQL_TEST 2>&1
--error 1
--exec echo "replace_regex /a /b c ;" | $MYSQL_TEST 2>&1

# REQUIREMENT
#   replace_regex should replace substitutions from left to right in output

create table t1 (a int, b int);
insert into t1 values (1,3);
insert into t1 values (2,4);
--replace_regex /A/C/ /B/D/i /3/2/ /2/1/
select * from t1;
drop table t1;

# ----------------------------------------------------------------------------
# Tests of send
# ----------------------------------------------------------------------------

create table t1 ( f1 char(10));
insert into t1 values ("Abcd");

# 1. Basic test

send select * from t1;
reap;

# 2. Test with error

--send select * from t2;
--error ER_NO_SUCH_TABLE
--reap

# 3. test send of next stmt

--send
select * from t1;
--reap

# 4. Non-query stmt betwen send and reap allowed

--send select * from t1;
--sleep 0.05
--echo Result coming up
--reap

# 5. Test of send_eval

--let $my_stmt= select * from t1;
--send_eval $my_stmt
--reap

# 6. Test that mysqltest does not allow query stmt between send and reap
# Untestable directly as it causes mysqltest to fail

--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.in
--send select * from t1;
select 1;
--reap
EOF
--error 1
# Must filter unpredictable extra warning from output
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.in > $MYSQL_TMP_DIR/mysqltest.out 2>&1
--perl
  my $dir= $ENV{'MYSQL_TMP_DIR'};
  open (FILE, "$dir/mysqltest.out");
  while (<FILE>) {
    print unless /Note: net_clear/; # This shows up on rare occations
  }
EOF
remove_file $MYSQL_TMP_DIR/mysqltest.out;
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.in;

drop table t1;

# ----------------------------------------------------------------------------
# test for remove_file
# ----------------------------------------------------------------------------

--error 1
--exec echo "remove_file ;" | $MYSQL_TEST 2>&1

--error 1
remove_file non_existing_file;

# ----------------------------------------------------------------------------
# test for remove_files_wildcard
# ----------------------------------------------------------------------------

--error 1
--exec echo "remove_files_wildcard ;" | $MYSQL_TEST 2>&1

--error 1
remove_files_wildcard non_existing_dir;

--error 1
remove_files_wildcard non_existing_dir non_existing_file;

# ----------------------------------------------------------------------------
# test for write_file
# ----------------------------------------------------------------------------
--error 1
--exec echo "write_file ;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "write_file filename ;" | $MYSQL_TEST 2>&1

# Comment out this test as it confuses cmd.exe with unmatched "
#--error 1
#--exec echo "write_file filename \";" | $MYSQL_TEST 2>&1

write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1
EOF
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
cat_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp END_DELIMITER;
Content for test_file1 contains EOF
END_DELIMITER
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

# write to already exisiting file
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--error 1
--exec echo "write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;" | $MYSQL_TEST 2>&1

remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

# ----------------------------------------------------------------------------
# test for append_file
# ----------------------------------------------------------------------------

write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1
EOF
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

append_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Appended text
EOF
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
append_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Appended text on nonexisting file
EOF

remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

# Test append_file within while
let $outer= 2; # Number of outer loops
while ($outer)
{
  append_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;
These lines should be repeated,
if things work as expected
EOF
  dec $outer;
}

cat_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/app_while.tmp;

# ----------------------------------------------------------------------------
# test for cat_file
# ----------------------------------------------------------------------------

--write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp
Some data
for cat_file command
of mysqltest
EOF
cat_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;

--replace_regex /my_errno=[0-9]*/(my_errno)/
--error 1
--exec echo "cat_file non_existing_file;" | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# test for diff_files
# ----------------------------------------------------------------------------

--write_file $MYSQLTEST_VARDIR/tmp/diff1.tmp
Some data
for diff_file command
of mysqltest
EOF

--write_file $MYSQLTEST_VARDIR/tmp/diff2.tmp
Some data
for diff_file command
of mysqltest
EOF

--write_file $MYSQLTEST_VARDIR/tmp/diff3.tmp
Some other data
for diff_file command
of mysqltest
EOF

--write_file $MYSQLTEST_VARDIR/tmp/diff4.tmp
Some data
for diff_file command
of musqltest
EOF

# Compare equal files
--diff_files $MYSQLTEST_VARDIR/tmp/diff1.tmp $MYSQLTEST_VARDIR/tmp/diff2.tmp
--diff_files $MYSQLTEST_VARDIR/tmp/diff2.tmp $MYSQLTEST_VARDIR/tmp/diff1.tmp

# Compare files that differ in size
--error 2
--diff_files $MYSQLTEST_VARDIR/tmp/diff1.tmp $MYSQLTEST_VARDIR/tmp/diff3.tmp
--error 2
--diff_files $MYSQLTEST_VARDIR/tmp/diff3.tmp $MYSQLTEST_VARDIR/tmp/diff1.tmp

# Compare files that differ only in content
--error 1
--diff_files $MYSQLTEST_VARDIR/tmp/diff1.tmp $MYSQLTEST_VARDIR/tmp/diff4.tmp
--error 1
--diff_files $MYSQLTEST_VARDIR/tmp/diff4.tmp $MYSQLTEST_VARDIR/tmp/diff1.tmp

# Compare equal files, again...
--diff_files $MYSQLTEST_VARDIR/tmp/diff1.tmp $MYSQLTEST_VARDIR/tmp/diff2.tmp

--remove_file $MYSQLTEST_VARDIR/tmp/diff1.tmp
--remove_file $MYSQLTEST_VARDIR/tmp/diff2.tmp
--remove_file $MYSQLTEST_VARDIR/tmp/diff3.tmp
--remove_file $MYSQLTEST_VARDIR/tmp/diff4.tmp


# ----------------------------------------------------------------------------
# test for file_exist
# ----------------------------------------------------------------------------
--error 1
--exec echo "file_exists ;" | $MYSQL_TEST 2>&1

--error 0,1
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
write_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
Content for test_file1
EOF
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/test_file1.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/test_file1.tmp;


# ----------------------------------------------------------------------------
# test for copy_file
# ----------------------------------------------------------------------------
--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
file1
EOF

copy_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file2.tmp;

--error 1
--exec echo "copy_file ;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "copy_file from_file;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# test for move_file
# ----------------------------------------------------------------------------

# - Check that if source file does not exist, nothing will be created.

--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
--error 1
move_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;

# - Check that if source file exists, everything works properly.

--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
file1
EOF

move_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;

# - Check that if destination file exists, everything works properly.
#   (file2.tmp exists from the previous check; file1.tmp needs to be created)

--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
file1
EOF

move_file $MYSQLTEST_VARDIR/tmp/file1.tmp $MYSQLTEST_VARDIR/tmp/file2.tmp;
--error 1
file_exists $MYSQLTEST_VARDIR/tmp/file1.tmp;
file_exists $MYSQLTEST_VARDIR/tmp/file2.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file2.tmp;

# - Check usage.

--error 1
--exec echo "move_file ;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "move_file from_file;" | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# test for chmod
# ----------------------------------------------------------------------------
--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
file1
EOF

chmod 0000 $MYSQLTEST_VARDIR/tmp/file1.tmp;
# The below write fails, but --error is not implemented
# for write_file
#--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
#test should fail
#EOF

chmod 0777 $MYSQLTEST_VARDIR/tmp/file1.tmp;
remove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;
--write_file $MYSQLTEST_VARDIR/tmp/file1.tmp
test2
EOF

remove_file $MYSQLTEST_VARDIR/tmp/file1.tmp;

--error 1
--exec echo "chmod ;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "chmod 0 from_file;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "chmod 08 from_file;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "chmod from_file;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "chmod ABZD from_file;" | $MYSQL_TEST 2>&1

--error 1
--exec echo "chmod 06789 from_file;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# test for perl
# ----------------------------------------------------------------------------
--perl
print "hello\n";
EOF

--perl EOF
print "hello\n";
EOF

--perl DELIMITER
print "hello\n";
DELIMITER

--error 1
--exec echo "perl TOO_LONG_DELIMITER ;" | $MYSQL_TEST 2>&1

perl;
print "hello\n";
EOF

perl;
  # Print "hello"
  print "hello\n";
EOF

# Test perl within while, also with if being false first iteration
let $outer= 3;
let $ifval= 0;
while ($outer) {
  if ($ifval) {
    perl UNTIL;
      my $val= 5;
      print "val is $val\n";
UNTIL
  }
  inc $ifval;
  dec $outer;
}

# ----------------------------------------------------------------------------
# test for die
# ----------------------------------------------------------------------------

--error 1
--exec echo "die test of die;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# test for exit
# ----------------------------------------------------------------------------

--exec echo "echo Some output; exit; echo Not this;" | $MYSQL_TEST 2>&1

# ----------------------------------------------------------------------------
# test for sorted_result
# ----------------------------------------------------------------------------

create table t1( a int, b char(255), c timestamp);
insert into t1 values(1, 'Line 1', '2007-04-05'), (2, "Part 2", '2007-04-05');
insert into t1 values(1, 'Line 1', '2007-04-05'), (2, "Part 3", '2007-04-05');
select * from t1;
--sorted_result
select * from t1;
# Should not be sorted
select * from t1;
disable_result_log;
sorted_result;
select * from t1;
enable_result_log;
--sorted_result
select '';
sorted_result;
select "h";
--sorted_result
select "he";
--sorted_result
select "hep";
--sorted_result
select "hepp";

drop table t1;

# 1. Assignment of result set sorting
sorted_result;
 SELECT 2 as "my_col"
UNION
SELECT 1;
#
--sorted_result
SELECT 2 as "my_col" UNION SELECT 1;
--sorted_result
SELECT 2 as "my_col"
UNION
SELECT 1;

# 2. Ensure that the table header will be not sorted into the result
--sorted_result
SELECT '2' as "3"
UNION
SELECT '1';

# 3. Ensure that an empty result set does not cause problems
CREATE TABLE t1( a CHAR);
--sorted_result
SELECT * FROM t1;
DROP TABLE t1;

# 4. Ensure that NULL values within the result set do not cause problems
SELECT NULL as "my_col1",2 AS "my_col2"
UNION
SELECT NULL,1;
--sorted_result
SELECT NULL as "my_col1",2 AS "my_col2"
UNION
SELECT NULL,1;
#
SELECT 2 as "my_col1",NULL AS "my_col2"
UNION
SELECT 1,NULL;
--sorted_result
SELECT 2 as "my_col1",NULL AS "my_col2"
UNION
SELECT 1,NULL;

# 5. "sorted_result" changes nothing when applied to a non query statement.
sorted_result;
 SET @a = 17;
#
# 6. Show that "sorted_result;" before the "SET @a = 17;" above does not affect
# the now following query.
SELECT 2 as "my_col"
UNION
SELECT 1;

# 7. Ensure that "sorted_result" in combination with $variables works
let $my_stmt=SELECT 2 as "my_col"
UNION
SELECT 1;
--sorted_result
eval $my_stmt;

# 8. Ensure that "sorted_result " does not change the semantics of
#    "--error ...." or the protocol output after such an expected failure
--sorted_result
--error ER_NO_SUCH_TABLE

SELECT '2' as "my_col1",2 as "my_col2"
UNION
SELECT '1',1 from t2;

# 9. Ensure that several result formatting options including "sorted_result"
#    - have all an effect
#    - "--sorted_result" does not need to be direct before the statement
#    - Row sorting is applied after modification of the column content
--sorted_result
--replace_column 1 #
SELECT '1' as "my_col1",2 as "my_col2"
UNION
SELECT '2',1;

# 10. Ensure that at least 1024 rows within a result set do not cause problems
#
CREATE TABLE t1 (f1 INT);
INSERT INTO t1 SET f1 = 1024;
INSERT INTO t1 SELECT f1 - 1 FROM t1;
INSERT INTO t1 SELECT f1 - 2 FROM t1;
INSERT INTO t1 SELECT f1 - 4 FROM t1;
INSERT INTO t1 SELECT f1 - 8 FROM t1;
INSERT INTO t1 SELECT f1 - 16 FROM t1;
INSERT INTO t1 SELECT f1 - 32 FROM t1;
INSERT INTO t1 SELECT f1 - 64 FROM t1;
INSERT INTO t1 SELECT f1 - 128 FROM t1;
INSERT INTO t1 SELECT f1 - 256 FROM t1;
INSERT INTO t1 SELECT f1 - 512 FROM t1;
--disable_result_log
--sorted_result
SELECT * FROM t1;
--enable_result_log
DROP TABLE t1;

# ----------------------------------------------------------------------------
# test for lowercase_result
# ----------------------------------------------------------------------------

# 1. Basic test
--lowercase_result
SELECT "500g BLBRSYLTETY" AS "WILL BE lower cased";

# 2. test that it does not apply to next statement
SELECT "UPPER" AS "WILL NOT BE lower cased";

# 3. test that it does not affect non-SQL or the following statement
--lowercase_result
--echo UP
SELECT 0 as "UP AGAIN";

# 4. test that it works with eval and variables
let $lower_stmt=SELECT "ABCdef" AS "uvwXYZ";
--lowercase_result
eval $lower_stmt;

# 5. test that it works in combination with sort
sorted_result;
lowercase_result;
SELECT "Xyz" AS Name UNION SELECT "Abc" as Name ORDER BY Name DESC;

# 6. Test combination with replace, and that lower casing is done first
--lowercase_result
--replace_result old new
SELECT 1 as "SOME OLD TEXT";

# 7. Test missing lower casing of "unknown" characters
--character_set utf8
--lowercase_result
SELECT 0 as "WILL NOT lower case ";
--character_set latin1

# ----------------------------------------------------------------------------
# Some coverage tests
# ----------------------------------------------------------------------------

--disable_query_log
--exec $MYSQL_TEST --help 2>&1 > /dev/null
--exec $MYSQL_TEST --version 2>&1 > /dev/null
--enable_query_log
--disable_abort_on_error
--error 1
--exec $MYSQL_TEST a b c 2>&1 > /dev/null
--enable_abort_on_error
--enable_query_log

# ----------------------------------------------------------------------------
# test for query_get_value
# ----------------------------------------------------------------------------

CREATE TABLE t1(
 a int, b varchar(255), c datetime
);
SHOW COLUMNS FROM t1;

#------------ Positive tests ------------
# 1. constant parameters
#    value is simple string without spaces
let $value= query_get_value(SHOW COLUMNS FROM t1, Type, 1);
--echo statement=SHOW COLUMNS FROM t1 row_number=1, column_name="Type", Value=$value
let $value= query_get_value("SHOW COLUMNS FROM t1", Type, 1);
--echo statement="SHOW COLUMNS FROM t1" row_number=1, column_name="Type", Value=$value
#
# 2. $variables as parameters
#    value IS NULL
let $my_show= SHOW COLUMNS FROM t1;
let $column_name= Default;
let $row_number= 1;
let $value= query_get_value($my_show, $column_name, $row_number);
--echo statement=$my_show row_number=$row_number, column_name=$column_name, Value=$value
#
# 3. result set of a SELECT (not recommended, because projection and
#         selection could be done much better by pure SELECT functionality)
#    value is string with space in the middle
let $value= query_get_value(SELECT 'A B' AS "MyColumn", MyColumn, 1);
--echo value= ->$value<-
#
# 4. column name with space
let $value= query_get_value(SELECT 1 AS "My Column", My Column, 1);
--echo value= $value
#
# 4.1 Query containing , protected by quotes, quotes also on column
let $value= query_get_value('SELECT 1 as a, 2 as b', "b", 1);
--echo value= $value
#
#------------ Negative tests ------------
# 5. Incomplete statement including missing parameters
# 5.1 incomplete statement
--error 1
--exec echo "let \$value= query_get_value(SHOW;" | $MYSQL_TEST 2>&1
# 5.2 missing query
--error 1
--exec echo "let \$value= query_get_value;" | $MYSQL_TEST 2>&1
# 5.3 missing column name
--error 1
--exec echo "let \$value= query_get_value(SHOW COLUMNS FROM t1);" | $MYSQL_TEST 2>&1
# 5.4 missing row number
--error 1
--exec echo "let \$value= query_get_value(SHOW COLUMNS FROM t1, Field);" | $MYSQL_TEST 2>&1
#
# 6. Somehow "wrong" value of parameters
# 6.1 row parameter
# 6.1.1 non sense number 0
let $value= initialized;
let $value= query_get_value(SHOW COLUMNS FROM t1, Field, 0);
--echo value= $value
# 6.1.2 after the last row
let $value= initialized;
let $value= query_get_value(SHOW COLUMNS FROM t1, Field, 10);
--echo value= $value
# 6.1.3 invalid row number
--error 1
--exec echo "let \$value= query_get_value(SHOW COLUMNS FROM t1, Field, notnumber);" | $MYSQL_TEST 2>&1
# 6.2 column name parameter, name of not existing column
--error 1
--exec echo "let \$value= query_get_value(SHOW COLUMNS FROM t1, column_not_exists, 1);" | $MYSQL_TEST 2>&1
# 6.3. statement which never gives a result set
--error 1
--exec echo "let \$value= query_get_value(SET @A = 1, Field, 1);" | $MYSQL_TEST 2>&1
# 6.4. statement contains a ","
#      Note: There is no need to improve this, because we need query_get_value
#            for SHOW commands only.
--error 1
--exec echo "let \$value= query_get_value(SELECT 1 AS "A", 1 AS "B", 1);" | $MYSQL_TEST 2>&1
#
# 7. empty result set
let $value= initialized;
let $value= query_get_value(SELECT a FROM t1, a, 1);
--echo value= $value
#
# 9. failing statement
--error 1
--exec echo "let \$value= query_get_value(SHOW COLNS FROM t1, Field, 1);" | $MYSQL_TEST 2>&1
#
# 10. Artificial example how to process a complete SHOW result set:
let $show_statement= SHOW COLUMNS FROM t1;
let $rowno= 1;
let $run=1;
let $count= 0;
--echo
--echo Field Type Null Key Default Extra
while ($run)
{
   let $Field=   query_get_value($show_statement, Field,   $rowno);
   if (`SELECT '$Field' = 'No such row'`)
   {
      let $run= 0;
   }
   if (`SELECT '$Field' <> 'No such row'`)
   {
      let $Type=    query_get_value($show_statement, Type,    $rowno);
      let $Null=    query_get_value($show_statement, Null,    $rowno);
      if (`SELECT '$Null' = 'YES'`)
      {
         inc $count;
      }
      let $Key=     query_get_value($show_statement, Key,     $rowno);
      let $Default= query_get_value($show_statement, Default, $rowno);
      let $Extra=   query_get_value($show_statement, Extra,   $rowno);
      --echo $Field $Type $Null ->$Key<- $Default $Extra
      inc $rowno;
   }
}
--echo
--echo Number of columns with Default NULL: $count
--echo
eval $show_statement;

drop table t1;

# ----------------------------------------------------------------------------
# Test change_user command
# ----------------------------------------------------------------------------

--error 1
--exec echo "--change_user root,,inexistent" | $MYSQL_TEST 2>&1

--error 1
--exec echo "--change_user inexistent,,test" | $MYSQL_TEST 2>&1

--error 1
--exec echo "--change_user root,inexistent,test" | $MYSQL_TEST 2>&1

--change_user
--change_user root
--change_user root,,
--change_user root,,test

# ----------------------------------------------------------------------------
# Test mkdir and rmdir command
# ----------------------------------------------------------------------------

mkdir $MYSQLTEST_VARDIR/tmp/testdir;
rmdir $MYSQLTEST_VARDIR/tmp/testdir;

# Directory already exist
mkdir $MYSQLTEST_VARDIR/tmp/testdir;
--error 1
mkdir $MYSQLTEST_VARDIR/tmp/testdir;

# Remove dir with file inside
write_file $MYSQLTEST_VARDIR/tmp/testdir/file1.txt;
hello
EOF

# Verify that --replace_result also work on list_files
--replace_result file REPLACED_FILE
list_files $MYSQLTEST_VARDIR/tmp/testdir;
# list_files gets the directory list before creating the new file
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir *;
list_files_append_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir *2*;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
list_files_append_file $MYSQLTEST_VARDIR/tmp/testdir/file3.txt $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
diff_files $MYSQLTEST_VARDIR/tmp/testdir/file2.txt $MYSQLTEST_VARDIR/tmp/testdir/file3.txt;
--error 1
rmdir $MYSQLTEST_VARDIR/tmp/testdir;

cat_file $MYSQLTEST_VARDIR/tmp/testdir/file3.txt;

list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/file11.txt $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir file?.txt;
list_files_write_file $MYSQLTEST_VARDIR/tmp/testdir/dir-list.txt $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
cat_file $MYSQLTEST_VARDIR/tmp/testdir/dir-list.txt;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir file*.txt;
list_files $MYSQLTEST_VARDIR/tmp/testdir;
remove_files_wildcard $MYSQLTEST_VARDIR/tmp/testdir;
list_files $MYSQLTEST_VARDIR/tmp/testdir;
rmdir $MYSQLTEST_VARDIR/tmp/testdir;

#
# Bug#36041 mysql-test-run doesn't seem to string match 100% effectively
#           on Windows
#

--replace_result c:\\a.txt z
SELECT 'c:\\a.txt' AS col;

#
# Bug#32307 mysqltest - does not detect illegal if syntax
#

let $test= 1;
if ($test){
  echo hej;
}

--write_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql
if ($mysql_errno != 1436)
{
 echo ^ Should not be allowed!
}
EOF
--error 1
--exec $MYSQL_TEST < $MYSQLTEST_VARDIR/tmp/mysqltest.sql 2>&1
remove_file $MYSQLTEST_VARDIR/tmp/mysqltest.sql;


# ----------------------------------------------------------------------------
# Test that -- is not allowed as comment, only as mysqltest builtin command
# ----------------------------------------------------------------------------

# valid
select 1;
--query select 1
--query -- a comment for the server

# Not valid, "select" is not a mysqltest command
--error 1
--exec echo "--select 1;" | $MYSQL_TEST 2>&1


# ----------------------------------------------------------------------------
# BUG#35701 please allow test language variables in connection and sync_slave_with_master
# Test that "connection $variable" works and that $CURRENT_CONNECTION has the right value.
# ----------------------------------------------------------------------------

connect (con1,localhost,root,,);
--echo $CURRENT_CONNECTION
connect (con2,localhost,root,,);
--echo $CURRENT_CONNECTION

connection default;
--echo $CURRENT_CONNECTION

connection con1;
--echo $CURRENT_CONNECTION

connection con2;
--echo $CURRENT_CONNECTION

let $x= con1;
let $y= con2;

connection $x;
--echo $CURRENT_CONNECTION

connection $y;
--echo $CURRENT_CONNECTION

# Disconnect the not selected connection
disconnect $x;
--echo $CURRENT_CONNECTION

# Disconnect the selected connection
disconnect $y;
--echo $CURRENT_CONNECTION


--echo End of tests

connection default;
# Wait till we reached the initial number of concurrent sessions
--source include/wait_until_count_sessions.inc
