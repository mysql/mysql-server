# Initialize
--disable_warnings
drop table if exists t1,t2,t3;
--enable_warnings

select * from (select 2 from DUAL) b;
-- error 1054
SELECT 1 as a FROM (SELECT 1 UNION SELECT a) b;
-- error 1054
SELECT 1 as a FROM (SELECT a UNION SELECT 1) b;
CREATE TABLE t1 (a int not null, b char (10) not null);
insert into t1 values(1,'a'),(2,'b'),(3,'c'),(3,'c');
CREATE TABLE t2 (a int not null, b char (10) not null);
insert into t2 values (3,'c'),(4,'d'),(5,'f'),(6,'e');
select t1.a,t3.y from t1,(select a as y from t2  where b='c') as t3  where t1.a = t3.y;
select t1.a,t3.a from t1,(select * from t2  where b='c') as t3  where t1.a = t3.a;
CREATE TABLE t3 (a int not null, b char (10) not null);
insert into t3 values (3,'f'),(4,'y'),(5,'z'),(6,'c');
select t1.a,t4.y from t1,(select t2.a as y from t2,(select t3.b from t3 where t3.a>3) as t5  where t2.b=t5.b) as t4  where t1.a = t4.y;
--error 1054
SELECT a FROM (SELECT 1 FROM (SELECT 1) a HAVING a=1) b;
--error 1052
SELECT a,b as a FROM (SELECT '1' as a,'2' as b) b  HAVING a=1;
SELECT a,2 as a FROM (SELECT '1' as a) b HAVING a=2;
SELECT a,2 as a FROM (SELECT '1' as a) b HAVING a=1;
--error 1054
SELECT 1 FROM (SELECT 1) a WHERE a=2;
--error 1054
SELECT (SELECT 1) as a FROM (SELECT 1 FROM t1  HAVING a=1) as a;
select * from t1 as x1, (select * from t1) as x2;
explain select * from t1 as x1, (select * from t1) as x2;
drop table if exists  t2,t3;
select * from (select 1) as a;
select a from (select 1 as a) as b;
select 1 from (select 1) as a;
select * from (select * from t1 union select * from t1) a;
select * from (select * from t1 union all select * from t1) a;
select * from (select * from t1 union all select * from t1 limit 2) a;
explain select * from (select * from t1 union select * from t1) a;
explain select * from (select * from t1 union all select * from t1) a;
CREATE TABLE t2 (a int not null);
insert into t2 values(1);
select * from (select * from t1 where t1.a=(select a from t2 where t2.a=t1.a)) a;
select * from (select * from t1 where t1.a=(select t2.a from t2 where t2.a=t1.a) union select t1.a, t1.b from t1) a;
explain select * from (select t1.*, t2.a as t2a from t1,t2 where t1.a=t2.a) t1;
drop table t1, t2;
create table t1(a int not null, t char(8), index(a));
disable_query_log;
let $1 = 10000;
while ($1)
 {
  eval insert into t1 values ($1,'$1'); 
  dec $1;
 }
enable_query_log;
SELECT * FROM (SELECT * FROM t1) as b ORDER BY a  ASC LIMIT 0,20;
explain select count(*) from t1 as tt1, (select * from t1) as tt2;
drop table t1;
SELECT * FROM (SELECT (SELECT * FROM (SELECT 1 as a) as a )) as b;
select * from (select 1 as a) b  left join (select 2 as a) c using(a);
--error 1054
SELECT * FROM (SELECT 1 UNION SELECT a) b;
--error 1054
SELECT 1 as a FROM (SELECT a UNION SELECT 1) b;
--error 1054
SELECT 1 as a FROM (SELECT 1 UNION SELECT a) b;
--error 1054
select 1 from  (select 2) a order by 0;

#
# Test of explain (bug #251)
#

create table t1 (id int);
insert into t1 values (1),(2),(3);
describe select * from (select * from t1 group by id) bar;
drop table t1;

#
# test->used_keys test for derived tables
#
create table t1 (mat_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, matintnum CHAR(6) NOT NULL, test MEDIUMINT UNSIGNED NULL);
create table t2 (mat_id MEDIUMINT UNSIGNED NOT NULL, pla_id MEDIUMINT UNSIGNED NOT NULL);
insert into t1 values (NULL, 'a', 1), (NULL, 'b', 2), (NULL, 'c', 3), (NULL, 'd', 4), (NULL, 'e', 5), (NULL, 'f', 6), (NULL, 'g', 7), (NULL, 'h', 8), (NULL, 'i', 9);
insert into t2 values (1, 100), (1, 101), (1, 102), (2, 100), (2, 103), (2, 104), (3, 101), (3, 102), (3, 105);

analyze table t1, t2;

--sorted_result
SELECT STRAIGHT_JOIN d.pla_id, m2.mat_id FROM t1 m2 INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
--sorted_result
SELECT STRAIGHT_JOIN d.pla_id, m2.test FROM t1 m2  INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;

explain SELECT STRAIGHT_JOIN d.pla_id, m2.mat_id FROM t1 m2 INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
explain SELECT STRAIGHT_JOIN d.pla_id, m2.test FROM t1 m2  INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
drop table t1,t2;

#
# derived table reference
#
SELECT a.x FROM (SELECT 1 AS x) AS a HAVING a.x = 1;

#
# Test for select if database is not selected.
#
# Connect without a database as user mysqltest_1
create user mysqltest_1;
create table t1 select 1 as a;
connect (con1,localhost,mysqltest_1,,*NO-ONE*,$MASTER_MYPORT,$MASTER_MYSOCK);
connection con1;
--error 1046
select 2 as a from (select * from t1) b;
use test;
select 2 as a from (select * from t1) b;
drop table t1;
--error 1064
select mail_id,  if(folder.f_description!='', folder.f_description, folder.f_name) as folder_name,  date, address_id, phrase, address,  subject from folder, (select  mail.mail_id as mail_id,  date_format(mail.h_date, '%b %e, %Y %h:%i') as date,  mail.folder_id,  sender.address_id as address_id,  sender.phrase as phrase, sender.address as address,    mail.h_subject as subject from    mail left join mxa as mxa_sender on mail.mail_id=mxa_sender.mail_id and mxa_sender.type='from' left join address as sender on mxa_sender.address_id=sender.address_id  mxa as mxa_recipient,   address as recipient, where 1     and mail.mail_id=mxa_recipient.mail_id   and mxa_recipient.address_id=recipient.address_id   and mxa_recipient.type='to'  and  match(sender.phrase, sender.address, sender.comment) against ('jeremy' in boolean mode)   and  match(recipient.phrase, recipient.address, recipient.comment) against ('monty' in boolean mode) order by mail.h_date desc limit 0, 25 ) as query where query.folder_id=folder.folder_id;

#
# UPDATE/DELETE/INSERT of derived tables
#
create table t1 (a int);
insert into t1 values (1),(2),(3);
-- error 1288
update (select * from t1) as t1 set a = 5;
-- error 1064
delete from (select * from t1);
-- error 1064
insert into  (select * from t1) values (5);
drop table t1;

#
# deived tables with subquery inside all by one table
#
create table t1 (E1 INTEGER UNSIGNED NOT NULL, E2 INTEGER UNSIGNED NOT NULL, E3 INTEGER UNSIGNED NOT NULL, PRIMARY KEY(E1)
);
insert into t1 VALUES(1,1,1), (2,2,1);
select count(*) from t1 INNER JOIN (SELECT A.E1, A.E2, A.E3 FROM t1 AS A WHERE A.E3 = (SELECT MAX(B.E3) FROM t1 AS B WHERE A.E2 = B.E2)) AS THEMAX ON t1.E1 = THEMAX.E2 AND t1.E1 = t1.E2;
explain select count(*) from t1 INNER JOIN (SELECT A.E1, A.E2, A.E3 FROM t1 AS A WHERE A.E3 = (SELECT MAX(B.E3) FROM t1 AS B WHERE A.E2 = B.E2)) AS THEMAX ON t1.E1 = THEMAX.E2 AND t1.E1 = t1.E2;
drop table t1;

create table t1 (a int);
insert into t1 values (1),(2);
select * from ( select * from t1 union select * from t1) a,(select * from t1 union select * from t1) b;
explain select * from ( select * from t1 union select * from t1) a,(select * from t1 union select * from t1) b;
drop table t1;

#
# multi-update & multi-delete with derived tables
#
CREATE TABLE `t1` (
  `N` int(11) unsigned NOT NULL default '0',
  `M` tinyint(1) default '0'
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO `t1` (N, M) VALUES (1, 0),(1, 0),(1, 0),(2, 0),(2, 0),(3, 0);
UPDATE `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2;
select * from t1;
-- error 1288
UPDATE `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2, P2.N = 2;
-- error 1054
UPDATE `t1` AS P1 INNER JOIN (SELECT aaaa FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2;
delete P1.* from `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N;
select * from t1;
--replace_result P2 p2
--error ER_NON_UPDATABLE_TABLE
delete P1.*,P2.* from `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N;
-- error 1054
delete P1.* from `t1` AS P1 INNER JOIN (SELECT aaa FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N;
drop table t1;

#
# correct lex->current_select
#
CREATE TABLE t1 (
  OBJECTID int(11) NOT NULL default '0',
  SORTORDER int(11) NOT NULL auto_increment,
  KEY t1_SortIndex (SORTORDER),
  KEY t1_IdIndex (OBJECTID)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
CREATE TABLE t2 (
  ID int(11) default NULL,
  PARID int(11) default NULL,
  UNIQUE KEY t2_ID_IDX (ID),
  KEY t2_PARID_IDX (PARID)
) engine=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t2 VALUES (1000,0),(1001,0),(1002,0),(1003,0),(1008,1),(1009,1),(1010,1),(1011,1),(1016,2);
CREATE TABLE t3 (
  ID int(11) default NULL,
  DATA decimal(10,2) default NULL,
  UNIQUE KEY t3_ID_IDX (ID)
) engine=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t3 VALUES (1000,0.00),(1001,0.25),(1002,0.50),(1003,0.75),(1008,1.00),(1009,1.25),(1010,1.50),(1011,1.75);
select 497, TMP.ID, NULL from (select 497 as ID, MAX(t3.DATA) as DATA      from t1 join t2 on (t1.ObjectID = t2.ID) join t3 on (t1.ObjectID = t3.ID) group by t2.ParID order by DATA DESC) as TMP;
drop table t1, t2, t3;

#
# explain derived
#
CREATE TABLE t1 (name char(1) default NULL, val int(5) default NULL);
INSERT INTO t1 VALUES ('a',1),  ('a',2),  ('a',2),  ('a',2),  ('a',3),  ('a',6), ('a',7), ('a',11), ('a',11), ('a',12), ('a',13), ('a',13), ('a',20), ('b',2), ('b',3), ('b',4), ('b',5);
SELECT s.name, AVG(s.val) AS median FROM (SELECT x.name, x.val FROM t1 x, t1 y WHERE x.name=y.name GROUP BY x.name, x.val HAVING SUM(y.val <= x.val) >= COUNT(*)/2 AND SUM(y.val >= x.val) >= COUNT(*)/2) AS s GROUP BY s.name;
explain SELECT s.name, AVG(s.val) AS median FROM (SELECT x.name, x.val FROM t1 x, t1 y WHERE x.name=y.name GROUP BY x.name, x.val HAVING SUM(y.val <= x.val) >= COUNT(*)/2 AND SUM(y.val >= x.val) >= COUNT(*)/2) AS s GROUP BY s.name;
drop table t1;

#
# "Using index" in explain
#
create table t2 (a int, b int, primary key (a));
insert into t2 values (1,7),(2,7);
explain select a from t2 where a>1;
explain select a from (select a from t2 where a>1) tt;
drop table t2;

#
# select list counter
#
CREATE TABLE `t1` ( `itemid` int(11) NOT NULL default '0', `grpid` varchar(15) NOT NULL default '', `vendor` int(11) NOT NULL default '0', `date_` date NOT NULL default '0000-00-00', `price` decimal(12,2) NOT NULL default '0.00', PRIMARY KEY  (`itemid`,`grpid`,`vendor`,`date_`), KEY `itemid` (`itemid`,`vendor`), KEY `itemid_2` (`itemid`,`date_`));
insert into t1 values (128, 'rozn', 2, curdate(), 10),
  (128, 'rozn', 1, curdate(), 10);
SELECT MIN(price) min, MAX(price) max, AVG(price) avg FROM (SELECT SUBSTRING( MAX(concat(date_,";",price)), 12) price FROM t1 WHERE itemid=128 AND  grpid='rozn' GROUP BY itemid, grpid, vendor) lastprices;
DROP TABLE t1;

#
# DISTINCT over grouped select on subquery in the FROM clause
#
create table t1 (a integer, b integer);
insert into t1 values (1,4), (2,2),(2,2), (4,1),(4,1),(4,1),(4,1);
select distinct sum(b) from t1 group by a;
select distinct sum(b) from (select a,b from t1) y group by a;
drop table t1;


#
# Test for bug #7413 "Subquery with non-scalar results participating in
# select list of derived table crashes server" aka "VIEW with sub query can
# cause the MySQL server to crash". If we have encountered problem during
# filling of derived table we should report error and perform cleanup
# properly.
#
CREATE TABLE t1 (a char(10), b char(10));
INSERT INTO t1 VALUES ('root','localhost'), ('root','%');
--error 1242
SELECT * FROM (SELECT (SELECT a.a FROM t1 AS a WHERE a.a = b.a) FROM t1 AS b) AS c;
DROP TABLE t1;
#
# test of union subquery in the FROM clause with complex distinct/all (BUG#6565)
#
create table t1(a int);
create table t2(a int);
create table t3(a int);
insert into t1 values(1),(1);
insert into t2 values(2),(2);
insert into t3 values(3),(3);
select * from t1 union distinct select * from t2 union all select * from t3;
select * from (select * from t1 union distinct select * from t2 union all select * from t3) X;
drop table t1, t2, t3;

#
# Bug #11864 non unique names are allowed in subquery
#
create table t1 (a int);
create table t2 (a int);
--error 1060
select * from (select * from t1,t2) foo;
drop table t1,t2;

#
# Bug#10586 - query works with 4.1.8, but not with 4.1.11
#
create table t1 (ID int unsigned not null auto_increment,
                 DATA varchar(5) not null, primary key (ID));
create table t2 (ID int unsigned not null auto_increment,
                 DATA varchar(5) not null, FID int unsigned not null,
                 primary key (ID));
select A.* from (t1 inner join (select * from t2) as A on t1.ID = A.FID);
select t2.* from ((select * from t1) as A inner join t2 on A.ID = t2.FID);
select t2.* from (select * from t1) as A inner join t2 on A.ID = t2.FID;
drop table t1, t2;

connection con1;
disconnect con1;
--source include/wait_until_disconnected.inc
connection default;
drop user mysqltest_1;

--echo # End of 4.1 tests

#
# Bug #41156: List of derived tables acts like a chain of
#             mutually-nested subqueries
#

SELECT 0 FROM
(SELECT 0) t01, (SELECT 0) t02, (SELECT 0) t03, (SELECT 0) t04, (SELECT 0) t05,
(SELECT 0) t06, (SELECT 0) t07, (SELECT 0) t08, (SELECT 0) t09, (SELECT 0) t10,
(SELECT 0) t11, (SELECT 0) t12, (SELECT 0) t13, (SELECT 0) t14, (SELECT 0) t15,
(SELECT 0) t16, (SELECT 0) t17, (SELECT 0) t18, (SELECT 0) t19, (SELECT 0) t20,
(SELECT 0) t21, (SELECT 0) t22, (SELECT 0) t23, (SELECT 0) t24, (SELECT 0) t25,
(SELECT 0) t26, (SELECT 0) t27, (SELECT 0) t28, (SELECT 0) t29, (SELECT 0) t30,
(SELECT 0) t31, (SELECT 0) t32, (SELECT 0) t33, (SELECT 0) t34, (SELECT 0) t35,
(SELECT 0) t36, (SELECT 0) t37, (SELECT 0) t38, (SELECT 0) t39, (SELECT 0) t40,
(SELECT 0) t41, (SELECT 0) t42, (SELECT 0) t43, (SELECT 0) t44, (SELECT 0) t45,
(SELECT 0) t46, (SELECT 0) t47, (SELECT 0) t48, (SELECT 0) t49, (SELECT 0) t50,
(SELECT 0) t51, (SELECT 0) t52, (SELECT 0) t53, (SELECT 0) t54, (SELECT 0) t55,
(SELECT 0) t56, (SELECT 0) t57, (SELECT 0) t58, (SELECT 0) t59, (SELECT 0) t60,
(SELECT 0) t61; # 61 == MAX_TABLES

--echo #
--echo #  A nested materialized derived table is used before being populated.
--echo #  (addon for bug#19077)
--echo #

CREATE TABLE t1 (i INT, j BIGINT);
INSERT INTO t1 VALUES (1, 2), (2, 2), (3, 2);
SELECT * FROM (SELECT MIN(i) FROM t1
WHERE j = SUBSTRING('12', (SELECT * FROM (SELECT MIN(j) FROM t1) t2))) t3;
DROP TABLE t1;

--echo # End of 5.0 tests

--echo #
--echo # Bug#55586: Crash JOIN of two subqueries in FROM + ORDER BY and GROUP BY
--echo #
CREATE TABLE C (
  `col_int_key` int(11) DEFAULT NULL,
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_varchar_nokey` varchar(1) DEFAULT NULL,
  KEY `col_varchar_key` (`col_varchar_key`,`col_int_key`)
);

INSERT INTO C VALUES (2,'w','w');
INSERT INTO C VALUES (2,'d','d');
--sorted_result
SELECT SUM(DISTINCT table2.col_int_key) field1, 
       table1.col_varchar_key field2 
FROM 
  (SELECT * FROM C  ) table1
  JOIN (SELECT * FROM C  ) table2
  ON table2 .`col_varchar_key` = table1 .`col_varchar_nokey` 
GROUP  BY field2
ORDER  BY field1;

DROP TABLE C;
--echo # End of test for bug#55586

--echo #
--echo # Bug#55561: Crash on JOIN with 2 FROM subqueries
--echo #
CREATE TABLE C (
  col_int int DEFAULT NULL,
  col_varchar varchar(1) DEFAULT NULL
);

INSERT INTO `C` VALUES (0,NULL);
INSERT INTO `C` VALUES (5,'y');
 
SELECT table1.col_varchar
FROM 
 ( SELECT * FROM C  ) table1  
 JOIN ( SELECT * FROM C  ) table2  ON table2.col_varchar = table1.col_varchar
WHERE 
  table2.col_varchar < table2.col_varchar
  AND table1.col_varchar != 'k' 
LIMIT  1;
DROP TABLE C;
--echo # End on bug#55561

--echo #
--echo # Bug#56233: Hang during key generation for derived tables
--echo #
CREATE TABLE C (
  col_varchar_10_key varchar(10) DEFAULT NULL,
  col_int_key int DEFAULT NULL,
  pk int NOT NULL AUTO_INCREMENT,
  col_date_key date DEFAULT NULL,
  PRIMARY KEY (`pk`),
  KEY `col_varchar_10_key` (`col_varchar_10_key`),
  KEY `col_int_key` (`col_int_key`),
  KEY `col_date_key` (`col_date_key`)
);

INSERT INTO C VALUES ('ok',3,1,'2003-04-02');

CREATE ALGORITHM=TEMPTABLE VIEW viewC AS SELECT * FROM C;

SELECT  table1.col_date_key AS field1 
FROM
  C AS table1
WHERE 
  (table1.col_int_key <=ANY 
    ( SELECT SUBQUERY1_t1.col_int_key 
      FROM viewC AS SUBQUERY1_t1 
      WHERE SUBQUERY1_t1.col_varchar_10_key <= table1.col_varchar_10_key 
    ) 
  )
;
DROP TABLE C;
DROP VIEW viewC;
--echo #

--echo #
--echo # Bug#55950: FROM Subquery joined by 2 varchar fields returns empty
--echo #            set
--echo #
CREATE TABLE `CC` (
  `i1` varchar(1) DEFAULT NULL,
  `i2` varchar(1) DEFAULT NULL
);

INSERT INTO `CC` VALUES ('m','m');
INSERT INTO `CC` VALUES ('c','c');

CREATE TABLE `C` (
  `o1` varchar(1) DEFAULT NULL
);

INSERT INTO `C` VALUES ('m');
 
SELECT table1 . o1 
FROM C table1  
  JOIN ( C table2  
    JOIN ( SELECT * FROM CC ) table3  
    ON table3 .`i1`  = table2 .o1  
  ) ON table3 .`i2`  = table2 .o1   
;

--echo # Ref access to the derived table should be used.
EXPLAIN SELECT table1 . o1 
FROM C table1  
  JOIN ( C table2  
    JOIN ( SELECT * FROM CC ) table3  
    ON table3 .`i1`  = table2 .o1  
  ) ON table3 .`i2`  = table2 .o1   
;

DROP TABLE CC;
DROP TABLE C;
--echo # End of test for bug#55950

--echo #
--echo # Bug#56592: Subquery with DISTINCT in FROM clause returns only partial
--echo # result
--echo #
CREATE TABLE `t1` (
  `pk` int(11) NOT NULL,
  `col_int_key` int(11) DEFAULT NULL,
  `col_datetime_key` datetime DEFAULT NULL
) ENGINE=MyISAM;
INSERT INTO t1 VALUES (2, 9, NULL), (3, 3, '1900-01-01 00:00:00'),
(8, 8, '1900-01-01 00:00:00'), (15, 0, '2007-12-15 12:39:34');

SELECT * FROM ( 
  SELECT DISTINCT tableB.col_datetime_key 
  FROM t1 tableA LEFT JOIN t1 tableB ON tableA.pk < tableB.col_int_key
) AS FROM_SUBQUERY;

EXPLAIN SELECT * FROM ( 
  SELECT DISTINCT tableB.col_datetime_key 
  FROM t1 tableA LEFT JOIN t1 tableB ON tableA.pk < tableB.col_int_key
) AS FROM_SUBQUERY;

EXPLAIN SELECT * FROM ( 
  SELECT DISTINCT tableA.col_datetime_key 
  FROM t1 tableA LEFT JOIN t1 tableB ON tableA.pk < tableB.col_int_key
) AS FROM_SUBQUERY;

DROP TABLE t1;

--echo #
--echo # Bug#58730 Assertion failed: table->key_read == 0 in close_thread_table,
--echo #           temptable views
--echo #

CREATE TABLE t1 (a INT);
CREATE TABLE t2 (b INT, KEY (b));
INSERT INTO t1 VALUES (1),(1);
INSERT INTO t2 VALUES (1),(1);

CREATE algorithm=temptable VIEW v1 AS
  SELECT 1 FROM t1 LEFT JOIN t1 t3 ON 1 > (SELECT 1 FROM t1);
CREATE algorithm=temptable VIEW v2 AS SELECT 1 FROM t2;

# This caused the assert to be triggered.
--error ER_SUBQUERY_NO_1_ROW
EXPLAIN SELECT 1 FROM t1 JOIN v1 ON 1 > (SELECT 1 FROM v2);

DROP TABLE t1, t2;
DROP VIEW v1, v2;

--echo #
--echo # WL#5274: Postpone materialization of views/subqueries in FROM clause.
--echo #          Additional tests.
--echo #
# TODO: update test result after WL#5275 is pushed
CREATE TABLE t1(f1 int, f11 int);
CREATE TABLE t2(f2 int, f22 int);
INSERT INTO t1 VALUES(1,1),(2,2),(3,3),(5,5),(9,9),(7,7);
INSERT INTO t2 VALUES(1,1),(3,3),(2,2),(4,4),(8,8),(6,6);

--echo for merged derived tables
--echo  explain for simple derived
EXPLAIN SELECT * FROM (SELECT * FROM t1) tt;
SELECT * FROM (SELECT * FROM t1) tt;
--echo  explain for multitable derived
EXPLAIN EXTENDED SELECT * FROM (SELECT * FROM t1 JOIN t2 ON f1=f2) tt;
SELECT * FROM (SELECT * FROM t1 JOIN t2 ON f1=f2) tt;
--echo  explain for derived with where
FLUSH STATUS;
EXPLAIN EXTENDED 
  SELECT * FROM (SELECT * FROM t1 WHERE f1 IN (2,3)) tt WHERE f11=2;
SHOW STATUS LIKE 'Handler_read%';
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE f1 IN (2,3)) tt WHERE f11=2;
SHOW STATUS LIKE 'Handler_read%';

--echo join of derived
EXPLAIN EXTENDED 
  SELECT * FROM (SELECT * FROM t1 WHERE f1 IN (2,3)) tt JOIN
  (SELECT * FROM t1 WHERE f1 IN (1,2)) aa ON tt.f1=aa.f1;
SELECT * FROM (SELECT * FROM t1 WHERE f1 IN (2,3)) tt JOIN
  (SELECT * FROM t1 WHERE f1 IN (1,2)) aa ON tt.f1=aa.f1;

--echo for merged views
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE VIEW v2 AS SELECT * FROM t1 JOIN t2 ON f1=f2;
CREATE VIEW v3 AS SELECT * FROM t1 WHERE f1 IN (2,3);
CREATE VIEW v4 AS SELECT * FROM t2 WHERE f2 IN (2,3);
--echo  explain for simple views
EXPLAIN EXTENDED SELECT * FROM v1;
SELECT * FROM v1;
--echo  explain for multitable views
EXPLAIN EXTENDED SELECT * FROM v2;
SELECT * FROM v2;
--echo  explain for views with where
EXPLAIN EXTENDED SELECT * FROM v3 WHERE f11 IN (1,3);
SELECT * FROM v3 WHERE f11 IN (1,3);
--echo explain for joined views
EXPLAIN EXTENDED
  SELECT * FROM v3 JOIN v4 ON f1=f2;
SELECT * FROM v3 JOIN v4 ON f1=f2;

FLUSH STATUS;
EXPLAIN EXTENDED SELECT * FROM v4 WHERE f2 IN (1,3);
SHOW STATUS LIKE 'Handler_read%';
FLUSH STATUS;
SELECT * FROM v4 WHERE f2 IN (1,3);
SHOW STATUS LIKE 'Handler_read%';

--echo for materialized derived tables
--echo  explain for simple derived
EXPLAIN EXTENDED SELECT * FROM (SELECT * FROM t1 GROUP BY f1) tt;
SELECT * FROM (SELECT * FROM t1 HAVING f1=f1) tt;
--echo  explain showing created indexes and late materialization
FLUSH STATUS;
EXPLAIN EXTENDED
  SELECT * FROM t1 JOIN (SELECT * FROM t2 GROUP BY f2) tt ON f1=f2;
SHOW STATUS LIKE 'Handler_read%';
FLUSH STATUS;
SELECT * FROM t1 JOIN (SELECT * FROM t2 GROUP BY f2) tt ON f1=f2;
SHOW STATUS LIKE 'Handler_read%';

--echo for materialized views
DROP VIEW v1,v2,v3;
CREATE VIEW v1 AS SELECT * FROM t1 GROUP BY f1;
CREATE VIEW v2 AS SELECT * FROM t2 GROUP BY f2;
CREATE VIEW v3 AS SELECT t1.f1,t1.f11 FROM t1 JOIN t1 AS t11 HAVING t1.f1<100;
--echo  explain for simple derived
EXPLAIN EXTENDED SELECT * FROM v1;
SELECT * FROM v1;
--echo  explain showing created indexes and late materialization for views
FLUSH STATUS;
EXPLAIN EXTENDED SELECT * FROM t1 JOIN v2 ON f1=f2;
SHOW STATUS LIKE 'Handler_read%';
FLUSH STATUS;
SELECT * FROM t1 JOIN v2 ON f1=f2;
SHOW STATUS LIKE 'Handler_read%';

EXPLAIN EXTENDED
  SELECT * FROM t1,v3 AS v31,v3 WHERE t1.f1=v31.f1 and t1.f1=v3.f1;
FLUSH STATUS;
SELECT * FROM t1,v3 AS v31,v3 WHERE t1.f1=v31.f1 and t1.f1=v3.f1;
SHOW STATUS LIKE 'Handler_read%';
--echo  explain showing late materialization for views
EXPLAIN EXTENDED SELECT * FROM v1 JOIN v4 ON f1=f2;
SELECT * FROM v1 JOIN v4 ON f1=f2;

--echo merged derived in merged derived
EXPLAIN EXTENDED SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7) tt WHERE f1 > 2) zz;
SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7) tt WHERE f1 > 2) zz;

--echo materialized derived in merged derived
EXPLAIN EXTENDED  SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) zz;
SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) zz;

--echo merged derived in materialized derived
EXPLAIN  extended SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7) tt WHERE f1 > 2 GROUP BY f1) zz;
SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7) tt WHERE f1 > 2 GROUP BY f1) zz;

--echo materialized derived in materialized derived
EXPLAIN EXTENDED  SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) zz;
SELECT * FROM (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) zz;

--echo mat in merged derived join mat in merged derived
EXPLAIN EXTENDED  SELECT * FROM 
 (SELECT * FROM (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) x
JOIN 
 (SELECT * FROM (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) z
 ON x.f1 = z.f1;

FLUSH STATUS;
SELECT * FROM 
 (SELECT * FROM (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) x
JOIN 
 (SELECT * FROM (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2) z
 ON x.f1 = z.f1;
SHOW STATUS LIKE 'Handler_read%';
FLUSH STATUS;

--echo merged in merged derived join merged in merged derived
EXPLAIN EXTENDED  SELECT * FROM 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 ) tt WHERE f1 > 2 ) x
JOIN 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 ) tt WHERE f1 > 2 ) z
 ON x.f1 = z.f1;

SELECT * FROM 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 ) tt WHERE f1 > 2 ) x
JOIN 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 ) tt WHERE f1 > 2 ) z
 ON x.f1 = z.f1;

--echo materialized in materialized derived join 
--echo   materialized in materialized derived
EXPLAIN EXTENDED  SELECT * FROM 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) x
JOIN 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) z
 ON x.f1 = z.f1;

SELECT * FROM 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) x
JOIN 
 (SELECT * FROM 
  (SELECT * FROM t1 WHERE f1 < 7 GROUP BY f1) tt WHERE f1 > 2 GROUP BY f1) z
 ON x.f1 = z.f1;

--echo merged view in materialized derived
EXPLAIN EXTENDED
SELECT * FROM (SELECT * FROM v4 GROUP BY 1) tt;
SELECT * FROM (SELECT * FROM v4 GROUP BY 1) tt;

--echo materialized view in merged derived
EXPLAIN EXTENDED 
SELECT * FROM ( SELECT * FROM v1 WHERE f1 < 7) tt;
SELECT * FROM ( SELECT * FROM v1 WHERE f1 < 7) tt;

--echo merged view in a merged view in a merged derived
CREATE VIEW v6 AS SELECT * FROM v4 WHERE f2 < 7;
EXPLAIN EXTENDED SELECT * FROM (SELECT * FROM v6) tt;
SELECT * FROM (SELECT * FROM v6) tt;

--echo materialized view in a merged view in a materialized derived
CREATE VIEW v7 AS SELECT * FROM v1;
EXPLAIN EXTENDED SELECT * FROM (SELECT * FROM v7 GROUP BY 1) tt;
SELECT * FROM (SELECT * FROM v7 GROUP BY 1) tt;

--echo JOIN of above two
EXPLAIN EXTENDED SELECT * FROM v6 JOIN v7 ON f2=f1;
SELECT * FROM v6 JOIN v7 ON f2=f1;

--echo test two keys
CREATE TABLE t3(f3 INT, f33 INT);
INSERT INTO t1 VALUES(6,6),(8,8);
INSERT INTO t3 VALUES(1,1),(2,2),(3,3),(5,5);
let $query= SELECT * FROM t1 JOIN (SELECT * FROM t2) tt ON t1.f1=tt.f2
  JOIN t3 ON tt.f22=t3.f3;
eval EXPLAIN EXTENDED $query;
eval $query;

DROP TABLE t1,t2,t3; 
DROP VIEW v1,v2,v3,v4,v6,v7;

--echo #

--echo #
--echo # BUG#11783262: CRASH IN ITEM_FIELD::ITEM_FIELD IN ITEM.CC ON SUBQUERY
--echo #               IN FROM WITH WL5274 
--echo #

CREATE TABLE t1 (
  col_int_key INT,
  col_time_key time,
  col_varchar_key VARCHAR(1),
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key,col_int_key)
) ENGINE=INNODB;
SELECT alias1.col_time_key AS field1
FROM ( ( SELECT SQ1_alias1.* FROM t1 AS SQ1_alias1 ) AS alias1
  INNER JOIN t1 AS alias2
  ON (alias2.col_int_key = alias1.col_int_key)
  )
WHERE alias1.col_int_key = 207
ORDER BY alias1.col_varchar_key, field1;

DROP TABLE t1; 
--echo #
--echo # Bug#11807437: VALGRIND WARNING IN MYSQL_DERIVED_OPTIMIZE() LINE 293
--echo #
CREATE TABLE t1 (
  f1 int(11) DEFAULT NULL
);

SELECT 1
FROM (
  SELECT 1, 2 FROM DUAL
  WHERE EXISTS  (
    SELECT f1
    FROM  t1
    )) AS tt
;

DROP TABLE t1;
--echo #

--echo #
--echo # Bug#11808582: VALGRIND ON WL#5274: INVALID WRITE IN MC_REPLACE_STRMEM.C:493) 
--echo #
CREATE TABLE t1 (
  pk INT NOT NULL AUTO_INCREMENT,
  col_int_key INT,
  col_time_key time,
  col_varchar_key VARCHAR(1),
  PRIMARY KEY (pk),
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key,col_int_key)
) ENGINE=InnoDB;
SELECT tt.col_time_key
FROM ( ( SELECT * FROM t1 ) AS tt
  INNER JOIN t1
  ON (t1.col_int_key = tt.col_int_key)
  )
WHERE tt.col_int_key = 207
ORDER BY tt.col_varchar_key, tt.pk ASC, 1;

DROP TABLE t1;
--echo #
--echo # Bug#11791677 - ASSERTION FAILED IN JOIN_MATERIALIZE_TABLE IN
--echo #                SQL_SELECT.CC ON NESTED SUBQUERY 
--echo #
CREATE TABLE t1 (
  pk int(11) NOT NULL AUTO_INCREMENT,
  col_int_key int(11) DEFAULT NULL,
  col_varchar_key varchar(1) DEFAULT NULL,
  PRIMARY KEY (pk),
  KEY col_varchar_key (col_varchar_key,col_int_key)
);

INSERT INTO t1 VALUES (10,8,'v'), (29,4,'c');
  
CREATE TABLE t2 (  
  pk int(11) NOT NULL AUTO_INCREMENT,
  col_int_nokey int(11) DEFAULT NULL,
  col_varchar_key varchar(1) DEFAULT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t2 VALUES (16,1,'c'), (20,4,'d');

CREATE TABLE t3 (
  `field1` varchar(1) DEFAULT NULL,
  `field2` int(11) DEFAULT NULL
);

INSERT INTO t3 VALUES ('m',6),('c',4);

SELECT *
FROM t3
WHERE (field1, field2) IN (
  SELECT t1.col_varchar_key AS field1,
         t1.col_int_key AS field2
  FROM ( t1 INNER JOIN (
      SELECT t2.*
      FROM t2
      WHERE t2.col_int_nokey < t2.pk ) AS alias2
    ON (alias2.col_varchar_key = t1.col_varchar_key ) )
  GROUP BY field1, field2
  ORDER BY t1.col_int_key, t1 .pk DESC )
;

DROP TABLE t1,t2,t3;
--echo #

--echo #
--echo # Bug#11791705 - CRASH IN JOIN_MATERIALIZE_TABLE OR ASSERTION FAIL:
--echo #                !TAB->SAVE_READ_FIRST_RECORD
--echo #
CREATE TABLE t1 (a INTEGER);
INSERT INTO t1 VALUES (NULL),(NULL);

SELECT * FROM t1
WHERE (a, a) NOT IN
  (SELECT * FROM (SELECT 8, 4 UNION SELECT 2, 3) tt) ;

DROP TABLE t1; 
--echo #
--echo # Bug#11791649 - ASSERT: FIXED == 0, IN ITEM.CC ON EXPLAIN WITH VIEW
--echo #                IN SUBQUERY 
--echo #
CREATE TABLE t1 (pk int);
INSERT INTO t1 VALUES (1);

CREATE TABLE t2 (col_varchar_nokey varchar(1));
INSERT INTO t2 VALUES ('m'), ('f');

EXPLAIN SELECT pk
FROM t1
WHERE (2) IN
  ( SELECT *
     FROM (SELECT COUNT(col_varchar_nokey) FROM t2) d
  )
; 
DROP TABLE t1,t2;
--echo #

--echo #
--echo # Bug#12735934 - Lost LIMIT clause caused wrong result.
--echo #
CREATE TABLE t1 (f1 VARCHAR(1), key(f1));
INSERT INTO t1 VALUES ('a');
CREATE VIEW v1 AS SELECT f1 FROM t1 ORDER BY 1 LIMIT 0;
SELECT * FROM v1;
DROP VIEW v1;
DROP TABLE t1;

--echo #

--echo #
--echo # Bug#12726927: An outdated assertion caused server failure.
--echo #
CREATE TABLE t1 (
  pk int(11) NOT NULL AUTO_INCREMENT,
  col_int_nokey int(11) NOT NULL,
  col_varchar_key varchar(1) NOT NULL,
  PRIMARY KEY (pk),
  KEY col_varchar_key (col_varchar_key)
) ENGINE=MyISAM;

INSERT INTO t1 VALUES (10,1,'v'), (24,18,'h');

CREATE TABLE t2 (
  pk int(11) NOT NULL AUTO_INCREMENT,
  col_date_key date NOT NULL,
  col_date_nokey date NOT NULL,
  col_time_nokey time NOT NULL,
  col_varchar_key varchar(1) NOT NULL,
  col_varchar_nokey varchar(1) NOT NULL,
  PRIMARY KEY (pk),
  KEY col_date_key (col_date_key),
  KEY col_varchar_key (col_varchar_key)
) ENGINE=MyISAM;

INSERT INTO t2 VALUES (1,'1900-01-01','1900-01-01','00:00:00','k','k');

SELECT OUTR.col_date_key
FROM t2 AS OUTR2
  LEFT JOIN t2 AS OUTR ON OUTR2.pk < OUTR.pk
WHERE ( OUTR.col_varchar_nokey , OUTR.col_varchar_key )
  IN (
    SELECT DISTINCT col_varchar_key , col_varchar_key
    FROM t1
    WHERE col_int_nokey XOR OUTR.col_time_nokey
  )
  XOR OUTR.col_date_nokey IS NULL
;

DROP TABLE t1,t2;
--echo #

--echo #
--echo # Bug#12799731 - CRASH IN END_READ_RECORD.
--echo #
create table t1(f1 char(255) charset utf8);
insert into t1 values('1'),('2'),('3'),('4'),('5'),('6'),('7'),('8'),('9'),('0');
set @save_heap_size= @@max_heap_table_size;
set @@max_heap_table_size= 1;
flush status;
select count(*) from t1 join (
  select t1.f1 from t1 join t1 as t2 join t1 as t3) tt on t1.f1 = tt.f1;
--echo Should be greater than 1000 as it also includes records dumped from
--echo heap to myisam.
show status like 'Handler_write';
set @@max_heap_table_size= @save_heap_size;
drop table t1;

--echo #

--echo #
--echo # Bug#12896124: Crash on rqg_mdl_stability test
--echo #
CREATE TABLE t1(f1 INT);
INSERT INTO t1 VALUES (1),(2),(3);
CREATE FUNCTION func1 (param1 INTEGER) RETURNS INT NOT DETERMINISTIC
return param1;
CREATE FUNCTION func2 (param1 INTEGER) RETURNS INT 
return param1;
SELECT * FROM (SELECT * FROM t1) tt WHERE f1 = func1(f1);
EXPLAIN SELECT * FROM (SELECT * FROM t1) tt WHERE f1 = func1(f1);
SELECT * FROM (SELECT * FROM t1) tt WHERE f1 = func2(f1);
EXPLAIN SELECT * FROM (SELECT * FROM t1) tt WHERE f1 = func2(f1);
DROP FUNCTION func1;
DROP FUNCTION func2;
DROP TABLE t1;
--echo #

--echo #
--echo # Bug#12909844: Missing type cast caused false assertion
--echo #
CREATE TABLE t1 ( fk INT) ENGINE=INNODB;
CREATE TABLE t2 (
f1 INT,  f2 INT,  f3 INT,  f4 INT,  f5 INT,  f6 INT,
f7 INT,  f8 INT,  f9 INT,  f10 INT, f11 INT, f12 INT,
f13 INT, f14 INT, f15 INT, f16 INT, f17 INT, f18 INT,
f19 INT, f20 INT, f21 INT, f22 INT, f23 INT, f24 INT,
f25 INT, f26 INT, f27 INT, f28 INT, f29 INT, f30 INT,
f31 INT, f32 TEXT, fk INT) ENGINE=INNODB;
SELECT alias2.fk AS field1 FROM t1 AS alias1 JOIN
  (SELECT * FROM t2 ) AS alias2 ON alias1.fk = alias2.fk;
EXPLAIN 
SELECT alias2.fk AS field1 FROM t1 AS alias1 JOIN
  (SELECT * FROM t2 ) AS alias2 ON alias1.fk = alias2.fk;
DROP TABLE t1, t2;
--echo #

--echo #
--echo # Bug#12910039: Incorrect merge caused segmentation fault.
--echo #
CREATE TABLE t1 (f1 int) ENGINE=myisam;
CREATE TABLE t2 (f1 text) ENGINE=innodb;
SELECT 1 FROM (
  ( SELECT * FROM ( SELECT * FROM t2 ) AS alias1 ) AS alias1,
  ( SELECT * FROM t1 ) AS alias2 );
DROP TABLE t1,t2;
--echo #

--echo #
--echo # Bug#12910006: MRR initialization on a derived table caused crash.
--echo #
SET @save_switch= @@SESSION.optimizer_switch;
SET @@SESSION.optimizer_switch="batched_key_access=on";

CREATE TABLE t1 ( pk integer auto_increment,
col_blob_key blob, primary key (pk)) ENGINE=innodb;

CREATE TABLE t2 (col_tinytext tinytext null,
pk integer auto_increment, col_text text,
col_blob blob, primary key (pk)) ENGINE=innodb;

SELECT alias1.col_text AS field1 ,
       alias1.col_tinytext AS field2
FROM t2 AS alias1
  LEFT OUTER JOIN ( SELECT * FROM t1 ) AS alias2 ON alias1.pk = alias2.pk
WHERE alias2.pk >=1  AND alias2.pk < 3
ORDER BY field1,field2 ASC;

SET @@SESSION.optimizer_switch= @save_switch;
DROP TABLE t1, t2;

--echo #
--echo # Bug#13106350: MRR initialization on a derived table caused crash.
--echo #

# IMPORTANT: Enable these switch settings when backporting is merged to trunk
# SET @save_switch= @@optimizer_switch;
# SET @@optimizer_switch="materialization=off";

CREATE TABLE t1 (pk INTEGER PRIMARY KEY, vc VARCHAR(20));

INSERT INTO t1 VALUES(7, 'seven'), (13, 'thirteen');

CREATE TABLE t2 (pk INTEGER PRIMARY KEY, vc1 VARCHAR(20), vc2 VARCHAR(20));

INSERT INTO t2 VALUES(7, 'seven', 's'), (14, 'fourteen', 'f');

CREATE TABLE t3 (pk INTEGER PRIMARY KEY, vc VARCHAR(20));

INSERT INTO t3 VALUES(5, 'f'), (6, 's'), (7, 's');

let $query=
SELECT derived.vc
FROM (SELECT * FROM t1) AS derived
WHERE derived.vc IN (
  SELECT t2.vc1
  FROM t2 JOIN t3 ON t2.vc2=t3.vc);
eval explain $query;
eval $query;

# SET @@optimizer_switch= @save_switch;

DROP TABLE t1, t2, t3;

--echo #

--echo #
--echo # Bug#13107577: Derived table in a semi-join caused failed assertion. 
--echo #
CREATE TABLE t1 (
  `col_int_key` int(11) NOT NULL,
  `col_varchar_nokey` varchar(1) NOT NULL
) ENGINE=MyISAM;

INSERT INTO t1 VALUES (8,'m'), (4,'b'), (4,'x'), (7,'g'), (4,'p');

CREATE VIEW v1 AS SELECT * FROM t1;

SELECT col_int_key
FROM t1
WHERE ( NOT EXISTS (
  SELECT col_varchar_nokey
  FROM t1 
  WHERE ( 7 ) IN (
      SELECT v1.col_int_key
      FROM ( v1 JOIN ( SELECT * FROM t1 ) AS d1
        ON ( d1.col_varchar_nokey = v1.col_varchar_nokey ) )
    )
) )
;

DROP VIEW v1;
DROP TABLE t1;
--echo #

--echo #
--echo # Bug#13105833: Crash when using LooseScan sj-strategy for a view.
--echo #
CREATE TABLE t1 (pk int(11)) ENGINE=InnoDB; 
INSERT INTO t1 VALUES (1);

CREATE TABLE t2 (pk int(11)) ENGINE=InnoDB; 
INSERT INTO t2 VALUES (1), (2), (3);

CREATE VIEW v1 AS SELECT DISTINCT pk FROM t1;

SELECT pk 
FROM t2
WHERE pk IN ( SELECT * FROM v1 ) ;

DROP TABLE t1,t2;
DROP VIEW v1;

--echo #

--echo #
--echo # Bug#13261277: Unchecked key length caused missing records.
--echo #
CREATE TABLE t1 (  
  col_varchar varchar(1024) CHARACTER SET utf8 DEFAULT NULL,
  stub1 varchar(1024) CHARACTER SET utf8 DEFAULT NULL,
  stub2 varchar(1024) CHARACTER SET utf8 DEFAULT NULL,
  stub3 varchar(1024) CHARACTER SET utf8 DEFAULT NULL
);

INSERT INTO t1 VALUES
  ('d','d','l','ther'),
  (NULL,'s','NJBIQ','trzetuchv'),
  (-715390976,'coul','MYWFB','cfhtrzetu'),
  (1696792576,'f','i\'s','c'),
  (1,'i','ltpemcfhtr','gsltpemcf'),
  (-663027712,'mgsltpemcf','sa','amgsltpem'),
  (-1686700032,'JPRVK','i','vamgsltpe'),
  (NULL,'STUNB','UNVJV','u'),
  (5,'oka','qyihvamgsl','AXSMD'),
  (NULL,'tqwmqyihva','h','yntqwmqyi'),
  (3,'EGMJN','e','e');

CREATE TABLE t2 (
  col_varchar varchar(10) DEFAULT NULL,
  col_int INT DEFAULT NULL
);

INSERT INTO t2 VALUES ('d',9);

SET @save_heap_size= @@max_heap_table_size;
SET @@max_heap_table_size= 16384;

SELECT t2.col_int
FROM t2
    RIGHT JOIN ( SELECT * FROM t1 ) AS dt 
  ON t2.col_varchar = dt.col_varchar
WHERE t2.col_int IS NOT NULL ;

--echo # Shouldn't use auto_key0 for derived table
EXPLAIN 
SELECT t2.col_int
FROM t2
    RIGHT JOIN ( SELECT * FROM t1 ) AS dt
  ON t2.col_varchar = dt.col_varchar
WHERE t2.col_int IS NOT NULL ;

SET @@max_heap_table_size= @save_heap_size;
DROP TABLE t1,t2;
--echo #

--echo #
--echo # Bug#13383857: Another crash in memcpy from
--echo #               join_cache::write_record_data with semijoin
--echo #

CREATE TABLE t1 (
  col_int_key INT DEFAULT NULL,
  col_time_nokey TIME DEFAULT NULL,
  col_varchar_key VARCHAR(1) DEFAULT NULL,
  col_varchar_nokey VARCHAR(1) DEFAULT NULL,
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key,col_int_key)
);

INSERT INTO t1 VALUES
 (8,'22:55:23','x','x'),
 (7,'10:19:31','d','d'),
 (1,'14:40:36','r','r'),
 (7,'04:37:47','f','f'),
 (9,'19:34:06','y','y'),
 (NULL,'20:35:33','u','u'),
 (1,NULL,'m','m'),
 (9,'14:43:37',NULL,NULL),
 (2,'02:23:09','o','o'),
 (9,'01:22:45','w','w'),
 (2,'00:00:00','m','m'),
 (4,'00:13:25','q','q'),
 (0,'03:47:16',NULL,NULL),
 (4,'01:41:48','d','d'),
 (8,'00:00:00','g','g'),
 (NULL,'22:32:04','x','x'),
 (NULL,'16:44:14','f','f'),
 (0,'17:38:37','p','p'),
 (NULL,'08:46:48','j','j'),
 (8,'14:11:27','c','c');

CREATE TABLE t2 (
  col_int_key INT DEFAULT NULL,
  col_time_nokey TIME DEFAULT NULL,
  col_varchar_key VARCHAR(1) DEFAULT NULL,
  col_varchar_nokey VARCHAR(1) DEFAULT NULL,
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key,col_int_key)
);

INSERT INTO t2 VALUES
 (4,'22:34:09','v','v'),
 (62,'14:26:02','v','v'),
 (7,'14:03:03','c','c'),
 (1,'01:46:09',NULL,NULL),
 (0,'16:21:18','x','x'),
 (7,'18:56:33','i','i'),
 (7,NULL,'e','e'),
 (1,'09:29:08','p','p'),
 (7,'19:11:10','s','s'),
 (1,'11:57:26','j','j'),
 (5,'00:39:46','z','z'),
 (2,'03:28:15','c','c'),
 (0,'06:44:18','a','a'),
 (1,'14:36:39','q','q'),
 (8,'18:42:45','y','y'),
 (1,'02:57:29',NULL,NULL),
 (1,'16:46:13','r','r'),
 (9,'19:39:02','v','v'),
 (1,NULL,NULL,NULL),
 (5,'20:58:33','r','r');

CREATE TABLE t3 (
  col_int_key INT DEFAULT NULL,
  col_time_nokey TIME DEFAULT NULL,
  col_varchar_key VARCHAR(1) DEFAULT NULL,
  col_varchar_nokey VARCHAR(1) DEFAULT NULL,
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key,col_int_key)
);

INSERT INTO t3 VALUES (8,'04:07:22','g','g');

let $query=
SELECT col_time_nokey AS x
FROM (SELECT * FROM t2) AS outr
WHERE col_varchar_nokey IN (
  SELECT innr.col_varchar_key
  FROM (SELECT * FROM t3) AS innr2
    LEFT JOIN (SELECT * FROM t1) AS innr
    ON innr2.col_varchar_key >= innr.col_varchar_key
  WHERE outr.col_varchar_nokey = 'e'
  )
  AND outr.col_varchar_key <> 'r'
;
eval explain $query;
eval $query;

DROP TABLE t1, t2, t3;

--echo #
--echo # Bug#13354889: Crash on a derived table with more than 64 fields.
--echo #
create table t1 (
field00 int, field01 int, field02 int, field03 int,
field04 int, field05 int, field06 int, field07 int,
field10 int, field11 int, field12 int, field13 int,
field14 int, field15 int, field16 int, field17 int,
field20 int, field21 int, field22 int, field23 int,
field24 int, field25 int, field26 int, field27 int,
field30 int, field31 int, field32 int, field33 int,
field34 int, field35 int, field36 int, field37 int,
field40 int, field41 int, field42 int, field43 int,
field44 int, field45 int, field46 int, field47 int,
field50 int, field51 int, field52 int, field53 int,
field54 int, field55 int, field56 int, field57 int,
field60 int, field61 int, field62 int, field63 int,
field64 int, field65 int, field66 int, field67 int,
field70 int, field71 int, field72 int, field73 int,
field74 int, field75 int, field76 int, field77 int,
field100 int
);

insert into t1(field100) values (1),(2),(3),(4),(5),(6),(7),(8),(9),(0);
insert into t1 select * from t1;
insert into t1 select * from t1;
insert into t1 select * from t1;

select tt.field100 from t1 join (select * from t1) tt where t1.field100=tt.field100
limit 1;
--echo Should use auto_key0 and ref access.
explain 
select tt.field100 from t1 join (select * from t1) tt where t1.field100=tt.field100
limit 1;

drop table t1;
--echo #

--echo #
--echo # Bug#13390138: crash in memcpy from join_cache::write_record_data
--echo #

CREATE TABLE t1 (
  col_varchar_key varchar(1),
  col_varchar_nokey varchar(1),
  KEY col_varchar_key (col_varchar_key)
) ENGINE=MyISAM;

INSERT INTO t1 VALUES ('r','r');

CREATE TABLE t2 (
  col_varchar_key varchar(1),
  col_varchar_nokey varchar(1),
  KEY col_varchar_key (col_varchar_key)
);

INSERT INTO t2 VALUES
 (NULL,NULL),
 ('r','r');

CREATE TABLE t3 (
  col_int_key int,
  col_varchar_key varchar(1),
  col_varchar_nokey varchar(1),
  KEY col_int_key (col_int_key),
  KEY col_varchar_key (col_varchar_key, col_int_key)
);

INSERT INTO t3 VALUES
 (9,'f','f'),
 (4,'y','y'),
 (3,'u','u'),
 (2,'m','m'),
 (NULL,NULL,NULL),
 (2,'o','o'),
 (NULL,'r','r'),
 (6,'m','m'),
 (7,'q','q'),
 (6,'c','c');

let $query=
SELECT grandparent.col_varchar_nokey AS g1
FROM (SELECT * FROM t3) AS grandparent
WHERE grandparent.col_varchar_nokey IN
 (SELECT parent.col_varchar_key AS p1
  FROM (SELECT * FROM t2) AS parent
  WHERE grandparent.col_varchar_key IN (
    SELECT child1.col_varchar_key AS c1
    FROM (SELECT * FROM t1) AS child1
      LEFT JOIN (SELECT * FROM t2) AS child2
      ON child1.col_varchar_nokey <> child2.col_varchar_key
    )
    AND grandparent.col_int_key IS UNKNOWN
  )
ORDER BY grandparent.col_varchar_nokey;

eval explain $query;
eval $query;

DROP TABLE t1, t2, t3;

--echo #
--echo # Bug#13457552: Crash on instantiating a derived table in a query with
--echo #               empty result.
--echo #
CREATE TABLE t1 ( pk INT, col_blob BLOB ) ENGINE = MyISAM;
CREATE TABLE t2 ( pk INT, col_blob BLOB ) ENGINE = InnoDB;
SELECT pk FROM ( SELECT col_blob, pk FROM t2 ) AS A NATURAL JOIN t1;
EXPLAIN SELECT pk FROM ( SELECT col_blob, pk FROM t2 ) AS A NATURAL JOIN t1;
DROP TABLE t1,t2;

--echo #
--echo # Bug #13801019 ASSERTION `0' FAILED IN CREATE_MYISAM_TMP_TABLE
--echo #

CREATE TABLE t1 (a INT, b BLOB) ENGINE=InnoDB;
CREATE TABLE t2 (c INT);
CREATE TABLE t3 (d INT);
INSERT INTO t3 VALUES (0);

SELECT * FROM (SELECT * FROM t1) AS a1 RIGHT JOIN t3 LEFT JOIN t2 ON d=c ON a=c;

DROP TABLE t1, t2, t3;

--echo #
--echo # Bug #17814492 - INVALID RESULTS FROM SUBQUERY WITH IN CLAUSE
--echo #

CREATE TABLE t1 (
 a INTEGER NOT NULL,
 b VARCHAR(1000) NOT NULL,
 c TEXT NOT NULL
)ENGINE=InnoDB;

INSERT INTO t1 VALUES (1, 'xxx', 'abc');
INSERT INTO t1 VALUES (2, 'yyy', 'abc');
INSERT INTO t1 SELECT a, b, c FROM t1 WHERE b='yyy';
INSERT INTO t1 SELECT a, b, c FROM t1 WHERE b='yyy';
INSERT INTO t1 SELECT a, b, c FROM t1 WHERE b='yyy';

CREATE TABLE t2 (
 a INTEGER NOT NULL
)ENGINE=InnoDB;

INSERT INTO t2 VALUES (1), (2);

SET @save_optimizer_switch= @@optimizer_switch;
SET @@SESSION.optimizer_switch="index_condition_pushdown=on";

EXPLAIN SELECT a1.a, a1.b, a1.c FROM (SELECT a, b, c FROM t1 ) a1
JOIN t2 ON a1.a=t2.a WHERE a1.b='xxx';

SELECT a1.a, a1.b, a1.c FROM (SELECT a, b, c FROM t1 ) a1
JOIN t2 ON a1.a=t2.a WHERE a1.b='xxx';

SET @@SESSION.optimizer_switch= @save_optimizer_switch;

DROP TABLE t2, t1;

--echo # End of test for Bug #17814492
