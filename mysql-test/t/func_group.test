#
# simple test of all group functions
#

--disable_warnings
drop table if exists t1,t2,t3,t4,t5,t6;
--enable_warnings

set @sav_dpi= @@div_precision_increment;
set div_precision_increment= 5;
show variables like 'div_precision_increment';
create table t1 (grp int, a bigint unsigned, c char(10) not null);
insert into t1 values (1,1,"a");
insert into t1 values (2,2,"b");
insert into t1 values (2,3,"c");
insert into t1 values (3,4,"E");
insert into t1 values (3,5,"C");
insert into t1 values (3,6,"D");

# Test of MySQL field extension with and without matching records.
#### Note: The two following statements may fail if the execution plan
#### or optimizer is changed. The result for column c is undefined.
select a,c,sum(a) from t1 group by a;
select a,c,sum(a) from t1 where a > 10 group by a;
select sum(a) from t1 where a > 10;
select a from t1 order by rand(10);
select distinct a from t1 order by rand(10);
select count(distinct a),count(distinct grp) from t1;
insert into t1 values (null,null,'');
select count(distinct a),count(distinct grp) from t1;

select sum(all a),count(all a),avg(all a),std(all a),variance(all a),bit_or(all a),bit_and(all a),min(all a),max(all a),min(all c),max(all c) from t1;
select grp, sum(a),count(a),avg(a),std(a),variance(a),bit_or(a),bit_and(a),min(a),max(a),min(c),max(c) from t1 group by grp;
--disable_warnings
select grp, sum(a)+count(a)+avg(a)+std(a)+variance(a)+bit_or(a)+bit_and(a)+min(a)+max(a)+min(c)+max(c) as sum from t1 group by grp;
--enable_warnings

create table t2 (grp int, a bigint unsigned, c char(10));
insert into t2 select grp,max(a)+max(grp),max(c) from t1 group by grp;

# REPLACE ... SELECT doesn't yet work with PS
replace into t2 select grp, a, c from t1 limit 2,1;
select * from t2;

drop table t1,t2;

#
# Problem with std()
#

CREATE TABLE t1 (id int(11),value1 float(10,2));
INSERT INTO t1 VALUES (1,0.00),(1,1.00), (1,2.00), (2,10.00), (2,11.00), (2,12.00); 
CREATE TABLE t2 (id int(11),name char(20)); 
INSERT INTO t2 VALUES (1,'Set One'),(2,'Set Two'); 
select id, avg(value1), std(value1), variance(value1) from t1 group by id;
select name, avg(value1), std(value1), variance(value1) from t1, t2 where t1.id = t2.id group by t1.id;
drop table t1,t2;

#
# Test of bug in left join & avg
#

create table t1 (id int not null);
create table t2 (id int not null,rating int null);
insert into t1 values(1),(2),(3);
insert into t2 values(1, 3),(2, NULL),(2, NULL),(3, 2),(3, NULL);
select t1.id, avg(rating) from t1 left join t2 on ( t1.id = t2.id ) group by t1.id;
# Test different types with avg()
select sql_small_result t2.id, avg(rating) from t2 group by t2.id;
select sql_big_result t2.id, avg(rating) from t2 group by t2.id;
select sql_small_result t2.id, avg(rating+0.0e0) from t2 group by t2.id;
select sql_big_result t2.id, avg(rating+0.0e0) from t2 group by t2.id;
drop table t1,t2;

#
# test of count
#
create table t1 (a smallint(6) primary key, c char(10), b text);
INSERT INTO t1 VALUES (1,'1','1');
INSERT INTO t1 VALUES (2,'2','2');
INSERT INTO t1 VALUES (4,'4','4');

select count(*) from t1;
select count(*) from t1 where a = 1;
select count(*) from t1 where a = 100;
select count(*) from t1 where a >= 10;
select count(a) from t1 where a = 1;
select count(a) from t1 where a = 100;
select count(a) from t1 where a >= 10;
select count(b) from t1 where b >= 2;
select count(b) from t1 where b >= 10;
select count(c) from t1 where c = 10;
drop table t1;

#
# Test of bug in COUNT(i)*(i+0)
#

CREATE TABLE t1 (d DATETIME, i INT);
INSERT INTO t1 VALUES (NOW(), 1);
SELECT COUNT(i), i, COUNT(i)*i FROM t1 GROUP BY i;
SELECT COUNT(i), (i+0), COUNT(i)*(i+0) FROM t1 GROUP BY i; 
DROP TABLE t1;

#
# Another SUM() problem with 3.23.2
#

create table t1 (
        num float(5,2),
        user char(20)
);
insert into t1 values (10.3,'nem'),(20.53,'monty'),(30.23,'sinisa');
insert into t1 values (30.13,'nem'),(20.98,'monty'),(10.45,'sinisa');
insert into t1 values (5.2,'nem'),(8.64,'monty'),(11.12,'sinisa');
select sum(num) from t1;
select sum(num) from t1 group by user;
drop table t1;

#
# Test problem with MIN() optimization in case of null values
#

create table t1 (a1 int, a2 char(3), key k1(a1), key k2(a2));
insert into t1 values(10,'aaa'), (10,null), (10,'bbb'), (20,'zzz');
create table t2(a1 char(3), a2 int, a3 real, key k1(a1), key k2(a2, a1));
select * from t1;
# The following returned NULL in 4.0.10
select min(a2) from t1;
select max(t1.a1), max(t2.a2) from t1, t2;
select max(t1.a1) from t1, t2;
select max(t2.a2), max(t1.a1) from t1, t2;

explain select min(a2) from t1;
explain select max(t1.a1), max(t2.a2) from t1, t2;

insert into t2 values('AAA', 10, 0.5);
insert into t2 values('BBB', 20, 1.0);
select t1.a1, t1.a2, t2.a1, t2.a2 from t1,t2;

SET @save_optimizer_switch=@@optimizer_switch;
SET optimizer_switch='outer_join_with_cache=off';
select max(t1.a1), max(t2.a1) from t1, t2 where t2.a2=9;
select max(t2.a1), max(t1.a1) from t1, t2 where t2.a2=9;
select t1.a1, t1.a2, t2.a1, t2.a2 from t1 left outer join t2 on t1.a1=10;
select max(t1.a2) from t1 left outer join t2 on t1.a1=10;
select max(t2.a1) from t2 left outer join t1 on t2.a2=10 where t2.a2=20;
select max(t2.a1) from t2 left outer join t1 on t2.a2=10 where t2.a2=10;
select max(t2.a1) from t1 left outer join t2 on t1.a2=t2.a1 and 1=0 where t2.a1='AAA';
select max(t1.a2),max(t2.a1) from t1 left outer join t2 on t1.a1=10;
SET optimizer_switch=@save_optimizer_switch;
drop table t1,t2;

#
# Test of group function and NULL values
#

CREATE TABLE t1 (a int, b int);
select count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1;
select a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
insert into t1 values (1,null);
select a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
insert into t1 values (1,null);
insert into t1 values (2,null);
select a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
select SQL_BIG_RESULT a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
insert into t1 values (2,1);
select a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
select SQL_BIG_RESULT a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
insert into t1 values (3,1);
select a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b) from t1 group by a;
select SQL_BIG_RESULT a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b), bit_xor(b) from t1 group by a;
explain extended select SQL_BIG_RESULT a,count(b), sum(b), avg(b), std(b), min(b), max(b), bit_and(b), bit_or(b), bit_xor(b) from t1 group by a;
drop table t1;

#
# Bug #1972: test for bit_and(), bit_or() and negative values
# 
create table t1 (col int);
insert into t1 values (-1), (-2), (-3);
select bit_and(col), bit_or(col) from t1;
select SQL_BIG_RESULT bit_and(col), bit_or(col) from t1 group by col;
drop table t1;

#
# Bug #3376: avg() and an empty table
#

create table t1 (a int);
select avg(2) from t1;
drop table t1;

#
# Tests to check MIN/MAX query optimization
#

# Create database schema
create table t1(
  a1 char(3) primary key,
  a2 smallint,
  a3 char(3),
  a4 real,
  a5 date,
  key k1(a2,a3),
  key k2(a4 desc,a1),
  key k3(a5,a1)
);
create table t2(
  a1 char(3) primary key,
  a2 char(17),
  a3 char(2),
  a4 char(3),
  key k1(a3, a2),
  key k2(a4)
);

# Populate table t1
insert into t1 values('AME',0,'SEA',0.100,date'1942-02-19');
insert into t1 values('HBR',1,'SEA',0.085,date'1948-03-05');
insert into t1 values('BOT',2,'SEA',0.085,date'1951-11-29');
insert into t1 values('BMC',3,'SEA',0.085,date'1958-09-08');
insert into t1 values('TWU',0,'LAX',0.080,date'1969-10-05');
insert into t1 values('BDL',0,'DEN',0.080,date'1960-11-27');
insert into t1 values('DTX',1,'NYC',0.080,date'1961-05-04');
insert into t1 values('PLS',1,'WDC',0.075,date'1949-01-02');
insert into t1 values('ZAJ',2,'CHI',0.075,date'1960-06-15');
insert into t1 values('VVV',2,'MIN',0.075,date'1959-06-28');
insert into t1 values('GTM',3,'DAL',0.070,date'1977-09-23');
insert into t1 values('SSJ',null,'CHI',null,date'1974-03-19');
insert into t1 values('KKK',3,'ATL',null,null);
insert into t1 values('XXX',null,'MIN',null,null);
insert into t1 values('WWW',1,'LED',null,null);

# Populate table t2
insert into t2 values('TKF','Seattle','WA','AME');
insert into t2 values('LCC','Los Angeles','CA','TWU');
insert into t2 values('DEN','Denver','CO','BDL');
insert into t2 values('SDC','San Diego','CA','TWU');
insert into t2 values('NOL','New Orleans','LA','GTM');
insert into t2 values('LAK','Los Angeles','CA','TWU');
insert into t2 values('AAA','AAA','AA','AME');

# Show the table contents
select * from t1;
select * from t2;

# Queries with min/max functions 
# which regular min/max optimization are applied to

explain 
select min(a1) from t1;
select min(a1) from t1;
explain 
select max(a4) from t1;
select max(a4) from t1;
explain 
select min(a5), max(a5) from t1;
select min(a5), max(a5) from t1;
explain 
select min(a3) from t1 where a2 = 2;
select min(a3) from t1 where a2 = 2;
explain 
select min(a1), max(a1) from t1 where a4 = 0.080;
select min(a1), max(a1) from t1 where a4 = 0.080;

explain 
select min(t1.a5), max(t2.a3) from t1, t2;
select min(t1.a5), max(t2.a3) from t1, t2;
explain 
select min(t1.a3), max(t2.a2) from t1, t2 where t1.a2 = 0 and t2.a3 = 'CA';
select min(t1.a3), max(t2.a2) from t1, t2 where t1.a2 = 0 and t2.a3 = 'CA';

# Queries with min/max functions 
# which extended min/max optimization are applied to

explain 
select min(a1) from t1 where a1 > 'KKK';
select min(a1) from t1 where a1 > 'KKK';
explain 
select min(a1) from t1 where a1 >= 'KKK';
select min(a1) from t1 where a1 >= 'KKK';
explain 
select max(a3) from t1 where a2 = 2 and a3 < 'SEA';
select max(a3) from t1 where a2 = 2 and a3 < 'SEA';
explain 
select max(a5) from t1 where a5 < date'1970-01-01';
select max(a5) from t1 where a5 < date'1970-01-01';
explain 
select max(a3) from t1 where a2 is null;
select max(a3) from t1 where a2 is null;
explain 
select max(a3) from t1 where a2 = 0 and a3 between 'K' and 'Q';
select max(a3) from t1 where a2 = 0 and a3 between 'K' and 'Q';
explain
select min(a1), max(a1) from t1 where a1 between 'A' and 'P';
select min(a1), max(a1) from t1 where a1 between 'A' and 'P';
explain 
select max(a3) from t1 where a3 < 'SEA' and a2 = 2 and a3 <= 'MIN';
select max(a3) from t1 where a3 < 'SEA' and a2 = 2 and a3 <= 'MIN';
explain 
select max(a3) from t1 where a3 = 'MIN' and a2 = 2;
select max(a3) from t1 where a3 = 'MIN' and a2 = 2;
explain 
select max(a3) from t1 where a3 = 'DEN' and a2 = 2;
select max(a3) from t1 where a3 = 'DEN' and a2 = 2;

explain
select max(t1.a3), min(t2.a2) from t1, t2 where t1.a2 = 2 and t1.a3 < 'MIN' and t2.a3 = 'CA';
select max(t1.a3), min(t2.a2) from t1, t2 where t1.a2 = 2 and t1.a3 < 'MIN' and t2.a3 = 'CA';

explain
select max(a3) from t1 where a2 is null and a2 = 2;
select max(a3) from t1 where a2 is null and a2 = 2;

explain
select max(a2) from t1 where a2 >= 1;
select max(a2) from t1 where a2 >= 1;
explain
select min(a3) from t1 where a2 = 2 and a3 < 'SEA';
select min(a3) from t1 where a2 = 2 and a3 < 'SEA';

explain
select min(a3) from t1 where a2 = 4;
select min(a3) from t1 where a2 = 4;
explain
select min(a3) from t1 where a2 = 2 and a3 > 'SEA';
select min(a3) from t1 where a2 = 2 and a3 > 'SEA';
explain
select (min(a4)+max(a4))/2 from t1;
select (min(a4)+max(a4))/2 from t1;
explain
select min(a3) from t1 where 2 = a2;
select min(a3) from t1 where 2 = a2;
explain
select max(a3) from t1 where a2 = 2 and 'SEA' > a3;
select max(a3) from t1 where a2 = 2 and 'SEA' > a3;
explain
select max(a3) from t1 where a2 = 2 and 'SEA' < a3;
select max(a3) from t1 where a2 = 2 and 'SEA' < a3;
explain
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI';
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI';
explain
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI' and a3 < 'SEA';
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI' and a3 < 'SEA';
explain
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI' and a3 = 'MIN';
select min(a3) from t1 where a2 = 2 and a3 >= 'CHI' and a3 = 'MIN';
explain
select min(a3) from t1 where a2 = 2 and a3 >= 'SEA' and a3 = 'MIN';
select min(a3) from t1 where a2 = 2 and a3 >= 'SEA' and a3 = 'MIN';

explain
select min(t1.a1), min(t2.a4) from t1,t2 where t1.a1 < 'KKK' and t2.a4 < 'KKK';
select min(t1.a1), min(t2.a4) from t1,t2 where t1.a1 < 'KKK' and t2.a4 < 'KKK';

# Queries to which max/min optimization is not applied

explain 
select min(a1) from t1 where a1 > 'KKK' or a1 < 'XXX';
explain 
select min(a1) from t1 where a1 != 'KKK';
explain
select max(a3) from t1 where a2 < 2 and a3 < 'SEA';
explain
select max(t1.a3), min(t2.a2) from t1, t2 where t1.a2 = 2 and t1.a3 < 'MIN' and t2.a3 > 'CA';

explain
select min(a4 - 0.01) from t1;
explain
select max(a4 + 0.01) from t1;
explain
select min(a3) from t1 where (a2 +1 ) is null;
explain
select min(a3) from t1 where (a2 + 1) = 2;
explain
select min(a3) from t1 where 2 = (a2 + 1);
explain
select min(a2) from t1 where a2 < 2 * a2 - 8;
explain
select min(a1) from t1  where a1 between a3 and 'KKK';
explain
select min(a4) from t1  where (a4 + 0.01) between 0.07 and 0.08;
explain
select concat(min(t1.a1),min(t2.a4)) from t1, t2 where t2.a4 <> 'AME';
drop table t1, t2;

# Moved to func_group_innodb
#--disable_warnings
#create table t1 (USR_ID integer not null, MAX_REQ integer not null, constraint PK_SEA_USER primary key (USR_ID)) engine=InnoDB;
#--enable_warnings
#insert into t1 values (1, 3);
#select count(*) + MAX_REQ - MAX_REQ + MAX_REQ - MAX_REQ + MAX_REQ - MAX_REQ + MAX_REQ - MAX_REQ + MAX_REQ - MAX_REQ from t1 group by MAX_REQ;
#select Case When Count(*) < MAX_REQ Then 1 Else 0 End from t1 where t1.USR_ID = 1 group by MAX_REQ;
#drop table t1;


create table t1 (a char(10));
insert into t1 values ('a'),('b'),('c');
select coercibility(max(a)) from t1;
drop table t1;

#
# Bug #6658 MAX(column) returns incorrect coercibility
#
create table t1 (a char character set latin2);
insert into t1 values ('a'),('b');
select charset(max(a)), coercibility(max(a)),
       charset(min(a)), coercibility(min(a)) from t1;
show create table t1;
create table t2 select max(a),min(a) from t1;
show create table t2;
drop table t2;
create table t2 select concat(a) from t1;
show create table t2;
drop table t2,t1;

#
# aggregate functions on static tables
#
create table t1 (a int);
insert into t1 values (1);
select max(a) as b from t1 having b=1;
select a from t1 having a=1;
drop table t1;

#
# Bug #3435: variance(const), stddev(const) and an empty table
#

create table t1 (a int);
select variance(2) from t1;
select stddev(2) from t1;
drop table t1;


#
# cleunup() of optimized away count(*) and max/min
#
create table t1 (a int);
insert into t1 values (1),(2);
prepare stmt1 from 'SELECT COUNT(*) FROM t1';
execute stmt1;
execute stmt1;
execute stmt1;
deallocate prepare stmt1;
drop table t1;

create table t1 (a int, primary key(a));
insert into t1 values (1),(2);
prepare stmt1 from 'SELECT max(a) FROM t1';
execute stmt1;
execute stmt1;
execute stmt1;
deallocate prepare stmt1;
drop table t1;

#
# Bug #5406 min/max optimization for empty set
#

CREATE TABLE t1 (a int primary key);
INSERT INTO t1 VALUES (1),(2),(3),(4);

SELECT MAX(a) FROM t1 WHERE a > 5;
SELECT MIN(a) FROM t1 WHERE a < 0;

DROP TABLE t1;

#
# Bug #5555 GROUP BY enum_field" returns incorrect results
#
 
CREATE TABLE t1 (
  id int(10) unsigned NOT NULL auto_increment,
  val enum('one','two','three') NOT NULL default 'one',
  PRIMARY KEY  (id)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
 
INSERT INTO t1 VALUES
(1,'one'),(2,'two'),(3,'three'),(4,'one'),(5,'two');
 
select val, count(*) from t1 group by val;
drop table t1;

CREATE TABLE t1 (
  id int(10) unsigned NOT NULL auto_increment,
  val set('one','two','three') NOT NULL default 'one',
  PRIMARY KEY  (id)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO t1 VALUES
(1,'one'),(2,'two'),(3,'three'),(4,'one'),(5,'two');

select val, count(*) from t1 group by val;
drop table t1;

#
# Bug #5615: type of aggregate function column wrong when using group by
#

create table t1(a int, b datetime);
insert into t1 values (1, NOW()), (2, NOW());
create table t2 select MAX(b) from t1 group by a;
show create table t2;
drop table t1, t2;

#
# Bug 7833:  Wrong datatype of aggregate column is returned
#

create table t1(f1 datetime);
insert into t1 values (now());
create table t2 select f2 from (select max(now()) f2 from t1) a;
show columns from t2;
drop table t2;
create table t2 select f2 from (select now() f2 from t1) a;
show columns from t2;
drop table t2, t1;

#
# Bug 8893: wrong result for min/max optimization with 2 indexes
#

CREATE TABLE t1(
  id int PRIMARY KEY,
  a  int,
  b  int,
  INDEX i_b_id(a,b,id),
  INDEX i_id(a,id)
);
INSERT INTO t1 VALUES 
  (1,1,4), (2,2,1), (3,1,3), (4,2,1), (5,1,1);
SELECT MAX(id) FROM t1 WHERE id < 3 AND a=2 AND b=6;
DROP TABLE t1;

# change the order of the last two index definitions

CREATE TABLE t1(
  id int PRIMARY KEY,
  a  int,
  b  int,
  INDEX i_id(a,id),
  INDEX i_b_id(a,b,id)
);
INSERT INTO t1 VALUES 
  (1,1,4), (2,2,1), (3,1,3), (4,2,1), (5,1,1);
SELECT MAX(id) FROM t1 WHERE id < 3 AND a=2 AND b=6;
DROP TABLE t1;


#
# Bug #12882  	min/max inconsistent on empty table
#
# Test case moved to func_group_innodb
#
# Bug #18206: min/max optimization cannot be applied to partial index
#

CREATE TABLE t1 (id int PRIMARY KEY, b char(3), INDEX(b));
INSERT INTO t1 VALUES (1,'xx'), (2,'aa');
SELECT * FROM t1;

SELECT MAX(b) FROM t1 WHERE b < 'ppppp';
SHOW WARNINGS;
SELECT MAX(b) FROM t1 WHERE b < 'pp';
DROP TABLE t1;

CREATE TABLE t1 (id int PRIMARY KEY, b char(16), INDEX(b(4)));
INSERT INTO t1 VALUES (1, 'xxxxbbbb'), (2, 'xxxxaaaa');
SELECT MAX(b) FROM t1;
EXPLAIN SELECT MAX(b) FROM t1;
DROP TABLE t1;

CREATE TABLE t1 (id int , b varchar(512), INDEX(b(250))) COLLATE latin1_bin;
INSERT INTO t1 VALUES
  (1,CONCAT(REPEAT('_', 250), "qq")), (1,CONCAT(REPEAT('_', 250), "zz")),
  (1,CONCAT(REPEAT('_', 250), "aa")), (1,CONCAT(REPEAT('_', 250), "ff"));

SELECT MAX(b) FROM t1;
EXPLAIN SELECT MAX(b) FROM t1;
DROP TABLE t1;
#
# Bug #16792  query with subselect, join, and group not returning proper values
#
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1),(1,2),(2,3);

SELECT (SELECT COUNT(DISTINCT t1.b)) FROM t1 GROUP BY t1.a;
SELECT (SELECT COUNT(DISTINCT 12)) FROM t1 GROUP BY t1.a;
# an attempt to test all aggregate function with no table.
SELECT AVG(2), BIT_AND(2), BIT_OR(2), BIT_XOR(2), COUNT(*), COUNT(12),
       COUNT(DISTINCT 12), MIN(2),MAX(2),STD(2), VARIANCE(2),SUM(2),
       GROUP_CONCAT(2),GROUP_CONCAT(DISTINCT 2);
DROP TABLE t1;

# End of 4.1 tests

#
# decimal-related tests
#
create table t2 (ff double);
insert into t2 values (2.2);
select cast(sum(distinct ff) as decimal(5,2)) from t2;
select cast(sum(distinct ff) as signed) from t2;
select cast(variance(ff) as decimal(10,3)) from t2;
select cast(min(ff) as decimal(5,2)) from t2;

create table t1 (df decimal(5,1));
insert into t1 values(1.1);
insert into t1 values(2.2);
select cast(sum(distinct df) as signed) from t1;
select cast(min(df) as signed) from t1;
select 1e8 * sum(distinct df) from t1;
select 1e8 * min(df) from t1;

create table t3 (ifl int);
insert into t3 values(1), (2);
select cast(min(ifl) as decimal(5,2)) from t3;

drop table t1, t2, t3;


#
# BUG#3190, WL#1639: Standard Deviation STDDEV - 2 different calculations
#

CREATE TABLE t1 (id int(11),value1 float(10,2));
INSERT INTO t1 VALUES (1,0.00),(1,1.00), (1,2.00), (2,10.00), (2,11.00), (2,12.00), (2,13.00);
select id, stddev_pop(value1), var_pop(value1), stddev_samp(value1), var_samp(value1) from t1 group by id;
DROP TABLE t1;

#
# BUG#8464 decimal AVG returns incorrect result
#

CREATE TABLE t1 (col1 decimal(16,12));
INSERT INTO t1 VALUES (-5.00000000001),(-5.00000000002),(-5.00000000003),(-5.00000000000),(-5.00000000001),(-5.00000000002);
insert into t1 select * from t1;
select col1,count(col1),sum(col1),avg(col1) from t1 group by col1;
DROP TABLE t1;

#
# BUG#8465 decimal MIN and MAX return incorrect result
#

create table t1 (col1 decimal(16,12));
insert into t1 values (-5.00000000001);
insert into t1 values (-5.00000000001);
select col1,sum(col1),max(col1),min(col1) from t1 group by col1;
delete from t1;
insert into t1 values (5.00000000001);
insert into t1 values (5.00000000001);
select col1,sum(col1),max(col1),min(col1) from t1 group by col1;
DROP TABLE t1;

#
# Test that new VARCHAR correctly works with COUNT(DISTINCT)
#

CREATE TABLE t1 (a VARCHAR(400));
INSERT INTO t1 (a) VALUES ("A"), ("a"), ("a "), ("a   "),
                          ("B"), ("b"), ("b "), ("b   ");
SELECT COUNT(DISTINCT a) FROM t1;
DROP TABLE t1;

#
# Test for buf #9210: GROUP BY with expression if a decimal type
#

CREATE TABLE t1 (a int, b int, c int);
INSERT INTO t1 (a, b, c) VALUES
  (1,1,1), (1,1,2), (1,1,3),
  (1,2,1), (1,2,2), (1,2,3),
  (1,3,1), (1,3,2), (1,3,3),
  (2,1,1), (2,1,2), (2,1,3),
  (2,2,1), (2,2,2), (2,2,3),
  (2,3,1), (2,3,2), (2,3,3),
  (3,1,1), (3,1,2), (3,1,3),
  (3,2,1), (3,2,2), (3,2,3),
  (3,3,1), (3,3,2), (3,3,3);

SELECT b/c as v, a FROM t1 ORDER BY v;
SELECT b/c as v, SUM(a) FROM t1 GROUP BY v;
SELECT SUM(a) FROM t1 GROUP BY b/c;

DROP TABLE t1;
set div_precision_increment= @sav_dpi;

#
# Bug #20868: Client connection is broken on SQL query error
#
CREATE TABLE t1 (a INT PRIMARY KEY, b INT);
INSERT INTO t1 VALUES (1,1), (2,2);

CREATE TABLE t2 (a INT PRIMARY KEY, b INT);
INSERT INTO t2 VALUES (1,1), (3,3);

SELECT SQL_NO_CACHE 
  (SELECT SUM(c.a) FROM t1 ttt, t2 ccc 
   WHERE ttt.a = ccc.b AND ttt.a = t.a GROUP BY ttt.a) AS minid   
FROM t1 t, t2 c WHERE t.a = c.b;

DROP TABLE t1,t2;

#
# Bug #10966: Variance functions return wrong data type
#

create table t1 select variance(0);                                               
show create table t1;                                                           
drop table t1;                                                                  
create table t1 select stddev(0);
show create table t1;
drop table t1;
 

#
# Bug#22555: STDDEV yields positive result for groups with only one row
#

create table bug22555 (i smallint primary key auto_increment, s1 smallint, s2 smallint, e decimal(30,10), o double);
insert into bug22555 (s1, s2, e, o) values (53, 78, 11.4276528, 6.828112), (17, 78, 5.916793, 1.8502951), (18, 76, 2.679231, 9.17975591), (31, 62, 6.07831, 0.1), (19, 41, 5.37463, 15.1), (83, 73, 14.567426, 7.959222), (92, 53, 6.10151, 13.1856852), (7, 12, 13.92272, 3.442007), (92, 35, 11.95358909, 6.01376678), (38, 84, 2.572, 7.904571);
select std(s1/s2) from bug22555 group by i;
select std(e) from bug22555 group by i;
select std(o) from bug22555 group by i;
drop table bug22555;

create table bug22555 (i smallint, s1 smallint, s2 smallint, o1 double, o2 double, e1 decimal, e2 decimal);
insert into bug22555 values (1,53,78,53,78,53,78),(2,17,78,17,78,17,78),(3,18,76,18,76,18,76);
select i, count(*) from bug22555 group by i;
select std(s1/s2) from bug22555 where i=1;
select std(s1/s2) from bug22555 where i=2;
select std(s1/s2) from bug22555 where i=3;
select std(s1/s2) from bug22555 where i=1 group by i;
select std(s1/s2) from bug22555 where i=2 group by i;
select std(s1/s2) from bug22555 where i=3 group by i;
select std(s1/s2) from bug22555 group by i order by i;
select i, count(*), std(o1/o2) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
set @saved_div_precision_increment=@@div_precision_increment;
set div_precision_increment=19;
select i, count(*), variance(s1/s2) from bug22555 group by i order by i;
select i, count(*), variance(o1/o2) from bug22555 group by i order by i;
select i, count(*), variance(e1/e2) from bug22555 group by i order by i;
select i, count(*), std(s1/s2) from bug22555 group by i order by i;
select i, count(*), std(o1/o2) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
set div_precision_increment=20;
select i, count(*), variance(s1/s2) from bug22555 group by i order by i;
select i, count(*), variance(o1/o2) from bug22555 group by i order by i;
select i, count(*), variance(e1/e2) from bug22555 group by i order by i;
select i, count(*), std(s1/s2) from bug22555 group by i order by i;
select i, count(*), std(o1/o2) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
set @@div_precision_increment=@saved_div_precision_increment;
insert into bug22555 values (1,53,78,53,78,53,78),(2,17,78,17,78,17,78),(3,18,76,18,76,18,76);
insert into bug22555 values (1,53,78,53,78,53,78),(2,17,78,17,78,17,78),(3,18,76,18,76,18,76);
insert into bug22555 values (1,53,78,53,78,53,78),(2,17,78,17,78,17,78),(3,18,76,18,76,18,76);

select i, count(*), std(s1/s2) from bug22555 group by i order by i;
select i, count(*), round(std(o1/o2), 16) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
select std(s1/s2) from bug22555;
select std(o1/o2) from bug22555;
select std(e1/e2) from bug22555;
set @saved_div_precision_increment=@@div_precision_increment;
set div_precision_increment=19;
select i, count(*), std(s1/s2) from bug22555 group by i order by i;
select i, count(*), round(std(o1/o2), 16) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
select round(std(s1/s2), 17) from bug22555;
select std(o1/o2) from bug22555;
select round(std(e1/e2), 17) from bug22555;
set div_precision_increment=20;
select i, count(*), std(s1/s2) from bug22555 group by i order by i;
select i, count(*), round(std(o1/o2), 16) from bug22555 group by i order by i;
select i, count(*), std(e1/e2) from bug22555 group by i order by i;
select round(std(s1/s2), 17) from bug22555;
select std(o1/o2) from bug22555;
select round(std(e1/e2), 17) from bug22555;
set @@div_precision_increment=@saved_div_precision_increment;
drop table bug22555;

create table bug22555 (s smallint, o double, e decimal);
insert into bug22555 values (1,1,1),(2,2,2),(3,3,3),(6,6,6),(7,7,7);
select var_samp(s), var_pop(s) from bug22555;
select var_samp(o), var_pop(o) from bug22555;
select var_samp(e), var_pop(e) from bug22555;
drop table bug22555;

create table bug22555 (s smallint, o double, e decimal);
insert into bug22555 values (null,null,null),(null,null,null);
select var_samp(s) as 'null', var_pop(s) as 'null' from bug22555;
select var_samp(o) as 'null', var_pop(o) as 'null' from bug22555;
select var_samp(e) as 'null', var_pop(e) as 'null' from bug22555;
insert into bug22555 values (1,1,1);
select var_samp(s) as 'null', var_pop(s) as '0' from bug22555;
select var_samp(o) as 'null', var_pop(o) as '0' from bug22555;
select var_samp(e) as 'null', var_pop(e) as '0' from bug22555;
insert into bug22555 values (2,2,2);
select var_samp(s) as '0.5', var_pop(s) as '0.25' from bug22555;
select var_samp(o) as '0.5', var_pop(o) as '0.25' from bug22555;
select var_samp(e) as '0.5', var_pop(e) as '0.25' from bug22555;
drop table bug22555;


#
# Bug #21976: Unnecessary warning with count(decimal)
#

create table t1 (a decimal(20));
insert into t1 values (12345678901234567890);
select count(a) from t1;
select count(distinct a) from t1;
drop table t1;

#
# Bug #23184: SELECT causes server crash
# 
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8);
INSERT INTO t1 SELECT a, b+8       FROM t1;
INSERT INTO t1 SELECT a, b+16      FROM t1;
INSERT INTO t1 SELECT a, b+32      FROM t1;
INSERT INTO t1 SELECT a, b+64      FROM t1;
INSERT INTO t1 SELECT a, b+128     FROM t1;
INSERT INTO t1 SELECT a, b+256     FROM t1;
INSERT INTO t1 SELECT a, b+512     FROM t1;
INSERT INTO t1 SELECT a, b+1024    FROM t1;
INSERT INTO t1 SELECT a, b+2048    FROM t1;
INSERT INTO t1 SELECT a, b+4096    FROM t1;
INSERT INTO t1 SELECT a, b+8192    FROM t1;
INSERT INTO t1 SELECT a, b+16384   FROM t1;
INSERT INTO t1 SELECT a, b+32768   FROM t1;
SELECT a,COUNT(DISTINCT b) AS cnt FROM t1 GROUP BY a HAVING cnt > 50;
SELECT a,SUM(DISTINCT b) AS sumation FROM t1 GROUP BY a HAVING sumation > 50;
SELECT a,AVG(DISTINCT b) AS average FROM t1 GROUP BY a HAVING average > 50;

DROP TABLE t1;

#
# Bug #27573: MIN() on an indexed column which is always NULL sets _other_ 
# results to NULL
#
CREATE TABLE t1 ( a INT, b INT, KEY(a) );
INSERT INTO t1 VALUES (NULL, 1), (NULL, 2);
EXPLAIN SELECT MIN(a), MIN(b) FROM t1;
SELECT MIN(a), MIN(b) FROM t1;

CREATE TABLE t2( a INT, b INT, c INT, KEY(a, b) );
INSERT INTO t2 ( a, b, c ) VALUES ( 1, NULL, 2 ), ( 1, 3, 4 ), ( 1, 4, 4 );
EXPLAIN SELECT MIN(b), MIN(c) FROM t2 WHERE a = 1;
SELECT MIN(b), MIN(c) FROM t2 WHERE a = 1;

CREATE TABLE t3 (a INT, b INT, c int, KEY(a, b));
INSERT INTO t3 VALUES (1, NULL, 1), (2, NULL, 2),  (2, NULL, 2),  (3, NULL, 3);
EXPLAIN SELECT MIN(a), MIN(b) FROM t3 where a = 2;
SELECT MIN(a), MIN(b) FROM t3 where a = 2;

CREATE TABLE t4 (a INT, b INT, c int, KEY(a, b));
INSERT INTO t4 VALUES (1, 1, 1), (2, NULL, 2),  (2, NULL, 2),  (3, 1, 3);
EXPLAIN SELECT MIN(a), MIN(b) FROM t4 where a = 2;
SELECT MIN(a), MIN(b) FROM t4 where a = 2;
SELECT MIN(b), min(c) FROM t4 where a = 2;

CREATE TABLE t5( a INT, b INT, KEY( a, b) ); 
INSERT INTO t5 VALUES( 1, 1 ), ( 1, 2 );
EXPLAIN SELECT MIN(a), MIN(b) FROM t5 WHERE a = 1;
SELECT MIN(a), MIN(b) FROM t5 WHERE a = 1;
SELECT MIN(a), MIN(b) FROM t5 WHERE a = 1 and b > 1;

DROP TABLE t1, t2, t3, t4, t5;

#
# Bug #31156: mysqld: item_sum.cc:918: 
#  virtual bool Item_sum_distinct::setup(THD*): Assertion
#

CREATE TABLE t1 (a INT);
INSERT INTO t1 values (),(),();
SELECT (SELECT SLEEP(0) FROM t1 ORDER BY AVG(DISTINCT a) ) as x FROM t1 
  GROUP BY x;
SELECT 1 FROM t1 GROUP BY (SELECT SLEEP(0) FROM t1 ORDER BY AVG(DISTINCT a) );

DROP TABLE t1;

#
# Bug #30715: Assertion failed: item_field->field->real_maybe_null(), file
# .\opt_sum.cc, line
#

CREATE TABLE t1 (a int, b date NOT NULL, KEY k1 (a,b));
SELECT MIN(b) FROM t1 WHERE a=1 AND b>'2007-08-01';
DROP TABLE t1;

#
# Bug #31794: no syntax error on SELECT id FROM t HAVING count(*)>2;
#

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4);

SET SQL_MODE=ONLY_FULL_GROUP_BY;
--error ER_MIX_OF_GROUP_FUNC_AND_FIELDS
SELECT a FROM t1 HAVING COUNT(*)>2;
--error ER_MIX_OF_GROUP_FUNC_AND_FIELDS
SELECT COUNT(*), a FROM t1;

SET SQL_MODE=DEFAULT;
SELECT a FROM t1 HAVING COUNT(*)>2;
SELECT COUNT(*), a FROM t1;

DROP TABLE t1;

#
# Bug #33133: Views are not transparent
#

set SQL_MODE=ONLY_FULL_GROUP_BY;

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4);
CREATE VIEW v1 AS SELECT a,(a + 1) AS y FROM t1;
EXPLAIN EXTENDED SELECT y FROM v1 GROUP BY v1.y;

DROP VIEW v1;
DROP TABLE t1;
SET SQL_MODE=DEFAULT;

#
# Bug #34512: CAST( AVG( double ) AS DECIMAL ) returns wrong results
#

CREATE TABLE t1(a DOUBLE);
INSERT INTO t1 VALUES (10), (20);
SELECT AVG(a), CAST(AVG(a) AS DECIMAL) FROM t1;

DROP TABLE t1;

#
# Bug #37348: Crash in or immediately after JOIN::make_sum_func_list
#

CREATE TABLE derived1 (a bigint(21));
INSERT INTO derived1 VALUES (2);


CREATE TABLE D (
  pk int(11) NOT NULL AUTO_INCREMENT,
  int_nokey int(11) DEFAULT NULL,
  int_key int(11) DEFAULT NULL,
  filler blob,
  PRIMARY KEY (pk),
  KEY int_key (int_key)
);

INSERT INTO D VALUES 
  (39,40,4,repeat('  X', 42)),
  (43,56,4,repeat('  X', 42)),
  (47,12,4,repeat('  X', 42)),
  (71,28,4,repeat('  X', 42)),
  (76,54,4,repeat('  X', 42)),
  (83,45,4,repeat('  X', 42)),
  (105,53,12,NULL);

SELECT 
  (SELECT COUNT( int_nokey ) 
   FROM derived1 AS X 
   WHERE 
     X.int_nokey < 61 
   GROUP BY pk 
   LIMIT 1) 
FROM D AS X 
WHERE X.int_key < 13  
GROUP BY int_nokey LIMIT 1;

DROP TABLE derived1;
DROP TABLE D;

#
# Bug #39656: Behaviour different for agg functions with & without where -
# ONLY_FULL_GROUP_BY
# MDEV-5617 mysqld crashes when running a query with ONLY_FULL_GROUP_BY
#

CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1), (1,2), (1,3);
CREATE TABLE t2 (b INT);
INSERT INTO t2 VALUES (3),(4);

SET SQL_MODE='ONLY_FULL_GROUP_BY';

SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t1 where a=1;

--error ER_MIX_OF_GROUP_FUNC_AND_FIELDS
SELECT COUNT(*),a FROM t1;

SELECT COUNT(*) FROM t1 a JOIN t1 b ON a.a= b.a;

--error ER_MIX_OF_GROUP_FUNC_AND_FIELDS
SELECT COUNT(*), (SELECT count(*) FROM t1 inr WHERE inr.a = outr.a) 
  FROM t1 outr;

--error ER_MIX_OF_GROUP_FUNC_AND_FIELDS
SELECT COUNT(*) FROM t1 outr, (SELECT b, count(*) FROM t2) as t3;

SELECT COUNT(*) FROM t1 outr where (1,1) in (SELECT a, count(*) FROM t2);

SELECT COUNT(*) FROM t1 a JOIN t1 outr 
  ON a.a= (SELECT count(*) FROM t1 inr WHERE inr.a = outr.a);

SELECT * FROM (SELECT a FROM t1 GROUP BY a) sq JOIN t2 ON a = b;

SET SQL_MODE=default;
DROP TABLE t1,t2;


###
--echo End of 5.0 tests

--echo #
--echo # BUG#47280 - strange results from count(*) with order by multiple 
--echo #             columns without where/group
--echo # 

--echo # 
--echo # Initialize test
--echo # 

CREATE TABLE t1 (
  pk INT NOT NULL,
  i INT,
  PRIMARY KEY (pk)
);
INSERT INTO t1 VALUES (1,11),(2,12),(3,13);

--echo #
--echo # Start test
--echo # All the following queries shall return 1 record
--echo #

--echo
--echo # Masking all correct values {11...13} for column i in this result. 
--replace_column 2 #
SELECT MAX(pk) as max, i
FROM t1
ORDER BY max;

--echo
EXPLAIN
SELECT MAX(pk) as max, i
FROM t1
ORDER BY max;

--echo
--echo # Only 11 is correct for collumn i in this result
SELECT MAX(pk) as max, i
FROM t1
WHERE pk<2
ORDER BY max;

--echo #
--echo # Cleanup
--echo #
DROP TABLE t1;

--echo #
--echo # Bug#43668: Wrong comparison and MIN/MAX for YEAR(2)
--echo #
create table t1 (f1 year(2), f2 year(4), f3 date, f4 datetime);
insert into t1 values
  (98,1998,19980101,"1998-01-01 00:00:00"),
  (00,2000,20000101,"2000-01-01 00:00:01"),
  (02,2002,20020101,"2002-01-01 23:59:59"),
  (60,2060,20600101,"2060-01-01 11:11:11"),
  (70,1970,19700101,"1970-11-11 22:22:22"),
  (NULL,NULL,NULL,NULL),
  (71,1971,19710101,"1971-11-11 22:22:22");
select min(f1),max(f1) from t1;
select min(f2),max(f2) from t1;
select min(f3),max(f3) from t1;
select min(f4),max(f4) from t1;
select a.f1 as a, b.f1 as b, a.f1 > b.f1 as gt,
       a.f1 < b.f1 as lt, a.f1<=>b.f1 as eq
from t1 a, t1 b;
select a.f1 as a, b.f2 as b, a.f1 > b.f2 as gt,
       a.f1 < b.f2 as lt, a.f1<=>b.f2 as eq
from t1 a, t1 b;
select a.f1 as a, b.f3 as b, a.f1 > b.f3 as gt,
       a.f1 < b.f3 as lt, a.f1<=>b.f3 as eq
from t1 a, t1 b;
select a.f1 as a, b.f4 as b, a.f1 > b.f4 as gt,
       a.f1 < b.f4 as lt, a.f1<=>b.f4 as eq
from t1 a, t1 b;
select *, f1 = f2 from t1;
drop table t1;

--echo #
--echo # Bug #54465: assert: field_types == 0 || field_types[field_pos] ==
--echo #             MYSQL_TYPE_LONGLONG
--echo #

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2);

SELECT MAX((SELECT 1 FROM t1 ORDER BY @var LIMIT 1)) m FROM t1 t2, t1 
       ORDER BY t1.a;

DROP TABLE t1;

--echo #
--echo #  Bug#58030 crash in Item_func_geometry_from_text::val_str
--echo #

--disable_result_log

SELECT MAX(TIMESTAMP(RAND(0)));
SELECT MIN(TIMESTAMP(RAND(0)));

--echo #
--echo #  Bug#58177 crash and valgrind warnings in decimal and protocol sending functions...
--echo #

SELECT MIN(GET_LOCK('aaaaaaaaaaaaaaaaa',0) / '0b1111111111111111111111111111111111111111111111111111111111111111111111111' ^ (RAND()));
SELECT MIN(GET_LOCK('aaaaaaaaaaaaaaaaa',0) / '0b1111111111111111111111111111111111111111111111111111111111111111111111111' ^ (RAND()));
SELECT MIN(GET_LOCK('aaaaaaaaaaaaaaaaa',0) / '0b1111111111111111111111111111111111111111111111111111111111111111111111111' ^ (RAND()));
SELECT MIN(GET_LOCK('aaaaaaaaaaaaaaaaa',0) / '0b1111111111111111111111111111111111111111111111111111111111111111111111111' ^ (RAND()));
SELECT RELEASE_LOCK('aaaaaaaaaaaaaaaaa');

--enable_result_log


--echo #
--echo # Bug #11766094 - 59132: MIN() AND MAX() REMOVE UNSIGNEDNESS 
--echo #

CREATE TABLE t1 (a BIGINT UNSIGNED);
INSERT INTO t1 VALUES (18446668621106209655);
SELECT MAX(LENGTH(a)), LENGTH(MAX(a)), MIN(a), MAX(a), CONCAT(MIN(a)), CONCAT(MAX(a)) FROM t1;
DROP TABLE t1;

--echo #
--echo # Bug #11766270  59343: YEAR(4): INCORRECT RESULT AND VALGRIND WARNINGS WITH MIN/MAX, UNION
--echo #

CREATE TABLE t1(f1 YEAR(4));
INSERT INTO t1 VALUES (0000),(2001);
--enable_metadata
(SELECT MAX(f1) FROM t1) UNION (SELECT MAX(f1) FROM t1);
--disable_metadata
DROP TABLE t1;

--echo #
--echo # LP BUG#813418 - incorrect optimisation of max/min by index for
--echo # negated BETWEEN
CREATE TABLE t1 (a int, KEY (a));
INSERT INTO t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10);
SELECT MAX(a) FROM t1 WHERE a NOT BETWEEN 3 AND 9;
drop table t1;

--echo #
--echo End of 5.1 tests

--echo #
--echo # Bug #904345: MIN/MAX optimization  with constant FALSE condition
--echo #

CREATE TABLE t1 (a int NOT NULL, KEY(a));
INSERT INTO t1 VALUES (10), (8), (11), (7), (15), (12), (9);

CREATE TABLE t2 (a int, b int);
INSERT INTO t2 VALUES
  (8,2), (6,9), (8,4), (5,3), (9,1);

EXPLAIN EXTENDED
SELECT MAX(a) FROM t1 WHERE (1,2) IN (SELECT 3,4) AND a<10;
SELECT MAX(a) FROM t1 WHERE (1,2) IN (SELECT 3,4) AND a<10;

EXPLAIN EXTENDED
SELECT MAX(a) FROM t1 WHERE (1,2) IN (SELECT a,b FROM t2 WHERE b<5) and a<10; 
SELECT MAX(a) FROM t1 WHERE (1,2) IN (SELECT a,b FROM t2 WHERE b<5) and a<10; 

EXPLAIN EXTENDED
SELECT MAX(a) FROM t1 WHERE RAND()*0<>0 AND a<10;
SELECT MAX(a) FROM t1 WHERE RAND()*0<>0 AND a<10;

DROP TABLE t1,t2;

--echo #
--echo # Bug #879860: MIN/MAX for subquery returning empty set 
--echo #

CREATE TABLE t1 (a int PRIMARY KEY);
INSERT INTO t1 VALUES (1);

CREATE TABLE t2 (a int NOT NULL);
INSERT INTO t2 VALUES (10);

CREATE TABLE t3 ( a int, b int);
INSERT INTO t3 VALUES (19,1), (20,5);

EXPLAIN EXTENDED
SELECT (SELECT MIN(t1.a) FROM t1,t2 WHERE t2.a = t3.b) FROM t3;
SELECT (SELECT MIN(t1.a) FROM t1,t2 WHERE t2.a = t3.b) FROM t3;

DROP TABLE t1,t2,t3;

--echo #
--echo # Bug #884175: MIN/MAX for short varchar = long const  
--echo #

CREATE TABLE t1 (f1 varchar(1), f2 varchar(1), KEY (f2));
INSERT INTO t1 VALUES ('b', 'b'), ('a','a');

EXPLAIN 
SELECT MAX(f1) FROM t1 WHERE f1 = 'abc';
SELECT MAX(f1) FROM t1 WHERE f1 = 'abc';

EXPLAIN
SELECT MAX(f2) FROM t1 WHERE f2 = 'abc';
SELECT MAX(f2) FROM t1 WHERE f2 = 'abc';

EXPLAIN
SELECT MIN(f1) FROM t1 WHERE f1 >= 'abc';
SELECT MIN(f1) FROM t1 WHERE f1 >= 'abc';

EXPLAIN
SELECT MIN(f2) FROM t1 WHERE f2 >= 'abc';
SELECT MIN(f2) FROM t1 WHERE f2 >= 'abc';

EXPLAIN
SELECT MIN(f1) FROM t1 WHERE f1 BETWEEN 'abc' AND 'b' ;
SELECT MIN(f1) FROM t1 WHERE f1 BETWEEN 'abc' AND 'b' ;

EXPLAIN
SELECT MIN(f2) FROM t1 WHERE f2 BETWEEN 'abc' AND 'b' ;
SELECT MIN(f2) FROM t1 WHERE f2 BETWEEN 'abc' AND 'b' ;

DROP TABLE t1;


--echo End of 5.2 tests

--echo #
--echo # BUG#46680 - Assertion failed in file item_subselect.cc, 
--echo #             line 305 crashing on HAVING subquery
--echo #

--echo # Create tables
--echo #

CREATE TABLE t1 (
  pk INT,
  v VARCHAR(1) DEFAULT NULL,
  PRIMARY KEY(pk)
);
CREATE TABLE t2 LIKE t1;
CREATE TABLE t3 LIKE t1;
CREATE TABLE empty1 (a int);

INSERT INTO t1 VALUES (1,'c'),(2,NULL);
INSERT INTO t2 VALUES (3,'m'),(4,NULL);
INSERT INTO t3 VALUES (1,'n');

set @save_optimizer_switch=@@optimizer_switch;
set @@optimizer_switch='materialization=on,in_to_exists=off,semijoin=off';

--echo
--echo #
--echo # 1) Test that subquery materialization is setup for query with
--echo #    premature optimize() exit due to "Impossible WHERE"
--echo #
SELECT MIN(t2.pk)
FROM t2 JOIN t1 ON t1.pk=t2.pk
WHERE 'j'
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
EXPLAIN
SELECT MIN(t2.pk)
FROM t2 JOIN t1 ON t1.pk=t2.pk
WHERE 'j'
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo 
--echo #
--echo # 2) Test that subquery materialization is setup for query with
--echo #    premature optimize() exit due to "No matching min/max row"
--echo #
SELECT MIN(t2.pk)
FROM t2 
WHERE t2.pk>10
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
EXPLAIN
SELECT MIN(t2.pk)
FROM t2 
WHERE t2.pk>10
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
--echo #
--echo # 3) Test that subquery materialization is setup for query with
--echo #    premature optimize() exit due to "Select tables optimized away"
--echo #
SELECT MIN(pk)
FROM t1
WHERE pk=NULL
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
EXPLAIN
SELECT MIN(pk)
FROM t1
WHERE pk=NULL
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo 
--echo #
--echo # 4) Test that subquery materialization is setup for query with
--echo #    premature optimize() exit due to "No matching row in const table"
--echo #
--echo
SELECT MIN(a)
FROM (SELECT a FROM empty1) tt
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
set @tmp_optimizer_switch=@@optimizer_switch;
set optimizer_switch='derived_merge=off,derived_with_keys=off';
EXPLAIN 
SELECT MIN(a)
FROM (SELECT a FROM empty1) tt
HAVING ('m') IN ( 
SELECT v
FROM t2);
set optimizer_switch=@tmp_optimizer_switch;

--echo 
--echo #
--echo # 5) Test that subquery materialization is setup for query with
--echo #    premature optimize() exit due to "Impossible WHERE noticed 
--echo #    after reading const tables"
--echo #
SELECT min(t1.pk)
FROM t1
WHERE t1.pk IN (SELECT 1 from t3 where pk>10)
HAVING ('m') IN ( 
SELECT v
FROM t2);

--echo
EXPLAIN
SELECT min(t1.pk)
FROM t1
WHERE t1.pk IN (SELECT 1 from t3 where pk>10)
HAVING ('m') IN ( 
SELECT v
FROM t2);

set @@optimizer_switch=@save_optimizer_switch;

--echo #
--echo # Cleanup for BUG#46680
--echo #
DROP TABLE IF EXISTS t1,t2,t3,empty1;

#
# MDEV-4286 Server crashes in Protocol_text::store, stack smashing detected
#
create table t1 (i int, d date);
insert into t1 values (1, '2008-10-02'), (2, '2010-12-12');
select avg(export_set( 3, 'y', sha(i))), group_concat(d) from t1 group by d order by i;
drop table t1;

--echo #
--echo # MDEV-4290: crash in st_select_lex::mark_as_dependent
--echo #
create table `t1`(`a` int);

--error ER_INVALID_GROUP_FUNC_USE
select 1 from t1 v1 right join t1 on count(*);
--error ER_INVALID_GROUP_FUNC_USE
select 1 from t1 order by
(
	select 1 from 
	(
		select 1 from t1 v1 right join t1 on count(*)
	) v   
);
insert into t1 values (1),(1),(2),(2);
select count(*) from t1;
select z from (select count(*) as z from t1) v; 
--echo # next is how it implemented now (may be changed in case of dependent
--echo # derived tables)
select z from (select count(*) as z from t1) v group by 1; 
drop table t1;

#
# Bug mdev-5015: Degenerate OR condition in an aggregated join
#

CREATE TABLE t1 (i1 int, INDEX(i1));
INSERT INTO t1 VALUES (9),(8);

CREATE TABLE t2 (i2 int);
INSERT INTO t2 VALUES (8),(4);


CREATE TABLE t3 (i3 int, INDEX(i3));
INSERT INTO t3 VALUES (9),(8);

SELECT MAX(t3.i3) FROM t3, t2, t1 WHERE t1.i1 = t2.i2 AND ( 0 OR t3.i3 = t2.i2 );

SELECT MAX(t3.i3) FROM t3, t2, t1 WHERE t1.i1 = t2.i2 AND  t3.i3 = t2.i2;

DROP TABLE  t1,t2,t3;

--echo # end of 5.3 tests

--echo #
--echo # Bug#52123 Assertion failed: aggregator == aggr->Aggrtype(),
--echo #           file .\item_sum.cc, line 587
--echo #

CREATE TABLE t1(a int, KEY(a));
INSERT INTO t1 VALUES (1), (2);
SELECT 1 FROM t1 ORDER BY AVG(DISTINCT a);
DROP TABLE t1;

--echo #
--echo # Bug#55648: Server crash on MIN/MAX on maximum time value
--echo #
CREATE TABLE t1(c1 TIME NOT NULL);
INSERT INTO t1 VALUES('837:59:59');
INSERT INTO t1 VALUES('838:59:59');
SELECT MAX(c1) FROM t1;
DROP TABLE t1;
--echo # End of the bug#55648

--echo #
--echo # Bug#56120: Failed assertion on MIN/MAX on negative time value
--echo #
CREATE TABLE t1(c1 TIME NOT NULL);
INSERT INTO t1 VALUES('-00:00:01');
SELECT MAX(c1),MIN(c1) FROM t1;
DROP TABLE t1;
--echo # End of the bug#56120

--echo #
--echo # Bug#57932 "query with AVG(DISTINCT) returns NULL if last
--echo # aggregated value was NULL"
--echo #
CREATE TABLE t1 (col_int_nokey int(11));
INSERT INTO t1 VALUES (7),(8),(NULL);
SELECT AVG(DISTINCT col_int_nokey) FROM t1;
SELECT AVG(DISTINCT outr.col_int_nokey) FROM t1 AS outr LEFT JOIN t1 AS outr2 ON
outr.col_int_nokey = outr2.col_int_nokey;
DROP TABLE t1;
--echo # End of the bug#57932


--echo #
--echo # MDEV-5257: MIN/MAX Optimization (Select tables optimized away) does not work for DateTime
--echo # MDEV-3855: MIN/MAX optimization doesnt work for int_col > INET_ATON
--echo #  (correct the fix for Bug #884175)
--echo #

CREATE TABLE `t1` (
  `a` int(11) NOT NULL AUTO_INCREMENT,
  `b` datetime DEFAULT NULL,
  PRIMARY KEY (`a`),
  KEY `idx_b` (`b`)
);

INSERT INTO `t1` (b) VALUES ('2013-01-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-02-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-03-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-04-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-05-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-06-06 23:59:59');
INSERT INTO `t1` (b) VALUES ('2013-07-06 23:59:59');

--echo # The following should produce "Select tables optimized away"
EXPLAIN SELECT MIN(b) FROM t1 WHERE b <= '2013-11-06 23:59:59';

-- connect (con1,localhost,root,,)
-- connection con1
set names utf8;
-- echo # Should be the same as above:
EXPLAIN SELECT MIN(b) FROM t1 WHERE b <= '2013-11-06 23:59:59';

--connection default
--disconnect con1

DROP TABLE t1;

CREATE TABLE `t1` (
  `a` int(11) NOT NULL AUTO_INCREMENT,
  `b` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`a`),
  KEY `idx_b` (`b`)
);

insert into t1 (b) values (INET_ATON('192.168.0.1'));
insert into t1 (b) values (INET_ATON('192.168.0.2'));
insert into t1 (b) values (INET_ATON('192.168.0.3'));
insert into t1 (b) values (INET_ATON('192.168.0.4'));
insert into t1 (b) values (INET_ATON('192.168.200.200'));
--echo # should show "Select tables optimized away"
explain select MIN(b) from t1 where b >= inet_aton('192.168.119.32');
DROP TABLE t1;

--echo #
--echo # MDEV-6743 crash in GROUP_CONCAT(IF () ORDER BY 1)
--echo #

CREATE TABLE t1 (pk INT, t2_id INT, t5_id INT, PRIMARY KEY (pk));
INSERT INTO t1 VALUES (1,3,12),(2,3,15);

CREATE TABLE t2 (pk INT, PRIMARY KEY (pk));
INSERT INTO t2 VALUES (4),(5);

CREATE TABLE t3 (t2_id INT, t4_id INT);
INSERT INTO t3 VALUES (6,11),(7,12);

CREATE TABLE t4 (id INT);
INSERT INTO t4 VALUES (13),(14);

CREATE TABLE t5 (pk INT, f VARCHAR(50), t6_id INT, PRIMARY KEY (pk));
INSERT INTO t5 VALUES (9,'FOO',NULL);

CREATE TABLE t6 (pk INT, f VARCHAR(120), b TINYINT(4), PRIMARY KEY (pk));

PREPARE stmt FROM "
  SELECT      t1.t2_id, GROUP_CONCAT(IF (t6.b, t6.f, t5.f) ORDER BY 1)
  FROM        t1
  JOIN        t2 ON t1.t2_id = t2.pk
  JOIN        t3 ON t2.pk = t3.t2_id
  JOIN        t4 ON t4.id = t3.t4_id
  JOIN        t5 ON t1.t5_id = t5.pk
  LEFT JOIN   t6 ON t6.pk = t5.t6_id
  GROUP BY    t1.t2_id
";

EXECUTE stmt;
EXECUTE stmt;
EXECUTE stmt;

DROP TABLE t1,t2,t3,t4,t5,t6;

--echo #
--echo # MDEV-10500 CASE/IF Statement returns multiple values and shifts further result values to the next column
--echo #

CREATE TABLE t1 (
  id int not null AUTO_INCREMENT,
  active bool not null,
  data1 bigint,
  data2 bigint,
  data3 bigint,
  primary key (id)
);
INSERT INTO t1 (active,data1,data2,data3) VALUES (1,null,100,200);
SELECT
  CASE WHEN active THEN SUM(data1) END AS C_1,
  SUM(data2) AS C_2,
  SUM(data3) AS C_3
FROM t1;
SELECT
  IF(active, SUM(data1), 5) AS C_1,
  SUM(data2) AS C_2,
  SUM(data3) AS C_3
FROM t1;
DROP TABLE t1;

--echo #
--echo # MDEV-10468 Assertion `nr >= 0.0' failed in Item_sum_std::val_real()
--echo #
SELECT STDDEV_POP(f) FROM (SELECT "1e+309" AS f UNION SELECT "-1e+309" AS f) tbl;
SELECT STDDEV(f) FROM (SELECT 1.7976931348623157e+308 AS f UNION SELECT -1.7976931348623157e+308 AS f) tbl;
