# Can't test with embedded server that doesn't support grants
-- source include/not_embedded.inc

--disable_warnings
drop database if exists events_test;
drop database if exists db_x;
drop database if exists mysqltest_db2;
drop database if exists mysqltest_no_such_database;
--enable_warnings
create database events_test;
use events_test;

#
# START:  BUG #17289 Events: missing privilege check for drop database
#
CREATE USER pauline@localhost;
CREATE DATABASE db_x;
GRANT EVENT ON db_x.* TO pauline@localhost;
USE db_x;
CREATE TABLE x_table(a int);
connect (priv_conn,localhost,pauline,,db_x);
CREATE EVENT e_x1 ON SCHEDULE EVERY 1 SECOND DO DROP DATABASE db_x;
CREATE EVENT e_x2 ON SCHEDULE EVERY 1 SECOND DO DROP TABLE x_table;
connection default;
SHOW DATABASES LIKE 'db_x';
SET GLOBAL event_scheduler=1;
--sleep 1.2
SHOW DATABASES LIKE 'db_x';
SHOW TABLES FROM db_x;
SET GLOBAL event_scheduler=off;
connection priv_conn;
DROP EVENT e_x1;
DROP EVENT e_x2;
disconnect priv_conn;
connection default;
DROP DATABASE db_x;
DROP USER pauline@localhost;
USE events_test;
#
# END:    BUG #17289 Events: missing privilege check for drop database
#
SET GLOBAL event_scheduler=off;
drop event if exists event1;
create event event1 on schedule every 15 minute starts now() ends date_add(now(), interval 5 hour) DO begin end;
alter event event1 rename to event2 enable;
alter event event2 disable;
alter event event2 enable;
alter event event2 on completion not preserve;
delimiter __;
alter event event2 on schedule every 1 year on completion preserve rename to event3 comment "new comment" do begin select 1; end__
delimiter ;__
alter event event3 rename to event2;

drop event event2;
create event event2 on schedule every 2 second starts now() ends date_add(now(), interval 5 hour) comment "some" DO begin end;
drop event event2;

#
# BUG #16537 (Events: mysql.event.starts is null)
#
CREATE EVENT event_starts_test ON SCHEDULE EVERY 10 SECOND COMMENT "" DO SELECT 1;
SELECT interval_field, interval_value, body FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
ALTER EVENT event_starts_test ON SCHEDULE AT '2020-02-02 20:00:02';
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
ALTER EVENT event_starts_test COMMENT "non-empty comment";
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
ALTER EVENT event_starts_test COMMENT "";
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
DROP EVENT event_starts_test;

CREATE EVENT event_starts_test ON SCHEDULE EVERY 20 SECOND STARTS '2020-02-02 20:00:02' ENDS '2022-02-02 20:00:02' DO SELECT 2;
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
ALTER EVENT event_starts_test COMMENT "non-empty comment";
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
ALTER EVENT event_starts_test COMMENT "";
SELECT execute_at IS NULL, starts IS NULL, ends IS NULL, comment FROM mysql.event WHERE db='events_test' AND name='event_starts_test';
DROP EVENT event_starts_test;
#
#
create table test_nested(a int);
create event e_43 on schedule every 1 second do set @a = 5;
--error ER_EVENT_RECURSION_FORBIDDEN
alter event e_43 do alter event e_43 do set @a = 4;
delimiter |;
alter event e_43 do
begin
  alter event e_43 on schedule every 5 minute;
  insert into test_nested values(1);
end|
delimiter ;|
set global event_scheduler = on;
--sleep 3
select db, name, body, status, interval_field, interval_value from mysql.event;
drop event e_43;
drop table test_nested;

--echo "Let's check whether we can use non-qualified names"
create table non_qualif(a int);
create event non_qualif_ev on schedule every 10 minute do insert into non_qualif values (800219);
--sleep 1.1
select * from non_qualif;
drop event non_qualif_ev;
drop table non_qualif;

--error ER_EVENT_DOES_NOT_EXIST
alter event non_existant rename to non_existant_too;

set global event_scheduler = off;
create event existant on schedule at now() + interval 1 year do select 12;
--error ER_EVENT_ALREADY_EXISTS
alter event non_existant rename to existant;
--error ER_EVENT_SAME_NAME
alter event existant rename to events_test.existant;
drop event existant;


create table t_event3 (a int, b float);
drop event if exists event3;
create event event3 on schedule every 50 + 10 minute starts date_add("20100101", interval 5 minute) ends date_add("20151010", interval 5 day) comment "portokala_comment" DO insert into t_event3 values (unix_timestamp(), rand());
select count(*) from t_event3;
drop event event3;
drop table t_event3;


set names utf8;
#
# SHOW CREATE EVENT test begin
#
CREATE EVENT root6 ON SCHEDULE EVERY '10:20' MINUTE_SECOND ON COMPLETION PRESERVE ENABLE COMMENT 'some comment' DO select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root6;
create event root7 on schedule every 2 year do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root7;
create event root8 on schedule every '2:5' year_month do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root8;
create event root8_1 on schedule every '2:15' year_month do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root8_1;
create event root9 on schedule every 2 week ON COMPLETION PRESERVE DISABLE COMMENT 'ÐºÐ¾Ð¼ÐµÐ½Ñ‚Ð°Ñ€ Ð½Ð° ÐºÐ¸Ñ€Ð¸Ð»Ð¸Ñ†Ð°' do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root9;
create event root10 on schedule every '20:5' day_hour do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root10;
create event root11 on schedule every '20:25' day_hour do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root11;
create event root12 on schedule every '20:25' hour_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root12;
create event root13 on schedule every '25:25' hour_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root13;
create event root13_1 on schedule every '11:65' hour_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root13_1;
create event root14 on schedule every '35:35' minute_second do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root14;
create event root15 on schedule every '35:66' minute_second do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root15;
create event root16 on schedule every '35:56' day_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root16;
create event root17 on schedule every '35:12:45' day_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root17;
create event root17_1 on schedule every '35:25:65' day_minute do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root17_1;
create event root18 on schedule every '35:12:45' hour_second do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root18;
create event root19 on schedule every '15:59:85' hour_second do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root19;
create event root20 on schedule every '50:20:12:45' day_second do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT root20;
set names cp1251;
create event ðóóò21 on schedule every '50:23:59:95' day_second COMMENT 'òîâà å 1251 êîìåíòàð' do select 1;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT ðóóò21;
insert into mysql.event (
  db,
  name,
  body,
  definer,
  interval_value,
  interval_field,
  originator,
  character_set_client,
  collation_connection,
  db_collation,
  body_utf8)
values (
  database(),
  "root22",
  "select 1",
  user(),
  100,
  "SECOND_MICROSECOND",
  1,
  'utf8',
  'utf8_general_ci',
  'utf8_general_ci',
  'select 1');
--error ER_NOT_SUPPORTED_YET
show create event root22;
--error ER_NOT_SUPPORTED_YET
SHOW EVENTS;
drop event root22;
--error ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG
create event root23 on schedule every -100 year do select 1;
--error ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG
create event root23 on schedule every 222222222222222222222 year do select 1;
drop event root6;
drop event root7;
drop event root8;
drop event root8_1;
drop event root9;
drop event root10;
drop event root11;
drop event root12;
drop event root13;
drop event root13_1;
drop event root14;
drop event root15;
drop event root16;
drop event root17;
drop event root17_1;
drop event root18;
drop event root19;
drop event root20;
drop event ðóóò21;

set names latin1;
#
# SHOW CREATE EVENT test end
#

#
# mysql.event intact checking
# Check that the server does not crash if
# one has destroyed or tampered with the event table. 
# Please see see for events_restart_phase* tests to 
# see the server behavior at start up with bad mysql.event
# table.
#
#
--echo Create a test event. Only event metadata is relevant, 
--echo the actual schedule and body are not.
#
CREATE EVENT intact_check ON SCHEDULE EVERY 10 HOUR DO SELECT "nothing";
--replace_column 8 # 9 #
SHOW EVENTS;
#
--echo Try to alter mysql.event: the server should fail to load
--echo event information after mysql.event was tampered with.
--echo 
--echo First, let's add a column to the end and make sure everything
--echo works as before
--echo 
ALTER TABLE mysql.event ADD dummy INT;
--replace_column 8 # 9 #
SHOW EVENTS;
SELECT event_name FROM INFORMATION_SCHEMA.events;
--replace_regex /STARTS '[^']+'/STARTS '#'/
SHOW CREATE EVENT intact_check;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT no_such_event;
CREATE EVENT intact_check_1 ON SCHEDULE EVERY 5 HOUR DO SELECT 5;
ALTER EVENT intact_check_1 ON SCHEDULE EVERY 8 HOUR DO SELECT 8;
ALTER EVENT intact_check_1 RENAME TO intact_check_2;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check_1;
DROP EVENT intact_check_2;
DROP EVENT intact_check;
DROP DATABASE IF EXISTS mysqltest_no_such_database;
CREATE DATABASE mysqltest_db2;
DROP DATABASE mysqltest_db2;
SELECT @@event_scheduler;
SHOW VARIABLES LIKE 'event_scheduler';
SET GLOBAL event_scheduler=OFF;
# Clean up
ALTER TABLE mysql.event DROP dummy;
CREATE EVENT intact_check ON SCHEDULE EVERY 10 HOUR DO SELECT "nothing";
--echo 
--echo Now let's add a column to the first position: the server
--echo expects to see event schema name there
--echo 
ALTER TABLE mysql.event ADD dummy INT FIRST;
--error ER_CANNOT_LOAD_FROM_TABLE
SHOW EVENTS;
--error ER_CANNOT_LOAD_FROM_TABLE
SELECT event_name FROM INFORMATION_SCHEMA.events;
--error ER_EVENT_DOES_NOT_EXIST
SHOW CREATE EVENT intact_check;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT no_such_event;
--error ER_CANNOT_LOAD_FROM_TABLE
CREATE EVENT intact_check_1 ON SCHEDULE EVERY 5 HOUR DO SELECT 5;
--error ER_EVENT_DOES_NOT_EXIST
ALTER EVENT intact_check_1 ON SCHEDULE EVERY 8 HOUR DO SELECT 8;
--error ER_EVENT_DOES_NOT_EXIST
ALTER EVENT intact_check_1 RENAME TO intact_check_2;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check_1;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check_2;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check;
# Should work OK
DROP DATABASE IF EXISTS mysqltest_no_such_database;
CREATE DATABASE mysqltest_db2;
DROP DATABASE mysqltest_db2;
SELECT @@event_scheduler;
SHOW VARIABLES LIKE 'event_scheduler';
SET GLOBAL event_scheduler=OFF;
--echo Clean up
ALTER TABLE mysql.event DROP dummy;
DELETE FROM mysql.event;
CREATE EVENT intact_check ON SCHEDULE EVERY 10 HOUR DO SELECT "nothing";
--echo Back up the table, further changes are not reversible
CREATE TABLE event_like LIKE mysql.event;
INSERT INTO event_like SELECT * FROM mysql.event;
--echo 
--echo Drop some columns and try more checks. 
--echo
--echo 
ALTER TABLE mysql.event DROP comment, DROP starts;
--error ER_CANNOT_LOAD_FROM_TABLE
SHOW EVENTS;
--error ER_CANNOT_LOAD_FROM_TABLE
SELECT event_name FROM INFORMATION_SCHEMA.EVENTS;
--error ER_CANNOT_LOAD_FROM_TABLE
SHOW CREATE EVENT intact_check;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT no_such_event;
--error ER_COL_COUNT_DOESNT_MATCH_CORRUPTED
CREATE EVENT intact_check_1 ON SCHEDULE EVERY 5 HOUR DO SELECT 5;
--error ER_EVENT_DOES_NOT_EXIST
ALTER EVENT intact_check_1 ON SCHEDULE EVERY 8 HOUR DO SELECT 8;
--error ER_EVENT_DOES_NOT_EXIST
ALTER EVENT intact_check_1 RENAME TO intact_check_2;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check_1;
--error ER_EVENT_DOES_NOT_EXIST
DROP EVENT intact_check_2;
# Should succeed
DROP EVENT intact_check;
DROP DATABASE IF EXISTS mysqltest_no_such_database;
CREATE DATABASE mysqltest_db2;
DROP DATABASE mysqltest_db2;
SELECT @@event_scheduler;
SHOW VARIABLES LIKE 'event_scheduler';
SET GLOBAL event_scheduler=OFF;
--echo 
--echo Now drop the table, and test again
--echo
--echo 
DROP TABLE mysql.event;
--error ER_NO_SUCH_TABLE
SHOW EVENTS;
--error ER_NO_SUCH_TABLE
SELECT event_name FROM INFORMATION_SCHEMA.events;
--error ER_NO_SUCH_TABLE
SHOW CREATE EVENT intact_check;
--error ER_NO_SUCH_TABLE
DROP EVENT no_such_event;
--error ER_NO_SUCH_TABLE
CREATE EVENT intact_check_1 ON SCHEDULE EVERY 5 HOUR DO SELECT 5;
--error ER_NO_SUCH_TABLE
ALTER EVENT intact_check_1 ON SCHEDULE EVERY 8 HOUR DO SELECT 8;
--error ER_NO_SUCH_TABLE
ALTER EVENT intact_check_1 RENAME  TO intact_check_2;
--error ER_NO_SUCH_TABLE
DROP EVENT intact_check_1;
--error ER_NO_SUCH_TABLE
DROP EVENT intact_check_2;
--error ER_NO_SUCH_TABLE
DROP EVENT intact_check;
DROP DATABASE IF EXISTS mysqltest_no_such_database;
CREATE DATABASE mysqltest_db2;
DROP DATABASE mysqltest_db2;
--echo OK, there is an unnecessary warning about the non-existent table 
--echo but it's not easy to fix and no one complained about it.
--echo A similar warning is printed if mysql.proc is missing.
SHOW WARNINGS;
SELECT @@event_scheduler;
SHOW VARIABLES LIKE 'event_scheduler';
SET GLOBAL event_scheduler=OFF;
--echo Restore the original table.
CREATE TABLE mysql.event like event_like;
DROP TABLE event_like;
--replace_column 8 # 9 #
SHOW EVENTS;
#
# mysql.event intact checking end
#

create event e_26 on schedule at '2017-01-01 00:00:00' disable do set @a = 5;
select db, name, body, definer, convert_tz(execute_at, 'UTC', 'SYSTEM'), on_completion from mysql.event;
drop event e_26;
--error ER_WRONG_VALUE
create event e_26 on schedule at NULL disable do set @a = 5;
--error ER_WRONG_VALUE
create event e_26 on schedule at 'definitely not a datetime' disable do set @a = 5;

set names utf8;
create event Ð·Ð°Ð´Ð°Ñ‡ÐºÐ° on schedule every 123 minute starts now() ends now() + interval 1 month do select 1;
drop event Ð·Ð°Ð´Ð°Ñ‡ÐºÐ°;

# event_scheduler is a global var
--error ER_GLOBAL_VARIABLE
set event_scheduler=off;
# event_scheduler could be only either 1 or 2
--error ER_WRONG_VALUE_FOR_VAR
set global event_scheduler=3;
--error ER_WRONG_VALUE_FOR_VAR
set global event_scheduler=disabled;

--echo "DISABLE the scheduler. Testing that it does not work when the variable is 0"
set global event_scheduler=off;
select definer, name, db from mysql.event;
select get_lock("test_lock1", 20);
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ° on schedule every 10 hour do select get_lock("test_lock1", 20);
--echo "Should return 1 row"
select definer, name, db from mysql.event;

--echo "Should be only 0 process"
select /*1*/ user, host, db, command, state, info
  from information_schema.processlist
  where (user='event_scheduler')
  order by info;
select release_lock("test_lock1");
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°;
--echo "Should have 0 events"
select count(*) from mysql.event;

#
#
#
--echo "ENABLE the scheduler and get a lock"
set global event_scheduler=on;
select get_lock("test_lock2", 20);
--echo "Create an event which tries to acquire a mutex. The event locks on the mutex"
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ° on schedule every 10 hour do select get_lock("test_lock2", 20);

--echo "Should have only 2 processes: the scheduler and the locked event"
let $wait_condition= select count(*) = 2 from information_schema.processlist
  where ( (state like 'User lock%' AND info like 'select get_lock%')
       OR (command='Daemon' AND user='event_scheduler' AND
           state = 'Waiting for next activation'));
--source include/wait_condition.inc

select /*2*/ user, host, db, command, state, info
  from information_schema.processlist
  where (info like "select get_lock%" OR user='event_scheduler')
  order by info;
--echo "Release the mutex, the event worker should finish."
select release_lock("test_lock2");
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°;

# Wait for release_lock("test_lock2") to complete,
# to avoid polluting the next test information_schema.processlist
let $wait_condition= select count(*) = 0 from information_schema.processlist
  where (state like 'User lock%' AND info like 'select get_lock%');
--source include/wait_condition.inc


##
## 1. get a lock
## 2. create an event
## 3. sleep so it has time to start
## 4. should appear in processlist
## 5. kill the scheduler, it will wait for the child to stop
## 6. both processes should be there on show processlist
## 7. release the lock and sleep, both scheduler and child should end
set global event_scheduler=1;
select get_lock("test_lock2_1", 20);
create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°21 on schedule every 10 hour do select get_lock("test_lock2_1", 20);

--echo "Should have only 2 processes: the scheduler and the locked event"
let $wait_condition= select count(*) = 2 from information_schema.processlist
  where ( (state like 'User lock%' AND info like 'select get_lock%')
          OR (command='Daemon' AND user='event_scheduler' AND
              state = 'Waiting for next activation'));
--source include/wait_condition.inc

select /*3*/ user, host, db, command, state, info
  from information_schema.processlist
  where (info like "select get_lock%" OR user='event_scheduler')
  order by info;

set global event_scheduler=off;

let $wait_condition= select count(*) =1 from information_schema.processlist
  where (info like "select get_lock%" OR user='event_scheduler');
--source include/wait_condition.inc

--echo "Should have only our process now:"
select /*4*/ user, host, db, command, state, info
  from information_schema.processlist
  where (info like "select get_lock%" OR user='event_scheduler')
  order by info;
select release_lock("test_lock2_1");
drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°21;
let $wait_condition=
  select count(*) = 0 from information_schema.processlist
  where db='events_test' and command = 'Connect' and user=current_user();
--source include/wait_condition.inc

####
# Bug #16410  Events: CREATE EVENT is legal in a CREATE TRIGGER statement
#
create table t_16 (s1 int);
--error ER_EVENT_RECURSION_FORBIDDEN
create trigger t_16_bi before insert on t_16 for each row create event  e_16 on schedule every 1 second do set @a=5;
drop table t_16;
#
# end of test case
####

#
# START: BUG #17453: Creating Event crash the server
#
create event white_space
on schedule every 10 hour
disable
do
select 1;
select event_schema, event_name, definer, event_definition from information_schema.events where event_name='white_space';
drop event white_space;
create event white_space on schedule every 10 hour disable do

select 2;
select event_schema, event_name, definer, event_definition from information_schema.events where event_name='white_space';
drop event white_space;
create event white_space on schedule every 10 hour disable do	select 3;
select event_schema, event_name, definer, event_definition from information_schema.events where event_name='white_space';
drop event white_space;
#
# END:  BUG #17453: Creating Event crash the server
#

#
# Bug#17403 "Events: packets out of order with show create event"
#
create event e1 on schedule every 1 year do set @a = 5;
create table t1 (s1 int);
--error ER_SP_NO_RETSET
create trigger t1_ai after insert on t1 for each row show create event e1;
drop table t1;
drop event e1;

##set global event_scheduler=1;
##select get_lock("test_lock3", 20);
##create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ° on schedule every 10 hour do select get_lock("test_lock3", 20);
##select sleep(2);
##select /*5*/ user, host, db, command, state, info from information_schema.processlist where info is null or info not like '%processlist%' order by info;
##drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°;
##select release_lock("test_lock3");

#
# test with very often occuring event
# (disabled for now, locks)
##select get_lock("test_lock4", 20);
##create event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°4 on schedule every 1 second do select get_lock("test_lock4", 20);
##select sleep(3);
##select /*6*/ user, host, db, command, state, info from information_schema.processlist where info is null or info not like '%processlist%' order by info;
##drop event Ð·Ð°ÐºÐ°Ñ‡ÐºÐ°4;
##select release_lock("test_lock4");

##set global event_scheduler=off;
##select sleep(2);
##--replace_column 1 # 6 #
##show processlist;
##select count(*) from mysql.event;

#
# Test wrong syntax
#

--error 1102
SHOW EVENTS FROM aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;
--error 1102
SHOW EVENTS FROM ``;

SHOW EVENTS FROM `events\\test`;
#
# A check for events SQL under LOCK TABLES and in pre-locked mode.
#
--echo
--echo LOCK TABLES mode.
--echo 
#
# SHOW CREATE EVENT and INFORMATION_SCHEMA.events are available and 
# cause an implicit lock/unlock of mysql.event table, regardless of the
# currently locked tables.
#
create table t1 (a int);
create event e1 on schedule every 10 hour do select 1;
#
lock table t1 read;
#
--replace_regex /STARTS '[^']+'/STARTS '#'/
show create event e1;
select event_name from information_schema.events;
--error ER_TABLE_NOT_LOCKED
create event e2 on schedule every 10 hour do select 1;
--error ER_TABLE_NOT_LOCKED
alter event e2 disable;
--error ER_TABLE_NOT_LOCKED
alter event e2 rename to e3;
--error ER_TABLE_NOT_LOCKED
drop event e2;
--error ER_TABLE_NOT_LOCKED
drop event e1;
unlock tables;
#
lock table t1 write;
#
--replace_regex /STARTS '[^']+'/STARTS '#'/
show create event e1;
select event_name from information_schema.events;
--error ER_TABLE_NOT_LOCKED
create event e2 on schedule every 10 hour do select 1;
--error ER_TABLE_NOT_LOCKED
alter event e2 disable;
--error ER_TABLE_NOT_LOCKED
alter event e2 rename to e3;
--error ER_TABLE_NOT_LOCKED
drop event e2;
--error ER_TABLE_NOT_LOCKED
drop event e1;
unlock tables;
#
lock table t1 read, mysql.event read;
#
--replace_regex /STARTS '[^']+'/STARTS '#'/
show create event e1;
select event_name from information_schema.events;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
create event e2 on schedule every 10 hour do select 1;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
alter event e2 disable;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
alter event e2 rename to e3;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
drop event e2;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
drop event e1;
unlock tables;
#
lock table t1 write, mysql.event read;
#
--replace_regex /STARTS '[^']+'/STARTS '#'/
show create event e1;
select event_name from information_schema.events;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
create event e2 on schedule every 10 hour do select 1;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
alter event e2 disable;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
alter event e2 rename to e3;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
drop event e2;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
drop event e1;
unlock tables;
#
--error ER_WRONG_LOCK_OF_SYSTEM_TABLE
lock table t1 read, mysql.event write;
#
--error ER_WRONG_LOCK_OF_SYSTEM_TABLE
lock table t1 write, mysql.event write;
#
lock table mysql.event write;
--replace_regex /STARTS '[^']+'/STARTS '#'/
show create event e1;
select event_name from information_schema.events;
create event e2 on schedule every 10 hour do select 1;
alter event e2 disable;
alter event e2 rename to e3;
drop event e3;
drop event e1;
unlock tables;
--echo Make sure we have left no events 
select event_name from information_schema.events;
--echo
--echo Events in sub-statements, events and prelocking
--echo 
--echo 
create event e1 on schedule every 10 hour do select 1;
delimiter |;
--error ER_SP_NO_RETSET
create function f1() returns int
begin
  show create event e1;
  return 1;
end|
--error ER_SP_NO_RETSET
create trigger trg before insert on t1 for each row
begin
  show create event e1;
end|
--error ER_SP_NO_RETSET
create function f1() returns int
begin
  select event_name from information_schema.events;
  return 1;
end|
--error ER_SP_NO_RETSET
create trigger trg before insert on t1 for each row
begin
  select event_name from information_schema.events;
end|
--error ER_EVENT_RECURSION_FORBIDDEN
create function f1() returns int
begin
  create event e2 on schedule every 10 hour do select 1;
  return 1;
end|
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
create function f1() returns int
begin
  alter event e1 rename to e2;
  return 1;
end|
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
create function f1() returns int
begin
  drop event e2;
  return 1;
end|
--echo ----------------------------------------------------------------------
create trigger trg before insert on t1 for each row
begin
  set new.a= f1();
end|
create function f1() returns int
begin
  call p1();
  return 0;
end|
create procedure p1()
begin
  select event_name from information_schema.events;
end|
--error ER_SP_NO_RETSET
insert into t1 (a) values (1)|
drop procedure p1|
create procedure p1()
begin
  show create event e1; 
end|
--error ER_SP_NO_RETSET
insert into t1 (a) values (1)|
drop procedure p1|
create procedure p1()
begin
  create temporary table tmp select event_name from information_schema.events;
end|
--echo expected to work, since we redirect the output into a tmp table
insert into t1 (a) values (1)|
select * from tmp|
drop temporary table tmp|
drop procedure p1|
create procedure p1()
begin
  alter event e1 rename to e2;
end|
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
insert into t1 (a) values (1)|
drop procedure p1|
create procedure p1()
begin
  drop event e1;
end|
--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG
insert into t1 (a) values (1)|
drop table t1|
drop event e1|
delimiter ;|


# 
# End of tests
#

let $wait_condition=
  select count(*) = 0 from information_schema.processlist
  where db='events_test' and command = 'Connect' and user=current_user();
--source include/wait_condition.inc

drop database events_test;
