#
# Tests for various concurrency-related aspects of ALTER TABLE implemetation
#
# This test takes rather long time so let us run it only in --big-test mode
--source include/big_test.inc
# We are using some debug-only features in this test
--source include/have_debug.inc

# Also we are using SBR to check that statements are executed
# in proper order.
--source include/force_binlog_format_statement.inc

--source include/count_sessions.inc

#
# Additional coverage for the main ALTER TABLE case
#
# We should be sure that table being altered is properly
# locked during statement execution and in particular that
# no DDL or DML statement can sneak in and get access to
# the table when real operation has already taken place
# but this fact has not been noted in binary log yet.
--disable_warnings
drop table if exists t1, t2, t3;
--enable_warnings
connect (addconroot, localhost, root,,);
connect (addconroot2, localhost, root,,);
connection default;
create table t1 (i int);
# We are going to check that statements are logged in correct order
reset master;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
--send alter table t1 change i c char(10) default 'Test1';
connection addconroot;
# Wait until ALTER TABLE acquires metadata lock.
set debug_sync='now WAIT_FOR parked'; 
--send insert into t1 values ();
connection addconroot2;
# Wait until the above INSERT INTO t1 is blocked due to ALTER
let $wait_condition=
    select count(*) = 1 from information_schema.processlist
    where state = "Waiting for table metadata lock" and
          info = "insert into t1 values ()";
--source include/wait_condition.inc
# Resume ALTER execution.
set debug_sync='now SIGNAL go';
connection default;
--reap
connection addconroot;
--reap
connection default;
select * from t1;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
--send alter table t1 change c vc varchar(100) default 'Test2';
connection addconroot;
# Wait until ALTER TABLE acquires metadata lock.
set debug_sync='now WAIT_FOR parked';
--send rename table t1 to t2;
connection addconroot2;
# Wait until the above RENAME TABLE is blocked due to ALTER
let $wait_condition=
    select count(*) = 1 from information_schema.processlist
    where state = "Waiting for table metadata lock" and
          info = "rename table t1 to t2";
--source include/wait_condition.inc
# Resume ALTER execution.
set debug_sync='now SIGNAL go';
connection default;
--reap
connection addconroot;
--reap
connection default;
drop table t2;
# And now tests for ALTER TABLE with RENAME clause. In this
# case target table name should be properly locked as well.
create table t1 (i int);
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
--send alter table t1 change i c char(10) default 'Test3', rename to t2;
connection addconroot;
# Wait until ALTER TABLE acquires metadata lock.
set debug_sync='now WAIT_FOR parked';
--send insert into t2 values();
connection addconroot2;
# Wait until the above INSERT INTO t2 is blocked due to ALTER
let $wait_condition=
    select count(*) = 1 from information_schema.processlist
    where state = "Waiting for table metadata lock" and
           info = "insert into t2 values()";
--source include/wait_condition.inc
# Resume ALTER execution.
set debug_sync='now SIGNAL go';
connection default;
--reap
connection addconroot;
--reap
connection default;
select * from t2;
--send alter table t2 change c vc varchar(100) default 'Test2', rename to t1;
connection addconroot;
connection default;
--reap
rename table t1 to t3;

disconnect addconroot;
disconnect addconroot2;
drop table t3;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
set debug_sync='RESET';

# Check that all statements were logged in correct order
source include/show_binlog_events.inc;


--echo End of 5.1 tests
--source include/restore_default_binlog_format.inc

<<<<<<< HEAD

--echo #
--echo # Additional coverage for WL#7743 "New data dictionary: changes
--echo # to DDL-related parts of SE API".
--echo #
--echo # Killed ALTER TABLE on temporary table sometimes led to assertion
--echo # failure on connection close.
--enable_connect_log
--connect (con1, localhost, root,,)
create temporary table t1 (i int) engine=innodb;
set debug= "+d,mysql_lock_tables_kill_query";
--error ER_QUERY_INTERRUPTED
alter table t1 add index (i);
set debug= "-d,mysql_lock_tables_kill_query";
--echo # The below disconnect should drop temporary table automagically.
--disconnect con1
--source include/wait_until_disconnected.inc
connection default;
--disable_connect_log


--echo #
--echo # Test coverage for new (since 8.0) behavior of ALTER TABLE RENAME
--echo # under LOCK TABLES.
--echo #

--enable_connect_log
connect (con1, localhost, root,,);
SET @old_lock_wait_timeout= @@lock_wait_timeout;
connection default;

--echo #
--echo # 1) Simple ALTER TABLE RENAME.
--echo #
--echo # 1.1) Successfull ALTER TABLE RENAME.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 RENAME TO t2;
--echo # Table is available under new name under LOCK TABLES.
SELECT * FROM t2;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM t2;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not for old table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;

connection default;
UNLOCK TABLES;

--echo #
--echo # 1.2) ALTER TABLE RENAME in case when several tables are locked.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 RENAME TO t3;
--echo # Table t1 should be still locked, and t2 should be available as t3
--echo # with correct lock type.
SELECT * FROM t1;
INSERT INTO t3 values (1);
UNLOCK TABLES;

--echo #
--echo # 1.3) ALTER TABLE RENAME in case when same table locked more than once.
--echo #
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 RENAME TO t4;
--echo # Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
INSERT INTO t4 VALUES (2);
DELETE a FROM t4 AS a, t4 AS b;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
DELETE b FROM t4 AS a, t4 AS b;
UNLOCK TABLES;
DROP TABLES t1, t4;

--echo # 1.4) ALTER TABLE RENAME to different schema.
--echo #
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 RENAME TO mysqltest.t1;
--echo # Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM mysqltest.t1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not to old schema and table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;
--echo # Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
ALTER DATABASE mysqltest CHARACTER SET latin1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;

connection default;
UNLOCK TABLES;
DROP DATABASE mysqltest;

--echo #
--echo # 2) ALTER TABLE INPLACE with RENAME clause.
--echo #
--echo # 2.1) Successful ALTER TABLE INPLACE with RENAME clause.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN j INT, RENAME TO t2, ALGORITHM=INPLACE;
--echo # Table is available under new name under LOCK TABLES.
SELECT * FROM t2;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM t2;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not for old table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;

connection default;
UNLOCK TABLES;

--echo #
--echo # 2.2) ALTER TABLE INPLACE with RENAME clause in case when several
--echo #      tables are locked.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 ADD COLUMN k INT, RENAME TO t3, ALGORITHM=INPLACE;
--echo # Table t1 should be still locked, and t2 should be available as t3
--echo # with correct lock type.
SELECT * FROM t1;
INSERT INTO t3 values (1, 2, 3);
UNLOCK TABLES;

--echo #
--echo # 2.3) ALTER TABLE INPLACE with RENAME clause in case when same table
--echo #      locked more than once.
--echo #
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 ADD COLUMN l INT, RENAME TO t4, ALGORITHM=INPLACE;
--echo # Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
INSERT INTO t4 VALUES (2, 3, 4, 5);
DELETE a FROM t4 AS a, t4 AS b;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
DELETE b FROM t4 AS a, t4 AS b;
UNLOCK TABLES;
DROP TABLES t1, t4;

--echo # 2.4) ALTER TABLE INPLACE with RENAME clause to different schema.
--echo #
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN k INT, RENAME TO mysqltest.t1, ALGORITHM=INPLACE;
--echo # Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM mysqltest.t1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not to old schema and table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;
--echo # Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
ALTER DATABASE mysqltest CHARACTER SET latin1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;

connection default;
UNLOCK TABLES;
DROP DATABASE mysqltest;

--echo #
--echo # 3) ALTER TABLE COPY with RENAME clause.
--echo #
--echo # 3.1) Successful ALTER TABLE COPY with RENAME clause.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN j INT, RENAME TO t2, ALGORITHM=COPY;
--echo # Table is available under new name under LOCK TABLES.
SELECT * FROM t2;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM t2;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not for old table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;

connection default;
UNLOCK TABLES;

--echo #
--echo # 3.2) ALTER TABLE COPY with RENAME clause in case when several
--echo #      tables are locked.
--echo #
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 ADD COLUMN k INT, RENAME TO t3, ALGORITHM=COPY;
--echo # Table t1 should be still locked, and t2 should be available as t3
--echo # with correct lock type.
SELECT * FROM t1;
INSERT INTO t3 values (1, 2, 3);
UNLOCK TABLES;

--echo #
--echo # 3.3) ALTER TABLE COPY with RENAME clause in case when same table
--echo #      locked more than once.
--echo #
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 ADD COLUMN l INT, RENAME TO t4, ALGORITHM=COPY;
--echo # Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
INSERT INTO t4 VALUES (2, 3, 4, 5);
DELETE a FROM t4 AS a, t4 AS b;
--error ER_TABLE_NOT_LOCKED_FOR_WRITE
DELETE b FROM t4 AS a, t4 AS b;
UNLOCK TABLES;
DROP TABLES t1, t4;

--echo # 3.4) ALTER TABLE COPY with RENAME clause to different schema.
--echo #
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN k INT, RENAME TO mysqltest.t1, ALGORITHM=COPY;
--echo # Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;

connection con1;
--echo # Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM mysqltest.t1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--echo # But not to old schema and table name.
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;
--echo # Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
ALTER DATABASE mysqltest CHARACTER SET latin1;
SET @@lock_wait_timeout= @old_lock_wait_timeout;

connection default;
UNLOCK TABLES;
<<<<<<< HEAD
DROP DATABASE mysqltest;
=======
DROP TABLES t1, t4;

--echo #
--echo # 3.5) Special case ALTER TABLE COPY with RENAME clause which
--echo #      non-atomic, adds foreign keys and fails at the late stage.
--echo #
CREATE TABLE t1 (pk INT PRIMARY KEY) ENGINE=InnoDB;
CREATE TABLE t2 (fk INT) ENGINE=MyISAM;
LOCK TABLES t2 WRITE, t1 WRITE;
SET @@debug='+d,injecting_fault_writing';
--replace_regex /(errno: .*)/(errno: #)/
--error ER_ERROR_ON_WRITE
ALTER TABLE t2 ADD FOREIGN KEY (fk) REFERENCES t1(pk), ENGINE=InnoDB, RENAME TO t3, ALGORITHM=COPY;
SET @@debug='-d,injecting_fault_writing';
--echo # Table should be removed from locked tables list and new
--echo # table name should not be added.
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t2;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t3;

connection con1;
--echo # However, metadata locks on both old and new names are still kept.
# Disable prepared statements, since for them the below check
# works differently. The prepare phase of statements execution
# acquires weaker S metadata locks (which do not conflict with
# SNRW locks held by LOCK TABLE WRITE) and manages to discover
# that tables with such names don't exist.
--disable_ps_protocol
SET @@lock_wait_timeout= 1;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM t2;
--error ER_LOCK_WAIT_TIMEOUT
SELECT * FROM t3;
SET @@lock_wait_timeout= @old_lock_wait_timeout;
--enable_ps_protocol

connection default;
--echo # And delete from parent table is possible and doesn't cause asserts.
DELETE FROM t1;
UNLOCK TABLES;
DROP TABLES t3, t1;

connection con1;
disconnect con1;
--source include/wait_until_disconnected.inc
connection default;

--disable_connect_log
--echo #
--echo # Bug#24786075   FIND A WAY TO LIST #SQL... TABLE LEFT IN      
--echo #                DATA DICTIONARY IN CASE ALTER FAILS.
--echo # Test that we can see hidden temporary tables using ALTER TABLE.
--echo # Test that we can delete the hidden temporary tables that were
--echo # left by ALTER TABLE table failures in rare situations.
--echo #

CREATE TABLE t1(a INT) ENGINE=MyISAM;

SET debug="+d,exit_after_alter_table_before_rename";
--error ER_UNKNOWN_ERROR
ALTER TABLE t1 modify column a varchar(30);
SET debug="-d,exit_after_alter_table_before_rename";

--echo # Verify that #sql... tables are not seen by I_S and SHOW
SELECT COUNT(TABLE_NAME) FROM INFORMATION_SCHEMA.TABLES
  WHERE TABLE_SCHEMA='test' AND TABLE_NAME like '#sql%';
SHOW TABLES FROM test;

--echo # The SHOW EXTENDED [FULL] syntax should show the hidden table.
--replace_regex /#sql.*$/#sql-xxxxx/
SHOW EXTENDED TABLES FROM test;

--replace_regex /#sql.*$/#sql-xxxxx/
SHOW EXTENDED FULL TABLES FROM test;

--echo # Dropping the temporary table.
let $value=
  query_get_value(SHOW EXTENDED TABLES FROM test, Tables_in_test, 1);
let $stmt = DROP TABLE `$value`;
--replace_regex /#sql.*$/#sql-xxxxx/
eval $stmt;

--echo # Verify that the temporary table is dropped.
--replace_regex /#sql.*$/#sql-xxxxx/
SHOW EXTENDED TABLES FROM test;

--replace_regex /#sql.*$/#sql-xxxxx/
SHOW EXTENDED FULL TABLES FROM test;

--echo # clean-up
DROP TABLE t1;

# Wait till all disconnects are completed
--source include/wait_until_count_sessions.inc
=======
--echo #
--echo # BUG#29375764: SIMPLE ALTER CAUSE UNNECESSARY INNODB INDEX REBUILDS,
--echo #               5.7.23 OR LATER 5.7 RLSES
--echo #

############################################################################
# In 5.7.22:
# CREATE DATABASE my_db;
# CREATE TABLE my_db.t1(i INT PRIMARY KEY, v VARCHAR(9), KEY (v));
#
# DATADIR NAME: data_50722
# zip -r data_50722.zip data_50722
############################################################################

--echo # Copy the zipped 5.7.22 data directory and unzip it.
--copy_file $MYSQLTEST_VARDIR/std_data/data_50722.zip $MYSQL_TMP_DIR/data_50722.zip
--file_exists $MYSQL_TMP_DIR/data_50722.zip
--exec unzip -qo $MYSQL_TMP_DIR/data_50722.zip -d $MYSQL_TMP_DIR

let $DATADIR_50722 = $MYSQL_TMP_DIR/data_50722;
let $MYSQLD_LOG = $MYSQL_TMP_DIR/data_50722/my_err.log;

# SHUTDOWN
--source include/shutdown_mysqld.inc

--echo # Restart the server with the 5.7.22 data directory.
--exec echo "restart: --datadir=$DATADIR_50722 --log-error=$MYSQLD_LOG --innodb_undo_tablespaces=0" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc

--echo # UPGRADE
--exec $MYSQL_UPGRADE --skip-verbose --force 2>&1

SET DEBUG="+d, assert_index_def_has_no_pack_flag";
--echo # Without the patch, an assert is triggered, indicating that index definitions
--echo # have changed that would result in a index rebuild.
ALTER TABLE my_db.t1 COMMENT "No index rebuild necessary";

--echo # CLEANUP
DROP TABLE my_db.t1;
DROP DATABASE my_db;

# SHUTDOWN
--source include/shutdown_mysqld.inc

--echo # Remove copied files and directories.
--remove_file $MYSQL_TMP_DIR/data_50722.zip
--remove_files_wildcard $DATADIR_50722/sys *
--remove_files_wildcard $DATADIR_50722/mysql *
--remove_files_wildcard $DATADIR_50722/performance_schema *
--remove_files_wildcard $DATADIR_50722/test *
--remove_files_wildcard $DATADIR_50722 *
--rmdir $DATADIR_50722/sys
--rmdir $DATADIR_50722/mysql
--rmdir $DATADIR_50722/performance_schema
--rmdir $DATADIR_50722/test
--rmdir $DATADIR_50722

--echo # Restart server with default options.
--exec echo "restart:" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc
>>>>>>> upstream/cluster-7.6
>>>>>>> pr/231
