-- source include/have_query_cache.inc
-- source include/long_test.inc

#
# Tests with query cache
#
set GLOBAL query_cache_size=1355776;

# Reset query cache variables.

flush query cache; # This crashed in some versions
flush query cache; # This crashed in some versions
reset query cache;
flush status;
--disable_warnings
drop table if exists t1,t2,t3,t4,t11,t21,t1_1,t1_2,t9,t9_1,t9_2;
drop database if exists mysqltest;

# Fix possible left overs from other tests
drop table if exists ```a`;
drop view if exists v1;
--enable_warnings

#
# First simple test
#

create table t1 (a int not null);
insert into t1 values (1),(2),(3);
select * from t1;
select * from t1;
select sql_no_cache * from t1;
select length(now()) from t1;

# Only check the variables that are independent of the machine and startup
# options

show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";

drop table t1;

show status like "Qcache_queries_in_cache";

#
# MERGE TABLES with INSERT/UPDATE and DELETE
#
create table t1 (a int not null) ENGINE=MyISAM;
insert into t1 values (1),(2),(3);
create table t2 (a int not null) ENGINE=MyISAM;
insert into t2 values (4),(5),(6);
create table t3 (a int not null) engine=MERGE UNION=(t1,t2) INSERT_METHOD=FIRST;
# insert
select * from t3;
select * from t3;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
insert into t2  values (7);
show status like "Qcache_queries_in_cache";
select * from t1;
select * from t1;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
insert into t3 values (8);
show status like "Qcache_queries_in_cache";
# update
select * from t3;
show status like "Qcache_queries_in_cache";
update t2 set a=9 where a=7;
show status like "Qcache_queries_in_cache";
select * from t1;
show status like "Qcache_queries_in_cache";
update t3 set a=10 where a=1;
show status like "Qcache_queries_in_cache";
#delete
select * from t3;
show status like "Qcache_queries_in_cache";
delete from t2 where a=9;
show status like "Qcache_queries_in_cache";
select * from t1;
show status like "Qcache_queries_in_cache";
delete from t3 where a=10;
show status like "Qcache_queries_in_cache";
drop table t1, t2, t3;
#
# SELECT SQL_CACHE ...
#
set query_cache_type=demand;
create table t1 (a int not null);
insert into t1 values (1),(2),(3);
select * from t1;
show status like "Qcache_queries_in_cache";
select sql_cache * from t1 union select * from t1;
set query_cache_type=2;
select sql_cache * from t1 union select * from t1;

show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
set query_cache_type=on;
#
# RESET QUERY CACHE
#
reset query cache;
show status like "Qcache_queries_in_cache";
#
# SELECT SQL_NO_CACHE
#
select sql_no_cache * from t1;
show status like "Qcache_queries_in_cache";
drop table t1;
#
# Check that queries that uses NOW(), LAST_INSERT_ID()... are not cached.
#
create table t1 (a text not null);
select CONNECTION_ID() from t1;
#GET_LOCK
#RELEASE_LOCK
#LOAD_FILE
select FOUND_ROWS();
select NOW() from t1;
select CURDATE() from t1;
select CURTIME() from t1;
select DATABASE() from t1;
select ENCRYPT("test") from t1;
select LAST_INSERT_ID() from t1;
select RAND() from t1;
select UNIX_TIMESTAMP() from t1;
select USER() from t1;
select CURRENT_USER() from t1;
select benchmark(1,1) from t1;
explain extended select benchmark(1,1) from t1;
show status like "Qcache_queries_in_cache";
#
# Tests when the cache is filled
#
create table t2 (a text not null);
insert into t1 values("1111111111111111111111111111111111111111111111111111");
insert into t2 select * from t1;
insert into t1 select * from t2; # 2
insert into t2 select * from t1; # 3
insert into t1 select * from t2; # 5
insert into t2 select * from t1; # 8
insert into t1 select * from t2; # 13
insert into t2 select * from t1; # 21
insert into t1 select * from t2; # 34
insert into t2 select * from t1; # 55
insert into t1 select * from t2; # 89
insert into t2 select * from t1; # 144
insert into t1 select * from t2; # 233
insert into t2 select * from t1; # 357
insert into t1 select * from t2; # 610
insert into t2 select * from t1; # 987
insert into t1 select * from t2; # 1597
insert into t2 select * from t1; # 2584
insert into t1 select * from t2; # 4181

show status like "Qcache_hits";
show status like "Qcache_lowmem_prunes";
disable_result_log;
select a as a1, a as a2 from t1;
select a as a2, a as a3 from t1;
select a as a3, a as a4 from t1;
# next query must be out of 1Mb cache
select a as a1, a as a2 from t1;
enable_result_log;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
show status like "Qcache_lowmem_prunes";
reset query cache;
#
# Query bigger then query_cache_limit
#
insert into t2 select * from t1;
insert into t1 select * from t2;
insert into t2 select * from t1;
insert into t1 select * from t2;
insert into t2 select * from t1;
insert into t1 select * from t2;
insert into t2 select * from t1;
insert into t1 select * from t2;
insert into t2 select * from t1;
insert into t1 select * from t2;
disable_result_log;
select * from t1;
enable_result_log;
show status like "Qcache_queries_in_cache";
drop table t1,t2;

#
# noncachable ODBC work around (and prepare cache for drop database)
#
create database mysqltest;
create table mysqltest.t1 (i int not null auto_increment, a int, primary key (i));
insert into mysqltest.t1 (a) values (1);
select * from mysqltest.t1 where i is null;

#
# drop db
#
create table t1(a int);
select * from t1;
show status like "Qcache_queries_in_cache";
select * from mysqltest.t1;
show status like "Qcache_queries_in_cache";
drop database mysqltest;
show status like "Qcache_queries_in_cache";
drop table t1;

#
# Charset conversion (cp1251_koi8 always present)
#
create table t1 (a char(1) not null collate koi8r_general_ci);
insert into t1 values(_koi8r"á");
set CHARACTER SET koi8r;
select * from t1;
set CHARACTER SET cp1251_koi8;
select * from t1;
set CHARACTER SET DEFAULT;
show status like "Qcache_queries_in_cache";
show status like "Qcache_hits";
drop table t1;

# The following tests can't be done as the values differen on 32 and 64 bit
#  machines :(
#show variables like "query_cache_size";
#show status like "Qcache_free_memory";

#
# same tables in different db
#
create database if not exists mysqltest;
create table mysqltest.t1 (i int not null);
create table t1 (i int not null);
insert into mysqltest.t1 (i) values (1);
insert into t1 (i) values (2);

select * from t1;
use mysqltest;
select * from t1;
select * from t1;
use test;
select * from t1;
show status like "Qcache_queries_in_cache";
show status like "Qcache_hits";

drop database mysqltest;
drop table t1;

#
# FOUND_ROWS()
#

create table t1 (i int not null);
insert into t1 (i) values (1),(2),(3),(4);

select SQL_CALC_FOUND_ROWS * from t1 limit 2;
select FOUND_ROWS();
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";

select * from t1 where i=1;
select FOUND_ROWS();
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";

select SQL_CALC_FOUND_ROWS * from t1 limit 2;
select FOUND_ROWS();
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";

select * from t1 where i=1;
select FOUND_ROWS();
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
drop table t1;

#
# Test insert delayed
#

flush query cache;
reset query cache;

create table t1 (a int not null) ENGINE=MyISAM;
insert into t1 values (1),(2),(3);
select * from t1;
select * from t1;
show status like "Qcache_queries_in_cache";
insert delayed into t1 values (4);
--sleep 5     # Wait for insert delayed to be executed.
select a from t1;
show status like "Qcache_queries_in_cache";
drop table t1;
show status like "Qcache_queries_in_cache";

#
# Test of min result data unit size changing
#
show global variables like "query_cache_min_res_unit";
set GLOBAL query_cache_min_res_unit=1001;
show global variables like "query_cache_min_res_unit";
create table t1 (a int not null);
insert into t1 values (1),(2),(3);
create table t2 (a int not null);
insert into t2 values (1),(2),(3);
select * from t1;
select * from t1;
select * from t2;
select * from t2;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
drop table t1;
select a from t2;
select a from t2;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
drop table t2;
set GLOBAL query_cache_min_res_unit=default;
show global variables like "query_cache_min_res_unit";

#
# Case sensitive test
#
create table t1 (a int not null);
insert into t1 values (1);
select "aaa" from t1;
select "AAA" from t1;
drop table t1;

#
# Test of query cache resizing
#
create table t1 (a int);
set GLOBAL query_cache_size=1000;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=1024;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=10240;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=20480;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=40960;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=51200;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=61440;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=81920;
show global variables like "query_cache_size";
select * from t1;
set GLOBAL query_cache_size=102400;
show global variables like "query_cache_size";
select * from t1;
drop table t1;

#
# Temporary tables
#
set GLOBAL query_cache_size=1048576;
create table t1 (i int not null);
create table t2 (i int not null);
select * from t1;
show status like "Qcache_queries_in_cache";
create temporary table t3 (i int not null);
select * from t2;
show status like "Qcache_queries_in_cache";
select * from t3;
show status like "Qcache_queries_in_cache";
update t1 set i=(select distinct 1 from (select * from t2) a);
drop table t1, t2, t3;

#
# system databse test
#
use mysql;
disable_result_log;
select * from db;
enable_result_log;
show status like "Qcache_queries_in_cache";
use test;
disable_result_log;
select * from mysql.db;
enable_result_log;
show status like "Qcache_queries_in_cache";

#
# simple rename test
#
create table t1(id int auto_increment primary key);
insert into t1 values (NULL), (NULL), (NULL);
select * from t1 where id=2;
alter table t1 rename to t2;
--error ER_NO_SUCH_TABLE
select * from t1 where id=2;
drop table t2;
--error ER_NO_SUCH_TABLE
select * from t1 where id=2;

#
# Load data invalidation test
#
create table t1 (word char(20) not null);
select * from t1;
show status like "Qcache_queries_in_cache";
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
eval load data infile '$MYSQLTEST_VARDIR/std_data/words.dat' into table t1;
show status like "Qcache_queries_in_cache";
select count(*) from t1;
drop table t1;

#
# INTO OUTFILE/DUMPFILE test
#
create table t1 (a int);
insert into t1 values (1),(2),(3);
show status like "Qcache_queries_in_cache";
select * from t1 into outfile "query_cache.out.file";
--error ER_FILE_EXISTS_ERROR
select * from t1 into outfile "query_cache.out.file";
select * from t1 limit 1 into dumpfile "query_cache.dump.file";
show status like "Qcache_queries_in_cache";
drop table t1;
let $datadir=`select @@datadir`;
--remove_file $datadir/test/query_cache.dump.file
--remove_file $datadir/test/query_cache.out.file

#
# test of SQL_SELECT_LIMIT
#
create table t1 (a int);
insert into t1 values (1),(2);
show status like "Qcache_queries_in_cache";
select * from t1;
SET OPTION SQL_SELECT_LIMIT=1;
select * from t1;
show status like "Qcache_queries_in_cache";
SET OPTION SQL_SELECT_LIMIT=DEFAULT;
drop table t1;

#
# query cache crash on using same table twice in one query test
#
flush query cache;
reset query cache;
flush status;
set GLOBAL query_cache_size=1048576;

create table t1 (a int not null);
insert into t1 values (1),(2),(3);
create table t2 (a text not null);
create table t3 (a text not null);
insert into t3 values("1111111111111111111111111111111111111111111111111111");
insert into t2 select * from t3;
insert into t3 select * from t2;
insert into t2 select * from t3;
insert into t3 select * from t2;
insert into t2 select * from t3;
insert into t3 select * from t2;
insert into t2 select * from t3;
insert into t3 select * from t2;
insert into t2 select * from t3;
insert into t3 select * from t2;
drop table t2;
create table t2 (a int not null);
insert into t2 values (1),(2),(3);
create table t4 (a int not null);
insert into t4 values (1),(2),(3);

disable_result_log;
select * from t4;
select * from t2;
select * from t1 as tt, t1 as ttt  where tt.a=1 and ttt.a=2;
select * from t2;
select * from t4;
select * from t1 as tt, t1 as ttt  where tt.a=1 and ttt.a=2;
select * from t2;
select * from t4;
select * from t1 as tt, t1 as ttt  where tt.a=1 and ttt.a=2;

delete from t2 where a=1;
flush query cache;
select * from t3;
enable_result_log;
delete from t4 where a=1;
flush query cache;
drop table t1,t2,t3,t4;

#
# WRITE LOCK & QC
#
set query_cache_wlock_invalidate=1;
create table t1 (a int not null);
create table t2 (a int not null);
create view v1 as select * from t1;
select * from t1;
select * from t2;
show status like "Qcache_queries_in_cache";
lock table t1 write, t2 read;
show status like "Qcache_queries_in_cache";
unlock table;
select * from t1;
# Implicit locking of t1 does not invalidate QC
show status like "Qcache_queries_in_cache";
lock table v1 write;
show status like "Qcache_queries_in_cache";
unlock table;
drop view v1;
drop table t1,t2;
set query_cache_wlock_invalidate=default;

#
# hiding real table stored in query cache by temporary table
#
CREATE TABLE t1 (id INT PRIMARY KEY);
insert into t1 values (1),(2),(3);
select * from t1;
create temporary table t1 (a int not null auto_increment
primary key);
select * from t1;
drop table t1;
drop table t1;

#
# Test character set related variables:
#   character_set_result
#   character_set_client
#   charactet_set_connection/collation_connection
# If at least one of the above variables has changed,
# the cached query can't be reused. In the below test
# absolutely the same query is used several times,
# SELECT should fetch different results for every instance.
# No hits should be produced.
# New cache entry should appear for every SELECT.
#
SET NAMES koi8r;
CREATE TABLE t1 (a char(1) character set koi8r);
INSERT INTO t1 VALUES (_koi8r'á'),(_koi8r'Á');
#
# Run select
#
SELECT a,'Â','â'='Â' FROM t1;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
#
# Change collation_connection and run the same query again
#
set collation_connection=koi8r_bin;
SELECT a,'Â','â'='Â' FROM t1;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
#
# Now change character_set_client and run the same query again
#
set character_set_client=cp1251;
SELECT a,'Â','â'='Â' FROM t1;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
#
# And finally change character_set_results and run the same query again
#
set character_set_results=cp1251;
SELECT a,'Â','â'='Â' FROM t1;
show status like "Qcache_hits";
show status like "Qcache_queries_in_cache";
SET NAMES default;

DROP TABLE t1;

#
# DROP current database test
#
CREATE TABLE t1 (a int(1));
CREATE DATABASE mysqltest;
USE mysqltest;
DROP DATABASE mysqltest;
SELECT * FROM test.t1;
USE test;
DROP TABLE t1;

#
# charset with NULL
#
set character_set_results=null;
select @@character_set_results;
set character_set_results=default;
#
# query cache and environment variables
#
# max_sort_length
set GLOBAL query_cache_size=1355776;
create table t1 (id int auto_increment primary key, c char(25));
insert into t1 set c = repeat('x',24);
insert into t1 set c = concat(repeat('x',24),'x');
insert into t1 set c = concat(repeat('x',24),'w');
insert into t1 set c = concat(repeat('x',24),'y');
set max_sort_length=200;
select c from t1 order by c, id;
reset query cache;
set max_sort_length=20;
select c from t1 order by c, id;
set max_sort_length=200;
select c from t1 order by c, id;
set max_sort_length=default;
# sql_mode
select '1' || '3' from t1;
set SQL_MODE=oracle;
select '1' || '3' from t1;
set SQL_MODE=default;
drop table t1;
# group_concat_max_len
create table t1 (a varchar(20), b int);
insert into t1 values ('12345678901234567890', 1);
set group_concat_max_len=10;
select group_concat(a) FROM t1 group by b;
set group_concat_max_len=1024;
select group_concat(a) FROM t1 group by b;
set group_concat_max_len=default;
drop table t1;

# comments before command
#
create table t1 (a int);
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
/**/ select * from t1;
/**/ select * from t1;
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";

#
# Keep things tidy
#
DROP TABLE t1;
SET GLOBAL query_cache_size=0;

#
# Information schema & query cache test
#
SET SESSION query_cache_type = 2;
create table t1(a int);
select table_name from information_schema.tables
where table_schema="test";
drop table t1;
select table_name from information_schema.tables
where table_schema="test";
# Bug #8480: REPAIR TABLE needs to flush the table from the query cache
SET SESSION query_cache_type = 1;
set global query_cache_size=1024*1024;
flush query cache;
create table t1 ( a int );
insert into t1 values (1);
select a from t1;
select a from t1;
show status like 'qcache_queries_in_cache';
repair table t1;
show status like 'qcache_queries_in_cache';
drop table t1;

#
# Bug #9549: Make sure cached queries that span more than one cache block
# are handled properly in the embedded server.
#
# We just want a small query cache, so we can fragment it easily
set GLOBAL query_cache_size=64*1024;
# This actually gives us a usable cache size of about 48K

# Each table is about 14K
create table t1 (a text);
insert into t1 values (repeat('abcdefghijklmnopqrstuvwxyz', 550));
create table t2 (a text);
insert into t2 values (repeat('ijklmnopqrstuvwxyzabcdefgh', 550));

# Load a query from each table into the query cache
--disable_result_log
select a from t1; # Q1
select a from t2; # Q2
--enable_result_log
show status like 'Qcache_%_blocks';

# Now the cache looks like (14K for Q1)(14K for Q2)(20K free)

# Flush Q1 from the cache by adding an out-of-order chunk to t1
insert into t1 select reverse(a) from t1;
show status like 'Qcache_%_blocks';

# Now the cache looks like (14K free)(14K for Q2)(20K free)

# Load our new data into the query cache
--disable_result_log
select a from t1;  # Q3
--enable_result_log
show status like 'Qcache_%_blocks';

# Now the cache should be like (14K for Q3)(14K for Q2)(14K for Q3)(6K free)

# Note that Q3 is split across two chunks!

# Load Q3 from the cache, and actually pay attention to the results
select a from t1;

flush query cache;

drop table t1, t2;
set GLOBAL query_cache_size=1355776;


#
# Query with warning prohibited to query cache (BUG#9414)
#
flush status;
CREATE TABLE t1 (
  `date` datetime NOT NULL default '0000-00-00 00:00:00',
  KEY `date` (`date`)
) ENGINE=MyISAM;

INSERT INTO t1 VALUES ('20050326');
INSERT INTO t1 VALUES ('20050325');
SELECT COUNT(*) FROM t1 WHERE date BETWEEN '20050326' AND '20050327 invalid';
SELECT COUNT(*) FROM t1 WHERE date BETWEEN '20050326' AND '20050328 invalid';
SELECT COUNT(*) FROM t1 WHERE date BETWEEN '20050326' AND '20050327 invalid';
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
drop table t1;

#
# queries with subquery in the FROM clause (BUG#11522)
#
create table t1 (a int);
insert into t1 values (1);
reset query cache;
flush status;
select * from (select * from t1) a;
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
select * from (select * from t1) a;
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
insert into t1 values (2);
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
select * from (select * from t1) a;
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
drop table t1;

#
# BUG#14652: Queries with leading '(' characters.
#
create table t1 (a int);
flush status;
(select a from t1) union (select a from t1);
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";
(select a from t1) union (select a from t1);
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";

set query_cache_strip_comments=1;
(select a from t1) union (select a from t1);
(select a from t1) /* */union (select a from t1);
set query_cache_strip_comments=0;
(select a from t1) union (select a from t1);
show status like "Qcache_queries_in_cache";
show status like "Qcache_inserts";
show status like "Qcache_hits";

drop table t1;

#
# SP cursors and selects with query cache (BUG#9715)
#
create table t1 (a int);
insert into t1 values (1),(2);

--disable_warnings
drop procedure if exists p1;
--enable_warnings
delimiter //;
CREATE PROCEDURE `p1`()
begin
Declare c1 cursor for select a from t1;
open c1;
select * from t1;
end//
call p1()//
drop procedure p1;

create function f1() returns int
begin
Declare var1 int;
select max(a) from t1 into var1;
return var1;
end//
create procedure `p1`()
begin
 select a, f1() from t1;
end//
SET @old_log_bin_trust_function_creators= @@global.log_bin_trust_function_creators;
SET GLOBAL log_bin_trust_function_creators = 1;
call p1()//
SET GLOBAL log_bin_trust_function_creators = @old_log_bin_trust_function_creators;
drop procedure p1//
drop function f1//

drop table t1//
delimiter ;//

#
# query in QC from normal execution and SP (BUG#6897)
# improved to also test BUG#3583 and BUG#12990
#
flush query cache;
reset query cache;
flush status;
delimiter //;
create table t1 (s1 int)//
create procedure f1 () begin
select sql_cache * from t1;
select sql_cache * from t1;
select sql_cache * from t1;
end;//
create procedure f2 () begin
select sql_cache * from t1 where s1=1;
select sql_cache * from t1;
end;//
create procedure f3 () begin
select sql_cache * from t1;
select sql_cache * from t1 where s1=1;
end;//
create procedure f4 () begin
select sql_cache * from t1;
select sql_cache * from t1 where s1=1;
select sql_cache * from t1;
select sql_cache * from t1 where s1=1;
select sql_cache * from t1 where s1=1;
end;//
delimiter ;//
call f1();
call f1();
call f1();
select sql_cache * from t1;
insert into t1 values (1);
select sql_cache * from t1;
call f1();
call f1();
select sql_cache * from t1;
flush query cache;
reset query cache;
flush status;
select sql_cache * from t1;
select sql_cache * from t1 where s1=1;
call f1();
call f2();
call f3();
call f4();
call f4();
call f3();
call f2();
select sql_cache * from t1 where s1=1;
insert into t1 values (2);
call f1();
select sql_cache * from t1 where s1=1;
select sql_cache * from t1;
call f1();
call f3();
call f3();
call f1();

drop procedure f1;
drop procedure f2;
drop procedure f3;
drop procedure f4;
drop table t1;
set GLOBAL query_cache_size=0;

--echo End of 4.1 tests

#
# Bug #10303: problem with last_query_cost
#

SET GLOBAL query_cache_size=102400;
create table t1(a int);
insert into t1 values(0), (1), (4), (5);
select * from t1 where a > 3;
select * from t1 where a > 3;
show status like 'last_query_cost';
drop table t1;
SET GLOBAL query_cache_size=0;

#
# Bug #20045: Server crash on INSERT ... SELECT ... FROM non-mergeable view
#
set global query_cache_size=1024*1024;
flush status;
create table t1 (a int);
insert into t1 (a) values (1), (2), (3);
select * from t1;
show status like 'Qcache_hits';
select * from t1;
show status like 'Qcache_hits';
create table t2 like t1;
select * from t1;
show status like 'Qcache_hits';
insert into t2 select * from t1;
select * from t1;
show status like 'Qcache_hits';
drop table t1, t2;

create table t1(c1 int);
create table t2(c1 int);
create table t3(c1 int);
create view v1 as select t3.c1 as c1 from t3,t2 where t3.c1 = t2.c1;
start transaction;
insert into t1(c1) select c1 from v1;
drop table t1, t2, t3;
drop view v1;


#
# If running with --ps-protocol:
# see if a query from the text protocol is served with results cached
# from a query which used the binary (which would be wrong, results
# are in different formats); if that happens, the results will
# be incorrect and the test will fail.
#

create table t1(c1 int);
insert into t1 values(1),(10),(100);
select * from t1;
-- disable_ps_protocol
select * from t1;
select * from t1;
-- enable_ps_protocol
select * from t1;
drop table t1;

set global query_cache_size=0;

#
# Query cache and changes to system variables
#

create table t1 (a int);
insert into t1 values (1),(2),(3);
set GLOBAL query_cache_type=1;
set GLOBAL query_cache_limit=10240;
set GLOBAL query_cache_min_res_unit=0;
set GLOBAL query_cache_size= 102400;

# default_week_format
reset query cache;
set LOCAL default_week_format = 0;
select week('2007-01-04');
select week('2007-01-04') from t1;
select extract(WEEK FROM '2007-01-04') from t1;

set LOCAL default_week_format = 2;
select week('2007-01-04');
select week('2007-01-04') from t1;
select extract(WEEK FROM '2007-01-04') from t1;

# div_precision_increment
reset query cache;
set LOCAL div_precision_increment=2;
select 1/7;
select 1/7 from t1;

set LOCAL div_precision_increment=4;
select 1/7;
select 1/7 from t1;

drop table t1;

CREATE TABLE t1 (a VARCHAR(200), b TEXT, FULLTEXT (a,b));
INSERT INTO t1 VALUES('MySQL has now support', 'for full-text search'),
                       ('Full-text indexes', 'are called collections'),
                          ('Only MyISAM tables','support collections'),
             ('Function MATCH ... AGAINST()','is used to do a search'),
        ('Full-text search in MySQL', 'implements vector space model');


set GLOBAL ft_boolean_syntax='+ -><()~*:""&|';

select *, MATCH(a,b) AGAINST("+called +collections" IN BOOLEAN MODE) as x from t1;

# swap +/-
set GLOBAL ft_boolean_syntax='- +><()~*:""&|';

select *, MATCH(a,b) AGAINST("+called +collections" IN BOOLEAN MODE) as x from t1;

# If in the future we need to cache queries with functions
# be sure not to cause dead lock if the query cache is flushed
# while inserting a query in the query cache.
delimiter |;
create function change_global() returns integer deterministic
begin
  set global ft_boolean_syntax='+ -><()~*:""&|';
  return 1;
end|
delimiter ;|
select *, change_global() from t1;
drop function change_global;

drop table t1;

set GLOBAL query_cache_type=default;
set GLOBAL query_cache_limit=default;
set GLOBAL query_cache_min_res_unit=default;
set GLOBAL query_cache_size= default;


#
# Bug#28897 UUID() returns non-unique values when query cache is enabled
#

set GLOBAL query_cache_size=1024000;

create table t1 (a char);
insert into t1 values ('c');

let $q1= `select UUID(), a from t1`;
let $q2= `select UUID(), a from t1`;

# disabling the logging of the query because the UUIDs are different each run.
--disable_query_log
eval select a  from t1 where "$q1" = "$q2";
--enable_query_log

drop table t1;

set GLOBAL query_cache_size= default;

#
# Bug #29053 SQL_CACHE in UNION causes non-deterministic functions to be cached
#

# This syntax is no longer allowed, therefore the test case has been commented 
# out.
# See test for Bug#35020 below.
#set GLOBAL query_cache_size=1000000;
#
#create table t1 (a char);
#insert into t1 values ('c');
#
#let $q1= `select RAND() from t1 union select sql_cache 1 from t1;`;
#let $q2= `select RAND() from t1 union select sql_cache 1 from t1;`; 
#
# disabling the logging of the query because the times are different each run.
#--disable_query_log
#eval select a  from t1 where "$q1" = "$q2";
#--enable_query_log
#
#drop table t1;
#
#set GLOBAL query_cache_size= default;

#
# Bug#29856: Insufficient buffer space led to a server crash.
#
SET GLOBAL query_cache_size=64*1024*1024;
CREATE TABLE t1 (id INT);
DELIMITER |;
CREATE PROCEDURE proc29856(IN theUPC TEXT)
BEGIN
  SET @stmtStr := '';
  SELECT CONCAT("SELECT id FROM t1 WHERE id IN (",theUPC,")") INTO @stmtStr;
  PREPARE stmt FROM @stmtStr;
  EXECUTE stmt;
END |
DELIMITER ;|
CALL proc29856('1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,
51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,
102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,
121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,
140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,
178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,
197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,
235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,
254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,
273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,
292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,
311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,
330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,
349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,
368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,
387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,
406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,
425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,
444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,
463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,
482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,
501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,
520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,
539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,
558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,
577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,
596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,
615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,
634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,
653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,
672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,
691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,
710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,
729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,
748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,
767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,
786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,
805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,
824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,
843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,
862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,
881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,
900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,
919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,
938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,
957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,
976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,
995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,
1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,
1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,
1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,
1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,
1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,
1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,
1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,
1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,
1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,
1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,
1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,
1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,
1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,
1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,
1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,
1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,
1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,
1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,
1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,
1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,
1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,
1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,
1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,
1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,
1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,
1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,
1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,
1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,
1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,
1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,
1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,
1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,
1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,
1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,
1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,
1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,
1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,
1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,
1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,
1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,
1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,
1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,
1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,
1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,
1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,
1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,
1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,
1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,
1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,
1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,
1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,
1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,
1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,
1806,1807,1808,1809,1810,1811');
DROP PROCEDURE proc29856;
DROP TABLE t1;
SET GLOBAL query_cache_size= default;

#
--echo #
--echo # Bug#25132 disabled query cache: Qcache_free_blocks = 1
--echo #
set global query_cache_size=102400;
set global query_cache_size=0;
set global query_cache_type=0;
show status like 'Qcache_free_blocks';

--error ER_QUERY_CACHE_DISABLED
set global query_cache_size=102400;
set global query_cache_type=on;
set session query_cache_type=on;

--echo Restore default values.
 --disable_warnings
 drop database if exists db1;
 drop database if exists db2;
 --enable_warnings
 set GLOBAL query_cache_size=15*1024*1024;
 create database db1;
 use db1;
 create table t1(c1 int)engine=myisam;
 insert into t1(c1) values (1);
 select * from db1.t1 f;
 show status like 'Qcache_queries_in_cache';

 create database db2;
 rename table db1.t1 to db2.t2;
 drop database db1;
 show status like 'Qcache_queries_in_cache';
 drop database db2;
 set global query_cache_size=default;

 --disable_warnings
 drop database if exists db1;
 drop database if exists db3;
 --enable_warnings
 set GLOBAL query_cache_size=15*1024*1024;
 create database db1;
 create database db3;
 use db1;
 create table t1(c1 int) engine=myisam;
 use db3;
 create table t1(c1 int) engine=myisam;
 use db1;
 insert into t1(c1) values (1);
 use test;
 select * from db1.t1;
 select c1+1 from db1.t1;
 select * from db3.t1;
 show status like 'Qcache_queries_in_cache';
 create database db2;
 rename table db1.t1 to db2.t2; 
 drop database db1;
 show status like 'Qcache_queries_in_cache';
 drop database db2;
 drop database db3;

set GLOBAL query_cache_type=default;
set GLOBAL query_cache_limit=default;
set GLOBAL query_cache_min_res_unit=default;
set GLOBAL query_cache_size=default;
set local query_cache_type=default;

#
# Bug#33756 - query cache with concurrent_insert=0 appears broken
#
FLUSH STATUS;
SET GLOBAL query_cache_size=10*1024*1024;
SET @save_concurrent_insert= @@concurrent_insert;
SET GLOBAL concurrent_insert= 0;
CREATE TABLE t1 (c1 INT NOT NULL) ENGINE=MyISAM;
INSERT INTO t1 (c1) VALUES (1), (2);
#
SHOW GLOBAL VARIABLES LIKE 'concurrent_insert';
SHOW STATUS LIKE 'Qcache_hits';
SELECT * FROM t1;
SELECT * FROM t1;
SHOW STATUS LIKE 'Qcache_hits';
DROP TABLE t1;
SET GLOBAL concurrent_insert= @save_concurrent_insert;
SET GLOBAL query_cache_size= default;

#
# Bug#36326: nested transaction and select
#

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

FLUSH STATUS;
SET GLOBAL query_cache_size=1048576;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4),(5);
SHOW STATUS LIKE 'Qcache_queries_in_cache';
SELECT * FROM t1;
BEGIN;
SELECT * FROM t1;
COMMIT;
SHOW STATUS LIKE 'Qcache_queries_in_cache';
SHOW STATUS LIKE "Qcache_hits";
SELECT * FROM t1;
BEGIN;
SELECT * FROM t1;
COMMIT;
SHOW STATUS LIKE "Qcache_hits";
DROP TABLE t1;
SET GLOBAL query_cache_size= default;

#
# Bug#6760: Add SLEEP() function (feature request)
#
#   Logics of original test:
#   Reveal that a query with SLEEP does not need less time than estimated.
#
# Bug#12689: SLEEP() gets incorrectly cached/optimized-away
#
#   Description from bug report (slightly modified)
#
#   Bug 1 (happened all time):
#      SELECT * FROM t1 WHERE SLEEP(1) will only result in a sleep of 1
#      second, regardless of the number of rows in t1.
#   Bug 2 (happened all time):
#      Such a query will also get cached by the query cache, but should not.
#
# Notes (mleich, 2008-05)
# =======================
#
# Experiments around
#    Bug#36345 Test 'func_misc' fails on RHAS3 x86_64
# showed that the tests for both bugs could produce in case of parallel
# artificial system time (like via ntpd)
# - decreases false alarm
# - increases false success
#
# We try here to circumvent these issues by reimplementation of the tests
# and sophisticated scripting, although the cause of the problems is a massive
# error within the setup of the testing environment.
# Tests relying on or checking derivates of the system time must never meet
# parallel manipulations of system time.
#
# Results of experiments with/without manipulation of system time,
# information_schema.processlist content, high load on testing box
# ----------------------------------------------------------------
# Definition: Predicted_cumulative_sleep_time =
#                #_of_result_rows * sleep_time_per_result_row
#
# 1. Total (real sleep time) ~= predicted_cumulative_sleep_time !!
# 2. The state of a session within the PROCESSLIST changes to 'User sleep'
#    if the sessions runs a statement containing the sleep function and the
#    processing of the statement is just within the phase where the sleep
#    is done. (*)
# 3. NOW() and processlist.time behave "synchronous" to system time and
#    show also the "jumps" caused by system time manipulations. (*)
# 4. processlist.time is unsigned, the "next" value below 0 is ~ 4G (*)
# 5. Current processlist.time ~= current real sleep time if the system time
#    was not manipulated. (*)
# 6. High system load can cause delays of <= 2 seconds.
# 7. Thanks to Davi for excellent hints and ideas.
#
#    (*)
#    - information_schema.processlist is not available before MySQL 5.1.
#    - Observation of processlist content requires a
#      - "worker" session sending the query with "send" and pulling results
#        with "reap"
#      - session observing the processlist parallel to the worker session
#      "send" and "reap" do not work in case of an embedded server.
#    Conclusion: Tests based on processlist have too many restrictions.
#
# Solutions for subtests based on TIMEDIFF of values filled via NOW()
# -------------------------------------------------------------------
# Run the following sequence three times
#    1. SELECT <start_time>
#    2. Query with SLEEP
#    3. SELECT <end_time>
# If TIMEDIFF(<end_time>,<start_time>) is at least two times within a
# reasonable range assume that we did not met errors we were looking for.
#
# It is extreme unlikely that we have two system time changes within the
# < 30 seconds runtime. Even if the unlikely happens, there are so
# frequent runs of this test on this or another testing box which will
# catch the problem.
#

--echo #------------------------------------------------------------------------
--echo # Tests for Bug#6760 and Bug#12689
# Number of rows within the intended result set.
SET @row_count = 4;
# Parameter within SLEEP function
SET @sleep_time_per_result_row = 1;
# Maximum acceptable delay caused by high load on testing box
SET @max_acceptable_delay = 2;
# TIMEDIFF = time for query with sleep (mostly the time caused by SLEEP)
#            + time for delays caused by high load on testing box
# Ensure that at least a reasonable fraction of TIMEDIFF belongs to the SLEEP
# by appropriate setting of variables.
# Ensure that any "judging" has a base of minimum three attempts.
# (Test 2 uses all attempts except the first one.)
if (!` SELECT (@sleep_time_per_result_row * @row_count - @max_acceptable_delay >
              @sleep_time_per_result_row) AND (@row_count - 1 >= 3)`)
{
   --echo # Have to abort because of error in plausibility check
   --echo ######################################################
   --vertical_results
   SELECT @sleep_time_per_result_row * @row_count - @max_acceptable_delay >
               @sleep_time_per_result_row AS must_be_1,
               @row_count - 1 >= 3 AS must_be_also_1,
               @sleep_time_per_result_row, @row_count, @max_acceptable_delay;
   exit;
}
SET @@global.query_cache_size = 1024 * 64;
--disable_warnings
DROP TEMPORARY TABLE IF EXISTS t_history;
DROP TABLE IF EXISTS t1;
--enable_warnings
CREATE TEMPORARY TABLE t_history (attempt SMALLINT,
start_ts DATETIME, end_ts DATETIME,
start_cached INTEGER, end_cached INTEGER);
CREATE TABLE t1 (f1 BIGINT);
let $num = `SELECT @row_count`;
--disable_query_log
begin;
while ($num)
{
   INSERT INTO t1 VALUES (1);
   dec $num;
}
commit;
--enable_query_log

let $loops = 4;
let $num = $loops;
while ($num)
{
   let $Qcache_queries_in_cache =
       query_get_value(SHOW STATUS LIKE 'Qcache_queries_in_cache', Value, 1);
   eval
   INSERT INTO t_history
   SET attempt = $loops - $num + 1, start_ts = NOW(),
       start_cached = $Qcache_queries_in_cache;
   SELECT *, SLEEP(@sleep_time_per_result_row) FROM t1;
   #
   # Do not determine Qcache_queries_in_cache before updating end_ts. The SHOW
   # might cost too much time on an overloaded box.
   eval
   UPDATE t_history SET end_ts = NOW()
   WHERE attempt = $loops - $num + 1;
   let $Qcache_queries_in_cache =
          query_get_value(SHOW STATUS LIKE 'Qcache_queries_in_cache', Value, 1);
   eval
   UPDATE t_history SET end_cached = $Qcache_queries_in_cache
   WHERE attempt = $loops - $num + 1;
   # DEBUG eval SELECT * FROM t_history WHERE attempt = $loops - $num + 1;
   dec $num;
}

# 1. The majority of queries with SLEEP must need a reasonable time
#    -> SLEEP has an impact on runtime
#       = Replacement for original Bug#6760 test
#    -> total runtime is clear more needed than for one result row needed
#       = Replacement for one of the original Bug#12689 tests
--echo # Test 1: Does the query with SLEEP need a reasonable time?
eval SELECT COUNT(*) >= $loops - 1 INTO @aux1 FROM t_history
WHERE TIMEDIFF(end_ts,start_ts) - @sleep_time_per_result_row * @row_count
      BETWEEN 0 AND @max_acceptable_delay;
SELECT @aux1 AS "Expect 1";
#
# 2. The majority of queries (the first one must be ignored) with SLEEP must
#    need a reasonable time
#    -> If we assume that the result of a cached query will be sent back
#       immediate, without any sleep, than the query with SLEEP cannot be cached
#       (current and intended behaviour for queries with SLEEP).
#    -> It could be also not excluded that the query was cached but the server
#       honoured somehow the SLEEP. Such a behaviour would be also acceptable.
#    = Replacement for one of the original Bug#12689 tests
--echo # Test 2: Does the query with SLEEP need a reasonable time even in case
--echo #         of the non first execution?
eval SELECT COUNT(*) >= $loops - 1 - 1 INTO @aux2 FROM t_history
WHERE TIMEDIFF(end_ts,start_ts) - @sleep_time_per_result_row * @row_count
      BETWEEN 0 AND @max_acceptable_delay
      AND attempt > 1;
SELECT @aux2 AS "Expect 1";
#
# 3. The query with SLEEP should be not cached.
#    -> SHOW STATUS Qcache_queries_in_cache must be not incremented after
#       the execution of the query with SLEEP
--echo # Test 3: The query with SLEEP must be not cached.
eval SELECT COUNT(*) = $loops INTO @aux3 FROM t_history
WHERE end_cached = start_cached;
SELECT @aux3 AS "Expect 1";
#
# Dump the content of t_history if one of the tests failed.
if (`SELECT @aux1 + @aux2 + @aux3 <> 3`)
{
   --echo # Some tests failed, dumping the content of t_history
   SELECT * FROM t_history;
}
DROP TABLE t1;
DROP TEMPORARY TABLE t_history;
SET @@global.query_cache_size = default;

--echo End of 5.0 tests

#
# Bug #31157: Crash when select+order by the avg of some field within the
# group by
#
SET GLOBAL query_cache_size=1024*1024*512;
CREATE TABLE t1 (a ENUM('rainbow'));
INSERT INTO t1 VALUES (),(),(),(),();
SELECT 1 FROM t1 GROUP BY (SELECT 1 FROM t1 ORDER BY AVG(LAST_INSERT_ID()));
DROP TABLE t1;
CREATE TABLE t1 (a LONGBLOB);
INSERT INTO t1 SET a = 'aaaa';
INSERT INTO t1 SET a = 'aaaa';
SELECT 1 FROM t1 GROUP BY
  (SELECT LAST_INSERT_ID() FROM t1 ORDER BY MIN(a) ASC LIMIT 1);
DROP TABLE t1;
SET GLOBAL query_cache_size= default;


#
# Bug#35020: illegal sql_cache select syntax
#
CREATE TABLE t1( a INT );

--error ER_PARSE_ERROR
SET @v = ( SELECT SQL_CACHE    1 );
--error ER_PARSE_ERROR
SET @v = ( SELECT SQL_NO_CACHE 1 );

#
# Keywords 'SQL_CACHE' and 'SQL_NO_CACHE' are allowed as column names.
# Hence the error messages are not intuitive.
#
--error ER_BAD_FIELD_ERROR 
SELECT a FROM t1 WHERE a IN ( SELECT SQL_CACHE    a FROM t1 );
--error ER_BAD_FIELD_ERROR 
SELECT a FROM t1 WHERE a IN ( SELECT SQL_NO_CACHE a FROM t1 );
--error ER_BAD_FIELD_ERROR
SELECT ( SELECT SQL_CACHE a FROM t1 );
--error ER_BAD_FIELD_ERROR
SELECT ( SELECT SQL_NO_CACHE a FROM t1 );

SELECT SQL_CACHE * FROM t1;
SELECT SQL_NO_CACHE * FROM t1;

# SQL_CACHE is only allowed once in first top-level select.
--error ER_CANT_USE_OPTION_HERE
SELECT * FROM t1 UNION SELECT SQL_CACHE * FROM t1;
--error ER_CANT_USE_OPTION_HERE
SELECT * FROM t1 UNION SELECT SQL_NO_CACHE * FROM t1;
--error ER_BAD_FIELD_ERROR
SELECT * FROM t1 WHERE a IN (SELECT SQL_CACHE a FROM t1);
--error ER_BAD_FIELD_ERROR
SELECT * FROM t1 WHERE a IN (SELECT a FROM t1 UNION SELECT SQL_CACHE a FROM t1);

--error ER_CANT_USE_OPTION_HERE
SELECT * FROM t1 UNION SELECT SQL_NO_CACHE * FROM t1;
--error ER_BAD_FIELD_ERROR
SELECT * FROM t1 WHERE a IN (SELECT SQL_NO_CACHE a FROM t1);
--error ER_BAD_FIELD_ERROR
SELECT * FROM t1 WHERE a IN 
  (SELECT a FROM t1 UNION SELECT SQL_NO_CACHE a FROM t1);
--error ER_WRONG_USAGE
SELECT SQL_CACHE SQL_NO_CACHE * FROM t1;
--error ER_WRONG_USAGE
SELECT SQL_NO_CACHE SQL_CACHE * FROM t1;
--error ER_CANT_USE_OPTION_HERE
SELECT SQL_CACHE * FROM t1 UNION SELECT SQL_CACHE * FROM t1;
--error ER_CANT_USE_OPTION_HERE
SELECT SQL_CACHE * FROM t1 UNION SELECT SQL_NO_CACHE * FROM t1;
--error ER_CANT_USE_OPTION_HERE
SELECT SQL_NO_CACHE * FROM t1 UNION SELECT SQL_CACHE * FROM t1;
--error ER_CANT_USE_OPTION_HERE
SELECT SQL_NO_CACHE * FROM t1 UNION SELECT SQL_NO_CACHE * FROM t1;
--error ER_BAD_FIELD_ERROR
SELECT SQL_CACHE * FROM t1 WHERE a IN 
  (SELECT SQL_NO_CACHE a FROM t1);
--error ER_BAD_FIELD_ERROR
SELECT SQL_CACHE * FROM t1 WHERE a IN 
  (SELECT a FROM t1 UNION SELECT SQL_NO_CACHE a FROM t1);

DROP TABLE t1;

--echo End of 5.1 tests

--echo #
--echo # Bug#51336 Assert in reload_acl_and_cache during RESET QUERY CACHE
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

CREATE TABLE t1(id INT);

START TRANSACTION;
SELECT * FROM t1;
# This caused an assert
RESET QUERY CACHE;

COMMIT;
DROP TABLE t1;
--echo New query cache switching OFF mechanism test
set global query_cache_size=1024*1024*20;
set global query_cache_type=on;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;
set global query_cache_size=0;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;
set global query_cache_size=1024*1024*20;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;
set global query_cache_type=off;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;
set global query_cache_type=on;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;
set local query_cache_type= on;
select @@query_cache_size, @@global.query_cache_type, @@local.query_cache_type;

--echo #
--echo # MDEV-4981: Account for queries handled by query-cache in
--echo # USER_STATISTICS (and in HOST_STATISTICS)
--echo #

SET GLOBAL userstat=1;
set GLOBAL query_cache_size=1355776;
FLUSH USER_STATISTICS;
FLUSH CLIENT_STATISTICS;
reset query cache;
flush status;

create table t1 (a int);
insert into t1 values (1);
select * from t1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";
select * from t1;
select * from t1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";

drop table t1;
FLUSH USER_STATISTICS;
FLUSH CLIENT_STATISTICS;
flush status;

create table t1 (a int);
select * from t1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";
select * from t1;
select * from t1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";

FLUSH USER_STATISTICS;
FLUSH CLIENT_STATISTICS;
flush status;

create procedure p1()
  select * from t1;
call p1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";
call p1;
call p1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";

FLUSH USER_STATISTICS;
FLUSH CLIENT_STATISTICS;
flush status;

SET GLOBAL query_cache_size= 0;
call p1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";
call p1;
call p1;
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.CLIENT_STATISTICS
where CLIENT="localhost";
select SELECT_COMMANDS,ROWS_SENT,EMPTY_QUERIES from INFORMATION_SCHEMA.USER_STATISTICS
where USER="root";
show status like "Qcache_hits";
drop procedure p1;
drop table t1;
set GLOBAL query_cache_size=1355776;
SET GLOBAL userstat=default;

--echo End of 5.5 tests

--echo restore defaults
SET GLOBAL query_cache_type= default;
SET GLOBAL query_cache_size= default;
SET LOCAL query_cache_type= default;
