
--disable_warnings
drop table if exists t1, t2;
--enable_warnings

let $MYSQLD_DATADIR= `SELECT @@datadir`;

--echo #
--echo #BUG 18618561: FAILED ALTER TABLE ENGINE CHANGE WITH PARTITIONS
--echo #              CORRUPTS FRM
--echo # After WL#8971, the test case was rewritten to use InnoDB.
CREATE TABLE t1 (fld1 INT PRIMARY KEY) ENGINE= INNODB PARTITION BY HASH(fld1)
PARTITIONS 5;
SHOW CREATE TABLE t1;

--error ER_CHECK_NOT_IMPLEMENTED
ALTER TABLE t1 ENGINE= ARCHIVE;

--echo #After the patch, the ENGINE is correctly displayed as InnoDB
SHOW CREATE TABLE t1;

--echo #Cleanup.
DROP TABLE t1;

--echo #
--echo # Bug#11763825/56590: PARTITIONS: FULLTEXT SEARCHES FAIL
--echo # (bad/confusing error message)
--echo # After WL#8971, the test case was rewritten to use InnoDB.
--echo # The errors returned are  different.
--echo #
CREATE TABLE t1
(a INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
 b VARCHAR(200),
 c TEXT)
ENGINE=InnoDB
PARTITION BY HASH(a) PARTITIONS 1;

--error ER_TABLE_CANT_HANDLE_FT
CREATE FULLTEXT INDEX msg ON t1 (b, c);
DROP TABLE t1;

--error ER_TABLE_CANT_HANDLE_FT
CREATE TABLE t1
(a INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
 b VARCHAR(200),
 c TEXT,
 FULLTEXT (b, c))
ENGINE=InnoDB
PARTITION BY HASH(a) PARTITIONS 1;

--echo #
--echo # BUG#11933226 - 60681: CHECKSUM TABLE RETURNS 0 FOR PARTITIONED TABLE
--echo # After WL#8971, the test case was rewritten to use InnoDB.
--echo #
CREATE TABLE t1 (
  i INT
)
ENGINE=InnoDB
PARTITION BY RANGE (i)
(PARTITION p3 VALUES LESS THAN (3),
 PARTITION p5 VALUES LESS THAN (5),
 PARTITION pMax VALUES LESS THAN MAXVALUE);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6);
CHECKSUM TABLE t1;
ALTER TABLE t1 CHECKSUM = 1;
CHECKSUM TABLE t1 EXTENDED;
CHECKSUM TABLE t1;
SHOW CREATE TABLE t1;
DROP TABLE t1;

--echo # Same test without partitioning
CREATE TABLE t1 (
  i INT
) ENGINE=InnoDB;
SHOW CREATE TABLE t1;
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6);
CHECKSUM TABLE t1;
ALTER TABLE t1 CHECKSUM = 1;
CHECKSUM TABLE t1 EXTENDED;
CHECKSUM TABLE t1;
SHOW CREATE TABLE t1;
DROP TABLE t1;

--echo #
--echo # Bug#13694811: THE OPTIMIZER WRONGLY USES THE FIRST
--echo #               INNODB PARTITION STATISTICS
--echo #

CREATE TABLE t1
(a INT,
 b varchar(64),
 PRIMARY KEY (a),
 KEY (b))
ENGINE = InnoDB
PARTITION BY RANGE (a)
SUBPARTITION BY HASH (a) SUBPARTITIONS 10
(PARTITION pNeg VALUES LESS THAN (0),
 PARTITION p0 VALUES LESS THAN (1000),
 PARTITION pMAX VALUES LESS THAN MAXVALUE);

--echo # Only one row in the first 10 subpartitions
INSERT INTO t1 VALUES (-1, 'Only negative pk value');

INSERT INTO t1 VALUES (0, 'Mod Zero'), (1, 'One'), (2, 'Two'), (3, 'Three'),
(10, 'Zero'), (11, 'Mod One'), (12, 'Mod Two'), (13, 'Mod Three'),
(20, '0'), (21, '1'), (22, '2'), (23, '3'),
(4, '4'), (5, '5'), (6, '6'), (7, '7'), (8, '8'), (9, '9');
INSERT INTO t1 SELECT a + 30, b FROM t1 WHERE a >= 0;
ANALYZE TABLE t1;
EXPLAIN SELECT b FROM t1 WHERE b between 'L' and 'N' AND a > -100;
DROP TABLE t1;

--echo #
--echo # Bug#13007154: Crash in keys_to_use_for_scanning with ORDER BY
--echo #               and PARTITIONING
--echo #
CREATE TABLE t1 (a INT, KEY(a))
ENGINE = InnoDB
PARTITION BY KEY (a) PARTITIONS 1;
SELECT 1 FROM t1 WHERE a > (SELECT LAST_INSERT_ID() FROM t1 LIMIT 0)
ORDER BY a;
DROP TABLE t1;

--echo #
--echo # Bug#56287: crash when using Partition datetime in sub in query
--echo #

CREATE TABLE t1
(c1 bigint(20) unsigned NOT NULL AUTO_INCREMENT,
 c2 varchar(40) not null default '',
 c3 datetime not  NULL,
 PRIMARY KEY (c1,c3),
 KEY partidx(c3))
ENGINE=InnoDB
PARTITION BY RANGE (TO_DAYS(c3))
(PARTITION p200912 VALUES LESS THAN (to_days('2010-01-01')),
 PARTITION p201103 VALUES LESS THAN (to_days('2011-04-01')),
 PARTITION p201912 VALUES LESS THAN MAXVALUE);

insert into t1(c2,c3) values ("Test row",'2010-01-01 00:00:00');

SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 't1' AND TABLE_SCHEMA = 'test';
SELECT count(*) FROM t1 p where c3 in
(SELECT c3 FROM t1 t WHERE t.c3 < TIMESTAMP'2011-04-26 19:19:44'
 AND t.c3 > TIMESTAMP'2011-04-26 19:18:44') ;

DROP TABLE t1;


--echo #
--echo # Bug#54747: Deadlock between REORGANIZE PARTITION and
--echo #            SELECT is not detected
--echo #

# we need concurrency of 2 to allow InnoDB intrinsic table (spawned
# by Optimizer) to proceed.
SET @old_innodb_thread_concurrency := @@innodb_thread_concurrency;
SET @old_innodb_thread_sleep_delay := @@innodb_thread_sleep_delay;
SET GLOBAL innodb_thread_concurrency = 2;

CREATE TABLE t1
(user_num BIGINT,
 hours SMALLINT,
 KEY user_num (user_num))
ENGINE = InnoDB   
PARTITION BY RANGE COLUMNS (hours)
(PARTITION hour_003 VALUES LESS THAN (3),
 PARTITION hour_004 VALUES LESS THAN (4),
 PARTITION hour_005 VALUES LESS THAN (5),
 PARTITION hour_last VALUES LESS THAN (MAXVALUE));

INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3), (4, 4), (5, 5);

BEGIN;
SELECT COUNT(*) FROM t1;

--echo # con1
--connect (con1,localhost,root,,)
--echo # SEND a ALTER PARTITION which waits on the ongoing transaction.
--send
ALTER TABLE t1
REORGANIZE PARTITION hour_003, hour_004 INTO
(PARTITION oldest VALUES LESS THAN (4));

--echo # Connection default wait until the ALTER is in 'waiting for table...'
--echo # state and then continue the transaction by trying a SELECT
--connection default
let $wait_condition =
SELECT COUNT(*) = 1
FROM information_schema.processlist
WHERE INFO like 'ALTER TABLE t1%REORGANIZE PARTITION hour_003, hour_004%'
AND STATE = 'Waiting for table metadata lock';
--source include/wait_condition.inc
SELECT COUNT(*) FROM t1;
COMMIT;

--echo # con1, reaping ALTER.
--connection con1
--reap

--echo # Disconnecting con1 and switching to default. Cleaning up.
--disconnect con1

--connection default

SET GLOBAL innodb_thread_concurrency = @old_innodb_thread_concurrency;
SET GLOBAL innodb_thread_sleep_delay = @old_innodb_thread_sleep_delay;
DROP TABLE t1;


--echo #
--echo # Bug#50418: DROP PARTITION does not interact with transactions
--echo #
CREATE TABLE t1 (
    id INT AUTO_INCREMENT NOT NULL,
    name CHAR(50) NOT NULL,
    myDate DATE NOT NULL,
    PRIMARY KEY (id, myDate),
    INDEX idx_date (myDate)
    ) ENGINE=InnoDB
PARTITION BY RANGE ( TO_DAYS(myDate) ) (
    PARTITION p0 VALUES LESS THAN (734028),
    PARTITION p1 VALUES LESS THAN (734029),
    PARTITION p2 VALUES LESS THAN (734030),
    PARTITION p3 VALUES LESS THAN MAXVALUE
    ) ;
INSERT INTO t1 VALUES 
(NULL, 'Lachlan', '2009-09-13'),
  (NULL, 'Clint', '2009-09-13'),
  (NULL, 'John', '2009-09-14'),
  (NULL, 'Dave', '2009-09-14'),
  (NULL, 'Jeremy', '2009-09-15'),
  (NULL, 'Scott', '2009-09-15'),
  (NULL, 'Jeff', '2009-09-16'),
  (NULL, 'Joe', '2009-09-16');
SET AUTOCOMMIT=0;
SELECT * FROM t1 FOR UPDATE;
UPDATE t1 SET name = 'Mattias' WHERE id = 7;
SELECT * FROM t1 WHERE id = 7;
--connect (con1, localhost, root,,)
--echo # Connection con1
SET lock_wait_timeout = 1;
--echo # After the patch it will wait and fail on timeout.
--error ER_LOCK_WAIT_TIMEOUT
ALTER TABLE t1 DROP PARTITION p3;
SHOW WARNINGS;
--disconnect con1
--connection default
--echo # Connection default
SELECT * FROM t1;
--echo # No changes.
COMMIT;
DROP TABLE t1;


--echo #
--echo # Bug#51830: Incorrect partition pruning on range partition (regression)
--echo #
CREATE TABLE t1 (a INT NOT NULL)
ENGINE = InnoDB
PARTITION BY RANGE(a)
(PARTITION p10 VALUES LESS THAN (10),
 PARTITION p30 VALUES LESS THAN (30),
 PARTITION p50 VALUES LESS THAN (50),
 PARTITION p70 VALUES LESS THAN (70),
 PARTITION p90 VALUES LESS THAN (90));
INSERT INTO t1 VALUES (10),(30),(50);
INSERT INTO t1 VALUES (70);
INSERT INTO t1 VALUES (80);
INSERT INTO t1 VALUES (89);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
INSERT INTO t1 VALUES (90);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
INSERT INTO t1 VALUES (100);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert INTO t1 VALUES (110);
ANALYZE TABLE t1;
EXPLAIN SELECT * FROM t1 WHERE a > 90;
EXPLAIN SELECT * FROM t1 WHERE a >= 90;
EXPLAIN SELECT * FROM t1 WHERE a = 90;
EXPLAIN SELECT * FROM t1 WHERE a = 89;
EXPLAIN SELECT * FROM t1 WHERE a >= 89;
EXPLAIN SELECT * FROM t1 WHERE a > 89;
EXPLAIN SELECT * FROM t1 WHERE a = 100;
EXPLAIN SELECT * FROM t1 WHERE a >= 100;
EXPLAIN SELECT * FROM t1 WHERE a > 100;
DROP TABLE t1;

--echo #
--echo # Bug#50104: Partitioned table with just 1 partion works with fk
--echo #
CREATE TABLE t2 (
  id INT,
  PRIMARY KEY (id)
) ENGINE=InnoDB ;

CREATE TABLE t1 (
  id INT NOT NULL AUTO_INCREMENT,
  parent_id INT DEFAULT NULL,
  PRIMARY KEY (id),
  KEY parent_id (parent_id)
) ENGINE=InnoDB;

ALTER TABLE t1 PARTITION BY HASH (id) PARTITIONS 1;

--error ER_FOREIGN_KEY_ON_PARTITIONED
ALTER TABLE t1 ADD CONSTRAINT test_ibfk_1 FOREIGN KEY (parent_id) REFERENCES t2 (id);

ALTER TABLE t1 PARTITION BY HASH (id) PARTITIONS 2;

--error ER_FOREIGN_KEY_ON_PARTITIONED
ALTER TABLE t1 ADD CONSTRAINT test_ibfk_1 FOREIGN KEY (parent_id) REFERENCES t2 (id);

DROP TABLE t1, t2;

#
# BUG#47774, Assertion failure in InnoDB using column list partitioning
#
create table t1 (a varchar(5), b int signed, c varchar(10), d datetime)
partition by range columns(b,c)
subpartition by hash(to_seconds(d))
( partition p0 values less than (2, 'b'),
  partition p1 values less than (4, 'd'),
  partition p2 values less than (10, 'za'));
insert into t1 values ('a', 3, 'w', '2001-10-27 04:34:00');
insert into t1 values ('r', 7, 'w', '2001-10-27 05:34:00');
insert into t1 values ('g', 10, 'w', '2001-10-27 06:34:00');
update t1 set a = 'c' where a > 'f';
drop table t1;

#
# BUG#47776, Failed to update for MEMORY engine, crash for InnoDB and success for MyISAM
#
# Removed test cases for MyISAM and Memory when removing the Partition engine.

create table t1 (a varchar(5))
engine=innodb
partition by range columns(a)
( partition p0 values less than ('m'),
  partition p1 values less than ('za'));
insert into t1 values  ('j');
update t1 set a = 'z' where (a >= 'j');
drop table t1;

#
# Bug#47029: Crash when reorganize partition with subpartition
#
create table t1 (a int not null,
                 b datetime not null,
                 primary key (a,b))
engine=innodb
partition by range (to_days(b))
subpartition by hash (a)
subpartitions 2
( partition p0 values less than (to_days('2009-01-01')),
  partition p1 values less than (to_days('2009-02-01')),
  partition p2 values less than (to_days('2009-03-01')),
  partition p3 values less than maxvalue);
alter table t1 reorganize partition p1,p2 into
( partition p2 values less than (to_days('2009-03-01')));
drop table t1;
#
# Bug#40595: Non-matching rows not released with READ-COMMITTED on tables
#            with partitions
CREATE TABLE t1 (id INT PRIMARY KEY, data INT) ENGINE = InnoDB 
PARTITION BY RANGE(id) ( 
 PARTITION p0 VALUES LESS THAN (5), 
 PARTITION p1 VALUES LESS THAN (10), 
 PARTITION p2 VALUES LESS THAN MAXVALUE 
);

INSERT INTO t1 VALUES (1,1), (2,2), (3,3), (4,4), (5,5), (6,6), (7,7), (8,8),
                      (9,9), (10,10), (11,11);

SET @old_transaction_isolation := @@session.transaction_isolation;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

SET autocommit = 0;

UPDATE t1 SET DATA = data*2 WHERE id = 3;

# SHOW ENGINE InnoDB STATUS does not show transaction info in
# PERFORMANCE-VERSION
# grouping/referencing in replace_regex is very slow on long strings,
# removing all before/after the interesting row before grouping/referencing
#--replace_regex /.*---TRANSACTION [0-9]+ [0-9]+, .*, OS thread id [0-9]+// /MySQL thread id [0-9]+, query id [0-9]+ .*// /.*([0-9]+) lock struct\(s\), heap size [0-9]+, ([0-9]+) row lock\(s\).*/\1 lock struct(s) \2 row lock(s)/
#SHOW ENGINE InnoDB STATUS;

UPDATE t1 SET data = data*2 WHERE data = 2;

# SHOW ENGINE InnoDB STATUS does not show transaction info in
# PERFORMANCE-VERSION
# grouping/referencing in replace_regex is very slow on long strings,
# removing all before/after the interesting row before grouping/referencing
#--replace_regex /.*---TRANSACTION [0-9]+ [0-9]+, .*, OS thread id [0-9]+// /MySQL thread id [0-9]+, query id [0-9]+ .*// /.*([0-9]+ lock struct\(s\)), heap size [0-9]+, ([0-9]+ row lock\(s\)).*/\1 \2/
#SHOW ENGINE InnoDB STATUS;

SET @@session.transaction_isolation = @old_transaction_isolation;
SET autocommit = default;

DROP TABLE t1;

#
# Bug37721: ORDER BY when WHERE contains non-partitioned index column
# wrong order since it did not use pk as second compare
--echo # Bug#37721, test of ORDER BY on PK and WHERE on INDEX
CREATE TABLE t1 (
  a INT,
  b INT,
  PRIMARY KEY (a),
  INDEX (b))
ENGINE InnoDB
PARTITION BY HASH(a)
PARTITIONS 3;
# This will give the middle partition the highest value
INSERT INTO t1 VALUES (0,0),(4,0),(2,0);
SELECT a FROM t1 WHERE b = 0 ORDER BY a ASC;
SELECT a FROM t1 WHERE b = 0 ORDER BY a DESC;
ALTER TABLE t1 DROP INDEX b;
SELECT a FROM t1 WHERE b = 0 ORDER BY a ASC;
SELECT a FROM t1 WHERE b = 0 ORDER BY a DESC;
DROP TABLE t1;
CREATE TABLE t1 (
  a VARCHAR(600),
  b VARCHAR(600),
  PRIMARY KEY (a),
  INDEX (b))
ENGINE InnoDB
PARTITION BY KEY(a)
PARTITIONS 3;
# This will give the middle partition the highest value
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'1'),repeat('0',257));
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'3'),repeat('0',257));
INSERT INTO t1 VALUES (concat(repeat('MySQL',100),'2'),repeat('0',257));
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a ASC;
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a DESC;
ALTER TABLE t1 DROP INDEX b;
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a ASC;
SELECT right(a,1) FROM t1 WHERE b = repeat('0',257) ORDER BY a DESC;
DROP TABLE t1;

#
# Bug #14673: Wrong InnoDB default row format
#
create table t1 (a int) engine=innodb partition by hash(a) ;
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status like 't1';
drop table t1;

#
# Bug 21173: SHOW TABLE STATUS crashes server in InnoDB
#
create table t1 (a int)
engine = innodb
partition by key (a);
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status;
insert into t1 values (0), (1), (2), (3);
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status;
drop table t1;

create table t1 (a int auto_increment primary key)
engine = innodb
partition by key (a);
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status;
insert into t1 values (NULL), (NULL), (NULL), (NULL);
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status;
insert into t1 values (NULL), (NULL), (NULL), (NULL);
analyze table t1;
# Avg_row_length (col 6) and Data_length (col 7) vary depending
# on the page size.  Data_free for InnoDB tablespace varies
# depending on which tests have been run before this one.
--replace_column 6 # 7 # 10 # 12 # 13 #
show table status;
drop table t1;

#
# BUG 19122 Crash after ALTER TABLE t1 REBUILD PARTITION p1
#
create table t1 (a int)
partition by key (a)
(partition p1 engine = innodb);

alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
alter table t1 rebuild partition p1;
drop table t1;

#
# Bug 21339: Crash in Explain Partitions
#
create table t1 (a date)
engine = innodb
partition by range (year(a))
(partition p0 values less than (2006),
 partition p1 values less than (2007));
explain select * from t1
where a between '2006-01-01' and '2007-06-01';
drop table t1;

#
# Bug 20397: Partitions: Crash when using non-existing engine
#
--error ER_UNKNOWN_STORAGE_ENGINE
create table t1 (a int)
engine = x
partition by key (a);

create table t1 (a int)
engine = innodb
partition by list (a)
(partition p0 values in (0));

--error ER_UNKNOWN_STORAGE_ENGINE
alter table t1 engine = x;
show create table t1;
drop table t1;

# BUG#26117: index_merge sort-union over partitioned table crashes

create table t1
(
  id int unsigned auto_increment,
  time datetime not null,
  first_name varchar(40),
  last_name varchar(50),
  primary key (id, time),
  index first_index (first_name),
  index last_index (last_name)	
) engine=Innodb partition by range (to_days(time)) (
  partition p1 values less than (to_days('2007-02-07')),
  partition p2 values less than (to_days('2007-02-08')),
  partition p3 values less than MAXVALUE
);

insert into t1 (time, first_name, last_name) values ('2007-02-07', 'Q', 'Robert'),
('2007-02-07', 'Mark', 'Nate'), ('2007-02-07', 'Nate', 'Oscar'),
('2007-02-07', 'Zack', 'Alice'), ('2007-02-07', 'Jack', 'Kathy'),
('2007-02-06', 'Alice', 'Alice'), ('2007-02-06', 'Brian', 'Charles'),
('2007-02-06', 'Charles', 'David'), ('2007-02-06', 'David', 'Eric'),
('2007-02-07', 'Hector', 'Isaac'), ('2007-02-07', 'Oscar', 'Patricia'),
('2007-02-07', 'Patricia', 'Q'), ('2007-02-07', 'X', 'Yuri'),
('2007-02-07', 'Robert', 'Shawn'), ('2007-02-07', 'Kathy', 'Lois'),
('2007-02-07', 'Eric', 'Francis'), ('2007-02-06', 'Shawn', 'Theron'),
('2007-02-06', 'U', 'Vincent'), ('2007-02-06', 'Francis', 'George'),
('2007-02-06', 'George', 'Hector'), ('2007-02-06', 'Vincent', 'Walter'),
('2007-02-06', 'Walter', 'X'), ('2007-02-07', 'Lois', 'Mark'),
('2007-02-07', 'Yuri', 'Zack'), ('2007-02-07', 'Isaac', 'Jack'),
('2007-02-07', 'Sharon', 'Mark'), ('2007-02-07', 'Michael', 'Michelle'),
('2007-02-07', 'Derick', 'Nathan'), ('2007-02-07', 'Peter', 'Xavier'),
('2007-02-07', 'Fred', 'Harold'), ('2007-02-07', 'Katherine', 'Lisa'),
('2007-02-07', 'Tom', 'Rina'), ('2007-02-07', 'Jerry', 'Victor'),
('2007-02-07', 'Alexander', 'Terry'), ('2007-02-07', 'Justin', 'John'),
('2007-02-07', 'Greg', 'Ernest'), ('2007-02-07', 'Robert', 'Q'),
('2007-02-07', 'Nate', 'Mark'), ('2007-02-07', 'Oscar', 'Nate'),
('2007-02-07', 'Alice', 'Zack'), ('2007-02-07', 'Kathy', 'Jack'),
('2007-02-06', 'Alice', 'Alice'), ('2007-02-06', 'Charles', 'Brian'),
('2007-02-06', 'David', 'Charles'), ('2007-02-06', 'Eric', 'David'),
('2007-02-07', 'Isaac', 'Hector'), ('2007-02-07', 'Patricia', 'Oscar'),
('2007-02-07', 'Q', 'Patricia'), ('2007-02-07', 'Yuri', 'X'),
('2007-02-07', 'Shawn', 'Robert'), ('2007-02-07', 'Lois', 'Kathy'),
('2007-02-07', 'Francis', 'Eric'), ('2007-02-06', 'Theron', 'Shawn'),
('2007-02-06', 'Vincent', 'U'), ('2007-02-06', 'George', 'Francis'),
('2007-02-06', 'Hector', 'George'), ('2007-02-06', 'Walter', 'Vincent'),
('2007-02-06', 'X', 'Walter'), ('2007-02-07', 'Mark', 'Lois'),
('2007-02-07', 'Zack', 'Yuri'), ('2007-02-07', 'Jack', 'Isaac'),
('2007-02-07', 'Mark', 'Sharon'), ('2007-02-07', 'Michelle', 'Michael'),
('2007-02-07', 'Nathan', 'Derick'), ('2007-02-07', 'Xavier', 'Peter'),
('2007-02-07', 'Harold', 'Fred'), ('2007-02-07', 'Lisa', 'Katherine'),
('2007-02-07', 'Rina', 'Tom'), ('2007-02-07', 'Victor', 'Jerry'),
('2007-02-07', 'Terry', 'Alexander'), ('2007-02-07', 'John', 'Justin'),
('2007-02-07', 'Ernest', 'Greg');

SELECT * FROM t1 WHERE first_name='Andy' OR last_name='Jake';

drop table t1;

#
# BUG#30583 - Partition on DOUBLE key + INNODB + count(*) == crash
#
CREATE TABLE t1 (a DOUBLE NOT NULL, KEY(a)) ENGINE=InnoDB
PARTITION BY KEY(a) PARTITIONS 10;
INSERT INTO t1 VALUES(1),(2);
SELECT COUNT(*) FROM t1;
DROP TABLE t1;

#
# BUG#46483 - drop table of partitioned table may leave extraneous file
# Note: was only repeatable with InnoDB plugin
#
CREATE TABLE t1 (a INT) ENGINE=InnoDB
  PARTITION BY list(a) (PARTITION p1 VALUES IN (1));
CREATE INDEX i1 ON t1 (a);
DROP TABLE t1;

# Before the fix it should show extra file like #sql-2405_2.par
--list_files $MYSQLD_DATADIR/test/ *

--disable_testcase BUG#0000
--echo #
--echo # Bug#47343: InnoDB fails to clean-up after lock wait timeout on
--echo #            REORGANIZE PARTITION
--echo #
CREATE TABLE t1 (
	a INT,
	b DATE NOT NULL,
	PRIMARY KEY (a, b)
) ENGINE=InnoDB
PARTITION BY RANGE (a) (
	PARTITION pMAX VALUES LESS THAN MAXVALUE
) ;

INSERT INTO t1 VALUES (1, '2001-01-01'), (2, '2002-02-02'), (3, '2003-03-03');

START TRANSACTION;
SELECT * FROM t1 FOR UPDATE;

connect (con1, localhost, root,,);
--echo # Connection con1
--error ER_LOCK_WAIT_TIMEOUT
ALTER TABLE t1 REORGANIZE PARTITION pMAX INTO
(PARTITION p3 VALUES LESS THAN (3),
 PARTITION pMAX VALUES LESS THAN MAXVALUE);
SHOW WARNINGS;
--error ER_LOCK_WAIT_TIMEOUT
ALTER TABLE t1 REORGANIZE PARTITION pMAX INTO
(PARTITION p3 VALUES LESS THAN (3),
 PARTITION pMAX VALUES LESS THAN MAXVALUE);
SHOW WARNINGS;

#Contents of the 'test' database directory:
--list_files $MYSQLD_DATADIR/test

disconnect con1;
connection default;
--echo # Connection default
SELECT * FROM t1;
COMMIT;
DROP TABLE t1;

#
# Bug #55146    Assertion 'm_part_spec.start_part == m_part_spec.end_part' in index_read_idx_map
#

CREATE TABLE t1 (i1 int NOT NULL primary key, f1 int) ENGINE = InnoDB
    PARTITION BY HASH(i1) PARTITIONS 2;

INSERT INTO t1 VALUES (1,1), (2,2);

SELECT * FROM t1 WHERE i1 = ( SELECT i1 FROM t1 WHERE f1=0 LIMIT 1 );

DROP TABLE t1;

--enable_testcase

--echo #
--echo # Bug#54783: optimize table crashes with invalid timestamp default value and NO_ZERO_DATE
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (a INT, b TIMESTAMP DEFAULT '0000-00-00 00:00:00')
  ENGINE=INNODB PARTITION BY LINEAR HASH (a) PARTITIONS 1;
SET @old_mode = @@sql_mode;
SET SESSION sql_mode = '';
OPTIMIZE TABLE t1;
SET SESSION sql_mode = @old_mode;
DROP TABLE t1;
SET sql_mode = default;

--echo #
--echo # Bug#57985 "ONLINE/FAST ALTER PARTITION can fail and leave the
--echo #            table unusable".
--echo #
--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings
CREATE TABLE t1 (a bigint not null, b int not null, PRIMARY KEY (a))
  ENGINE = InnoDB PARTITION BY KEY(a) PARTITIONS 2;
INSERT INTO t1 values (0,1), (1,2);
--echo # The below ALTER should fail. It should leave the
--echo # table in its original, non-corrupted, usable state.
--error ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF
ALTER TABLE t1 ADD UNIQUE KEY (b);
--echo # The below statements should succeed, as ALTER should
--echo # have left table intact.
SHOW CREATE TABLE t1;
SELECT * FROM t1;
DROP TABLE t1;

--echo #
--echo # Bug#16943907: FLUSH TABLES FOR EXPORT: ASSERTION IN HA_PARTITION::EXTRA
--echo #
CREATE TABLE t1 (a int, PRIMARY KEY (a)) ENGINE=InnoDB
PARTITION BY HASH (a) PARTITIONS 2;
FLUSH TABLES t1 FOR EXPORT;
--echo # List of files after EXPORT (should include a .cfg file for each part).
--replace_result #p# #P#
--list_files $MYSQLD_DATADIR/test/ t1*
--echo # Copying the .cfg and .ibd files as backup
--copy_file $MYSQLD_DATADIR/test/t1#P#p0.cfg $MYSQLD_DATADIR/test/backup_t1#P#p0.cfg
--copy_file $MYSQLD_DATADIR/test/t1#P#p0.ibd $MYSQLD_DATADIR/test/backup_t1#P#p0.ibd
--copy_file $MYSQLD_DATADIR/test/t1#P#p1.cfg $MYSQLD_DATADIR/test/backup_t1#P#p1.cfg
--copy_file $MYSQLD_DATADIR/test/t1#P#p1.ibd $MYSQLD_DATADIR/test/backup_t1#P#p1.ibd
UNLOCK TABLES;
--echo # List of files after UNLOCK (no .cfg files).
--replace_result #p# #P#
--list_files $MYSQLD_DATADIR/test/ t1*
ALTER TABLE t1 DISCARD TABLESPACE;
--echo # List of files after DISCARD (no .cfg/.ibd files).
--replace_result #p# #P#
--list_files $MYSQLD_DATADIR/test/ t1*
--echo # Moving the .cfg and .ibd files back from backup
--move_file $MYSQLD_DATADIR/test/backup_t1#P#p0.cfg $MYSQLD_DATADIR/test/t1#P#p0.cfg
--move_file $MYSQLD_DATADIR/test/backup_t1#P#p0.ibd $MYSQLD_DATADIR/test/t1#P#p0.ibd
--move_file $MYSQLD_DATADIR/test/backup_t1#P#p1.cfg $MYSQLD_DATADIR/test/t1#P#p1.cfg
--move_file $MYSQLD_DATADIR/test/backup_t1#P#p1.ibd $MYSQLD_DATADIR/test/t1#P#p1.ibd
ALTER TABLE t1 IMPORT TABLESPACE;
--echo # List of files after IMPORT (.cfg files still there).
--replace_result #p# #P#
--list_files $MYSQLD_DATADIR/test/ t1*
DROP TABLE t1;
--echo # List of files after DROP (.cfg files should also be removed).
--list_files $MYSQLD_DATADIR/test/ t1*

--echo #
--echo # Bug#13737949: CRASH IN HA_PARTITION::INDEX_INIT
--echo # Bug#18694052: SERVER CRASH IN HA_PARTITION::INIT_RECORD_PRIORITY_QUEUE
--echo #
CREATE TABLE t1
(a INT,
 b INT,
 PRIMARY KEY (a))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 3;
START TRANSACTION WITH CONSISTENT SNAPSHOT;
--connect (con1, localhost, root,,)
--echo # con1
ALTER TABLE t1 ADD INDEX idx1 (b);
--connection default
--echo # con default
--error ER_TABLE_DEF_CHANGED
SELECT b FROM t1 WHERE b = 0;
--error ER_TABLE_DEF_CHANGED
SELECT b FROM t1 WHERE b = 0;
--error ER_TABLE_DEF_CHANGED
SELECT * FROM t1;
--disconnect con1
DROP TABLE t1;

--echo # Same test without partitioning
CREATE TABLE t1
(a INT,
 b INT,
 PRIMARY KEY (a))
ENGINE = InnoDB;
START TRANSACTION WITH CONSISTENT SNAPSHOT;
--echo # con1
--connect (con1, localhost, root,,)
ALTER TABLE t1 ADD INDEX idx1 (b);
--connection default
--echo # con default
--error ER_TABLE_DEF_CHANGED
SELECT b FROM t1 WHERE b = 0;
--error ER_TABLE_DEF_CHANGED
SELECT b FROM t1 WHERE b = 0;
--error ER_TABLE_DEF_CHANGED
SELECT * FROM t1;
--disconnect con1
DROP TABLE t1;

--echo Bug 17896265	 PARTITIONED TABLE HAS MISPLACED ROWS, AFTER INPLACE ALTER

#Check basic Interchange
CREATE TABLE t1 (
f1 INT(11) NOT NULL,
f2 INT(11) NOT NULL
)
ENGINE=InnoDB
PARTITION BY KEY (f1,f2) PARTITIONS 2;
INSERT INTO t1 VALUES (9585,5);
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 CHANGE f1 f1 INT AFTER f2, ALGORITHM=INPLACE;

# Check when interchanging columns do not change the order
CREATE TABLE t2 (
f1 INT(11) NOT NULL,
f2 INT(11) NOT NULL,
f3 INT(11) NOT NULL,
f4 INT(11) NOT NULL
)
ENGINE=InnoDB
PARTITION BY KEY (f2,f3) PARTITIONS 2;
INSERT INTO t2 VALUES (10,9585,5,20);

ALTER TABLE t2 CHANGE f3 f3 INT AFTER f4, ALGORITHM=INPLACE;
# Check if row is in the wrong partition!
CHECK TABLE t2;

--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t2 CHANGE f3 f3 INT AFTER f1, ALGORITHM=INPLACE;

#Bring back to original position
ALTER TABLE t2 CHANGE f4 f4 INT AFTER f3, ALGORITHM=INPLACE;
CHECK TABLE t2;

#Change the column order of field which are not part of KEY
ALTER TABLE t2 CHANGE f1 f1 INT AFTER f4, ALGORITHM=INPLACE;
CHECK TABLE t2;

#now order is f2,f3,f4,f1
ALTER TABLE t2 CHANGE f1 f1 INT AFTER f2, ALGORITHM=INPLACE;
CHECK TABLE t2;

#now order is f2,f1,f3,f4
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t2 CHANGE f2 f2 INT AFTER f4, ALGORITHM=INPLACE;

#check if Range partition is effected
CREATE TABLE t3 (f1 INT,f2 INT) ENGINE=INNODB
PARTITION BY RANGE(f1) (
PARTITION p0 VALUES LESS THAN (100),
PARTITION p1 VALUES LESS THAN (200),
PARTITION p2 VALUES LESS THAN (600),
PARTITION p3 VALUES LESS THAN MAXVALUE
);
insert into t3 values (90,120);
insert into t3 values (120,300);
ALTER TABLE t3 CHANGE f1 f1 int AFTER f2, ALGORITHM=INPLACE;
CHECK TABLE t3;

#check with hash partitions
CREATE TABLE t4 (
f1 INT(11) NOT NULL,
f2 INT(11) NOT NULL
)
ENGINE=InnoDB
PARTITION BY HASH (MOD(f1,f2)) PARTITIONS 2;
INSERT INTO t4 VALUES (9585,5);
ALTER TABLE t4 CHANGE f1 f1 INT AFTER f2, ALGORITHM=INPLACE;
CHECK TABLE t4;

#Check with column partitioning
CREATE TABLE t5 (
    f1 INT,
    f2 INT
)
ENGINE=InnoDB
PARTITION BY RANGE COLUMNS(f1,f2) (
    PARTITION p0 VALUES LESS THAN (10000,12),
    PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);

INSERT INTO t5 VALUES (1,20000);
ALTER TABLE t5 CHANGE f1 f1 INT AFTER f2, ALGORITHM=INPLACE;
CHECK TABLE t5;

#Check with column partitioning and subpartition
CREATE TABLE t6 (
    a INT,
    b INT
)
ENGINE=InnoDB
PARTITION BY RANGE COLUMNS(a,b)
SUBPARTITION BY KEY(a,b)
SUBPARTITIONS 2 (
    PARTITION p0 VALUES LESS THAN (10000,12),
    PARTITION p1 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);
INSERT INTO t6 VALUES (9585,5);

--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t6 CHANGE a a INT AFTER b, ALGORITHM=INPLACE;

#check when the columns are not adjacent
CREATE TABLE t7 (
f1 INT(11) NOT NULL,
f2 INT(11) NOT NULL,
f3 INT(11) NOT NULL,
f4 INT(11) NOT NULL,
f5 INT(11) NOT NULL

)
ENGINE=InnoDB
PARTITION BY KEY (f1,f5) PARTITIONS 2;
INSERT INTO t7 VALUES (9585,10,20,10,5);

ALTER TABLE t7 CHANGE f5 f5 INT AFTER f3, ALGORITHM=INPLACE;
CHECK TABLE t7;

ALTER TABLE t7 CHANGE f5 f5 INT AFTER f2, ALGORITHM=INPLACE;
CHECK TABLE t7;

--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t7 CHANGE f1 f1 INT AFTER f4, ALGORITHM=INPLACE;

DROP TABLE t1,t2,t3,t4,t5,t6,t7;

--echo # Coverage tests for Native InnoDB Partitioning

--echo #
--echo # Test enable/disable keys.
--echo #
CREATE TABLE t1 (a int, b int, primary key (a), key (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1,1),(2,1),(3,3),(4,1),(5,3),(6,1),(7,1),(8,1),(9,4),
(10,1),(11,3),(12,1),(13,3),(14,1),(15,1),(16,3),(17,1),(18,1),(19,1),(20,3);
EXPLAIN SELECT * FROM t1 WHERE b = 4;
ALTER TABLE t1 DISABLE KEYS;
INSERT INTO t1 VALUES (21,1),(22,1),(23,3),(24,1);
EXPLAIN SELECT * FROM t1 WHERE b = 4;
ALTER TABLE t1 ENABLE KEYS;
EXPLAIN SELECT * FROM t1 WHERE b = 4;
DROP TABLE t1;

--echo #
--echo # Test with different key sizes
--echo #
CREATE TABLE t1
(a int NOT NULL,
 b int NOT NULL,
 c varchar(10) NOT NULL,
 INDEX(a),
 UNIQUE KEY  (c(5), a, b)
)
ENGINE=InnoDB
PARTITION BY HASH (b) PARTITIONS 2;
SELECT * FROM t1 WHERE a = '92' AND c = '0.73';
SELECT * FROM t1 WHERE a = '1224';
DROP TABLE t1;

--echo #
--echo # Test with index_merge using PK
--echo #
CREATE TABLE t1
(
  a int NOT NULL,
  b int NOT NULL DEFAULT 2,
  c int NOT NULL DEFAULT 3,
  PRIMARY KEY (a),
  INDEX i2(b),
  INDEX i3(c)
)
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 3;

INSERT INTO t1 (a) VALUES (1),(2),(3),(4),(5),(6),(7),(8);
INSERT INTO t1 (a) SELECT a+8 FROM t1;

UPDATE t1 SET b=a,c=a;

ANALYZE TABLE t1;

--replace_column 10 #
EXPLAIN SELECT * FROM t1 WHERE a=3 OR b=4;
SELECT * FROM t1 WHERE a=3 OR b=4;
DROP TABLE t1;

--echo #
--echo # Test error handling in mysql_admin
--echo #
CREATE TABLE t1 (a int)
PARTITION BY LINEAR HASH (a) PARTITIONS 8;
LOAD INDEX INTO CACHE t1 PARTITION (ALL);
ALTER TABLE t1 COALESCE PARTITION 2;
DROP TABLE t1;


--echo #
--echo # Bug #17299181  CREATE_TIME AND UPDATE_TIME ARE
--echo #                WRONG FOR PARTITIONED TABLES
--echo #


CREATE TABLE t1 (a int, PRIMARY KEY (a)) ENGINE=InnoDB
PARTITION BY HASH (a) PARTITIONS 2;

ANALYZE TABLE t1;

SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE
CREATE_TIME IS NOT NULL AND TABLE_NAME='t1';

INSERT INTO t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8);

ANALYZE TABLE t1;

# Remove workaround of "OR FALSE" from the end of WHERE clause after fix
# of Bug#26389402 for I_S views definitions.
SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE
CREATE_TIME IS NOT NULL AND UPDATE_TIME IS NOT NULL
AND TABLE_NAME='t1' OR FALSE;

DROP TABLE t1;

--echo #
--echo # Bug#20160327 OPTIMIZE TABLE REMOVES THE DATA DIRECTORY IN PARTITIONS
--echo #

# Create one partition in default in data directory and other in
# different path

LET $MYSQL_DATA_DIR = `select @@datadir`;

--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
eval CREATE TABLE `t1` (
       `f1` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
       `f2` MEDIUMTEXT NOT NULL,
       `f3` CHAR(100) NOT NULL,
       `f4` TINYINT(1) unsigned NOT NULL,
       PRIMARY KEY (`f1`,`f4`)
     ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=latin1
     PARTITION BY LIST (`f4`)
     (PARTITION p0 VALUES IN (0) ENGINE = InnoDB,
      PARTITION p1 VALUES IN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR/temp_dir' ENGINE = InnoDB);

--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;

OPTIMIZE TABLE t1;
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_TMP_DIR/temp_dir/test
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_DATA_DIR/test


ALTER TABLE t1 OPTIMIZE PARTITION p0;
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_TMP_DIR/temp_dir/test
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_DATA_DIR/test

ALTER TABLE t1 OPTIMIZE PARTITION p1;
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_TMP_DIR/temp_dir/test
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_DATA_DIR/test


ALTER TABLE t1 REBUILD PARTITION ALL;
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_TMP_DIR/temp_dir/test
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_DATA_DIR/test


ALTER TABLE t1 ADD extracol VARCHAR(32) NULL;
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
SHOW CREATE TABLE t1;
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_TMP_DIR/temp_dir/test
--replace_regex  /#P#/#p#/  /#SP#/#sp#/
--list_files $MYSQL_DATA_DIR/test

DROP TABLE t1;

--rmdir $MYSQL_TMP_DIR/temp_dir/test
--rmdir $MYSQL_TMP_DIR/temp_dir

# TODO : Enable following once shared tablespaces are allowed in Partitioned
#	 Tables (wl#12034).
# #Create one partition in general tablespace and other in different path
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# let $restart_parameters = restart: --innodb-directories=$MYSQL_TMP_DIR;
# --source include/restart_mysqld.inc
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLESPACE ts1 ADD DATAFILE '$MYSQL_TMP_DIR/ts1.ibd' ENGINE=Innodb;
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLE `t1` (
#        `f1` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
#        `f2` MEDIUMTEXT NOT NULL,
#        `f3` CHAR(100) NOT NULL,
#        `f4` TINYINT(1) unsigned NOT NULL,
#        PRIMARY KEY (`f1`,`f4`)
#      ) TABLESPACE ts1 ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=latin1
#      PARTITION BY LIST (`f4`)
#      (PARTITION p0 VALUES IN (0) ENGINE = InnoDB,
#       PARTITION p1 VALUES IN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR/temp_tblspc' ENGINE = InnoDB);
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# OPTIMIZE TABLE t1;
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# ALTER TABLE t1 OPTIMIZE PARTITION p0;
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# ALTER TABLE t1 OPTIMIZE PARTITION p1;
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# DROP TABLE t1;
# DROP TABLESPACE ts1;
#
# --rmdir $MYSQL_TMP_DIR/temp_tblspc/test
# --rmdir $MYSQL_TMP_DIR/temp_tblspc
#
# #Create partitions in two different tablespaces
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLESPACE ts1 ADD DATAFILE '$MYSQL_TMP_DIR/ts1.ibd' ENGINE=Innodb;
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLESPACE ts2 ADD DATAFILE '$MYSQL_TMP_DIR/ts2.ibd' ENGINE=Innodb;
#
# eval CREATE TABLE `t1` (
#        `f1` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
#        `f4` TINYINT(1) unsigned NOT NULL,
#        PRIMARY KEY (`f1`,`f4`)
#      )  ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=latin1
#      PARTITION BY LIST (`f4`)
#      (PARTITION p0 VALUES IN (0) TABLESPACE ts1 ENGINE = InnoDB,
#       PARTITION p1 VALUES IN (1) TABLESPACE ts2 ENGINE = InnoDB);
#
# SHOW CREATE TABLE t1;
# OPTIMIZE TABLE t1;
# SHOW CREATE TABLE t1;
# DROP TABLE t1;
# DROP TABLESPACE ts1;
# DROP TABLESPACE ts2;
#
# #Create partitions to use differeent avaliable tablespace options
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLESPACE ts1 ADD DATAFILE '$MYSQL_TMP_DIR/ts1.ibd' ENGINE=Innodb;
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# eval CREATE TABLE `t1` (
#        `f1` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
#        `f4` TINYINT(1) unsigned NOT NULL,
#        PRIMARY KEY (`f1`,`f4`)
#      )  ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=latin1
#      PARTITION BY LIST (`f4`)
#      (PARTITION p0 VALUES IN (0) TABLESPACE ts1 ENGINE = InnoDB,
#       PARTITION p1 VALUES IN (1) TABLESPACE innodb_file_per_table DATA DIRECTORY='$MYSQL_TMP_DIR/temp_dir' ENGINE = InnoDB,
#       PARTITION p2 VALUES IN (2) TABLESPACE innodb_file_per_table ENGINE = InnoDB,
#       PARTITION p3 VALUES IN (3) TABLESPACE innodb_system ENGINE = InnoDB);
#
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# OPTIMIZE TABLE t1;
# --replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
# SHOW CREATE TABLE t1;
#
# DROP TABLE t1;
# DROP TABLESPACE ts1;
#
# --rmdir $MYSQL_TMP_DIR/temp_dir/test
# --rmdir $MYSQL_TMP_DIR/temp_dir

--echo
--echo Bug #25942592    INNODB: FAILING ASSERTION: INDEX->PAGE != 0XFFFFFFFF
--echo                   IN BTR0CUR.CC LINE 816
--echo
call mtr.add_suppression("Missing .ibd file for table");

#Unnamed Partitioins
CREATE TABLE t1(c1 INT,c2 CHAR (1),c3 DATE) ENGINE=InnoDB PARTITION BY HASH
(TO_DAYS(c3)) PARTITIONS 12;
ALTER TABLE t1 ADD INDEX(c1);
ALTER TABLE t1 DISCARD PARTITION p2 TABLESPACE;
--error ER_TABLESPACE_DISCARDED
SELECT COUNT(*)FROM t1,t1 AS b WHERE t1.c1=''AND t1.c2=b.c1;

#Named partitions
CREATE TABLE t2 (c1 int,c2 CHAR (1),c3 date,key(c1)) ENGINE=InnoDB
PARTITION BY RANGE (TO_DAYS(c3))
(
PARTITION p0 VALUES LESS THAN (TO_DAYS('1979-01-01')),
PARTITION p1 VALUES LESS THAN (TO_DAYS('1989-01-01')),
PARTITION p2 VALUES LESS THAN (TO_DAYS('1999-01-01'))
);

ALTER TABLE t2 DISCARD PARTITION p2 TABLESPACE;
--error ER_TABLESPACE_DISCARDED
SELECT COUNT(*)FROM t2,t2 AS b WHERE t2.c1=''AND t2.c2=b.c1;
DROP TABLE t1,t2;

--echo
--echo Bug #26034430    ASSERTION `PART_REC_BUF_PTR' FAILED.
--echo
--echo

CREATE TABLE t1 ( a INT NOT NULL, b INT NOT NULL, c INT NOT NULL, PRIMARY KEY(a,b)) PARTITION BY RANGE (a)(PARTITION x1 VALUES LESS THAN (1));

SELECT * FROM t1 WHERE (a = 1 and b = 1 and c = 'b') OR (a > 2) ORDER BY a DESC;

CREATE TABLE t(id INT(11) UNSIGNED NOT NULL AUTO_INCREMENT, dttm DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, msg
TEXT,PRIMARY KEY (id,dttm))ENGINE=INNODB DEFAULT CHARSET=UTF8MB4 ROW_FORMAT=DYNAMIC PARTITION BY RANGE
COLUMNS(dttm) (PARTITION pf_201612 VALUES LESS THAN ('20170101') ENGINE = INNODB);

SELECT * FROM t WHERE dttm > '2017-01-19' ORDER BY id DESC;

DROP TABLE t,t1;


--echo
--echo Bug #26731025	INNODB PARTITION TABLE WILL LOCK INTO THE NEAR RECORD AS A CONDITION IN THE USE
--echo
--echo

--connect (con1,localhost,root,,)
--connect (con2,localhost,root,,)

--connection default

create table test12 (name varchar(30),age bigint,grade bigint,date datetime
not null,partition_id int not null,
  PRIMARY KEY (`name`,`PARTITION_ID`),
  KEY `IDX_DATE` (`date`,`name`,`partition_id`),
  KEY `IDX_AGE` (`age`,`partition_id`) ) PARTITION BY RANGE
COLUMNS(PARTITION_ID)
(PARTITION p0 VALUES LESS THAN (0) ENGINE = InnoDB,
 PARTITION P1 VALUES LESS THAN (1) ENGINE = InnoDB,
 PARTITION P2 VALUES LESS THAN (2) ENGINE = InnoDB,
 PARTITION P3 VALUES LESS THAN (3) ENGINE = InnoDB,
 PARTITION P4 VALUES LESS THAN (4) ENGINE = InnoDB,
 PARTITION P5 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION P6 VALUES LESS THAN (6) ENGINE = InnoDB,
 PARTITION P7 VALUES LESS THAN (7) ENGINE = InnoDB,
 PARTITION P8 VALUES LESS THAN (8) ENGINE = InnoDB,
 PARTITION P9 VALUES LESS THAN (9) ENGINE = InnoDB);

 insert into test12 values('Tom1',20,1,'2017-08-25
12:12:12',1),('Tom2',21,1,'2017-08-25 12:12:12',1),('Tom3',23,1,'2017-08-25
12:12:12',1);

begin;update test12 set grade=3,date=now()  where age=23 and
partition_id=1;

--connection con1
begin;update test12 set grade=1,date=now()  where age=21 and
partition_id=1;

--connection con2
begin;update test12 set grade=0,date=now()  where age=20 and
partition_id=1;

--disconnect con1
--disconnect con2

--connection default
drop table test12;


--echo #
--echo # Bug#27073100: PARTITION UPDATE_TIME NOT CORRECT AFTER RESTART/REBUILD
--echo #

--echo # Set up.
CREATE TABLE t1 (fld1 INT(11) NOT NULL, fld2 INT(11) NOT NULL,
fld3 DATE NOT NULL,  fld4 DATE NOT NULL,
PRIMARY KEY (fld1, fld3),  KEY(fld1)) PARTITION
BY RANGE (YEAR(fld3))
(PARTITION p01 VALUES LESS THAN (1985) ENGINE = InnoDB,
PARTITION p02 VALUES LESS THAN (1986) ENGINE = InnoDB,
PARTITION p03 VALUES LESS THAN MAXVALUE ENGINE = InnoDB);
INSERT INTO t1 VALUES('11', '11111', '1984-11-16',
'2008-11-16'), ('12', '11112', '1985-11-16', '2008-11-16'),
('13', '11113', '1986-11-16', '2008-11-16');

--echo # Fetch the count of 'update_time' which is not null.
SELECT TABLE_NAME, COUNT(UPDATE_TIME) FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1' ORDER BY
PARTITION_ORDINAL_POSITION;

--echo # Rebuild the table.
ALTER TABLE t1 ENGINE=INNODB;

--echo # After table rebuild, the 'update_time' will be set to NULL.
--echo # Hence the count would return 0.
SELECT TABLE_NAME, COUNT(UPDATE_TIME) FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1' ORDER BY
PARTITION_ORDINAL_POSITION;

--echo # Update the table where partition p02 is updated.
UPDATE t1 SET fld2 = 71000 WHERE fld1 = 12 AND fld3 = '1985-11-16';

--echo # Without fix, the count for 'update_time' will be 3. After fix,
--echo # it will be 1 since only partition 'p02' is updated.
SELECT TABLE_NAME, COUNT(UPDATE_TIME)
FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA = 'test' AND
TABLE_NAME = 't1' ORDER BY PARTITION_ORDINAL_POSITION;

DROP TABLE t1;

--echo
--echo BUG#26553164 - INNODB PARTITION TABLE HAS UNEXPECTED ROW LOCK
--echo

--connect (conn1,localhost,root,,)

--connection default

CREATE TABLE `t1` (
  `id` int(11) NOT NULL,
  `dt` datetime NOT NULL,
  `data` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`,`dt`),
  KEY `idx_dt` (`dt`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (to_days(dt))
(PARTITION p20170218 VALUES LESS THAN (736744) ENGINE = InnoDB,
 PARTITION p20170219 VALUES LESS THAN (736745) ENGINE = InnoDB,
 PARTITION pMax VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */;

INSERT INTO t1 VALUES (1, '2018-04-25 10:18:00', '1');
INSERT INTO t1 VALUES (2, '2018-04-25 10:18:01', '2');
INSERT INTO t1 VALUES (3, '2018-04-25 10:18:02', '3');

SELECT * FROM t1;

begin;
UPDATE t1 SET data = '11' WHERE id = 1;

--connection conn1
begin;
UPDATE t1 SET data = '22' WHERE id = 2;
commit;

--disconnect conn1

--connection default
SELECT * FROM t1;

DROP TABLE t1;

--echo #
--echo # WL#1074 - Descending index support.
--echo #
CREATE TABLE t1
(a VARCHAR(10),
 b VARCHAR(10),
 PRIMARY KEY (a DESC, b DESC),
 KEY ab_asc (a ASC, b ASC),
 KEY a_asc_b_desc (a ASC, b DESC),
 key a_desc_b_asc (a DESC, b ASC))
ENGINE = InnoDB
PARTITION BY KEY (a, b) PARTITIONS 3;
INSERT INTO t1 VALUES ("0", "0"), ("1", "1"), ("2", "2"), ("3", "3"),
("4", "4"), ("55", "55"), ("54", "54"), ("1", "2"), ("1", "4"), ("1", "3"),
("55", "54"), ("0", "1");
ANALYZE TABLE t1;

--echo # Test non ordered index access
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`PRIMARY`);
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`ab_asc`);
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`a_asc_b_desc`);
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`a_desc_b_asc`);
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;

--echo # Test sorted index access
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a DESC, b DESC;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a, b;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a, b DESC;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a DESC, b;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 ORDER BY a DESC, b DESC;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 ORDER BY a, b;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 ORDER BY a, b DESC;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 ORDER BY a DESC, b;

--echo # Test index access in different sort order
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a, b;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a DESC, b;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a, b DESC;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
FLUSH STATUS;
SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a DESC, b;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a, b;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a DESC, b;
--replace_regex /"rows_examined_per_scan": [0-9]+/"rows_examined_per_scan": "X"/ /_per_join": [0-9]+/_per_join": "X"/ /_per_join": "[0-9]+K"/_per_join": "X"/  /"filtered": "[0-9.]+"/"filtered": "X"/ /_cost": "[0-9.]+"/_cost": "X"/ /"data_read_per_join": "[0-9.]+"/"data_read_per_join": "X"/
EXPLAIN FORMAT=JSON SELECT * FROM t1 FORCE INDEX (`PRIMARY`) ORDER BY a, b DESC;

--echo # Test HANDLER statements.
FLUSH STATUS;
HANDLER t1 OPEN;
HANDLER t1 READ `PRIMARY` FIRST;
HANDLER t1 READ `PRIMARY` NEXT;
HANDLER t1 READ `PRIMARY` NEXT;
HANDLER t1 READ `PRIMARY` NEXT;
HANDLER t1 READ `PRIMARY` NEXT;
HANDLER t1 READ `PRIMARY` LAST;
HANDLER t1 READ `PRIMARY` PREV;
HANDLER t1 READ `PRIMARY` PREV;
HANDLER t1 READ `PRIMARY` PREV;
HANDLER t1 READ ab_asc FIRST;
HANDLER t1 READ ab_asc NEXT;
HANDLER t1 READ ab_asc NEXT;
HANDLER t1 READ ab_asc NEXT;
HANDLER t1 READ ab_asc NEXT;
HANDLER t1 READ ab_asc LAST;
HANDLER t1 READ ab_asc PREV;
HANDLER t1 READ ab_asc PREV;
HANDLER t1 READ ab_asc PREV;
HANDLER t1 CLOSE;
SHOW STATUS WHERE Variable_name LIKE 'Handler%' AND Value >0;
DROP TABLE t1;
                                            
