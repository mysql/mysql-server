#--disable_abort_on_error
#
# Simple test for the partition storage engine
# taken from the select test.
#
# Last update:
# 2007-10-22 mleich  - Move ARCHIVE, BLACKHOLE and CSV related sub tests to
#                      new tests. Reason: All these might be not available.
#                    - Minor cleanup
#
--source include/no_valgrind_without_big.inc

--disable_warnings
drop table if exists t1, t2;
--enable_warnings

--echo #
--echo # Bug#11765667: bug#58655: ASSERTION FAILED,
--echo #                          SERVER CRASHES WITH MYSQLD GOT SIGNAL 6
--echo #
CREATE TABLE t1 (
       id MEDIUMINT NOT NULL AUTO_INCREMENT,
       dt DATE, st VARCHAR(255), uid INT,
       id2nd LONGBLOB, filler VARCHAR(255), PRIMARY KEY(id, dt)
);
INSERT INTO t1 (dt, st, uid, id2nd, filler) VALUES
   ('1991-03-14', 'Initial Insert', 200, 1234567, 'No Data'),
   ('1991-02-26', 'Initial Insert', 201, 1234567, 'No Data'),
   ('1992-03-16', 'Initial Insert', 234, 1234567, 'No Data'),
   ('1992-07-02', 'Initial Insert', 287, 1234567, 'No Data'),
   ('1991-05-26', 'Initial Insert', 256, 1234567, 'No Data'),
   ('1991-04-25', 'Initial Insert', 222, 1234567, 'No Data'),
   ('1993-03-12', 'Initial Insert', 267, 1234567, 'No Data'),
   ('1993-03-14', 'Initial Insert', 291, 1234567, 'No Data'),
   ('1991-12-20', 'Initial Insert', 298, 1234567, 'No Data'),
   ('1994-10-31', 'Initial Insert', 220, 1234567, 'No Data');
ALTER TABLE t1 PARTITION BY LIST (YEAR(dt)) (
    PARTITION d1 VALUES IN (1991, 1994),
    PARTITION d2 VALUES IN (1993),
    PARTITION d3 VALUES IN (1992, 1995, 1996)
);
INSERT INTO t1 (dt, st, uid, id2nd, filler) VALUES
   ('1991-07-14', 'After Partitioning Insert', 299, 1234567, 'Insert row');
UPDATE t1 SET filler='Updating the row' WHERE uid=298;

DROP TABLE t1;

--echo #
--echo # Bug#59297: Can't find record in 'tablename' on update inner join
--echo #
CREATE TABLE t1 (
a char(2) NOT NULL,
b char(2) NOT NULL,
c int(10) unsigned NOT NULL,
d varchar(255) DEFAULT NULL,
e varchar(1000) DEFAULT NULL,
PRIMARY KEY (a, b, c),
KEY (a),
KEY (a, b)
)
/*!50100 PARTITION BY KEY (a)
PARTITIONS 20 */;

INSERT INTO t1 (a, b, c, d, e) VALUES
('07', '03', 343, '1', '07_03_343'),
('01', '04', 343, '2', '01_04_343'),
('01', '06', 343, '3', '01_06_343'),
('01', '07', 343, '4', '01_07_343'),
('01', '08', 343, '5', '01_08_343'),
('01', '09', 343, '6', '01_09_343'),
('03', '03', 343, '7', '03_03_343'),
('03', '06', 343, '8', '03_06_343'),
('03', '07', 343, '9', '03_07_343'),
('04', '03', 343, '10', '04_03_343'),
('04', '06', 343, '11', '04_06_343'),
('05', '03', 343, '12', '05_03_343'),
('11', '03', 343, '13', '11_03_343'),
('11', '04', 343, '14', '11_04_343')
;

UPDATE t1 AS A,
(SELECT '03' AS a, '06' AS b, 343 AS c, 'last' AS d) AS B
SET A.e = B.d  
WHERE A.a = '03'  
AND A.b = '06' 
AND A.c = 343;

DROP TABLE t1;

--echo #
--echo # Bug#59503: explain crash in get_mm_leaf
--echo #
CREATE TABLE t1 (a VARCHAR(51) CHARACTER SET latin1)
PARTITION BY KEY (a) PARTITIONS 1;
INSERT INTO t1 VALUES ('a'),('b'),('c');
analyze table t1;
EXPLAIN SELECT 1 FROM t1 WHERE a > 1;
DROP TABLE t1;

--echo #
--echo # Bug#57778: failed primary key add to partitioned innodb table
--echo #            inconsistent and crashes
--echo #
CREATE TABLE t1 (a INT NOT NULL, b INT NOT NULL)
PARTITION BY KEY (a) PARTITIONS 2;
INSERT INTO t1 VALUES (0,1), (0,2);
--error ER_DUP_ENTRY
ALTER TABLE t1 ADD PRIMARY KEY (a);
SHOW CREATE TABLE t1;
SELECT * FROM t1;
UPDATE t1 SET a = 1, b = 1 WHERE a = 0 AND b = 2;
ALTER TABLE t1 ADD PRIMARY KEY (a);
SELECT * FROM t1;
ALTER TABLE t1 DROP PRIMARY KEY;
SELECT * FROM t1;
DROP TABLE t1;

--echo #
--echo # Bug#57113: ha_partition::extra(ha_extra_function):
--echo #            Assertion `m_extra_cache' failed
CREATE TABLE t1
(id INT NOT NULL PRIMARY KEY,
 name VARCHAR(16) NOT NULL,
 year YEAR,
 INDEX name (name(8))
)
PARTITION BY HASH(id) PARTITIONS 2;

INSERT INTO t1 VALUES ( 1, 'FooBar', '1924' );

CREATE TABLE t2 (id INT);

INSERT INTO t2 VALUES (1),(2);

UPDATE t1, t2 SET t1.year = '1955' WHERE t1.name = 'FooBar';

DROP TABLE t1, t2;
 
--echo #
--echo # Bug#55458: Partitioned MyISAM table gets crashed by multi-table update 
--echo # After WL#8971, this test case is rewritten to use InnoDB in order to
--echo # keep some test coverage for multi update and partitioning.
CREATE TABLE t1 (
  `id` int NOT NULL,
  `user_num` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB CHARSET=latin1;
INSERT INTO t1 VALUES (1,8601);
INSERT INTO t1 VALUES (2,8601);
INSERT INTO t1 VALUES (3,8601);
INSERT INTO t1 VALUES (4,8601);
CREATE TABLE t2 (
  `id` int(11) NOT NULL,
  `user_num` int DEFAULT NULL,
  `name` varchar(64) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB CHARSET=latin1
PARTITION BY HASH (id)
PARTITIONS 2;
INSERT INTO t2 VALUES (1,8601,'John');
INSERT INTO t2 VALUES (2,8601,'JS');
INSERT INTO t2 VALUES (3,8601,'John S');

UPDATE t1, t2 SET t2.name = 'John Smith' WHERE t1.user_num = t2.user_num;

DROP TABLE t1, t2;

--echo # Bug#39338: Fieldnames in
--echo #   INFORMATIONSCHEMA.PARTITIONS.PARTITION_EXPRESSION become unescaped
--echo # NOTE: the partition expression is saved as a string, so changing from
--echo #       normal quotes to ansi quotes does not change the expression, only
--echo #       for partition by KEY.
CREATE TABLE t1 (
    ID int(11) NOT NULL,
    `aaaa,aaaaa` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
    ddddddddd int(11) NOT NULL DEFAULT '0',
    new_field0 varchar(50),
    PRIMARY KEY(ID, `aaaa,aaaaa`, ddddddddd))
PARTITION BY RANGE(ID)
PARTITIONS 3
SUBPARTITION BY LINEAR KEY(ID,`aaaa,aaaaa`)
SUBPARTITIONS 2 (
    PARTITION p01 VALUES LESS THAN(100),
    PARTITION p11 VALUES LESS THAN(200),
    PARTITION p21 VALUES LESS THAN MAXVALUE);
SELECT PARTITION_EXPRESSION, SUBPARTITION_EXPRESSION FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME='t1';
show create table t1;
drop table t1;

#
# Bug#48276: can't add column if subpartition exists
CREATE TABLE t1 (a INT, b INT)
PARTITION BY LIST (a)
SUBPARTITION BY HASH (b)
(PARTITION p1 VALUES IN (1));
ALTER TABLE t1 ADD COLUMN c INT;
DROP TABLE t1;

#
# Bug#46639: 1030 (HY000): Got error 124 from storage engine on
# INSERT ... SELECT ...
CREATE TABLE t1 (
  a int NOT NULL,
  b int NOT NULL);

CREATE TABLE t2 (
  a int NOT NULL,
  b int NOT NULL,
  INDEX(b)
)
PARTITION BY HASH(a) PARTITIONS 2;

INSERT INTO t1 VALUES (399, 22);
INSERT INTO t2 VALUES (1, 22), (1, 42);

INSERT INTO t2 SELECT 1, 399 FROM t2, t1
WHERE t1.b = t2.b;

DROP TABLE t1, t2;

#
# Bug#46478: timestamp field incorrectly defaulted when partition is reorganized
#
CREATE TABLE t1 (
  a timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  b varchar(10),
  PRIMARY KEY (a)
)
PARTITION BY RANGE (UNIX_TIMESTAMP(a)) (
 PARTITION p1 VALUES LESS THAN (1199134800),
 PARTITION pmax VALUES LESS THAN MAXVALUE
);

INSERT INTO t1 VALUES ('2007-07-30 17:35:48', 'p1');
INSERT INTO t1 VALUES ('2009-07-14 17:35:55', 'pmax');
INSERT INTO t1 VALUES ('2009-09-21 17:31:42', 'pmax');

SELECT * FROM t1;
SELECT * FROM t1 where a between '2007-01-01' and '2007-08-01';
analyze table t1;
EXPLAIN SELECT * FROM t1 where a between '2007-01-01' and '2007-08-01';
EXPLAIN SELECT * FROM t1 where a = '2007-07-30 17:35:48';
ALTER TABLE t1 REORGANIZE PARTITION pmax INTO (
 PARTITION p3 VALUES LESS THAN (1247688000),
 PARTITION pmax VALUES LESS THAN MAXVALUE);
SELECT * FROM t1;
SELECT * FROM t1 where a between '2007-01-01' and '2007-08-01';
analyze table t1;
EXPLAIN SELECT * FROM t1 where a between '2007-01-01' and '2007-08-01';
EXPLAIN SELECT * FROM t1 where a = '2007-07-30 17:35:48';
SHOW CREATE TABLE t1;
DROP TABLE t1;

#
# Bug#45904: Error when CHARSET=utf8 and subpartitioning
#
create table t1 (a int NOT NULL, b varchar(5) NOT NULL)
default charset=utf8
partition by list (a)
subpartition by key (b)
(partition p0 values in (1),
 partition p1 values in (2));
drop table t1;

#
# Bug#44059: rec_per_key on empty partition gives weird optimiser results
#
create table t1 (a int, b int, key(a))
partition by list (a)
( partition p0 values in (1),
  partition p1 values in (2));
insert into t1 values (1,1),(2,1),(2,2),(2,3);
analyze table t1;
show indexes from t1;
analyze table t1;
show indexes from t1;
drop table t1;

#
# Bug#40181: hang if create index
#
create table t1 (a int)
partition by hash (a);
create index i on t1 (a);
insert into t1 values (1);
insert into t1 select * from t1;
--error ER_DUP_KEYNAME
create index i on t1 (a);
create index i2 on t1 (a);
drop table t1;

#
# Bug#36001: Partitions: spelling and using some error messages
#
CREATE TABLE t0 (a INT PRIMARY KEY);
--error ER_FOREIGN_KEY_ON_PARTITIONED
CREATE TABLE t1 (a INT, FOREIGN KEY (a) REFERENCES t0 (a))
PARTITION BY HASH (a);
DROP TABLE t0;

#
# Bug#40954: Crash if range search and order by.
#
CREATE TABLE t1 (
  pk INT NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (pk)
)
/*!50100 PARTITION BY HASH (pk)
PARTITIONS 2 */;
INSERT INTO t1 VALUES (NULL);
INSERT INTO t1 VALUES (NULL);
INSERT INTO t1 VALUES (NULL);
SELECT * FROM t1 WHERE pk < 0 ORDER BY pk;
DROP TABLE t1;

#
# Bug#35765: ALTER TABLE produces wrong error when non-existent storage engine
# used
--error ER_UNKNOWN_STORAGE_ENGINE
CREATE TABLE t1 (a INT)
ENGINE=NonExistentEngine;
--error ER_UNKNOWN_STORAGE_ENGINE
CREATE TABLE t1 (a INT)
ENGINE=NonExistentEngine
PARTITION BY HASH (a);

CREATE TABLE t1 (a INT);
--error ER_UNKNOWN_STORAGE_ENGINE
ALTER TABLE t1 ENGINE=NonExistentEngine;
# OK to only specify one partitions engine, since it is already assigned at
# table level (after create, it is specified on all levels and all parts).
--error ER_UNKNOWN_STORAGE_ENGINE
ALTER TABLE t1
PARTITION BY HASH (a)
(PARTITION p0 ENGINE=InnoDB,
 PARTITION p1 ENGINE=NonExistentEngine);
--error ER_UNKNOWN_STORAGE_ENGINE
ALTER TABLE t1 ENGINE=NonExistentEngine;
SHOW CREATE TABLE t1;
DROP TABLE t1;

SET sql_mode='';
CREATE TABLE t1 (a INT)
ENGINE=NonExistentEngine;
DROP TABLE t1;
CREATE TABLE t1 (a INT)
ENGINE=NonExistentEngine
PARTITION BY HASH (a);
DROP TABLE t1;
CREATE TABLE t1 (a INT);
ALTER TABLE t1 ENGINE=NonExistentEngine;
# OK to only specify one partitions engine, since it is already assigned at
# table level (after create, it is specified on all levels and all parts).
ALTER TABLE t1
PARTITION BY HASH (a)
(PARTITION p0 ENGINE=InnoDB,
 PARTITION p1 ENGINE=NonExistentEngine);
ALTER TABLE t1 ENGINE=NonExistentEngine;
SHOW CREATE TABLE t1;
DROP TABLE t1;
SET sql_mode=DEFAULT;

#
# Bug#40494: Crash MYSQL server crashes on range access with partitioning
#            and order by
#
CREATE TABLE t1 (a INT NOT NULL, KEY(a))
PARTITION BY RANGE(a)
(PARTITION p1 VALUES LESS THAN (200), PARTITION pmax VALUES LESS THAN MAXVALUE);
INSERT INTO t1 VALUES (2), (40), (40), (70), (60), (90), (199);
SELECT a FROM t1 WHERE a BETWEEN 60 AND 95 ORDER BY a ASC;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 60 AND 95;
INSERT INTO t1 VALUES (200), (250), (210);
SELECT a FROM t1 WHERE a BETWEEN 60 AND 220 ORDER BY a ASC;
SELECT a FROM t1 WHERE a BETWEEN 200 AND 220 ORDER BY a ASC;
SELECT a FROM t1 WHERE a BETWEEN 60 AND 95 ORDER BY a DESC;
SELECT a FROM t1 WHERE a BETWEEN 60 AND 220 ORDER BY a DESC;
SELECT a FROM t1 WHERE a BETWEEN 200 AND 220 ORDER BY a DESC;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 60 AND 220;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 200 AND 220;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 60 AND 95;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 60 AND 220;
--sorted_result
SELECT a FROM t1 WHERE a BETWEEN 200 AND 220;
DROP TABLE t1;

#
# Bug35931: Index search may return duplicates
#
CREATE TABLE t1 (
  a INT NOT NULL,   
  b MEDIUMINT NOT NULL,   
  c INT NOT NULL,
  KEY b (b)
)
PARTITION BY LIST (a) (
  PARTITION p0 VALUES IN (1) 
);
INSERT INTO t1 VALUES (1,1,0), (1,1,1), (1,1,2), (1,1,53), (1,1,4), (1,1,5),
(1,1,6), (1,1,7), (1,1,8), (1,1,9), (1,1,10), (1,1,11), (1,1,12), (1,1,13),
(1,1,14), (1,1,15), (1,1,16), (1,1,67), (1,1,18), (1,1,19), (1,1,20), (1,1,21),
(1,1,22), (1,1,23), (1,1,24), (1,1,75), (1,1,26), (1,1,27), (1,1,128),
(1,1,79), (1,1,30), (1,1,31), (1,1,32), (1,1,33), (1,1,34), (1,1,85), (1,1,36),
(1,1,37), (1,1,38), (1,1,39), (1,1,40), (1,1,241), (1,1,42), (1,1,43),
(1,1,44), (1,1,45), (1,1,46), (1,1,147), (1,1,48), (1,1,49), (1,2,0), (1,2,1),
(1,2,2), (1,2,3), (1,2,4), (1,2,5), (1,2,6), (1,2,7), (1,2,8), (1,2,9),
(1,2,10), (1,2,11), (1,2,12), (1,2,13), (1,2,14), (1,2,15), (1,2,16), (1,2,17),
(1,2,18), (1,2,19), (1,2,20), (1,2,21), (1,2,22), (1,2,23), (1,2,24), (1,2,25),
(1,2,26), (1,2,27), (1,2,28), (1,2,29), (1,2,30), (1,2,31), (1,2,32), (1,2,33),
(1,2,34), (1,2,35), (1,2,36), (1,2,37), (1,2,38), (1,2,39), (1,2,40), (1,2,41),
(1,2,42), (1,2,43), (1,2,44), (1,2,45), (1,2,46), (1,2,47), (1,2,48), (1,2,49),
(1,6,0), (1,6,1), (1,6,2), (1,6,3), (1,6,4), (1,6,5), (1,6,6), (1,6,7),
(1,6,8), (1,6,9), (1,6,10), (1,6,11), (1,6,12), (1,6,13), (1,6,14), (1,6,15),
(1,6,16), (1,6,17), (1,6,18), (1,6,19), (1,6,20), (1,6,21), (1,6,22), (1,6,23),
(1,6,24), (1,6,25), (1,6,26), (1,6,27), (1,6,28), (1,6,29), (1,6,30), (1,6,31),
(1,6,32), (1,6,33), (1,6,34), (1,6,35), (1,6,36), (1,6,37), (1,6,38), (1,6,39),
(1,6,40), (1,6,41), (1,6,42), (1,6,43), (1,6,44), (1,6,45), (1,6,46), (1,6,47),
(1,6,48), (1,6,49), (1,7,0), (1,7,1), (1,7,2), (1,7,3), (1,7,4), (1,7,5),
(1,7,6), (1,7,7), (1,7,8), (1,7,9), (1,7,10), (1,7,11), (1,7,12), (1,7,13),
(1,7,14), (1,7,15), (1,7,16), (1,7,17), (1,7,18), (1,7,19), (1,7,20), (1,7,21),
(1,7,22), (1,7,23), (1,7,24), (1,7,25), (1,7,26), (1,7,27), (1,7,28), (1,7,29),
  (1,7,30), (1,7,31), (1,7,32), (1,7,33), (1,7,34), (1,7,35), (1,7,38), (1,7,39),
(1,7,90), (1,7,41), (1,7,43), (1,7,48), (1,7,49), (1,9,0), (1,9,1), (1,9,2),
(1,9,3), (1,9,4), (1,9,5), (1,9,6), (1,9,7), (1,9,8), (1,9,9), (1,9,10),
(1,9,11), (1,9,12), (1,9,13), (1,9,14), (1,9,15), (1,9,16), (1,9,17), (1,9,18),
(1,9,19), (1,9,20), (1,9,21), (1,9,22), (1,9,23), (1,9,24), (1,9,25), (1,9,26),
(1,9,29), (1,9,32), (1,9,35), (1,9,38), (1,10,0), (1,10,1), (1,10,2), (1,10,3),
(1,10,4), (1,10,5), (1,10,6), (1,10,7), (1,10,8), (1,10,9), (1,10,10),
(1,10,11), (1,10,13), (1,10,14), (1,10,15), (1,10,16), (1,10,17), (1,10,18),
(1,10,22), (1,10,24), (1,10,25), (1,10,26), (1,10,28), (1,10,131), (1,10,33),
(1,10,84), (1,10,35), (1,10,40), (1,10,42), (1,10,49), (1,11,0), (1,11,1),
(1,11,2), (1,11,3), (1,11,4), (1,11,5), (1,11,6), (1,11,7), (1,11,8), (1,11,9),
(1,11,10), (1,11,11), (1,11,12), (1,11,13), (1,11,14), (1,11,15), (1,11,16),
(1,11,17), (1,11,18), (1,11,19), (1,11,20), (1,11,21), (1,11,22), (1,11,23),
(1,11,24), (1,11,25), (1,11,26), (1,11,27), (1,11,28), (1,11,30), (1,11,31),
(1,11,32), (1,11,33), (1,11,34), (1,11,35), (1,11,37), (1,11,39), (1,11,40),
(1,11,42), (1,11,44), (1,11,45), (1,11,47), (1,11,48), (1,14,104), (1,14,58),
(1,14,12), (1,14,13), (1,14,15), (1,14,16), (1,14,17), (1,14,34), (1,15,0),
(1,15,1), (1,15,2), (1,15,3), (1,15,4), (1,15,5), (1,15,7), (1,15,9),
(1,15,15), (1,15,27), (1,15,49), (1,16,0), (1,16,1), (1,16,3), (1,17,4),
(1,19,1);
SELECT COUNT(*) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
SELECT SUM(c) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
ALTER TABLE t1 DROP INDEX b;
SELECT COUNT(*) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
SELECT SUM(c) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
ALTER TABLE t1 ADD INDEX b USING HASH (b);
SELECT COUNT(*) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
SELECT SUM(c) FROM t1 WHERE b NOT IN ( 1,2,6,7,9,10,11 );
DROP TABLE t1;

# Bug#37327 Range scan on partitioned table returns duplicate rows
# (Duplicate of Bug#35931)
CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL,
  KEY `c1` (`c1`)
) DEFAULT CHARSET=latin1;

CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL,
  KEY `c1` (`c1`)
) DEFAULT CHARSET=latin1 /*!50100 PARTITION BY RANGE (c1) (PARTITION a VALUES LESS THAN (100) , PARTITION b VALUES LESS THAN MAXVALUE ) */;

INSERT INTO `t1` VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);
INSERT INTO `t2` VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);

analyze table t1;
EXPLAIN SELECT c1 FROM t1 WHERE (c1 > 10 AND c1 < 13) OR (c1 > 17 AND c1 < 20);

FLUSH STATUS;
SELECT c1 FROM t1 WHERE (c1 > 10 AND c1 < 13) OR (c1 > 17 AND c1 < 20);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';

EXPLAIN SELECT c1 FROM t2 WHERE (c1 > 10 AND c1 < 13) OR (c1 > 17 AND c1 < 20);

FLUSH STATUS;
SELECT c1 FROM t2 WHERE (c1 > 10 AND c1 < 13) OR (c1 > 17 AND c1 < 20);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';
DROP TABLE t1,t2;

# Bug#37329 Range scan on partitioned tables shows higher Handler_read_next
# (marked as duplicate of Bug#35931)
CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL,
  KEY `c1` (`c1`)
) DEFAULT CHARSET=latin1;

CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL,
  KEY `c1` (`c1`)
) DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (c1)
(PARTITION a VALUES LESS THAN (100) ,
 PARTITION b VALUES LESS THAN MAXVALUE ) */;

INSERT INTO `t1` VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);
INSERT INTO `t2` VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);

analyze table t1;
EXPLAIN SELECT c1 FROM t1 WHERE (c1 > 2 AND c1 < 5);

FLUSH STATUS;
SELECT c1 FROM t1 WHERE (c1 > 2 AND c1 < 5);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';

EXPLAIN SELECT c1 FROM t2 WHERE (c1 > 2 AND c1 < 5);

FLUSH STATUS;
SELECT c1 FROM t2 WHERE (c1 > 2 AND c1 < 5);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';

EXPLAIN SELECT c1 FROM t1 WHERE (c1 > 12 AND c1 < 15);

FLUSH STATUS;
SELECT c1 FROM t1 WHERE (c1 > 12 AND c1 < 15);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';

EXPLAIN SELECT c1 FROM t2 WHERE (c1 > 12 AND c1 < 15);

FLUSH STATUS;
SELECT c1 FROM t2 WHERE (c1 > 12 AND c1 < 15);
--skip_if_hypergraph  # Depends on the query plan.
SHOW STATUS LIKE 'Handler_read_%';
DROP TABLE t1,t2;

--error ER_PARTITION_FUNCTION_IS_NOT_ALLOWED
create table t1 (a int) partition by list ((a/3)*10 div 1)
(partition p0 values in (0), partition p1 values in (1));

#
# Bug #30695: An apostrophe ' in the comment of the ADD PARTITION causes the Server to crash.
#
# To verify the fix for crashing (on unix-type OS)
# uncomment the exec and error rows!

CREATE TABLE t1 (
    d DATE NOT NULL
)
PARTITION BY RANGE( YEAR(d) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990)
);

ALTER TABLE t1 ADD PARTITION (
PARTITION `p5` VALUES LESS THAN (2010)
COMMENT 'APSTART \' APEND'
);
#--exec sed 's/APSTART \\/APSTART  /' var/master-data/test/t1.frm > tmpt1.frm && mv tmpt1.frm var/master-data/test/t1.frm
#--error ER_PARSE_ERROR
SELECT * FROM t1 LIMIT 1;

DROP TABLE t1;

#
# Bug 30878: crashing when alter an auto_increment non partitioned
#            table to partitioned

create table t1 (id int auto_increment, s1 int, primary key (id));

insert into t1 values (null,1);
insert into t1 values (null,6);

-- sorted_result
select * from t1;

alter table t1 partition by range (id) (
  partition p0 values less than (3),
  partition p1 values less than maxvalue
);

drop table t1;

#
# Bug 15890: Strange number of partitions accepted
#
-- error ER_PARSE_ERROR
create table t1 (a int)
partition by key(a)
partitions 0.2+e1;
-- error ER_PARSE_ERROR
create table t1 (a int)
partition by key(a)
partitions -1;
-- error ER_PARSE_ERROR
create table t1 (a int)
partition by key(a)
partitions 1.5;
-- error ER_PARSE_ERROR
create table t1 (a int)
partition by key(a)
partitions 1e+300;

#
# Bug 19309 Partitions: Crash if double procedural alter
#
create table t1 (a int)
partition by list (a)
(partition p0 values in (1));

create procedure pz()
alter table t1;

call pz();
call pz();
drop procedure pz;
drop table t1;

#
# BUG 16002: Handle unsigned integer functions properly
#
--error ER_VALUES_IS_NOT_INT_TYPE_ERROR
create table t1 (a bigint)
partition by range (a)
(partition p0 values less than (0xFFFFFFFFFFFFFFFF),
 partition p1 values less than (10));
--error ER_VALUES_IS_NOT_INT_TYPE_ERROR
create table t1 (a bigint)
partition by list (a)
(partition p0 values in (0xFFFFFFFFFFFFFFFF),
 partition p1 values in (10));

create table t1 (a bigint unsigned)
partition by range (a)
(partition p0 values less than (100),
 partition p1 values less than MAXVALUE);
insert into t1 values (1);
drop table t1;

create table t1 (a bigint unsigned)
partition by hash (a);
insert into t1 values (0xFFFFFFFFFFFFFFFD);
insert into t1 values (0xFFFFFFFFFFFFFFFE);
select * from t1 where (a + 1) < 10;
select * from t1 where (a + 1) > 10;
drop table t1;

#
# BUG 19067 ALTER TABLE .. ADD PARTITION for subpartitioned table crashes
#
create table t1 (a int)
partition by range (a)
subpartition by key (a)
(partition p0 values less than (1));
alter table t1 add partition (partition p1 values less than (2));
show create table t1;
alter table t1 reorganize partition p1 into (partition p1 values less than (3));
show create table t1;
drop table t1;

#
# Partition by key no partition defined => OK
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a);

#
# Bug 13323: Select count(*) on empty table returns 2
#
select count(*) from t1;

#
# Test SHOW CREATE TABLE
#
show create table t1;

drop table t1;
#
# Partition by key no partition, list of fields
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a, b);

drop table t1;
#
# Partition by key specified 3 partitions and defined 3 => ok
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a)
partitions 3
(partition x1, partition x2, partition x3);

drop table t1;
#
# Partition by key specifying nodegroup
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a)
partitions 3
(partition x1 nodegroup 0,
 partition x2 nodegroup 1,
 partition x3 nodegroup 2);

drop table t1;
#
# Partition by key specifying engine
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a)
partitions 3
(partition x1 engine innodb,
 partition x2 engine innodb,
 partition x3 engine innodb);

drop table t1;
#
# Partition by key specifying tablespace
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by key (a)
partitions 3
(partition x1 tablespace innodb_file_per_table,
 partition x2 tablespace innodb_file_per_table,
 partition x3 tablespace innodb_file_per_table);

CREATE TABLE t2 LIKE t1;

SHOW CREATE TABLE t1;
SHOW CREATE TABLE t2;
drop table t2;
drop table t1;

#
# Partition by key list, basic
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by list (a)
partitions 3
(partition x1 values in (1,2,9,4),
 partition x2 values in (3, 11, 5, 7),
 partition x3 values in (16, 8, 5+19, 70-43));

SHOW CREATE TABLE t1;
drop table t1;
#
# Partition by key list, list function
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by list (b*a)
partitions 3
(partition x1 values in (1,2,9,4),
 partition x2 values in (3, 11, 5, 7),
 partition x3 values in (16, 8, 5+19, 70-43));

SHOW CREATE TABLE t1;
drop table t1;

#
# Partition by key list, list function, no spec of #partitions
#
CREATE TABLE t1 (
a int not null,
b int not null,
c int not null,
primary key(a,b))
partition by list (b*a)
(partition x1 values in (1),
 partition x2 values in (3, 11, 5, 7),
 partition x3 values in (16, 8, 5+19, 70-43));

SHOW CREATE TABLE t1;
drop table t1;

#
# Bug 13154: Insert crashes due to bad calculation of partition id
#            for PARTITION BY KEY and SUBPARTITION BY KEY
#
CREATE TABLE t1 (
a int not null)
partition by key(a);

LOCK TABLES t1 WRITE;
insert into t1 values (1);
insert into t1 values (2);
insert into t1 values (3);
insert into t1 values (4);
UNLOCK TABLES;

drop table t1;

#
# Bug #13644 DROP PARTITION NULL's DATE column
#
CREATE TABLE t1 (a int, name VARCHAR(50), purchased DATE)
PARTITION BY RANGE (a)
(PARTITION p0 VALUES LESS THAN (3),
 PARTITION p1 VALUES LESS THAN (7),
 PARTITION p2 VALUES LESS THAN (9),
 PARTITION p3 VALUES LESS THAN (11));
INSERT INTO t1 VALUES
(1, 'desk organiser', '2003-10-15'),
(2, 'CD player', '1993-11-05'),
(3, 'TV set', '1996-03-10'),
(4, 'bookcase', '1982-01-10'),
(5, 'exercise bike', '2004-05-09'),
(6, 'sofa', '1987-06-05'),
(7, 'popcorn maker', '2001-11-22'),
(8, 'acquarium', '1992-08-04'),
(9, 'study desk', '1984-09-16'),
(10, 'lava lamp', '1998-12-25');

SELECT * from t1 ORDER BY a;
ALTER TABLE t1 DROP PARTITION p0;
SELECT * from t1 ORDER BY a;

drop table t1;

#
# Bug #13442; Truncate Partitioned table doesn't work
#

CREATE TABLE t1 (a int)
PARTITION BY LIST (a)
(PARTITION p0 VALUES IN (1,2,3), PARTITION p1 VALUES IN (4,5,6));

insert into t1 values (1),(2),(3),(4),(5),(6);
select * from t1;
truncate t1;
select * from t1;
truncate t1;
select * from t1;
drop table t1;

#
# Bug #13445 Partition by KEY method crashes server
#
CREATE TABLE t1 (a int, b int, primary key(a,b))
PARTITION BY KEY(b,a) PARTITIONS 4;

insert into t1 values (0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
select * from t1 where a = 4;

drop table t1;

#
# Bug#22351 - handler::index_next_same() call to key_cmp_if_same()
#             uses the wrong buffer
#
CREATE TABLE t1 (c1 INT, c2 INT, PRIMARY KEY USING BTREE (c1,c2))
  PARTITION BY KEY(c2,c1) PARTITIONS 4;
INSERT INTO t1 VALUES (0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
SELECT * FROM t1 WHERE c1 = 4;
DROP TABLE t1;

#
# Bug #13438: Engine clause in PARTITION clause causes crash
#
CREATE TABLE t1 (a int)
PARTITION BY LIST (a)
PARTITIONS 1
(PARTITION x1 VALUES IN (1) ENGINE=InnoDB);

show create table t1;
drop table t1;

#
# Bug #13440: REPLACE causes crash in partitioned table
#
CREATE TABLE t1 (a int, unique(a))
PARTITION BY LIST (a)
(PARTITION x1 VALUES IN (10), PARTITION x2 VALUES IN (20));

--error ER_NO_PARTITION_FOR_GIVEN_VALUE 
REPLACE t1 SET a = 4;
drop table t1;

#
# Bug #14365: Crash if value too small in list partitioned table
#
CREATE TABLE t1 (a int)
PARTITION BY LIST (a)
(PARTITION x1 VALUES IN (2), PARTITION x2 VALUES IN (3));

insert into t1 values (2), (3);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (4);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (1);
drop table t1;

#
# Bug 14327: PARTITIONS clause gets lost in SHOW CREATE TABLE
#
CREATE TABLE t1 (a int)
PARTITION BY HASH(a)
PARTITIONS 5;

SHOW CREATE TABLE t1;

drop table t1;

#
# Bug #13446: Update to value outside of list values doesn't give error
#
CREATE TABLE t1 (a int)
PARTITION BY RANGE (a)
(PARTITION x1 VALUES LESS THAN (2));

insert into t1 values (1);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
update t1 set a = 5;

drop table t1;

#
# Bug #13441: Analyze on partitioned table didn't work
#
CREATE TABLE t1 (a int)
PARTITION BY LIST (a)
(PARTITION x1 VALUES IN (10), PARTITION x2 VALUES IN (20));

analyze table t1;

drop table t1;

#
# BUG 15221 (Cannot reorganize with the same name)
#
create table t1
(a int)
partition by range (a)
  ( partition p0 values less than(10),
    partition p1 values less than (20),
    partition p2 values less than (25));

alter table t1 reorganize partition p2 into (partition p2 values less than (30));
show create table t1;
drop table t1;

CREATE TABLE t1 (a int, b int)
PARTITION BY RANGE (a)
(PARTITION x0 VALUES LESS THAN (2),
 PARTITION x1 VALUES LESS THAN (4),
 PARTITION x2 VALUES LESS THAN (6),
 PARTITION x3 VALUES LESS THAN (8),
 PARTITION x4 VALUES LESS THAN (10),
 PARTITION x5 VALUES LESS THAN (12),
 PARTITION x6 VALUES LESS THAN (14),
 PARTITION x7 VALUES LESS THAN (16),
 PARTITION x8 VALUES LESS THAN (18),
 PARTITION x9 VALUES LESS THAN (20));

ALTER TABLE t1 REORGANIZE PARTITION x0,x1,x2 INTO
(PARTITION x1 VALUES LESS THAN (6));
show create table t1;
drop table t1;

# Testcase for BUG#15819
create table t1 (a int not null, b int not null) partition by LIST (a+b) (
  partition p0 values in (12),
  partition p1 values in (14)
);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (10,1);

drop table t1;

#
# Bug#16901 Partitions: crash, SELECT, column of part.
#           function=first column of primary key
#
create table t1 (f1 integer,f2 integer, f3 varchar(10), primary key(f1,f2))
partition by range(f1) subpartition by hash(f2) subpartitions 2
(partition p1 values less than (0),
 partition p2 values less than (2),
 partition p3 values less than (2147483647));

insert into t1 values(10,10,'10');
insert into t1 values(2,2,'2');
select * from t1 where f1 = 2;
drop table t1;

#
# Bug #16907 Partitions: crash, SELECT goes into last partition, UNIQUE INDEX
#
create table t1 (f1 integer,f2 integer, unique index(f1))
partition by range(f1 div 2)
subpartition by hash(f1) subpartitions 2
(partition partb values less than (2),
partition parte values less than (4),
partition partf values less than (10000));
insert into t1 values(10,1);
select * from t1 where f1 = 10;
drop table t1;

#
# Bug #16775: Wrong engine type stored for subpartition
# After WL#8971, this test case is rewritten to use InnoDB
# instead of InnoDB.
#
set @old_default_engine= @@session.default_storage_engine;
set session default_storage_engine= 'innodb';
create table t1 (f_int1 int(11) default null) engine = innodb
  partition by range (f_int1) subpartition by hash (f_int1)
  (partition part1 values less than (1000)
   (subpartition subpart11 engine = innodb));
drop table t1;
set session default_storage_engine= @old_default_engine;

#
# Bug #16782: Crash using REPLACE on table with primary key
#
create table t1 (f_int1 integer, f_int2 integer, primary key (f_int1))
  partition by hash(f_int1) partitions 2;
insert into t1 values (1,1),(2,2);
replace into t1 values (1,1),(2,2);
drop table t1;

#
# Bug #17169: Partitions: out of memory if add partition and unique
#
create table t1 (s1 int, unique (s1)) partition by list (s1) (partition x1 VALUES in (10), partition x2 values in (20));
alter table t1 add partition (partition x3 values in (30));
drop table t1;

#
# Bug #17754 Change to explicit removal of partitioning scheme
# Also added a number of tests to ensure that proper engine is
# choosen in all kinds of scenarios.
#

create table t1 (a int)
partition by key(a)
partitions 2
(partition p0 engine=innodb, partition p1 engine=innodb);
show create table t1;	

alter table t1;
show create table t1;

alter table t1 engine=innodb;
show create table t1;

alter table t1 remove partitioning;
show create table t1;

drop table t1;

create table t1 (a int)
engine=innodb
partition by key(a)
partitions 2
(partition p0 engine=innodb, partition p1 engine=innodb);
show create table t1;

alter table t1 add column b int remove partitioning;
show create table t1;

alter table t1
engine=innodb
partition by key(a)
(partition p0 engine=innodb, partition p1);
show create table t1;

alter table t1 engine=myisam, add column c int remove partitioning;
show create table t1;

alter table t1
engine=innodb
partition by key (a)
(partition p0, partition p1);
show create table t1;

alter table t1
partition by key (a)
(partition p0, partition p1);
show create table t1;

# Since alter, it already have ENGINE=INNODB from before on table level
# -> OK
alter table t1
partition by key(a)
(partition p0, partition p1 engine=innodb);

# Since alter, it already have ENGINE=INNODB from before on table level
# -> OK
alter table t1
partition by key(a)
(partition p0 engine=innodb, partition p1);

drop table t1;

# Bug #17432: Partition functions containing NULL values should return
#             LONGLONG_MIN
#
CREATE TABLE t1 (
 f_int1 INTEGER, f_int2 INTEGER,
 f_char1 CHAR(10), f_char2 CHAR(10), f_charbig VARCHAR(1000)
 )
 PARTITION BY RANGE(f_int1 DIV 2)
 SUBPARTITION BY HASH(f_int1)
 SUBPARTITIONS 2
 (PARTITION parta VALUES LESS THAN (0),
  PARTITION partb VALUES LESS THAN (5),
  PARTITION parte VALUES LESS THAN (10),
  PARTITION partf VALUES LESS THAN (2147483647));
INSERT INTO t1 SET f_int1 = NULL , f_int2 = -20, f_char1 = CAST(-20 AS CHAR),
                   f_char2 = CAST(-20 AS CHAR), f_charbig = '#NULL#';
SELECT * FROM t1 WHERE f_int1 IS NULL;
SELECT * FROM t1;
drop table t1;

#
# Bug 17430: Crash when SELECT * from t1 where field IS NULL
#

CREATE TABLE t1 (
 f_int1 INTEGER, f_int2 INTEGER,
 f_char1 CHAR(10), f_char2 CHAR(10), f_charbig VARCHAR(1000)  )
 PARTITION BY LIST(MOD(f_int1,2))
 SUBPARTITION BY KEY(f_int1)
 (PARTITION part1 VALUES IN (-1) (SUBPARTITION sp1, SUBPARTITION sp2),
  PARTITION part2 VALUES IN (0) (SUBPARTITION sp3, SUBPARTITION sp5),
  PARTITION part3 VALUES IN (1) (SUBPARTITION sp4, SUBPARTITION sp6));

INSERT INTO t1 SET f_int1 = 2, f_int2 = 2, f_char1 = '2', f_char2 = '2', f_charbig = '===2===';
INSERT INTO t1 SET f_int1 = 2, f_int2 = 2, f_char1 = '2', f_char2 = '2', f_charbig = '===2===';

SELECT * FROM t1 WHERE f_int1  IS NULL;
drop table t1;

#
# Bug#14363 Partitions: failure if create in stored procedure
#
delimiter //;

create procedure p ()
begin
create table t1 (s1 mediumint,s2 mediumint)
partition by list (s2)
(partition p1 values in (0),
 partition p2 values in (1));
end//

call p()//
drop procedure p//
drop table t1;

create procedure p ()
begin
create table t1 (a int not null,b int not null,c int not null,primary key (a,b))
partition by range (a)
subpartition by hash (a+b)
(partition x1 values less than (1)
 (subpartition x11,
  subpartition x12),
 partition x2 values less than (5)
 (subpartition x21,
  subpartition x22));
end//

call p()//
drop procedure p//
drop table t1//
delimiter ;//

#
# Bug #15447  Partitions: NULL is treated as zero
#

# NULL for RANGE partition
create table t1 (a int,b int,c int,key(a,b))
partition by range (a)
partitions 3
(partition x1 values less than (0),
 partition x2 values less than (10),
 partition x3 values less than maxvalue);

insert into t1 values (NULL, 1, 1);
insert into t1 values (0, 1, 1);
insert into t1 values (12, 1, 1);

--sorted_result
select partition_name, partition_description, table_rows
from information_schema.partitions where table_schema ='test';
SHOW CREATE TABLE t1;
drop table t1;

# NULL for LIST partition
--error ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR
create table t1 (a int,b int, c int)
partition by list(a)
partitions 2
(partition x123 values in (11,12),
 partition x234 values in (1 ,NULL, NULL));

--error ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR
create table t1 (a int,b int, c int)
partition by list(a)
partitions 2
(partition x123 values in (11, NULL),
 partition x234 values in (1 ,NULL));

create table t1 (a int,b int, c int)
partition by list(a)
partitions 2
(partition x123 values in (11, 12),
 partition x234 values in (5, 1));
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (NULL,1,1);
drop table t1;

create table t1 (a int,b int, c int)
partition by list(a)
partitions 2
(partition x123 values in (11, 12),
 partition x234 values in (NULL, 1));

insert into t1 values (11,1,6);
insert into t1 values (NULL,1,1);

--sorted_result
select partition_name, partition_description, table_rows
from information_schema.partitions where table_schema ='test';
drop table t1;

#
# BUG 17947 Crash with REBUILD PARTITION
#
create table t1 (a int)
partition by list (a)
(partition p0 values in (1));

--error ER_PARSE_ERROR
alter table t1 rebuild partition;

drop table t1;

#
# BUG 15253 Insert that should fail doesn't
#
create table t1 (a int)
partition by list (a)
(partition p0 values in (5));

--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (0);

drop table t1;

#
# BUG #16370 Subpartitions names not shown in SHOW CREATE TABLE output
#
create table t1 (a int)
partition by range (a) subpartition by hash (a)
(partition p0 values less than (100));

show create table t1;
alter table t1 add partition (partition p1 values less than (200)
(subpartition subpart21));

show create table t1;

drop table t1;

create table t1 (a int)
partition by key (a);

show create table t1;
alter table t1 add partition (partition p1);
show create table t1;

drop table t1;

#
# BUG 15407 Crash with subpartition
#
--error ER_PARSE_ERROR
create table t1 (a int, b int)
partition by range (a)
subpartition by hash(a)
(partition p0 values less than (0) (subpartition sp0),
 partition p1 values less than (1));

--error ER_PARSE_ERROR
create table t1 (a int, b int)
partition by range (a)
subpartition by hash(a)
(partition p0 values less than (0),
 partition p1 values less than (1) (subpartition sp0));

#
# Bug 46354 Crash with subpartition
#
--error ER_PARSE_ERROR
create table t1 (a int, b int)
partition by list (a)
subpartition by hash(a)
(partition p0 values in (0),
 partition p1 values in (1) (subpartition sp0));


#
# BUG 15961 No error when subpartition defined without subpartition by clause
#
--error ER_SUBPARTITION_ERROR
create table t1 (a int)
partition by hash (a)
(partition p0 (subpartition sp0));

#
# Bug 17127 
#
create table t1 (a int)
partition by range (a)
(partition p0 values less than (1));

--error ER_PARTITION_WRONG_VALUES_ERROR
alter table t1 add partition (partition p1 values in (2));
--error ER_PARTITION_REQUIRES_VALUES_ERROR
alter table t1 add partition (partition p1);

drop table t1;

create table t1 (a int)
partition by list (a)
(partition p0 values in (1));

--error ER_PARTITION_WRONG_VALUES_ERROR
alter table t1 add partition (partition p1 values less than (2));
--error ER_PARTITION_REQUIRES_VALUES_ERROR
alter table t1 add partition (partition p1);

drop table t1;

create table t1 (a int)
partition by hash (a)
(partition p0);

--error ER_PARTITION_WRONG_VALUES_ERROR
alter table t1 add partition (partition p1 values less than (2));
--error ER_PARTITION_WRONG_VALUES_ERROR
alter table t1 add partition (partition p1 values in (2));

drop table t1;

#
# BUG 17947 Crash with REBUILD PARTITION
#
create table t1 (a int)
partition by list (a)
(partition p0 values in (1));

--error ER_PARSE_ERROR
alter table t1 rebuild partition;

drop table t1;

#
# Bug #14526: Partitions: indexed searches fail
#
create table t2 (s1 int not null auto_increment, primary key (s1)) partition by list (s1) (partition p1 values in (1),partition p2 values in (2),partition p3 values in (3),partition p4 values in (4));
insert into t2 values (null),(null),(null);
select * from t2;
select * from t2 where s1 < 2;
update t2 set s1 = s1 + 1 order by s1 desc;
select * from t2 where s1 < 3;
select * from t2 where s1 = 2;
drop table t2;

#
# Bug #17497: Partitions: crash if add partition on temporary table
#
--error ER_PARTITION_NO_TEMPORARY
create temporary table t1 (a int) partition by hash(a);

#
# Bug #17097: Partitions: failing ADD PRIMARY KEY leads to temporary rotten
# metadata,crash
#
create table t1 (a int, b int) partition by list (a)
  (partition p1 values in (1), partition p2 values in (2));
--error ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF
alter table t1 add primary key (b);
show create table t1;
drop table t1;

############################################
#
# Author: Mikael Ronstrom
# Date:   2006-03-01
# Purpose
# Bug 17772: Crash at ALTER TABLE with rename
#            and add column + comment on
#            partitioned table
#
############################################
create table t1 (a int unsigned not null auto_increment primary key)
partition by key(a);
alter table t1 rename t2, add c char(10), comment "no comment";
show create table t2;

drop table t2;

#
# Bug#15336 Partitions: crash if create table as select
#
create table t1 (f1 int) partition by hash (f1) as select 1;
drop table t1;

#
# bug #14350 Partitions: crash if prepared statement
#
prepare stmt1 from 'create table t1 (s1 int) partition by hash (s1)';
execute stmt1;
--error ER_TABLE_EXISTS_ERROR
execute stmt1;
drop table t1;

#
# bug 17290 SP with delete, create and rollback to save point causes MySQLD core
#
delimiter |;
eval CREATE PROCEDURE test.p1(IN i INT)
BEGIN
  DECLARE CONTINUE HANDLER FOR sqlexception BEGIN END;
  DROP TABLE IF EXISTS t1;
  CREATE TABLE t1 (num INT,PRIMARY KEY(num));
  START TRANSACTION;
    INSERT INTO t1 VALUES(i);
    savepoint t1_save;
    INSERT INTO t1 VALUES (14);
    ROLLBACK to savepoint t1_save;
    COMMIT;
END|
delimiter ;|
CALL test.p1(12);
CALL test.p1(13);
drop table t1;
drop procedure test.p1;

#
# Bug 13520: Problem with delimiters in COMMENT DATA DIRECTORY ..
#
CREATE TABLE t1 (a int not null)
partition by key(a)
(partition p0 COMMENT='first partition');
drop table t1;

#
# Bug 13433: Problem with delimited identifiers
#
CREATE TABLE t1 (`a b` int not null)
partition by key(`a b`);
drop table t1;

CREATE TABLE t1 (`a b` int not null)
partition by hash(`a b`);
drop table t1;

#
# Bug#18053 Partitions: crash if null
# Bug#18070 Partitions: wrong result on WHERE ... IS NULL
#
create table t1 (f1 integer) partition by range(f1)
(partition p1 values less than (0), partition p2 values less than (10));
insert into t1 set f1 = null;
select * from t1 where f1 is null;
analyze table t1;
explain select * from t1 where f1 is null;
drop table t1;

create table t1 (f1 integer) partition by list(f1)
(partition p1 values in (1), partition p2 values in (null));
insert into t1 set f1 = null;
insert into t1 set f1 = 1;
select * from t1 where f1 is null or f1 = 1;
drop table t1;

create table t1 (f1 smallint)
partition by list (f1) (partition p0 values in (null));
insert into t1 values (null);
select * from t1 where f1 is null;
select * from t1 where f1 < 1;
select * from t1 where f1 <= NULL;
select * from t1 where f1 < NULL;
select * from t1 where f1 >= NULL;
select * from t1 where f1 > NULL;
select * from t1 where f1 > 1;
drop table t1;

create table t1 (f1 smallint)
partition by range (f1) (partition p0 values less than (0));
insert into t1 values (null);
select * from t1 where f1 is null;
drop table t1;

create table t1 (f1 integer) partition by list(f1)
(
 partition p1 values in (1),
 partition p2 values in (NULL),
 partition p3 values in (2),
 partition p4 values in (3),
 partition p5 values in (4)
);

insert into t1 values (1),(2),(3),(4),(null);
select * from t1 where f1 < 3;
analyze table t1;
explain select * from t1 where f1 < 3;
select * from t1 where f1 is null;
explain select * from t1 where f1 is null;
drop table t1;

create table t1 (f1 int) partition by list(f1 div 2)
(
 partition p1 values in (1),
 partition p2 values in (NULL),
 partition p3 values in (2),
 partition p4 values in (3),
 partition p5 values in (4)
);

insert into t1 values (2),(4),(6),(8),(null);
select * from t1 where f1 < 3;
analyze table t1;
explain select * from t1 where f1 < 3;
select * from t1 where f1 is null;
explain select * from t1 where f1 is null;
drop table t1;

create table t1 (a int) partition by LIST(a) (
  partition pn values in (NULL),
  partition p0 values in (0),
  partition p1 values in (1),
  partition p2 values in (2)
);
insert into t1 values (NULL),(0),(1),(2);
select * from t1 where a is null or a < 2;
analyze table t1;
explain select * from t1 where a is null or a < 2;
select * from t1 where a is null or a < 0 or a > 1;
explain select * from t1 where a is null or a < 0 or a > 1;
drop table t1;

#
#Bug# 17631 SHOW TABLE STATUS reports wrong engine
#
CREATE TABLE t1 (id INT NOT NULL PRIMARY KEY, name VARCHAR(20)) 
DEFAULT CHARSET=latin1
PARTITION BY RANGE(id)
(PARTITION p0  VALUES LESS THAN (10),
PARTITION p1 VALUES LESS THAN (20),
PARTITION p2 VALUES LESS THAN (30));
analyze table t1;
--replace_column 6 0 7 0 8 0 9 0 12 NULL 13 NULL 14 NULL
SHOW TABLE STATUS;
DROP TABLE t1;

#
#BUG 16002 Erroneus handling of unsigned partition functions
#
--error ER_PARTITION_CONST_DOMAIN_ERROR
create table t1 (a bigint unsigned)
partition by list (a)
(partition p0 values in (0-1));

create table t1 (a bigint unsigned)
partition by range (a)
(partition p0 values less than (10));

--error ER_NO_PARTITION_FOR_GIVEN_VALUE
insert into t1 values (0xFFFFFFFFFFFFFFFF);

drop table t1;

#
#BUG 18750 Problems with partition names
#
create table t1 (a int)
partition by list (a)
(partition `s1 s2` values in (0));
drop table t1;

create table t1 (a int)
partition by list (a)
(partition `7` values in (0));
drop table t1;

--error ER_WRONG_PARTITION_NAME
create table t1 (a int)
partition by list (a)
(partition `s1 s2 ` values in (0));

--error ER_WRONG_PARTITION_NAME
create table t1 (a int)
partition by list (a)
subpartition by hash (a)
(partition p1 values in (0) (subpartition `p1 p2 `));

#
# BUG 18752 SHOW CREATE TABLE doesn't show NULL value in SHOW CREATE TABLE
#
CREATE TABLE t1 (a int)
PARTITION BY LIST (a)
(PARTITION p0 VALUES IN (NULL));
SHOW CREATE TABLE t1;
DROP TABLE t1;

--error ER_NULL_IN_VALUES_LESS_THAN
CREATE TABLE t1 (a int)
PARTITION BY RANGE(a)
(PARTITION p0 VALUES LESS THAN (NULL));

#
# Bug#18753 Partitions: auto_increment fails
#
create table t1 (s1 int auto_increment primary key)
partition by list (s1)
(partition p1 values in (1),
 partition p2 values in (2),
 partition p3 values in (3));
insert into t1 values (null);
insert into t1 values (null);
insert into t1 values (null);
analyze table t1;
select auto_increment from information_schema.tables where table_name='t1';
select * from t1;
drop table t1;

#
# BUG 19140 Partitions: Create index for partitioned table crashes
#
create table t1 (a int)
partition by key(a);
insert into t1 values (1);
create index inx1 on t1(a);
drop table t1;

#
# BUG 19304 Partitions: MERGE handler not allowed in partitioned tables
#
--error ER_PARTITION_MERGE_ERROR
create table t1 (a int)
partition by key (a)
(partition p0 engine = MERGE);

#
# BUG 19062 Partition clause ignored if CREATE TABLE ... AS SELECT ...;
#
create table t1 (a varchar(1))
partition by key (a)
as select 'a';

show create table t1;
drop table t1;

#
# BUG 19501 Partitions: SHOW TABLE STATUS shows wrong Data_free
#
CREATE TABLE t1 (a int) PARTITION BY KEY(a);
INSERT into t1 values (1), (2);
analyze table t1;
--replace_column 9 0 12 NULL 13 NULL 14 NULL
SHOW TABLE STATUS;
DELETE from t1 where a = 1;
analyze table t1;
--replace_column 9 0 12 NULL 13 NULL 14 NULL
SHOW TABLE STATUS;
ALTER TABLE t1 OPTIMIZE PARTITION p0;
analyze table t1;
--replace_column 12 NULL 13 NULL 14 NULL
SHOW TABLE STATUS;
DROP TABLE t1;

#
# BUG 19502: ENABLE/DISABLE Keys don't work for partitioned tables
#
CREATE TABLE t1 (a int, index(a)) PARTITION BY KEY(a);
ALTER TABLE t1 DISABLE KEYS;
ALTER TABLE t1 ENABLE KEYS;
DROP TABLE t1;

#
# Bug 17455 Partitions: Wrong message and error when using Repair/Optimize
#                       table on partitioned table
# (added check/analyze for gcov of Bug#20129)
create table t1 (a int)
partition by key (a);

REPAIR TABLE t1;
OPTIMIZE TABLE t1;
CHECK TABLE t1;
ANALYZE TABLE t1;

drop table t1;

#
#BUG 17138 Problem with stored procedure and analyze partition
#
--disable_warnings
drop procedure if exists mysqltest_1;
--enable_warnings

create table t1 (a int)
partition by list (a)
(partition p0 values in (0));

insert into t1 values (0);
delimiter //;

create procedure mysqltest_1 ()
begin
  begin
    declare continue handler for sqlexception begin end;
    update ignore t1 set a = 1 where a = 0;
  end;
  prepare stmt1 from 'alter table t1';
  execute stmt1;
end//

call mysqltest_1()//
delimiter ;//
drop table t1;
drop procedure mysqltest_1;

#
# Bug 20583 Partitions: Crash using index_last
#
create table t1 (a int, index(a))
partition by hash(a);
insert into t1 values (1),(2);
select * from t1 ORDER BY a DESC;
drop table t1;

#
# Bug 21388: Bigint fails to find record
#
create table t1 (a bigint unsigned not null, primary key(a))
partition by key (a)
partitions 10;

show create table t1;
insert into t1 values (18446744073709551615), (0xFFFFFFFFFFFFFFFE),
(18446744073709551613), (18446744073709551612);
select * from t1;
select * from t1 where a = 18446744073709551615;
delete from t1 where a = 18446744073709551615;
select * from t1;
drop table t1;

#
# Bug 24502 reorganize partition closes connection
#
CREATE TABLE t1 (
  num int(11) NOT NULL, cs int(11) NOT NULL)
PARTITION BY RANGE (num) SUBPARTITION BY HASH (
cs) SUBPARTITIONS 2 (PARTITION p_X VALUES LESS THAN MAXVALUE);

ALTER TABLE t1 
REORGANIZE PARTITION p_X INTO ( 
    PARTITION p_100 VALUES LESS THAN (100), 
    PARTITION p_X VALUES LESS THAN MAXVALUE 
    );

drop table t1;

#
# Bug #24186 (nested query across partitions returns fewer records)
#

set session sql_mode='';

CREATE TABLE t2 (
  taken datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  id int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (id,taken),
  KEY taken (taken)
) DEFAULT CHARSET=latin1;

INSERT INTO t2 VALUES 
('2006-09-27 21:50:01',16421),
('2006-10-02 21:50:01',16421),
('2006-09-27 21:50:01',19092),
('2006-09-28 21:50:01',19092),
('2006-09-29 21:50:01',19092),
('2006-09-30 21:50:01',19092),
('2006-10-01 21:50:01',19092),
('2006-10-02 21:50:01',19092),
('2006-09-27 21:50:01',22589),
('2006-09-29 21:50:01',22589);

CREATE TABLE t1 (
  id int(8) NOT NULL,
  PRIMARY KEY (id)
) DEFAULT CHARSET=latin1;

INSERT INTO t1 VALUES 
(16421),
(19092),
(22589);

CREATE TABLE t4 (
  taken datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  id int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (id,taken),
  KEY taken (taken)
) DEFAULT CHARSET=latin1 
PARTITION BY RANGE (to_days(taken)) 
(
PARTITION p01 VALUES LESS THAN (732920) , 
PARTITION p02 VALUES LESS THAN (732950) , 
PARTITION p03 VALUES LESS THAN MAXVALUE ) ;

INSERT INTO t4 select * from t2;

set @f_date='2006-09-28';
set @t_date='2006-10-02';

SELECT t1.id AS MyISAM_part
FROM t1
WHERE t1.id IN (
    SELECT distinct id
    FROM t4
    WHERE taken BETWEEN @f_date AND date_add(@t_date, INTERVAL 1 DAY))
ORDER BY t1.id;

drop table t1, t2, t4;

CREATE TABLE t1 (
  taken datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  id int(11) NOT NULL DEFAULT '0',
  status varchar(20) NOT NULL DEFAULT '',
  PRIMARY KEY (id,taken)
) DEFAULT CHARSET=latin1
PARTITION BY RANGE (to_days(taken))
(
PARTITION p15 VALUES LESS THAN (732950) ,
PARTITION p16 VALUES LESS THAN MAXVALUE ) ;


INSERT INTO t1 VALUES
('2006-09-27 21:50:01',22589,'Open'),
('2006-09-29 21:50:01',22589,'Verified');

DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (
  id int(8) NOT NULL,
  severity tinyint(4) NOT NULL DEFAULT '0',
  priority tinyint(4) NOT NULL DEFAULT '0',
  status varchar(20) DEFAULT NULL,
  alien tinyint(4) NOT NULL
) DEFAULT CHARSET=latin1;

INSERT INTO t2 VALUES
(22589,1,1,'Need Feedback',0);

SELECT t2.id FROM t2 WHERE t2.id IN (SELECT id FROM t1 WHERE status = 'Verified');

drop table t1, t2;

#
# Bug #27123 partition + on duplicate key update + varchar = Can't find record in <table> 
#
create table t1 (c1 varchar(255),c2 tinyint,primary key(c1))
   partition by key (c1) partitions 10 ;
insert into t1 values ('aaa','1') on duplicate key update c2 = c2 + 1;
insert into t1 values ('aaa','1') on duplicate key update c2 = c2 + 1;
select * from t1;
drop table t1;

#
# Bug #28005 Partitions: can't use -9223372036854775808 
#

create table t1 (s1 bigint) partition by list (s1) (partition p1 values in (-9223372036854775808));
drop table t1;

#
# Bug #28806: Running SHOW TABLE STATUS during high INSERT load crashes server
#
create table t1(a int auto_increment, b int, primary key (a, b)) 
  partition by hash(b) partitions 2;
insert into t1 values (null, 1);
analyze table t1;
--replace_column 9 0 12 NULL 13 NULL 14 NULL
show table status;
drop table t1;

create table t1(a int auto_increment primary key)
  partition by key(a) partitions 2;
insert into t1 values (null), (null), (null);
analyze table t1;
--replace_column 9 0 12 NULL 13 NULL 14 NULL
show table status;
drop table t1;
# Bug #28488: Incorrect information in file: './test/t1_test#.frm'
#

CREATE TABLE t1(a INT NOT NULL, b TINYBLOB, KEY(a))
  PARTITION BY RANGE(a) ( PARTITION p0 VALUES LESS THAN (32));
INSERT INTO t1 VALUES (1, REPEAT('a', 10));
INSERT INTO t1 SELECT a + 1, b FROM t1;
INSERT INTO t1 SELECT a + 2, b FROM t1;
INSERT INTO t1 SELECT a + 4, b FROM t1;
INSERT INTO t1 SELECT a + 8, b FROM t1;

ALTER TABLE t1 ADD PARTITION (PARTITION p1 VALUES LESS THAN (64));
ALTER TABLE t1 DROP PARTITION p1;

DROP TABLE t1;

#
# Bug #30484: Partitions: crash with self-referencing trigger
#

create table t (s1 int) partition by key (s1);
create trigger t_ad after delete on t for each row insert into t values (old.s1);
insert into t values (1);
drop table t;

#
# Bug #27084 partitioning by list seems failing when using case 
# BUG #18198: Case no longer supported, test case removed
#

create table t2 (b int);
--error ER_BAD_FIELD_ERROR
create table t1 (b int)
PARTITION BY RANGE (t2.b) (
  PARTITION p1 VALUES LESS THAN (10),
  PARTITION p2 VALUES LESS THAN (20)
) select * from t2;
create table t1 (a int)
PARTITION BY RANGE (b) (
  PARTITION p1 VALUES LESS THAN (10),
  PARTITION p2 VALUES LESS THAN (20)
) select * from t2;
show create table t1;
drop table t1, t2;

#
# Bug #32067 Partitions: crash with timestamp column
#  this bug occurs randomly on some UPDATE statement
#  with the '1032: Can't find record in 't1'' error

create table t1
 (s1 timestamp on update current_timestamp, s2 int)
 partition by key(s1) partitions 3;

insert into t1 values (null,null);
--disable_query_log
let $cnt= 1000;
while ($cnt)
{
  update t1 set s2 = 1;
  update t1 set s2 = 2;
  dec $cnt;
}
--enable_query_log

drop table t1;

#
# BUG#32772: partition crash 1: enum column
#
# Note that month(int_col) is disallowed after bug#54483.
create table t1 (
  c0 int,
  c1 bigint,
  c2 set('sweet'),
  key (c2,c1,c0), 
  key(c0)
) partition by hash (c0) partitions 5;

--disable_warnings
insert ignore into t1 set c0 = -6502262, c1 = 3992917, c2 = 35019;
insert ignore into t1 set c0 = 241221, c1 = -6862346, c2 = 56644;
--enable_warnings
# This must not fail assert:
select c1 from t1 group by (select c0 from t1 limit 1);
drop table t1;

# Bug #30495: optimize table t1,t2,t3 extended errors
# (added more maintenace commands for Bug#20129
CREATE TABLE t1(a int)
PARTITION BY RANGE (a) (
  PARTITION p1 VALUES LESS THAN (10),
  PARTITION p2 VALUES LESS THAN (20)
);
--error ER_PARSE_ERROR
ALTER TABLE t1 OPTIMIZE PARTITION p1 EXTENDED;
--error ER_PARSE_ERROR
ALTER TABLE t1 ANALYZE PARTITION p1 EXTENDED;
ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p1;
ALTER TABLE t1 REPAIR PARTITION p1;
ALTER TABLE t1 OPTIMIZE PARTITION p1;
DROP TABLE t1;

#
# Bug #29258: Partitions: search fails for maximum unsigned bigint
#
CREATE TABLE t1 (s1 BIGINT UNSIGNED)
  PARTITION BY RANGE (s1) (
  PARTITION p0 VALUES LESS THAN (0), 
  PARTITION p1 VALUES LESS THAN (1), 
  PARTITION p2 VALUES LESS THAN (18446744073709551615)
);
INSERT INTO t1 VALUES (0), (18446744073709551614);
--error ER_NO_PARTITION_FOR_GIVEN_VALUE
INSERT INTO t1 VALUES (18446744073709551615);
DROP TABLE t1;

CREATE TABLE t1 (s1 BIGINT UNSIGNED)
 PARTITION BY RANGE (s1) (
  PARTITION p0 VALUES LESS THAN (0),
  PARTITION p1 VALUES LESS THAN (1),
  PARTITION p2 VALUES LESS THAN (18446744073709551614),
  PARTITION p3 VALUES LESS THAN MAXVALUE
);
INSERT INTO t1 VALUES (-1), (0), (18446744073709551613), 
  (18446744073709551614), (18446744073709551615);
SELECT * FROM t1;
SELECT * FROM t1 WHERE s1 = 0;
SELECT * FROM t1 WHERE s1 = 18446744073709551614;
SELECT * FROM t1 WHERE s1 = 18446744073709551615;
DROP TABLE t1;

CREATE TABLE t1 (s1 BIGINT UNSIGNED)  
 PARTITION BY RANGE (s1) (
  PARTITION p0 VALUES LESS THAN (0),
  PARTITION p1 VALUES LESS THAN (1),
  PARTITION p2 VALUES LESS THAN (18446744073709551615),
  PARTITION p3 VALUES LESS THAN MAXVALUE
);
DROP TABLE t1;

#
# Bug #31890 Partitions: ORDER BY DESC in InnoDB not working
#

CREATE TABLE t1
(int_column INT, char_column CHAR(5),
PRIMARY KEY(char_column,int_column))
PARTITION BY KEY(char_column,int_column)
PARTITIONS 101;
INSERT INTO t1 (int_column, char_column) VALUES
(      39868 ,'zZZRW'),       
(     545592 ,'zZzSD'),       
(       4936 ,'zzzsT'),       
(       9274 ,'ZzZSX'),       
(     970185 ,'ZZzTN'),       
(     786036 ,'zZzTO'),       
(      37240 ,'zZzTv'),       
(     313801 ,'zzzUM'),       
(     782427 ,'ZZZva'),       
(     907955 ,'zZZvP'),       
(     453491 ,'zzZWV'),       
(     756594 ,'ZZZXU'),       
(     718061 ,'ZZzZH');       
SELECT * FROM t1 ORDER BY char_column DESC;
DROP TABLE t1;

#
# Bug #32247 Test reports wrong value of "AUTO_INCREMENT" (on a partitioned InnoDB table)
#

CREATE TABLE t1(id MEDIUMINT NOT NULL AUTO_INCREMENT,
                user CHAR(25), PRIMARY KEY(id))
                   PARTITION BY RANGE(id)
                   SUBPARTITION BY hash(id) subpartitions 2
                   (PARTITION pa1 values less than (10),
                    PARTITION pa2 values less than (20),
                    PARTITION pa11 values less than MAXVALUE);
--disable_query_log
let $n= 15;
while ($n)
{
  insert into t1 (user) values ('mysql');
  dec $n;
}
--enable_query_log
show create table t1;
drop table t1;

#
# Bug #38272 timestamps fields incorrectly defaulted on update accross partitions.
#

CREATE TABLE  t1 (
  `ID` bigint(20) NOT NULL AUTO_INCREMENT,
  `createdDate` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `number` int,
  PRIMARY KEY (`ID`, number)
)
PARTITION BY RANGE (number) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11)
);

create table t2 (
  `ID` bigint(20),
  `createdDate` TIMESTAMP,
  `number` int
);

INSERT INTO t1 SET number=1;
insert into t2 select * from t1;
SELECT SLEEP(1);
UPDATE t1 SET number=6;
select count(*) from t1, t2 where t1.createdDate = t2.createdDate;

drop table t1, t2;

#
# Bug #38083 Error-causing row inserted into partitioned table despite error
#
SET @orig_sql_mode = @@SQL_MODE;
SET SQL_MODE='STRICT_ALL_TABLES,ERROR_FOR_DIVISION_BY_ZERO';
CREATE TABLE t1 (c1 INT)
       PARTITION BY LIST(1 DIV c1) (
       PARTITION p0 VALUES IN (NULL),
       PARTITION p1 VALUES IN (1)
     );
 
-- error ER_DIVISION_BY_ZERO
INSERT INTO t1 VALUES (0);
SELECT * FROM t1;
TRUNCATE t1;
-- error ER_DIVISION_BY_ZERO
INSERT INTO t1 VALUES (NULL), (0), (1), (2);
SELECT * FROM t1;
DROP TABLE t1;
SET SQL_MODE= @orig_sql_mode;



#
# Bug #38005 Partitions: error with insert select
#

create table t1 (s1 int) partition by hash(s1) partitions 2;
create index i on t1 (s1);
insert into t1 values (1);
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1 order by s1 desc;
select * from t1;
drop table t1;

create table t1 (s1 int) partition by range(s1) 
        (partition pa1 values less than (10),
         partition pa2 values less than MAXVALUE);
create index i on t1 (s1);
insert into t1 values (1);
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1 order by s1 desc;
select * from t1;
drop table t1;

create table t1 (s1 int) partition by range(s1) 
        (partition pa1 values less than (10),
         partition pa2 values less than MAXVALUE);
create index i on t1 (s1);
insert into t1 values (20);
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1 order by s1 desc;
select * from t1;
drop table t1;

create table t1 (s1 int) partition by range(s1) 
        (partition pa1 values less than (10),
         partition pa2 values less than MAXVALUE);
create index i on t1 (s1);
insert into t1 values (1), (2), (3), (4), (5), (6), (7), (8);
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1;
insert into t1 select s1 from t1 order by s1 desc;
insert into t1 select s1 from t1 where s1=3;
select count(*) from t1;
drop table t1;


--echo #
--echo # Bug#42944: partition not pruned correctly
--echo #
CREATE TABLE t1 (a int) PARTITION BY RANGE (a)
  (PARTITION p0 VALUES LESS THAN (100),
   PARTITION p1 VALUES LESS THAN (200),
   PARTITION p2 VALUES LESS THAN (300),
   PARTITION p3 VALUES LESS THAN MAXVALUE);
INSERT INTO t1 VALUES (10), (100), (200), (300), (400);
analyze table t1;
EXPLAIN SELECT * FROM t1 WHERE a>=200;
DROP TABLE t1;

#
# Bug#44821: select distinct on partitioned table returns wrong results
#
CREATE TABLE t1 ( a INT, b INT, c INT, KEY bc(b, c) )
PARTITION BY KEY (a, b) PARTITIONS 3
;

INSERT INTO t1 VALUES
(17, 1, -8),
(3,  1, -7),
(23, 1, -6),
(22, 1, -5),
(11, 1, -4),
(21, 1, -3),
(19, 1, -2),
(30, 1, -1),

(20, 1, 1),
(16, 1, 2),
(18, 1, 3),
(9,  1, 4),
(15, 1, 5),
(28, 1, 6),
(29, 1, 7),
(25, 1, 8),
(10, 1, 9),
(13, 1, 10),
(27, 1, 11),
(24, 1, 12),
(12, 1, 13),
(26, 1, 14),
(14, 1, 15)
;

SELECT b, c FROM t1 WHERE b = 1 GROUP BY b, c;
analyze table t1;
EXPLAIN
SELECT b, c FROM t1 WHERE b = 1 GROUP BY b, c;

DROP TABLE t1;

--echo #
--echo # Bug #45807: crash accessing partitioned table and sql_mode 
--echo #   contains ONLY_FULL_GROUP_BY
--echo # Bug#46923: select count(*) from partitioned table fails with
--echo # ONLY_FULL_GROUP_BY
--echo #

SET SESSION SQL_MODE='ONLY_FULL_GROUP_BY';
CREATE TABLE t1(id INT,KEY(id))
  PARTITION BY HASH(id) PARTITIONS 2;
SELECT COUNT(*) FROM t1;
DROP TABLE t1;
SET SESSION SQL_MODE=DEFAULT;

# This testcase is commented due to the Bug #46853
# Should be uncommented after fixing Bug #46853
#--echo #
#--echo # BUG#45816 - assertion failure with index containing double 
#--echo #             column on partitioned table
#--echo #
#
#CREATE TABLE t1 (
#  a INT DEFAULT NULL,
#  b DOUBLE DEFAULT NULL,
#  c INT DEFAULT NULL,
#  KEY idx2(b,a)
#) PARTITION BY HASH(c) PARTITIONS 3;
#
#INSERT INTO t1 VALUES (6,8,9);
#INSERT INTO t1 VALUES (6,8,10);
#
#SELECT  1 FROM t1 JOIN t1 AS t2 USING (a) FOR UPDATE;
#
#DROP TABLE t1;

--echo #
--echo # Bug#46198: Hang after failed ALTER TABLE on partitioned table.
--echo #

--disable_warnings
DROP TABLE IF EXISTS t1;
--enable_warnings

#
# Case 1.
#

CREATE TABLE t1 (s1 INT PRIMARY KEY) PARTITION BY HASH(s1);

LOCK TABLES t1 WRITE, t1 b READ;

UNLOCK TABLES;

--error ER_ONLY_ON_RANGE_LIST_PARTITION
ALTER TABLE t1 DROP PARTITION p1;

# The SELECT below used to hang in tdc_wait_for_old_versions().
SELECT * FROM t1;

DROP TABLE t1;

#
# Case 2.
#

CREATE TABLE t1 (s1 VARCHAR(5) PRIMARY KEY) PARTITION BY KEY(s1);

LOCK TABLES t1 WRITE, t1 b READ;

UNLOCK TABLES;

--error ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF
ALTER TABLE t1 ADD COLUMN (s3 VARCHAR(5) UNIQUE);

# The SELECT below used to hang in tdc_wait_for_old_versions().
SELECT * FROM t1;

DROP TABLE t1;

--echo #
--echo # BUG#51868 - crash with myisam_use_mmap and partitioned myisam tables
--echo #
SET GLOBAL myisam_use_mmap=1;
CREATE TABLE t1(a INT) PARTITION BY HASH(a) PARTITIONS 1;
INSERT INTO t1 VALUES(0);
FLUSH TABLE t1;
TRUNCATE TABLE t1;
INSERT INTO t1 VALUES(0);
DROP TABLE t1;
SET GLOBAL myisam_use_mmap=default;

--echo End of 5.1 tests
--echo # Start of 5.5 tests

--echo #
--echo # BUG#55385: UPDATE statement throws an error, but still updates
--echo #            the table entries

CREATE TABLE t1_part (
  partkey int,
  nokey int
) PARTITION BY LINEAR HASH(partkey) PARTITIONS 3;

INSERT INTO t1_part VALUES (1, 1) , (10, 10);
CREATE VIEW v1 AS SELECT * FROM t1_part;

--echo
--echo # Should be (1,1),(10,10)
SELECT * FROM t1_part;

--echo
--echo # Case 1
--echo # Update is refused because partitioning key is updated
--error ER_MULTI_UPDATE_KEY_CONFLICT
UPDATE t1_part AS A NATURAL JOIN t1_part B SET A.partkey = 2, B.nokey = 3;
--error ER_MULTI_UPDATE_KEY_CONFLICT
UPDATE t1_part AS A NATURAL JOIN t1_part B SET A.nokey = 2, B.partkey = 3;

--echo
--echo # Case 2
--echo # Like 1, but partition accessed through a view
--error ER_MULTI_UPDATE_KEY_CONFLICT
UPDATE t1_part AS A NATURAL JOIN v1 as B SET A.nokey = 2 , B.partkey = 3;
--error ER_MULTI_UPDATE_KEY_CONFLICT
UPDATE v1 AS A NATURAL JOIN t1_part as B SET A.nokey = 2 , B.partkey = 3;

--echo
--echo # Should be (1,1),(10,10)
SELECT * FROM t1_part;

--echo
--echo # Case 3
--echo # Update is accepted because partitioning key is not updated
UPDATE t1_part AS A NATURAL JOIN t1_part B SET A.nokey = 2 , B.nokey = 3;

--echo
--echo # Should be (1,3),(10,3)
SELECT * FROM t1_part;

--echo
# Cleanup
DROP VIEW v1;
DROP TABLE t1_part;

--echo # Moved from lock.test
--echo # Separate case for partitioned tables is important
--echo # because each partition has an own thr_lock object.

create table t1 (i int) partition by list (i)
  (partition p0 values in (1),
   partition p1 values in (2,3),
   partition p2 values in (4,5));
lock tables t1 write, t1 as a read, t1 as b read;
alter table t1 add column j int;
unlock tables;
drop table t1;

--echo # End of 5.5 tests

#
# Bug #12330344 Crash and/or valgrind errors in free_io_cache with join, view,
# partitioned table
#

CREATE TABLE t1(a INT PRIMARY KEY) PARTITION BY LINEAR KEY (a);
CREATE ALGORITHM=TEMPTABLE VIEW vtmp AS
SELECT 1 FROM t1 AS t1_0 JOIN t1 ON t1_0.a LIKE (SELECT 1 FROM t1);
SELECT * FROM vtmp;
DROP VIEW vtmp;
DROP TABLE t1;

--echo #
--echo # Bug#13580775 ASSERTION FAILED: RECORD_LENGTH == M_RECORD_LENGTH,
--echo # FILE FILESORT_UTILS.CC
--echo #

CREATE TABLE t1 (
  a INT PRIMARY KEY,
  b INT,
  c CHAR(1),
  d INT,
  KEY (c,d)
) PARTITION BY KEY () PARTITIONS 1;

INSERT INTO t1 VALUES (1,1,'a',1), (2,2,'a',1);

--error ER_WRONG_ARGUMENTS
SELECT 1 FROM t1 WHERE 1 IN
(SELECT  group_concat(b)
 FROM t1
 WHERE c > ST_geomfromtext('point(1 1)')
 GROUP BY b
);

DROP TABLE t1;

--echo #
--echo # WL#5855 (EXPLAIN FORMAT=JSON) partition test
--echo #

CREATE TABLE t1 (c1 int(11) DEFAULT NULL, KEY c1 (c1))
  PARTITION BY RANGE (c1)
    (PARTITION a VALUES LESS THAN (10),
     PARTITION b VALUES LESS THAN (100),
     PARTITION c VALUES LESS THAN MAXVALUE);

INSERT INTO t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);

let $query=SELECT c1 FROM t1 WHERE (c1 > 2 AND c1 < 15);
--eval EXPLAIN $query
--eval EXPLAIN $query
--skip_if_hypergraph  # Depends on the query plan.
--eval EXPLAIN FORMAT=JSON $query

DROP TABLE t1;

--echo #
--echo # Bug#19584181: CRASH AFTER DDL RETURNS WARNINGS - CORRUPT ERROR_HANDLER
--echo #

SET sql_mode= 'STRICT_TRANS_TABLES';
--error ER_WRONG_TYPE_COLUMN_VALUE_ERROR
CREATE TABLE t1 (d TIME)
  PARTITION BY RANGE COLUMNS (d)
    (PARTITION p0 VALUES LESS THAN ('2000-01-01'),
     PARTITION p1 VALUES LESS THAN ('2040-01-01'));

# Before this fix, sql_mode would have been reset to 0.
SELECT @@sql_mode;
SET sql_mode= DEFAULT;

--echo #
--echo # ASSERTION FAILED: !THD->IS_ERROR() PARTITIONS + OUT OF RANGE VALUES
--echo #
CREATE TABLE t1 (a int PRIMARY KEY)
PARTITION BY LINEAR KEY(a) PARTITIONS 2;
--error ER_DATA_OUT_OF_RANGE
SELECT 1 FROM t1 WHERE EXP(10000);
DROP TABLE t1;

--disable_query_log
CALL mtr.add_suppression(".ERROR.  Operating system error number");
CALL mtr.add_suppression(".ERROR.  The error means mysqld does not have the access");
--enable_query_log

# The test for Bug 20770 is disabled on Windows due to BUG#19107; it
# should be moved into partition.test once the bug has been resolved.

#
# Bug 20770 Partitions: DATA DIRECTORY clause change in reorganize
#                       does not remove old directory

let $MYSQLD_DATADIR= `select @@datadir`;

--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
eval create table t1 (a int)
partition by range (a)
subpartition by hash (a)
(partition p0 VALUES LESS THAN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR'
 (SUBPARTITION subpart00, SUBPARTITION subpart01));

--echo # Checking if file exists before alter
--file_exists $MYSQL_TMP_DIR/test/t1#p#p0#sp#subpart00.ibd
--file_exists $MYSQL_TMP_DIR/test/t1#p#p0#sp#subpart01.ibd

--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
eval ALTER TABLE t1 REORGANIZE PARTITION p0 INTO
(partition p1 VALUES LESS THAN (1) DATA DIRECTORY = '$MYSQL_TMP_DIR'
 (SUBPARTITION subpart10, SUBPARTITION subpart11),
 partition p2 VALUES LESS THAN (2) DATA DIRECTORY = '$MYSQL_TMP_DIR'
 (SUBPARTITION subpart20, SUBPARTITION subpart21));

--echo # Checking if file exists after alter
--file_exists $MYSQL_TMP_DIR/test/t1#p#p1#sp#subpart10.ibd
--file_exists $MYSQL_TMP_DIR/test/t1#p#p1#sp#subpart11.ibd
--file_exists $MYSQL_TMP_DIR/test/t1#p#p2#sp#subpart20.ibd
--file_exists $MYSQL_TMP_DIR/test/t1#p#p2#sp#subpart21.ibd

drop table t1;

#
# Bug #24633 SQL MODE "NO_DIR_IN_CREATE" does not work with partitioned tables
#
set innodb_strict_mode=off;
disable_query_log;
eval create table t2 (i int )
partition by range (i)
(
 partition p01 values less than (1000)
 data directory='$MYSQL_TMP_DIR'
 index directory='$MYSQL_TMP_DIR'
);
enable_query_log;

set @org_mode=@@sql_mode;
set @@sql_mode='NO_DIR_IN_CREATE';
select @@sql_mode;
create table t1 (i int )
partition by range (i)
(
  partition p01 values less than (1000)
  data directory='/not/existing'
  index directory='/not/existing'
);
show create table t2;
DROP TABLE t1, t2;
set @@sql_mode=@org_mode;

#
# Bug#32167: another privilege bypass with DATA/INDEX DIRECTORY
#

let $MYSQLD_DATADIR= `select @@datadir`;

--replace_result $MYSQLD_DATADIR MYSQLD_DATADIR
--replace_regex /(Incorrect path value: ).*/\1'MYSQLD_DATADIR\/test'/
--error ER_WRONG_VALUE
eval CREATE TABLE t1(a INT)
PARTITION BY KEY (a)
(PARTITION p0 DATA DIRECTORY '$MYSQLD_DATADIR/test');

--replace_result $MYSQLD_DATADIR MYSQLD_DATADIR
--replace_regex /(Incorrect path value: ).*/\1'MYSQLD_DATADIR\/test'/
--error ER_WRONG_VALUE
eval CREATE TABLE t1(a INT)
PARTITION BY KEY (a)
(PARTITION p0 INDEX DIRECTORY '$MYSQLD_DATADIR/test');

--replace_result $MYSQLD_DATADIR MYSQLD_DATADIR
--replace_regex  /(Incorrect path value: ).*/\1'MYSQLD_DATADIR\/test'/
--error ER_WRONG_VALUE
eval CREATE TABLE ts (id INT, purchased DATE)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased)) (
PARTITION p0 VALUES LESS THAN (1990) (
SUBPARTITION s0a
  DATA DIRECTORY = '$MYSQLD_DATADIR/test',
SUBPARTITION s0b
  DATA DIRECTORY = '$MYSQLD_DATADIR/test'
));

--replace_result $MYSQLD_DATADIR MYSQLD_DATADIR
--replace_regex  /(Incorrect path value: ).*/\1'MYSQLD_DATADIR\/test'/
--error ER_WRONG_VALUE
eval CREATE TABLE ts (id INT, purchased DATE)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased)) (
PARTITION p0 VALUES LESS THAN (1990) (
SUBPARTITION s0a
  INDEX DIRECTORY = '$MYSQLD_DATADIR/test',
SUBPARTITION s0b
  INDEX DIRECTORY = '$MYSQLD_DATADIR/test'
));

# End Windows specific test failures.

# These tests contain non-Windows specific directory/file format.

#
# Bug 25141: Crash Server on Partitioning command
#

--disable_warnings
DROP TABLE IF EXISTS `example`;
--enable_warnings

--mkdir $MYSQL_TMP_DIR/p0Data
--mkdir $MYSQL_TMP_DIR/p1Data
--mkdir $MYSQL_TMP_DIR/p2Data
--mkdir $MYSQL_TMP_DIR/p3Data
--replace_result $MYSQL_TMP_DIR MYSQL_TMP_DIR
eval CREATE TABLE `example` (
  `ID_EXAMPLE` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `DESCRIPTION` varchar(30) NOT NULL,
  `LEVEL` smallint(5) unsigned DEFAULT NULL,
  PRIMARY KEY (`ID_EXAMPLE`)
)
PARTITION BY HASH(ID_EXAMPLE)(
PARTITION p0 DATA DIRECTORY = '$MYSQL_TMP_DIR/p0Data',
PARTITION p1 DATA DIRECTORY = '$MYSQL_TMP_DIR/p1Data',
PARTITION p2 DATA DIRECTORY = '$MYSQL_TMP_DIR/p2Data',
PARTITION p3 DATA DIRECTORY = '$MYSQL_TMP_DIR/p3Data'
);

let $MYSQLD_DATADIR= `select @@datadir`;

--echo # Checking that InnoDB data files are in test db and data dir
--file_exists $MYSQL_TMP_DIR/p0Data/test/example#p#p0.ibd
--file_exists $MYSQL_TMP_DIR/p1Data/test/example#p#p1.ibd
--file_exists $MYSQL_TMP_DIR/p2Data/test/example#p#p2.ibd
--file_exists $MYSQL_TMP_DIR/p3Data/test/example#p#p3.ibd
DROP TABLE example;
--rmdir $MYSQL_TMP_DIR/p0Data/test
--rmdir $MYSQL_TMP_DIR/p0Data
--rmdir $MYSQL_TMP_DIR/p1Data/test
--rmdir $MYSQL_TMP_DIR/p1Data
--rmdir $MYSQL_TMP_DIR/p2Data/test
--rmdir $MYSQL_TMP_DIR/p2Data
--rmdir $MYSQL_TMP_DIR/p3Data/test
--rmdir $MYSQL_TMP_DIR/p3Data


--echo #
--echo # Bug#18513130 STRANGE INTERACTION OF SQL_MODE=ANSI AND PARTITION
--echo #

SET @@SQL_MODE= 'ANSI_QUOTES';

CREATE TABLE t1(col1 INT, col2 DATE)
ENGINE=INNODB
PARTITION BY RANGE(YEAR("col2"))
SUBPARTITION BY HASH(TO_DAYS("col2"))(
      PARTITION p0 VALUES LESS THAN (1990)(
          SUBPARTITION s0,
          SUBPARTITION s1 tablespace=`innodb_file_per_table`
      ),
      PARTITION p1 VALUES LESS THAN MAXVALUE(
            SUBPARTITION s2,
            SUBPARTITION s3 tablespace="innodb_file_per_table"
        )
    );

SHOW CREATE TABLE t1;
SELECT partition_expression FROM information_schema.partitions
WHERE table_schema = 'test' AND table_name = 't1';

SET @@SQL_MODE= DEFAULT;
FLUSH TABLES;

SHOW CREATE TABLE t1;
SELECT partition_expression FROM information_schema.partitions
WHERE table_schema = 'test' AND table_name = 't1';

SET @@SQL_QUOTE_SHOW_CREATE= 0;
SHOW CREATE TABLE t1;
SELECT partition_expression FROM information_schema.partitions
WHERE table_schema = 'test' AND table_name = 't1';

SET @@SQL_QUOTE_SHOW_CREATE= 1;
DROP TABLE t1;


--echo #
--echo # Test max partitioning and subpartition expression length
--echo #

--let $ALMOST_TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("a+", 255),"a")`
--replace_result $ALMOST_TOO_LONG_EXPR ALMOST_TOO_LONG_EXPR
--eval CREATE TABLE t1 (a INT) PARTITION BY HASH($ALMOST_TOO_LONG_EXPR)
DROP TABLE t1;
--let $TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("a+", 256),"a")`
--replace_result $TOO_LONG_EXPR TOO_LONG_EXPR
--error ER_PART_EXPR_TOO_LONG
--eval CREATE TABLE t1 (a INT) PARTITION BY HASH($TOO_LONG_EXPR)

--echo # Check that the limit is on number of characters and not on bytes
--let $ALMOST_TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("\`\`+", 255),"\`\`")`
--replace_result $ALMOST_TOO_LONG_EXPR ALMOST_TOO_LONG_EXPR
--eval CREATE TABLE t1 (`` INT) PARTITION BY HASH($ALMOST_TOO_LONG_EXPR)
DROP TABLE t1;
--let $TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("\`\`+", 256),"\`\`")`
--replace_result $TOO_LONG_EXPR TOO_LONG_EXPR
--error ER_PART_EXPR_TOO_LONG
--eval CREATE TABLE t1 (`` INT) PARTITION BY HASH($TOO_LONG_EXPR)

--echo # Repeat the same tests for subpartitioning expressions.
--let $ALMOST_TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("a+", 255),"a")`
--replace_result $ALMOST_TOO_LONG_EXPR ALMOST_TOO_LONG_EXPR
--eval CREATE TABLE t1 (b INT, a INT) PARTITION BY LIST (b) SUBPARTITION BY HASH($ALMOST_TOO_LONG_EXPR) (PARTITION p1 VALUES IN (1))
DROP TABLE t1;
--let $TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("a+", 256),"a")`
--replace_result $TOO_LONG_EXPR TOO_LONG_EXPR
--error ER_PART_EXPR_TOO_LONG
--eval CREATE TABLE t1 (b INT, a INT) PARTITION BY LIST (b) SUBPARTITION BY HASH($TOO_LONG_EXPR) (PARTITION p1 VALUES IN (1))

--echo # Again the limit is on number of characters and not on bytes
--let $ALMOST_TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("\`\`+", 255),"\`\`")`
--replace_result $ALMOST_TOO_LONG_EXPR ALMOST_TOO_LONG_EXPR
--eval CREATE TABLE t1 (b INT, `` INT) PARTITION BY LIST (b) SUBPARTITION BY HASH($ALMOST_TOO_LONG_EXPR) (PARTITION p1 VALUES IN (1))
DROP TABLE t1;
--let $TOO_LONG_EXPR= `SELECT CONCAT(REPEAT("\`\`+", 256),"\`\`")`
--replace_result $TOO_LONG_EXPR TOO_LONG_EXPR
--error ER_PART_EXPR_TOO_LONG
--eval CREATE TABLE t1 (b INT, `` INT) PARTITION BY LIST (b) SUBPARTITION BY HASH($TOO_LONG_EXPR) (PARTITION p1 VALUES IN (1))

--echo #
--echo # Bug #27005020: UBSAN: GET_PART_ITER_FOR_INTERVAL_VIA_WALKING - SIGNED INTEGER OVERFLOW
--echo #
CREATE TABLE t (a BIGINT NOT NULL)
  PARTITION BY KEY(a) PARTITIONS 2;
INSERT INTO t VALUES(0);
SELECT 1 FROM t WHERE a = 0x8000000000000000;
DROP TABLE t;

--echo #
--echo # Bug#28573894 ALTER PARTITIONED TABLE ADD AUTO_INCREMENT DIFF RESULT
--echo #
CREATE TABLE t (a VARCHAR(10) NOT NULL,b INT,PRIMARY KEY (b)) ENGINE=INNODB
PARTITION BY RANGE (b)
(PARTITION pa VALUES LESS THAN (2),
 PARTITION pb VALUES LESS THAN (20),
 PARTITION pc VALUES LESS THAN (30),
 PARTITION pd VALUES LESS THAN (40));

INSERT INTO t
VALUES('A',0),('B',1),('C',2),('D',3),('E',4),('F',5),('G',25),('H',35);

ALTER TABLE t ADD COLUMN r INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD UNIQUE
KEY (r,b), ALGORITHM=INPLACE, LOCK=SHARED;
SELECT * FROM t;
DROP TABLE t;
# Cleanup
--force-rmdir $MYSQL_TMP_DIR/test/

--echo #
--echo # Bug#29317007: INIT_LEX_WITH_SINGLE_TABLE() CONFUSES TABLE
--echo #               AND SCHEMA NAME
--echo #

CREATE SCHEMA tables;
CREATE TABLE tables.mysql(a INT);
ALTER TABLE tables.mysql PARTITION BY HASH (a);
DROP SCHEMA tables;


--echo #
--echo # Bug#29058369: MEMORY ACCESS ERROR WITH ALTER TABLE CHARACTER CHANGE.
--echo #

--echo # Test case 1
CREATE TABLE t1(c1 INT, c2 CHAR) PARTITION BY HASH(c1) PARTITIONS 50;
SELECT MBRTOUCHES(a.c2, b.c2) FROM t1 AS a JOIN t1 AS b;
ALTER TABLE t1 CONVERT TO CHARACTER SET latin1;
DROP TABLE t1;

--echo # Test case 2
CREATE TABLE t1 (s1 INT PRIMARY KEY) PARTITION BY HASH(s1);
LOCK TABLES t1 WRITE, t1 b READ;
UNLOCK TABLES;

--error ER_ONLY_ON_RANGE_LIST_PARTITION
ALTER TABLE t1 DROP PARTITION p1;

ALTER TABLE t1 CONVERT TO CHARACTER SET latin1;
DROP TABLE t1;

--echo # Test case with subpartitions
CREATE TABLE t1 (c1 INT NOT NULL, c2 INT)
    PARTITION BY RANGE (c1) PARTITIONS 3 SUBPARTITION BY KEY (c2) (
        PARTITION p1 VALUES LESS THAN (200) (
            SUBPARTITION p11,
            SUBPARTITION p12,
            SUBPARTITION p13),
        PARTITION p2 VALUES LESS THAN (600) (
            SUBPARTITION p21,
            SUBPARTITION p22,
            SUBPARTITION p23),
        PARTITION p3 VALUES LESS THAN (1800) (
            SUBPARTITION p31,
            SUBPARTITION p32,
            SUBPARTITION p33));

SELECT MBRTOUCHES(a.c1, b.c2) FROM t1 AS a JOIN t1 AS b;
ALTER TABLE t1 CONVERT TO CHARACTER SET latin1;
DROP TABLE t1;


--echo #
--echo # Bug#29541665 "SWAPPING COLUMNS USED IN PARTITIONED EXPRESSION BY RENAMING BREAKS PARTITIONING".
--echo #

# Disabled execution under --ps-protocol until bug #13569548 "DBUG_ASSERT HIT
# IN COLUMNS PART EXPR IN THE VALUE LIST UNDER --PS-PROTOCOL" is fixed.
--disable_ps_protocol
--echo #
--echo # Test case mimicking the original one.
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
INSERT INTO t1 (i, j) VALUES (-1, 1);
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 CHANGE COLUMN i j INT, CHANGE COLUMN j i INT;
--echo # If the above ALTER succeeds the partitioning expression should
--echo # stay unchanged. Failed ALTER should not change it either.
SHOW CREATE TABLE t1;
--echo # There should be only single row belonging either
--echo # to p0 (iff i=-1) or p1 (iff i=1).
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
DROP TABLE t1;
--echo # Similar test case involving column replacement.
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
INSERT INTO t1 (i, j) VALUES (-1, 1);
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT DEFAULT 1;
--echo # If the above ALTER succeeds the partitioning expression should
--echo # stay unchanged. Failed ALTER should not change it either.
SHOW CREATE TABLE t1;
--echo # There should be only single row belonging either
--echo # to p0 (iff i=-1) or p1 (iff i=1).
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
DROP TABLE t1;

--echo #
--echo # More systematic test coverage.
--echo #

--echo #
--echo # 1) Renaming column on which partitioning expression depends.
--echo #
--echo # 1.1) Renaming column on which partitioning expression depends
--echo #      is prohibited (for both RENAME COLUMN and CHANGE syntaxes).
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i+1) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 RENAME COLUMN i TO k;
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 CHANGE COLUMN i k INT;
--echo # Even if substitute for renamed column is provided.
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 RENAME COLUMN i TO j, RENAME COLUMN j TO i;
--echo # Also works for case of degenerate expression like COLUMN partitioning.
DROP TABLE t1;
CREATE TABLE t1 (i INT) PARTITION BY LIST COLUMNS (i) (PARTITION p0 VALUES IN (-2,-1), PARTITION p1 VALUES IN (0, 1, 2));
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 RENAME COLUMN i TO k;
--echo #
--echo # 1.2) It is OK to rename such columns if partitioning is removed by
--echo #      the same ALTER TABLE.
ALTER TABLE t1 RENAME COLUMN i TO k REMOVE PARTITIONING;
DROP TABLE t1;
--echo #
--echo # 1.3) Renaming such columns is also OK if partitioned expression
--echo #      is updated by the same ALTER TABLE.
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
INSERT INTO t1 (i, j) VALUES (-1, 1);
ALTER TABLE t1 RENAME COLUMN i TO k PARTITION BY RANGE(k) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--echo # If new expression uses wrong column name an appropriate error
--echo # is reported.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 RENAME COLUMN k TO l PARTITION BY RANGE(m) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--echo #
--echo # 1.4) Such renames combined with partitioning function update should
--echo #      move rows between partitions as appropriate.
SHOW CREATE TABLE t1;
SELECT k, j FROM t1 PARTITION (p0);
SELECT k, j FROM t1 PARTITION (p1);
--echo # Partitioning expression is kept the same, but value in its column is changed by rename.
ALTER TABLE t1 RENAME COLUMN k TO j, RENAME COLUMN j TO k PARTITION BY RANGE(k) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
SHOW CREATE TABLE t1;
SELECT k, j FROM t1 PARTITION (p0);
SELECT k, j FROM t1 PARTITION (p1);
--echo # Because of this such renames can't be done in-place.
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 RENAME COLUMN k TO j, RENAME COLUMN j TO k, ALGORITHM=INPLACE PARTITION BY RANGE(k) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
DROP TABLE t1;
--echo #
--echo # 1.5) We also allow renaming columns which are used by partitioning function
--echo #      implicitly, because it is specified by "PARTITION BY KEY ()" (note empty
--echo #      column list) clause. In this case partitioning function is defined by
--echo #      the primary key, and the latter is automagically updated when column
--echo #      is renamed.
--echo #
--echo #      We test scenario similar to one from the bug report.
CREATE TABLE t1 (i INT, j INT, PRIMARY KEY (i)) PARTITION BY KEY () PARTITIONS 2 (PARTITION p0, PARTITION p1);
INSERT INTO t1 (i, j) VALUES (-1, 1);
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
ALTER TABLE t1 RENAME COLUMN i TO j, RENAME COLUMN j TO i;
--echo # PRIMARY KEY should contain use new column name.
SHOW CREATE TABLE t1;
--echo # Hence the row should not be moved between partitions.
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
DROP TABLE t1;
--echo #
--echo # However, renaming of columns is not allowed if their are mentioned
--echo # explicitly in the KEY list, as partitioning function is not updated
--echo # automagically in this case.
CREATE TABLE t1 (i INT, j INT, PRIMARY KEY (i, j)) PARTITION BY KEY (i) PARTITIONS 2 (PARTITION p0, PARTITION p1);
INSERT INTO t1 (i, j) VALUES (-1, 1);
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 RENAME COLUMN i TO j, RENAME COLUMN j TO i;
--echo # It is still possible to rename columns if partitioning is updated.
ALTER TABLE t1 RENAME COLUMN i TO j, RENAME COLUMN j TO i PARTITION BY KEY (i) PARTITIONS 2 (PARTITION p0, PARTITION p1);
--echo # Notice that we now use second column from PK for partitioning.
SHOW CREATE TABLE t1;
--echo # Hence the row should have been moved between partitions.
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
DROP TABLE t1;

--echo #
--echo # 2) Replacing (deleting and then adding) column on which partitioning
--echo #    expression depends.
--echo #
--echo # 2.1) Replacing column on which partitioning expression depends
--echo #      is prohibited.
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i+1) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT;
--echo # Also works for case of degenerate expression like COLUMN partitioning.
DROP TABLE t1;
CREATE TABLE t1 (i INT) PARTITION BY LIST COLUMNS (i) (PARTITION p0 VALUES IN (-2,-1), PARTITION p1 VALUES IN (0, 1, 2));
--error ER_DEPENDENT_BY_PARTITION_FUNC
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT;
--echo #
--echo # 2.2) It is OK to replace such columns if partitioning is removed by
--echo #      the same ALTER TABLE.
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT REMOVE PARTITIONING;
DROP TABLE t1;
--echo #
--echo # 2.3) Replacing such columns is also OK if partitioned expression
--echo #      is updated by the same ALTER TABLE.
CREATE TABLE t1 (i INT, j INT) PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--echo # If new expression uses wrong column name an appropriate error
--echo # is reported.
--error ER_BAD_FIELD_ERROR
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT PARTITION BY RANGE(k) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
--echo #
--echo # 2.4) Such replacements combined with partitioning function update should
--echo #      move rows between partitions as appropriate.
INSERT INTO t1 (i, j) VALUES (-1, 1);
SHOW CREATE TABLE t1;
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
--echo # Partitioning expression is kept the same, but value in its column is changed by replacement.
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT DEFAULT 1 PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
SHOW CREATE TABLE t1;
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
--echo # Because of this such replacements can't be done in-place.
--error ER_ALTER_OPERATION_NOT_SUPPORTED
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT DEFAULT 2, ALGORITHM=INPLACE PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN (0), PARTITION p1 VALUES LESS THAN MAXVALUE);
DROP TABLE t1;
--echo #
--echo # 2.5) We also allow removal of columns which are used by partitioning function
--echo #      implicitly, because it is specified by "PARTITION BY KEY ()" (note empty
--echo #      column list) clause. In this case partitioning function is defined by
--echo #      the primary key, and the latter is adjusted when one of its columns is
--echo #      dropped. Such adjustment is considered as change of primary key (and thus
--echo #      partitioning function) which is supposed to be correctly handled by SE by
--echo #      moving rows between partitions.
CREATE TABLE t1 (i INT, j INT, PRIMARY KEY (i, j)) PARTITION BY KEY () PARTITIONS 2 (PARTITION p0, PARTITION p1);
INSERT INTO t1 (i, j) VALUES (1, 2);
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
ALTER TABLE t1 DROP COLUMN i;
--echo # PRIMARY KEY is adjusted.
SHOW CREATE TABLE t1;
--echo # The row should be moved between partitions as appropriate.
SELECT j FROM t1 PARTITION (p0);
SELECT j FROM t1 PARTITION (p1);
--echo # Dropping all/last column in PRIMARY KEY is prohibited.
--error ER_FIELD_NOT_FOUND_PART_ERROR
ALTER TABLE t1 ADD COLUMN k INT, DROP COLUMN j;
DROP TABLE t1;
--echo # Let us also check how replacement of column in PRIMARY KEY works.
CREATE TABLE t1 (i INT, j INT, PRIMARY KEY (i, j)) PARTITION BY KEY () PARTITIONS 2 (PARTITION p0, PARTITION p1);
INSERT INTO t1 (i, j) VALUES (1, 2);
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
ALTER TABLE t1 DROP COLUMN i, ADD COLUMN i INT DEFAULT 0;
--echo # New column becomes part of PRIMARY KEY [sic!].
SHOW CREATE TABLE t1;
--echo # Again the row should be moved between partitions as appropriate.
SELECT i, j FROM t1 PARTITION (p0);
SELECT i, j FROM t1 PARTITION (p1);
DROP TABLE t1;
--enable_ps_protocol

--echo #
--echo # Bug #25207522: INCORRECT ORDER-BY BEHAVIOR ON A PARTITIONED TABLE
--echo # WITH A COMPOSITE PREFIX INDEX
--echo #
CREATE TABLE t(  id int unsigned NOT NULL,
        data varchar(2) DEFAULT NULL,
        KEY data_idx (data(1),id)
        ) DEFAULT CHARSET=utf8
        /*!50100 PARTITION BY RANGE (id)
        (PARTITION p10 VALUES LESS THAN (10) ,
         PARTITION p20 VALUES LESS THAN (20) ) */;

INSERT INTO t VALUES (6, 'ab'), (4, 'ab'), (5, 'ab'), (16, 'ab'), (14, 'ab'), (15, 'ab'), (5, 'ac'), (15, 'aa') ;
SELECT id FROM t WHERE data = 'ab' ORDER BY id ASC;
DROP TABLE t;

--echo #
--echo # Bug#29268656: BOGUS CONSTANT, RANDOM OR TIMEZONE-DEPENDENT
--echo #               EXPRESSIONS IN (SUB)PARTITIONING FU
--echo #

# Create table with default non-deterministic expression
CREATE TABLE t1 (c1 INT, c2 CHAR(32) DEFAULT (RANDOM_BYTES(32))) PARTITION BY HASH(c1);
CREATE TABLE t2 (c1 INT, c2 CHAR(32) DEFAULT (RANDOM_BYTES(32))) PARTITION BY RANGE(c1) (PARTITION p1 VALUES LESS THAN(100));

# ALter table with default non-deterministic expression
CREATE TABLE t (c1 INT, c2 INT) PARTITION BY RANGE(c1) (PARTITION p1 VALUES LESS THAN(100));
ALTER TABLE t MODIFY COLUMN c2 CHAR(32) DEFAULT (RANDOM_BYTES(32));
DROP TABLE t, t1, t2;

# Create table with generated column containing non-deterministic expression
--error ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED
CREATE TABLE t1 (c1 INT, c2 CHAR(32) GENERATED ALWAYS AS (RANDOM_BYTES(32))) PARTITION BY HASH(c1);
--error ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED
CREATE TABLE t2 (c1 INT, c2 CHAR(32) GENERATED ALWAYS AS (RANDOM_BYTES(32))) PARTITION BY RANGE(c1) (PARTITION p1 VALUES LESS THAN(100));

# Alter table with generated column containing non-deterministic expression
CREATE TABLE t (c1 INT, c2 INT) PARTITION BY RANGE(c1) (PARTITION p1 VALUES LESS THAN(100));
--error ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED
ALTER TABLE t MODIFY COLUMN c2 CHAR(32) GENERATED ALWAYS AS (RANDOM_BYTES(32)) STORED;
--error ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED
ALTER TABLE t ADD COLUMN c3 CHAR(32) GENERATED ALWAYS AS (RANDOM_BYTES(32));
DROP TABLE t;
