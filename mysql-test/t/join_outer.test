# The include statement below is a temp one for tests that are yet to
#be ported to run with InnoDB,
#but needs to be kept for tests that would need MyISAM in future.
--source include/force_myisam_default.inc
--source include/have_myisam.inc

#
# test of left outer join
#

--disable_warnings
drop table if exists t0,t1,t2,t3,t4,t5;
--enable_warnings

CREATE TABLE t1 (
  grp int(11) default NULL,
  a bigint(20) unsigned default NULL,
  c char(10) NOT NULL default ''
) ENGINE=MyISAM;
INSERT INTO t1 VALUES (1,1,'a'),(2,2,'b'),(2,3,'c'),(3,4,'E'),(3,5,'C'),(3,6,'D'),(NULL,NULL,'');
create table t2 (id int, a bigint unsigned not null, c char(10), d int, primary key (a));
insert into t2 values (1,1,"a",1),(3,4,"A",4),(3,5,"B",5),(3,6,"C",6),(4,7,"D",7);

select t1.*,t2.* from t1 JOIN t2 where t1.a=t2.a;
select t1.*,t2.* from t1 left join t2 on (t1.a=t2.a) order by t1.grp,t1.a,t2.c;
select t1.*,t2.* from { oj t2 left outer join t1 on (t1.a=t2.a) };
select t1.*,t2.* from t1 as t0,{ oj t2 left outer join t1 on (t1.a=t2.a) } WHERE t0.a=2;
select t1.*,t2.* from t1 left join t2 using (a);
select t1.*,t2.* from t1 left join t2 using (a) where t1.a=t2.a;
select t1.*,t2.* from t1 left join t2 using (a,c);
--sorted_result
select t1.*,t2.* from t1 left join t2 using (c);
select t1.*,t2.* from t1 natural left outer join t2;

select t1.*,t2.* from t1 left join t2 on (t1.a=t2.a) where t2.id=3;
select t1.*,t2.* from t1 left join t2 on (t1.a=t2.a) where t2.id is null;

explain select t1.*,t2.* from t1,t2 where t1.a=t2.a and isnull(t2.a)=1;
explain select t1.*,t2.* from t1 left join t2 on t1.a=t2.a where isnull(t2.a)=1;

--sorted_result
select t1.*,t2.*,t3.a from t1 left join t2 on (t1.a=t2.a) left join t1 as t3 on (t2.a=t3.a);

# The next query should rearange the left joins to get this to work
--error 1054
explain select t1.*,t2.*,t3.a from t1 left join t2 on (t3.a=t2.a) left join t1 as t3 on (t1.a=t3.a);
--error 1054
select t1.*,t2.*,t3.a from t1 left join t2 on (t3.a=t2.a) left join t1 as t3 on (t1.a=t3.a);

# The next query should give an error in MySQL
--error 1054
select t1.*,t2.*,t3.a from t1 left join t2 on (t3.a=t2.a) left join t1 as t3 on (t2.a=t3.a);

# Test of inner join
select t1.*,t2.* from t1 inner join t2 using (a);
select t1.*,t2.* from t1 inner join t2 on (t1.a=t2.a);
select t1.*,t2.* from t1 natural join t2;

drop table t1,t2;

#
# Test of left join bug
#

CREATE TABLE t1 (
 usr_id INT unsigned NOT NULL,
 uniq_id INT unsigned NOT NULL AUTO_INCREMENT,
        start_num INT unsigned NOT NULL DEFAULT 1,
        increment INT unsigned NOT NULL DEFAULT 1,
 PRIMARY KEY (uniq_id),
 INDEX usr_uniq_idx (usr_id, uniq_id),
 INDEX uniq_usr_idx (uniq_id, usr_id)
);
CREATE TABLE t2 (
 id INT unsigned NOT NULL DEFAULT 0,
 usr2_id INT unsigned NOT NULL DEFAULT 0,
 max INT unsigned NOT NULL DEFAULT 0,
 c_amount INT unsigned NOT NULL DEFAULT 0,
 d_max INT unsigned NOT NULL DEFAULT 0,
 d_num INT unsigned NOT NULL DEFAULT 0,
 orig_time INT unsigned NOT NULL DEFAULT 0,
 c_time INT unsigned NOT NULL DEFAULT 0,
 active ENUM ("no","yes") NOT NULL,
 PRIMARY KEY (id,usr2_id),
 INDEX id_idx (id),
 INDEX usr2_idx (usr2_id)
);
INSERT INTO t1 VALUES (3,NULL,0,50),(3,NULL,0,200),(3,NULL,0,25),(3,NULL,0,84676),(3,NULL,0,235),(3,NULL,0,10),(3,NULL,0,3098),(3,NULL,0,2947),(3,NULL,0,8987),(3,NULL,0,8347654),(3,NULL,0,20398),(3,NULL,0,8976),(3,NULL,0,500),(3,NULL,0,198);

#1st select shows that one record is returned with null entries for the right
#table, when selecting on an id that does not exist in the right table t2
SELECT t1.usr_id,t1.uniq_id,t1.increment,
t2.usr2_id,t2.c_amount,t2.max
FROM t1
LEFT JOIN t2 ON t2.id = t1.uniq_id
WHERE t1.uniq_id = 4
ORDER BY t2.c_amount;

# The same with RIGHT JOIN
SELECT t1.usr_id,t1.uniq_id,t1.increment,
t2.usr2_id,t2.c_amount,t2.max
FROM t2
RIGHT JOIN t1 ON t2.id = t1.uniq_id
WHERE t1.uniq_id = 4
ORDER BY t2.c_amount;

INSERT INTO t2 VALUES (2,3,3000,6000,0,0,746584,837484,'yes');
--error ER_DUP_ENTRY
INSERT INTO t2 VALUES (2,3,3000,6000,0,0,746584,837484,'yes');
INSERT INTO t2 VALUES (7,3,1000,2000,0,0,746294,937484,'yes');

#3rd select should show that one record is returned with null entries for the
# right table, when selecting on an id that does not exist in the right table
# t2 but this select returns an empty set!!!!
SELECT t1.usr_id,t1.uniq_id,t1.increment,t2.usr2_id,t2.c_amount,t2.max FROM t1 LEFT JOIN t2 ON t2.id = t1.uniq_id WHERE t1.uniq_id = 4 ORDER BY t2.c_amount;
--source include/turn_off_only_full_group_by.inc
SELECT t1.usr_id,t1.uniq_id,t1.increment,t2.usr2_id,t2.c_amount,t2.max FROM t1 LEFT JOIN t2 ON t2.id = t1.uniq_id WHERE t1.uniq_id = 4 GROUP BY t2.c_amount;
--source include/restore_sql_mode_after_turn_off_only_full_group_by.inc
# Removing the ORDER BY works:
SELECT t1.usr_id,t1.uniq_id,t1.increment,t2.usr2_id,t2.c_amount,t2.max FROM t1 LEFT JOIN t2 ON t2.id = t1.uniq_id WHERE t1.uniq_id = 4;

drop table t1,t2;

#
# Test of LEFT JOIN with const tables (failed for frankie@etsetb.upc.es)
#

CREATE TABLE t1 (
  cod_asig int(11) DEFAULT '0' NOT NULL,
  desc_larga_cat varchar(80) DEFAULT '' NOT NULL,
  desc_larga_cas varchar(80) DEFAULT '' NOT NULL,
  desc_corta_cat varchar(40) DEFAULT '' NOT NULL,
  desc_corta_cas varchar(40) DEFAULT '' NOT NULL,
  cred_total double(3,1) DEFAULT '0.0' NOT NULL,
  pre_requisit int(11),
  co_requisit int(11),
  preco_requisit int(11),
  PRIMARY KEY (cod_asig)
);

INSERT INTO t1 VALUES (10360,'asdfggfg','Introduccion a los  Ordenadores I','asdfggfg','Introduccio Ordinadors I',6.0,NULL,NULL,NULL);
INSERT INTO t1 VALUES (10361,'Components i Circuits Electronics I','Componentes y Circuitos Electronicos I','Components i Circuits Electronics I','Comp. i Circ. Electr. I',6.0,NULL,NULL,NULL);
INSERT INTO t1 VALUES (10362,'Laboratori d`Ordinadors','Laboratorio de Ordenadores','Laboratori d`Ordinadors','Laboratori Ordinadors',4.5,NULL,NULL,NULL);
INSERT INTO t1 VALUES (10363,'Tecniques de Comunicacio Oral i Escrita','Tecnicas de Comunicacion Oral y Escrita','Tecniques de Comunicacio Oral i Escrita','Tec. Com. Oral i Escrita',4.5,NULL,NULL,NULL);
INSERT INTO t1 VALUES (11403,'Projecte Fi de Carrera','Proyecto Fin de Carrera','Projecte Fi de Carrera','PFC',9.0,NULL,NULL,NULL);
INSERT INTO t1 VALUES (11404,'+lgebra lineal','Algebra lineal','+lgebra lineal','+lgebra lineal',15.0,NULL,NULL,NULL);
INSERT INTO t1 VALUES (11405,'+lgebra lineal','Algebra lineal','+lgebra lineal','+lgebra lineal',18.0,NULL,NULL,NULL);
INSERT INTO t1 VALUES (11406,'Calcul Infinitesimal','CÃŸlculo Infinitesimal','Calcul Infinitesimal','Calcul Infinitesimal',15.0,NULL,NULL,NULL);

CREATE TABLE t2 (
  idAssignatura int(11) DEFAULT '0' NOT NULL,
  Grup int(11) DEFAULT '0' NOT NULL,
  Places smallint(6) DEFAULT '0' NOT NULL,
  PlacesOcupades int(11) DEFAULT '0',
  PRIMARY KEY (idAssignatura,Grup)
);


INSERT INTO t2 VALUES (10360,12,333,0);
INSERT INTO t2 VALUES (10361,30,2,0);
INSERT INTO t2 VALUES (10361,40,3,0);
INSERT INTO t2 VALUES (10360,45,10,0);
INSERT INTO t2 VALUES (10362,10,12,0);
INSERT INTO t2 VALUES (10360,55,2,0);
INSERT INTO t2 VALUES (10360,70,0,0);
INSERT INTO t2 VALUES (10360,565656,0,0);
INSERT INTO t2 VALUES (10360,32767,7,0);
INSERT INTO t2 VALUES (10360,33,8,0);
INSERT INTO t2 VALUES (10360,7887,85,0);
INSERT INTO t2 VALUES (11405,88,8,0);
INSERT INTO t2 VALUES (10360,0,55,0);
INSERT INTO t2 VALUES (10360,99,0,0);
INSERT INTO t2 VALUES (11411,30,10,0);
INSERT INTO t2 VALUES (11404,0,0,0);
INSERT INTO t2 VALUES (10362,11,111,0);
INSERT INTO t2 VALUES (10363,33,333,0);
INSERT INTO t2 VALUES (11412,55,0,0);
INSERT INTO t2 VALUES (50003,66,6,0);
INSERT INTO t2 VALUES (11403,5,0,0);
INSERT INTO t2 VALUES (11406,11,11,0);
INSERT INTO t2 VALUES (11410,11410,131,0);
INSERT INTO t2 VALUES (11416,11416,32767,0);
INSERT INTO t2 VALUES (11409,0,0,0);

CREATE TABLE t3 (
  id int(11) NOT NULL auto_increment,
  dni_pasaporte char(16) DEFAULT '' NOT NULL,
  idPla int(11) DEFAULT '0' NOT NULL,
  cod_asig int(11) DEFAULT '0' NOT NULL,
  any smallint(6) DEFAULT '0' NOT NULL,
  quatrimestre smallint(6) DEFAULT '0' NOT NULL,
  estat char(1) DEFAULT 'M' NOT NULL,
  PRIMARY KEY (id),
  UNIQUE dni_pasaporte (dni_pasaporte,idPla),
  UNIQUE dni_pasaporte_2 (dni_pasaporte,idPla,cod_asig,any,quatrimestre)
);

INSERT INTO t3 VALUES (1,'11111111',1,10362,98,1,'M');

CREATE TABLE t4 (
  id int(11) NOT NULL auto_increment,
  papa int(11) DEFAULT '0' NOT NULL,
  fill int(11) DEFAULT '0' NOT NULL,
  idPla int(11) DEFAULT '0' NOT NULL,
  PRIMARY KEY (id),
  KEY papa (idPla,papa),
  UNIQUE papa_2 (idPla,papa,fill)
);

INSERT INTO t4 VALUES (1,-1,10360,1);
INSERT INTO t4 VALUES (2,-1,10361,1);
INSERT INTO t4 VALUES (3,-1,10362,1);

SELECT DISTINCT fill,desc_larga_cat,cred_total,Grup,Places,PlacesOcupades FROM t4 LEFT JOIN t3 ON t3.cod_asig=fill AND estat='S'   AND dni_pasaporte='11111111'   AND t3.idPla=1 , t2,t1 WHERE fill=t1.cod_asig   AND Places>PlacesOcupades   AND fill=idAssignatura   AND t4.idPla=1   AND papa=-1;

SELECT DISTINCT fill,t3.idPla FROM t4 LEFT JOIN t3 ON t3.cod_asig=t4.fill AND t3.estat='S' AND t3.dni_pasaporte='1234' AND t3.idPla=1 ;

INSERT INTO t3 VALUES (3,'1234',1,10360,98,1,'S');
SELECT DISTINCT fill,t3.idPla FROM t4 LEFT JOIN t3 ON t3.cod_asig=t4.fill AND t3.estat='S' AND t3.dni_pasaporte='1234' AND t3.idPla=1 ;

drop table t1,t2,t3,test.t4;

#
# Test of IS NULL on AUTO_INCREMENT with LEFT JOIN
#

CREATE TABLE t1 (
  id smallint(5) unsigned NOT NULL auto_increment,
  name char(60) DEFAULT '' NOT NULL,
  PRIMARY KEY (id)
);
INSERT INTO t1 VALUES (1,'Antonio Paz');
INSERT INTO t1 VALUES (2,'Lilliana Angelovska');
INSERT INTO t1 VALUES (3,'Thimble Smith');

CREATE TABLE t2 (
  id smallint(5) unsigned NOT NULL auto_increment,
  owner smallint(5) unsigned DEFAULT '0' NOT NULL,
  name char(60),
  PRIMARY KEY (id)
);
INSERT INTO t2 VALUES (1,1,'El Gato');
INSERT INTO t2 VALUES (2,1,'Perrito');
INSERT INTO t2 VALUES (3,3,'Happy');

--sorted_result
select t1.name, t2.name, t2.id from t1 left join t2 on (t1.id = t2.owner);
select t1.name, t2.name, t2.id from t1 left join t2 on (t1.id = t2.owner) where t2.id is null;
explain select t1.name, t2.name, t2.id from t1 left join t2 on (t1.id = t2.owner) where t2.id is null;
explain select t1.name, t2.name, t2.id from t1 left join t2 on (t1.id = t2.owner) where t2.name is null;
select count(*) from t1 left join t2 on (t1.id = t2.owner);

--sorted_result
select t1.name, t2.name, t2.id from t2 right join t1 on (t1.id = t2.owner);
select t1.name, t2.name, t2.id from t2 right join t1 on (t1.id = t2.owner) where t2.id is null;
explain select t1.name, t2.name, t2.id from t2 right join t1 on (t1.id = t2.owner) where t2.id is null;
explain select t1.name, t2.name, t2.id from t2 right join t1 on (t1.id = t2.owner) where t2.name is null;
select count(*) from t2 right join t1 on (t1.id = t2.owner);

--sorted_result
select t1.name, t2.name, t2.id,t3.id from t2 right join t1 on (t1.id = t2.owner) left join t1 as t3 on t3.id=t2.owner;
select t1.name, t2.name, t2.id,t3.id from t1 right join t2 on (t1.id = t2.owner) right join t1 as t3 on t3.id=t2.owner;
select t1.name, t2.name, t2.id, t2.owner, t3.id from t1 left join t2 on (t1.id = t2.owner) right join t1 as t3 on t3.id=t2.owner;

drop table t1,t2;

create table t1 (id int not null, str char(10), index(str));
insert into t1 values (1, null), (2, null), (3, "foo"), (4, "bar");
select * from t1 where str is not null order by id;
select * from t1 where str is null;
explain select * from t1 where str is null;
explain format=tree select * from t1 where str is null;  # Tests printing of index condition pushdown on RefIterator.
drop table t1;

#
# Test wrong LEFT JOIN query
#

CREATE TABLE t1 (
  t1_id bigint(21) NOT NULL auto_increment,
  PRIMARY KEY (t1_id)
);
CREATE TABLE t2 (
  t2_id bigint(21) NOT NULL auto_increment,
  PRIMARY KEY (t2_id)
);
CREATE TABLE t3 (
  t3_id bigint(21) NOT NULL auto_increment,
  PRIMARY KEY (t3_id)
);
CREATE TABLE t4 (
  seq_0_id bigint(21) DEFAULT '0' NOT NULL,
  seq_1_id bigint(21) DEFAULT '0' NOT NULL,
  KEY seq_0_id (seq_0_id),
  KEY seq_1_id (seq_1_id)
);
CREATE TABLE t5 (
  seq_0_id bigint(21) DEFAULT '0' NOT NULL,
  seq_1_id bigint(21) DEFAULT '0' NOT NULL,
  KEY seq_1_id (seq_1_id),
  KEY seq_0_id (seq_0_id)
);

insert into t1 values (1);
insert into t2 values (1);
insert into t3 values (1);
insert into t4 values (1,1);
insert into t5 values (1,1);

--error 1054
explain select * from t3 left join t4 on t4.seq_1_id = t2.t2_id left join t1 on t1.t1_id = t4.seq_0_id left join t5 on t5.seq_0_id = t1.t1_id left join t2 on t2.t2_id = t5.seq_1_id where t3.t3_id = 23;

drop table t1,t2,t3,t4,t5;

#
# Another LEFT JOIN problem
# (The problem was that the result changed when we added ORDER BY)
#

create table t1 (n int, m int, o int, key(n));
create table t2 (n int not null, m int, o int, primary key(n));
insert into t1 values (1, 2, 11), (1, 2, 7), (2, 2, 8), (1,2,9),(1,3,9);
insert into t2 values (1, 2, 3),(2, 2, 8), (4,3,9),(3,2,10);
select t1.*, t2.* from t1 left join t2 on t1.n = t2.n and
t1.m = t2.m where t1.n = 1;
select t1.*, t2.* from t1 left join t2 on t1.n = t2.n and
t1.m = t2.m where t1.n = 1 order by t1.o,t1.m;
drop table t1,t2;

# Test bug with NATURAL join:

CREATE TABLE t1 (id1 INT NOT NULL PRIMARY KEY, dat1 CHAR(1), id2 INT);   
INSERT INTO t1 VALUES (1,'a',1);
INSERT INTO t1 VALUES (2,'b',1);
INSERT INTO t1 VALUES (3,'c',2);

CREATE TABLE t2 (id2 INT NOT NULL PRIMARY KEY, dat2 CHAR(1));   
INSERT INTO t2 VALUES (1,'x');
INSERT INTO t2 VALUES (2,'y');
INSERT INTO t2 VALUES (3,'z');

SELECT t2.id2 FROM t2 LEFT OUTER JOIN t1 ON t1.id2 = t2.id2 WHERE id1 IS NULL;
SELECT t2.id2 FROM t2 NATURAL LEFT OUTER JOIN t1 WHERE id1 IS NULL;

drop table t1,t2;

create table t1 ( color varchar(20), name varchar(20) );
insert into t1 values ( 'red', 'apple' );
insert into t1 values ( 'yellow', 'banana' );
insert into t1 values ( 'green', 'lime' );
insert into t1 values ( 'black', 'grape' );
insert into t1 values ( 'blue', 'blueberry' );
create table t2 ( count int, color varchar(20) );
insert into t2 values (10, 'green');
insert into t2 values (5, 'black');
insert into t2 values (15, 'white');
insert into t2 values (7, 'green');
select * from t1;
select * from t2;
--sorted_result
select * from t2 natural join t1;
--sorted_result
select t2.count, t1.name from t2 natural join t1;
--sorted_result
select t2.count, t1.name from t2 inner join t1 using (color);
drop table t1;
drop table t2;

#
# Test of LEFT JOIN + GROUP FUNCTIONS within functions:
#

CREATE TABLE t1 (
  pcode varchar(8) DEFAULT '' NOT NULL
);
INSERT INTO t1 VALUES ('kvw2000'),('kvw2001'),('kvw3000'),('kvw3001'),('kvw3002'),('kvw3500'),('kvw3501'),('kvw3502'),('kvw3800'),('kvw3801'),('kvw3802'),('kvw3900'),('kvw3901'),('kvw3902'),('kvw4000'),('kvw4001'),('kvw4002'),('kvw4200'),('kvw4500'),('kvw5000'),('kvw5001'),('kvw5500'),('kvw5510'),('kvw5600'),('kvw5601'),('kvw6000'),('klw1000'),('klw1020'),('klw1500'),('klw2000'),('klw2001'),('klw2002'),('kld2000'),('klw2500'),('kmw1000'),('kmw1500'),('kmw2000'),('kmw2001'),('kmw2100'),('kmw3000'),('kmw3200');
CREATE TABLE t2 (
  pcode varchar(8) DEFAULT '' NOT NULL,
  KEY pcode (pcode)
);
INSERT INTO t2 VALUES ('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw2000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3000'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw3500'),('kvw6000'),('kvw6000'),('kld2000');
--source include/turn_off_only_full_group_by.inc

SELECT t1.pcode, IF(ISNULL(t2.pcode), 0, COUNT(*)) AS count FROM t1
LEFT JOIN t2 ON t1.pcode = t2.pcode GROUP BY t1.pcode;
SELECT SQL_BIG_RESULT t1.pcode, IF(ISNULL(t2.pcode), 0, COUNT(*)) AS count FROM t1 LEFT JOIN t2 ON t1.pcode = t2.pcode GROUP BY t1.pcode;

--source include/restore_sql_mode_after_turn_off_only_full_group_by.inc
drop table t1,t2;

#
# Another left join problem
#
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (
  id int(11),
  pid int(11),
  rep_del tinyint(4),
  KEY id (id),
  KEY pid (pid)
);
INSERT INTO t1 VALUES (1,NULL,NULL);
INSERT INTO t1 VALUES (2,1,NULL);
select * from t1 LEFT JOIN t1 t2 ON (t1.id=t2.pid) AND t2.rep_del IS NULL;
create index rep_del ON t1(rep_del);
select * from t1 LEFT JOIN t1 t2 ON (t1.id=t2.pid) AND t2.rep_del IS NULL;
drop table t1;

CREATE TABLE t1 (
  id int(11) DEFAULT '0' NOT NULL,
  name tinytext DEFAULT '' NOT NULL,
  UNIQUE id (id)
);
INSERT INTO t1 VALUES (1,'yes'),(2,'no');
CREATE TABLE t2 (
  id int(11) DEFAULT '0' NOT NULL,
  idx int(11) DEFAULT '0' NOT NULL,
  UNIQUE id (id,idx)
);
INSERT INTO t2 VALUES (1,1);
explain SELECT * from t1 left join t2 on t1.id=t2.id where t2.id IS NULL;
SELECT * from t1 left join t2 on t1.id=t2.id where t2.id IS NULL;
drop table t1,t2;
SET sql_mode = default;
#
# Test problem with using key_column= constant in ON and WHERE
#
create table t1 (bug_id mediumint, reporter mediumint);
create table t2 (bug_id mediumint, who mediumint, index(who));
insert into t2 values (1,1),(1,2);
insert into t1 values (1,1),(2,1);
SELECT * FROM t1 LEFT JOIN t2 ON (t1.bug_id =  t2.bug_id AND  t2.who = 2) WHERE  (t1.reporter = 2 OR t2.who = 2);
drop table t1,t2;

#
# Test problem with LEFT JOIN

create table t1 (fooID smallint unsigned auto_increment, primary key (fooID));
create table t2 (fooID smallint unsigned not null, barID smallint unsigned not null, primary key (fooID,barID));
insert into t1 (fooID) values (10),(20),(30);
insert into t2 values (10,1),(20,2),(30,3);
explain select * from t2 left join t1 on t1.fooID = t2.fooID and t1.fooID = 30;
select * from t2 left join t1 on t1.fooID = t2.fooID and t1.fooID = 30;
--sorted_result
select * from t2 left join t1 ignore index(primary) on t1.fooID = t2.fooID and t1.fooID = 30;
drop table t1,t2;

create table t1 (i int);
create table t2 (i int);
create table t3 (i int);
insert into t1 values(1),(2);
insert into t2 values(2),(3);
insert into t3 values(2),(4);
--sorted_result
select * from t1 natural left join t2 natural left join t3;
select * from t1 natural left join t2 where (t2.i is not null)=0;
--sorted_result
select * from t1 natural left join t2 where (t2.i is not null) is not null;
select * from t1 natural left join t2 where (i is not null)=0;
--sorted_result
select * from t1 natural left join t2 where (i is not null) is not null;
drop table t1,t2,t3;

#
# Test of USING
#
create table t1 (f1 integer,f2 integer,f3 integer);
create table t2 (f2 integer,f4 integer);
create table t3 (f3 integer,f5 integer);
select * from t1
         left outer join t2 using (f2)
         left outer join t3 using (f3);
drop table t1,t2,t3;

create table t1 (a1 int, a2 int);
create table t2 (b1 int not null, b2 int);
create table t3 (c1 int, c2 int);

insert into t1 values (1,2), (2,2), (3,2);
insert into t2 values (1,3), (2,3);
insert into t3 values (2,4),        (3,4);

select * from t1 left join t2  on  b1 = a1 left join t3  on  c1 = a1  and  b1 is null;
explain select * from t1 left join t2  on  b1 = a1 left join t3  on  c1 = a1  and  b1 is null;

drop table t1, t2, t3;

# Test for BUG#8711 '<=>' was considered to be a NULL-rejecting predicate.
create table t1 (
  a int(11),
  b char(10),
  key (a)
);
insert into t1 (a) values (1),(2),(3),(4);
create table t2 (a int);

select * from t1 left join t2 on t1.a=t2.a where not (t2.a <=> t1.a);
select * from t1 left join t2 on t1.a=t2.a having not (t2.a <=> t1.a);
drop table t1,t2;

# Test for BUG#5088

create table t1 (
  match_id tinyint(3) unsigned not null auto_increment,
  home tinyint(3) unsigned default '0',
  unique key match_id (match_id),
  key match_id_2 (match_id)
);

insert into t1 values("1", "2");

create table t2 (
  player_id tinyint(3) unsigned default '0',
  match_1_h tinyint(3) unsigned default '0',
  key player_id (player_id)
);

insert into t2 values("1", "5");
insert into t2 values("2", "9");
insert into t2 values("3", "3");
insert into t2 values("4", "7");
insert into t2 values("5", "6");
insert into t2 values("6", "8");
insert into t2 values("7", "4");
insert into t2 values("8", "12");
insert into t2 values("9", "11");
insert into t2 values("10", "10");

explain select s.*, '*', m.*, (s.match_1_h - m.home) UUX from 
  (t2 s left join t1 m on m.match_id = 1) 
  order by m.match_id desc;
  
explain select s.*, '*', m.*, (s.match_1_h - m.home) UUX from 
  (t2 s left join t1 m on m.match_id = 1) 
  order by UUX desc;

select s.*, '*', m.*, (s.match_1_h - m.home) UUX from 
  (t2 s left join t1 m on m.match_id = 1) 
  order by UUX desc;

explain select s.*, '*', m.*, (s.match_1_h - m.home) UUX from 
  t2 s straight_join t1 m where m.match_id = 1 
  order by UUX desc;

select s.*, '*', m.*, (s.match_1_h - m.home) UUX from 
  t2 s straight_join t1 m where m.match_id = 1 
  order by UUX desc;

drop table t1, t2;

# Tests for bugs #6307 and 6460

create table t1 (a int, b int, unique index idx (a, b));
create table t2 (a int, b int, c int, unique index idx (a, b));

insert into t1 values (1, 10), (1,11), (2,10), (2,11);
insert into t2 values (1,10,3);

select t1.a, t1.b, t2.c from t1 left join t2
                                on t1.a=t2.a and t1.b=t2.b and t2.c=3
   where t1.a=1 and t2.c is null;

drop table t1, t2;

CREATE TABLE t1 (
  ts_id bigint(20) default NULL,
  inst_id tinyint(4) default NULL,
  flag_name varchar(64) default NULL,
  flag_value text,
  UNIQUE KEY ts_id (ts_id,inst_id,flag_name)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE t2 (
  ts_id bigint(20) default NULL,
  inst_id tinyint(4) default NULL,
  flag_name varchar(64) default NULL,
  flag_value text,
  UNIQUE KEY ts_id (ts_id,inst_id,flag_name)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO t1 VALUES
  (111056548820001, 0, 'flag1', NULL),
  (111056548820001, 0, 'flag2', NULL),
  (2, 0, 'other_flag', NULL);

INSERT INTO t2 VALUES
  (111056548820001, 3, 'flag1', 'sss');

SELECT t1.flag_name,t2.flag_value 
  FROM t1 LEFT JOIN t2 
          ON (t1.ts_id = t2.ts_id AND t1.flag_name = t2.flag_name AND
              t2.inst_id = 3) 
  WHERE t1.inst_id = 0 AND t1.ts_id=111056548820001 AND
        t2.flag_value IS  NULL;

DROP TABLE t1,t2;

CREATE TABLE t1 (
  id int(11) unsigned NOT NULL auto_increment,
  text_id int(10) unsigned default NULL,
  PRIMARY KEY  (id)
);

INSERT INTO t1 VALUES("1", "0");
INSERT INTO t1 VALUES("2", "10");

CREATE TABLE t2 (
  text_id char(3) NOT NULL default '',
  language_id char(3) NOT NULL default '',
  text_data text,
  PRIMARY KEY  (text_id,language_id)
);

INSERT INTO t2 VALUES("0", "EN", "0-EN");
INSERT INTO t2 VALUES("0", "SV", "0-SV");
INSERT INTO t2 VALUES("10", "EN", "10-EN");
INSERT INTO t2 VALUES("10", "SV", "10-SV");
SELECT t1.id, t1.text_id, t2.text_data
  FROM t1 LEFT JOIN t2
               ON t1.text_id = t2.text_id
                  AND t2.language_id = 'SV'
  WHERE (t1.id LIKE '%' OR t2.text_data LIKE '%');

DROP TABLE t1, t2;

# Test for bug #5896  

CREATE TABLE t0 (a0 int PRIMARY KEY);
CREATE TABLE t1 (a1 int PRIMARY KEY);
CREATE TABLE t2 (a2 int);
CREATE TABLE t3 (a3 int);
INSERT INTO t0 VALUES (1);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1), (2);
INSERT INTO t3 VALUES (1), (2);

SELECT * FROM t1 LEFT JOIN t2 ON a1=0;
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON a1=0;
SELECT * FROM t1 LEFT JOIN (t2,t3) ON a1=0;
EXPLAIN SELECT * FROM t1 LEFT JOIN (t2,t3) ON a1=0;
SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=0 WHERE a0=a1;
EXPLAIN SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=0 WHERE a0=a1;

INSERT INTO t0 VALUES (0);
INSERT INTO t1 VALUES (0);
SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=5 WHERE a0=a1 AND a0=1;
EXPLAIN SELECT * FROM t0, t1 LEFT JOIN (t2,t3) ON a1=5 WHERE a0=a1 AND a0=1;

# Test for BUG#4480
drop table t1,t2;
create table t1 (a int, b int);
insert into t1 values (1,1),(2,2),(3,3);
create table t2 (a int, b int);
insert into t2 values (1,1), (2,2);

select * from t2 right join t1 on t2.a=t1.a;
select straight_join * from t2 right join t1 on t2.a=t1.a;

DROP TABLE t0,t1,t2,t3;

#
# Test for bug #9017: left join mistakingly converted to inner join
#

CREATE TABLE t1 (a int PRIMARY KEY, b int);
CREATE TABLE t2 (a int PRIMARY KEY, b int);

INSERT INTO t1 VALUES (1,1), (2,1), (3,1), (4,2);
INSERT INTO t2 VALUES (1,2), (2,2);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a WHERE t1.b=1;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a
  WHERE t1.b=1 XOR (NOT ISNULL(t2.a) AND t2.b=1);
SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a WHERE not(0+(t1.a=30 and t2.b=1));

DROP TABLE t1,t2;

# Bug #8681: Bad warning message when group_concat() exceeds max length
set group_concat_max_len=5;
create table t1 (a int, b varchar(20));
create table t2 (a int, c varchar(20));
insert into t1 values (1,"aaaaaaaaaa"),(2,"bbbbbbbbbb");
insert into t2 values (1,"cccccccccc"),(2,"dddddddddd");
select group_concat(t1.b,t2.c) from t1 left join t2 using(a) group by t1.a;
select group_concat(t1.b,t2.c) from t1 inner join t2 using(a) group by t1.a;
select group_concat(t1.b,t2.c) from t1 left join t2 using(a) group by a;
select group_concat(t1.b,t2.c) from t1 inner join t2 using(a) group by a;
drop table t1, t2;
set group_concat_max_len=default;

# End of 4.1 tests

#
# BUG#10162 - ON is merged with WHERE, left join is convered to a regular join
#
create table t1 (gid smallint(5) unsigned not null, x int(11) not null, y int(11) not null, art int(11) not null, primary key  (gid,x,y));
insert t1 values (1, -5, -8, 2), (1, 2, 2, 1), (1, 1, 1, 1);
create table t2 (gid smallint(5) unsigned not null, x int(11) not null, y int(11) not null, id int(11) not null, primary key  (gid,id,x,y), key id (id));
insert t2 values (1, -5, -8, 1), (1, 1, 1, 1), (1, 2, 2, 1);
create table t3 ( set_id smallint(5) unsigned not null, id tinyint(4) unsigned not null, name char(12) not null, primary key  (id,set_id));
insert t3 values (0, 1, 'a'), (1, 1, 'b'), (0, 2, 'c'), (1, 2, 'd'), (1, 3, 'e'), (1, 4, 'f'), (1, 5, 'g'), (1, 6, 'h');
explain select name from t1 left join t2 on t1.x = t2.x and t1.y = t2.y
left join t3 on t1.art = t3.id where t2.id =1 and t2.x = -5 and t2.y =-8
and t1.gid =1 and t2.gid =1 and t3.set_id =1;
drop tables t1,t2,t3;

#
# Test for bug #9938: invalid conversion from outer join to inner join 
# for queries containing indirect reference in WHERE clause
#

CREATE TABLE t1 (EMPNUM INT, GRP INT);
INSERT INTO t1 VALUES (0, 10);
INSERT INTO t1 VALUES (2, 30);

CREATE TABLE t2 (EMPNUM INT, NAME CHAR(5));
INSERT INTO t2 VALUES (0, 'KERI');
INSERT INTO t2 VALUES (9, 'BARRY');

CREATE VIEW v1 AS
SELECT COALESCE(t2.EMPNUM,t1.EMPNUM) AS EMPNUM, NAME, GRP
  FROM t2 LEFT OUTER JOIN t1 ON t2.EMPNUM=t1.EMPNUM;

SELECT * FROM v1;
SELECT * FROM v1 WHERE EMPNUM < 10;

DROP VIEW v1;
DROP TABLE t1,t2;

#
# Test for bug #11285: false Item_equal on expression in outer join
# 

CREATE TABLE t1 (c11 int);
CREATE TABLE t2 (c21 int);
INSERT INTO t1 VALUES (30), (40), (50);
INSERT INTO t2 VALUES (300), (400), (500);
SELECT * FROM t1 LEFT JOIN t2 ON (c11=c21 AND c21=30) WHERE c11=40;
DROP TABLE t1, t2;
#
# Test for bugs
# #12101: erroneously applied outer join elimination in case of WHERE NOT BETWEEN
# #12102: erroneously missing outer join elimination in case of WHERE IN/IF
#

CREATE TABLE t1 (a int PRIMARY KEY, b int);
CREATE TABLE t2 (a int PRIMARY KEY, b int);

INSERT INTO t1 VALUES (1,2), (2,1), (3,2), (4,3), (5,6), (6,5), (7,8), (8,7), (9,10);
INSERT INTO t2 VALUES (3,0), (4,1), (6,4), (7,5);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t2.b <= t1.a AND t1.a <= t1.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a BETWEEN t2.b AND t1.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a NOT BETWEEN t2.b AND t1.b);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t2.b > t1.a OR t1.a > t1.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a NOT BETWEEN t2.b AND t1.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a BETWEEN t2.b AND t1.b);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a = t2.a OR t2.b > t1.a OR t1.a > t1.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a != t2.a AND t1.a BETWEEN t2.b AND t1.b);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a = t2.a AND (t2.b > t1.a OR t1.a > t1.b);
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a != t2.a OR t1.a BETWEEN t2.b AND t1.b);

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a = t2.a OR t1.a = t2.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a IN(t2.a, t2.b);
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a NOT IN(t2.a, t2.b));

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a != t1.b AND t1.a != t2.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a NOT IN(t1.b, t2.b);
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t1.a IN(t1.b, t2.b));

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t2.a != t2.b OR (t1.a != t2.a AND t1.a != t2.b);
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t2.a = t2.b AND t1.a IN(t2.a, t2.b));

SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t2.a != t2.b AND t1.a != t1.b AND t1.a != t2.b;
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE NOT(t2.a = t2.b OR t1.a IN(t1.b, t2.b));

EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a = t2.a OR t1.a = t2.b;
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a IN(t2.a, t2.b);
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.a WHERE t1.a > IF(t1.a = t2.b-2, t2.b, t2.b-1);

DROP TABLE t1,t2;

#
# Test for bug #17164: ORed FALSE blocked conversion of outer join into join
#

# Test case moved to join_outer_innodb

#
# Bug 19396: LEFT OUTER JOIN over views in curly braces 
# 
--disable_warnings
DROP VIEW IF EXISTS v1,v2;
DROP TABLE IF EXISTS t1,t2;
--enable_warnings

CREATE TABLE t1 (a int);
CREATE table t2 (b int);
INSERT INTO t1 VALUES (1), (2), (3), (4), (1), (1), (3);
INSERT INTO t2 VALUES (2), (3);

CREATE VIEW v1 AS SELECT a FROM t1 JOIN t2 ON t1.a=t2.b;
CREATE VIEW v2 AS SELECT b FROM t2 JOIN t1 ON t2.b=t1.a;

# We see the functional dependency implied by ON:

SELECT v1.a, v2. b 
  FROM v1 LEFT OUTER JOIN v2 ON (v1.a=v2.b) AND (v1.a >= 3)
    GROUP BY v1.a;
SELECT v1.a, v2. b 
  FROM { OJ v1 LEFT OUTER JOIN v2 ON (v1.a=v2.b) AND (v1.a >= 3) }
    GROUP BY v1.a;

DROP VIEW v1,v2;
DROP TABLE t1,t2;

#
# Bug 19816: LEFT OUTER JOIN with constant ORed predicates in WHERE clause
# 

CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
INSERT INTO t1 VALUES (1), (2), (3), (4);
INSERT INTO t2 VALUES (2), (3);

--sorted_result
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.b WHERE (1=1);

--sorted_result
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.b WHERE (1 OR 1);
--sorted_result
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.b WHERE (0 OR 1);
--sorted_result
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.b WHERE (1=1 OR 2=2);
--sorted_result
SELECT * FROM t1 LEFT JOIN t2 ON t1.a = t2.b WHERE (1=1 OR 1=0);

DROP TABLE t1,t2;

#
# Bug 26017: LEFT OUTER JOIN over two constant tables and 
#            a case-insensitive comparison predicate field=const 
# 

CREATE TABLE t1 (
  f1 varchar(16) collate latin1_swedish_ci PRIMARY KEY,
  f2 varchar(16) collate latin1_swedish_ci
);
CREATE TABLE t2 (
  f1 varchar(16) collate latin1_swedish_ci PRIMARY KEY,
  f3 varchar(16) collate latin1_swedish_ci
);

INSERT INTO t1 VALUES ('bla','blah');
INSERT INTO t2 VALUES ('bla','sheep');

SELECT * FROM t1 JOIN t2 USING(f1) WHERE f1='Bla';
SELECT * FROM t1 LEFT JOIN t2 USING(f1) WHERE f1='bla';
SELECT * FROM t1 LEFT JOIN t2 USING(f1) WHERE f1='Bla';

DROP TABLE t1,t2;

#
# Bug 28188: 'not exists' optimization for outer joins 
#
 
CREATE TABLE t1 (id int PRIMARY KEY, a varchar(8));
CREATE TABLE t2 (id int NOT NULL, b int NOT NULL, INDEX idx(id));
INSERT INTO t1 VALUES
  (1,'aaaaaaa'), (5,'eeeeeee'), (4,'ddddddd'), (2,'bbbbbbb'), (3,'ccccccc');
INSERT INTO t2 VALUES
  (3,10), (2,20), (5,30), (3,20), (5,10), (3,40), (3,30), (2,10), (2,40);

EXPLAIN
SELECT t1.id, a FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.b IS NULL;

flush status;
SELECT t1.id, a FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.b IS NULL;
show status like 'Handler_read%';

DROP TABLE t1,t2;

#
# Bug 28571: outer join with false on condition over constant tables 
#

CREATE TABLE t1 (c int  PRIMARY KEY, e int NOT NULL);
INSERT INTO t1 VALUES (1,0), (2,1);
CREATE TABLE t2 (d int PRIMARY KEY);
INSERT INTO t2 VALUES (1), (2), (3);

EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON e<>0 WHERE c=1 AND d IS NULL;
SELECT * FROM t1 LEFT JOIN t2 ON e<>0 WHERE c=1 AND d IS NULL;
SELECT * FROM t1 LEFT JOIN t2 ON e<>0 WHERE c=1 AND d<=>NULL;

DROP TABLE t1,t2;

--echo #
--echo # Bug#47650: using group by with rollup without indexes returns incorrect 
--echo # results with where
--echo #
CREATE TABLE t1 ( a INT );
INSERT INTO t1 VALUES (1);

CREATE TABLE t2 ( a INT, b INT );
INSERT INTO t2 VALUES (1, 1),(1, 2),(1, 3),(2, 4),(2, 5);

EXPLAIN
SELECT t1.a, COUNT( t2.b ), SUM( t2.b ), MAX( t2.b )
FROM t1 LEFT JOIN t2 USING( a )
GROUP BY t1.a WITH ROLLUP;

SELECT t1.a, COUNT( t2.b ), SUM( t2.b ), MAX( t2.b )
FROM t1 LEFT JOIN t2 USING( a )
GROUP BY t1.a WITH ROLLUP;

EXPLAIN
SELECT t1.a, COUNT( t2.b ), SUM( t2.b ), MAX( t2.b )
FROM t1 JOIN t2 USING( a )
GROUP BY t1.a WITH ROLLUP;

SELECT t1.a, COUNT( t2.b ), SUM( t2.b ), MAX( t2.b )
FROM t1 JOIN t2 USING( a )
GROUP BY t1.a WITH ROLLUP;

DROP TABLE t1, t2;

--echo #
--echo # Bug#51598 Inconsistent behaviour with a COALESCE statement inside an IN comparison
--echo #
CREATE TABLE t1(f1 INT, f2 INT, f3 INT);
INSERT INTO t1 VALUES (1, NULL, 3);
CREATE TABLE t2(f1 INT, f2 INT);
INSERT INTO t2 VALUES (2, 1);

EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.f2 = t2.f2
WHERE (COALESCE(t1.f1, t2.f1), f3) IN ((1, 3), (2, 2));

SELECT * FROM t1 LEFT JOIN t2 ON t1.f2 = t2.f2
WHERE (COALESCE(t1.f1, t2.f1), f3) IN ((1, 3), (2, 2));

DROP TABLE t1, t2;

--echo #
--echo # Bug#52357: Assertion failed: join->best_read in greedy_search 
--echo # optimizer_search_depth=0
--echo #
CREATE TABLE t1( a INT );

INSERT INTO t1 VALUES (1),(2);
SET optimizer_search_depth = 0;

--echo # Should not core dump on query preparation
EXPLAIN
SELECT 1
FROM t1 tt3 LEFT  OUTER JOIN t1 tt4 ON 1
            LEFT  OUTER JOIN t1 tt5 ON 1
            LEFT  OUTER JOIN t1 tt6 ON 1
            LEFT  OUTER JOIN t1 tt7 ON 1
            LEFT  OUTER JOIN t1 tt8 ON 1
            RIGHT OUTER JOIN t1 tt2 ON 1
            RIGHT OUTER JOIN t1 tt1 ON 1
            STRAIGHT_JOIN    t1 tt9 ON 1;

SET optimizer_search_depth = DEFAULT;
DROP TABLE t1;

--echo #
--echo # Bug#46091 STRAIGHT_JOIN + RIGHT JOIN returns different result
--echo #
CREATE TABLE t1 (f1 INT NOT NULL);
INSERT INTO t1 VALUES (9),(0);

CREATE TABLE t2 (f1 INT NOT NULL);
INSERT INTO t2 VALUES
(5),(3),(0),(3),(1),(0),(1),(7),(1),(0),(0),(8),(4),(9),(0),(2),(0),(8),(5),(1);

SELECT STRAIGHT_JOIN COUNT(*) FROM t1 ta1
RIGHT JOIN t2 ta2 JOIN t2 ta3 ON ta2.f1 ON ta3.f1;

EXPLAIN SELECT STRAIGHT_JOIN COUNT(*) FROM t1 ta1
RIGHT JOIN t2 ta2 JOIN t2 ta3 ON ta2.f1 ON ta3.f1;

DROP TABLE t1, t2;

--echo #
--echo # Bug#48971 Segfault in add_found_match_trig_cond () at sql_select.cc:5990
--echo #
CREATE TABLE t1(f1 INT, PRIMARY KEY (f1));
INSERT INTO t1 VALUES (1),(2);

EXPLAIN SELECT STRAIGHT_JOIN jt1.f1 FROM t1 AS jt1
 LEFT JOIN t1 AS jt2
  RIGHT JOIN t1 AS jt3
    JOIN t1 AS jt4 ON 1
   LEFT JOIN t1 AS jt5 ON 1
  ON 1
  RIGHT JOIN t1 AS jt6 ON jt6.f1
 ON 1;

EXPLAIN SELECT STRAIGHT_JOIN jt1.f1 FROM t1 AS jt1
 RIGHT JOIN t1 AS jt2
  RIGHT JOIN t1 AS jt3
    JOIN t1 AS jt4 ON 1
   LEFT JOIN t1 AS jt5 ON 1
  ON 1
  RIGHT JOIN t1 AS jt6 ON jt6.f1
 ON 1;

DROP TABLE t1;

--echo #
--echo # Bug#57688 Assertion `!table || (!table->write_set || bitmap_is_set(table->write_set, field
--echo #

CREATE TABLE t1 (f1 INT NOT NULL, PRIMARY KEY (f1));
CREATE TABLE t2 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY (f1, f2));

INSERT INTO t1 VALUES (4);
INSERT INTO t2 VALUES (3, 3);
INSERT INTO t2 VALUES (7, 7);

EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t2.f1 = t1.f1
WHERE t1.f1 = 4
GROUP BY t2.f1, t2.f2;

SELECT * FROM t1 LEFT JOIN t2 ON t2.f1 = t1.f1
WHERE t1.f1 = 4
GROUP BY t2.f1, t2.f2;

EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t2.f1 = t1.f1
WHERE t1.f1 = 4 AND t2.f1 IS NOT NULL AND t2.f2 IS NOT NULL
GROUP BY t2.f1, t2.f2;

SELECT * FROM t1 LEFT JOIN t2 ON t2.f1 = t1.f1
WHERE t1.f1 = 4 AND t2.f1 IS NOT NULL AND t2.f2 IS NOT NULL
GROUP BY t2.f1, t2.f2;

DROP TABLE t1,t2;

--echo #
--echo # Bug#57034 incorrect OUTER JOIN result when joined on unique key
--echo #

CREATE TABLE t1 (pk INT PRIMARY KEY, 
                 col_int INT, 
                 col_int_unique INT UNIQUE KEY);
INSERT INTO t1 VALUES (1,NULL,2), (2,0,0);

CREATE TABLE t2 (pk INT PRIMARY KEY,
                 col_int INT,
                 col_int_unique INT UNIQUE KEY);
INSERT INTO t2 VALUES (1,0,1), (2,0,2);

EXPLAIN
SELECT * FROM t1 LEFT JOIN t2
  ON t1.col_int_unique = t2.col_int_unique AND t1.col_int = t2.col_int 
  WHERE t1.pk=1;

SELECT * FROM t1 LEFT JOIN t2
  ON t1.col_int_unique = t2.col_int_unique AND t1.col_int = t2.col_int 
  WHERE t1.pk=1;

DROP TABLE t1,t2;

--echo #
--echo # Bug#48046 Server incorrectly processing JOINs on NULL values
--echo #

# bug#48046 is a duplicate of bug#57034

CREATE TABLE `BB` (
  `pk` int(11) NOT NULL AUTO_INCREMENT,
  `time_key` time DEFAULT NULL,
  `varchar_key` varchar(1) DEFAULT NULL,
  `varchar_nokey` varchar(1) DEFAULT NULL,
  PRIMARY KEY (`pk`),
  KEY `time_key` (`time_key`),
  KEY `varchar_key` (`varchar_key`)
) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=latin1;

INSERT INTO `BB` VALUES (10,'18:27:58',NULL,NULL);

SELECT table1.time_key AS field1, table2.pk 
FROM BB table1  LEFT JOIN BB table2 
 ON table2.varchar_nokey = table1.varchar_key
 HAVING field1;

DROP TABLE BB;

--echo #
--echo # Bug#49600 Server incorrectly processing RIGHT JOIN with 
--echo #           constant WHERE clause and no index
--echo #

# bug#49600 is a duplicate of bug#57034

CREATE TABLE `BB` (
  `col_datetime_key` datetime DEFAULT NULL,
  `col_varchar_key` varchar(1) DEFAULT NULL,
  `col_varchar_nokey` varchar(1) DEFAULT NULL,
  KEY `col_datetime_key` (`col_datetime_key`),
  KEY `col_varchar_key` (`col_varchar_key`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;

INSERT INTO `BB` VALUES ('1900-01-01 00:00:00',NULL,NULL);

SELECT table1.col_datetime_key  
FROM BB table1 RIGHT JOIN BB table2 
 ON table2 .col_varchar_nokey = table1.col_varchar_key
 WHERE 7;

# Disable keys, and we get incorrect result for the same query
ALTER TABLE BB DISABLE KEYS;

SELECT table1.col_datetime_key  
FROM BB table1 RIGHT JOIN BB table2
 ON table2 .col_varchar_nokey = table1.col_varchar_key
 WHERE 7;

DROP TABLE BB;


--echo #
--echo # Bug#58490: Incorrect result in multi level OUTER JOIN
--echo # in combination with IS NULL
--echo #

CREATE TABLE t1 (i INT NOT NULL);
INSERT INTO t1 VALUES (0),    (2),(3),(4);
CREATE TABLE t2 (i INT NOT NULL);
INSERT INTO t2 VALUES (0),(1),    (3),(4);
CREATE TABLE t3 (i INT NOT NULL);
INSERT INTO t3 VALUES (0),(1),(2),    (4);
CREATE TABLE t4 (i INT NOT NULL);
INSERT INTO t4 VALUES (0),(1),(2),(3)   ;

--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( t2 LEFT JOIN
   ( t3 LEFT JOIN
     t4
     ON t4.i = t3.i
   )
   ON t3.i = t2.i
 )
 ON t2.i = t1.i
 ;

--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( t2 LEFT JOIN
   ( t3 LEFT JOIN
     t4
     ON t4.i = t3.i
   )
   ON t3.i = t2.i
 )
 ON t2.i = t1.i
 WHERE t4.i IS NULL;


# Most simplified testcase to reproduce the bug.
# (Has to be at least a two level nested outer join)
--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( ( t2 LEFT JOIN
     t3
     ON t3.i = t2.i
   )
 )
 ON t2.i = t1.i
 WHERE t3.i IS NULL;


# Extended testing:
# We then add some equi-join inside the query above:
# (There Used to be some problems here with first
#  proposed patch for this bug)
--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( ( t2 LEFT JOIN
     t3
     ON t3.i = t2.i
   )
   JOIN t4
   ON t4.i=t2.i
 )
 ON t2.i = t1.i
 WHERE t3.i IS NULL;

--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( ( t2 LEFT JOIN
     t3
     ON t3.i = t2.i
   )
   JOIN (t4 AS t4a JOIN t4 AS t4b ON t4a.i=t4b.i)
   ON t4a.i=t2.i
 )
 ON t2.i = t1.i
 WHERE t3.i IS NULL;

--sorted_result
SELECT * FROM
 t1 LEFT JOIN
 ( ( t2 LEFT JOIN
     t3
     ON t3.i = t2.i
   )
   JOIN (t4 AS t4a, t4 AS t4b)
   ON t4a.i=t2.i
 )
 ON t2.i = t1.i
 WHERE t3.i IS NULL;


DROP TABLE t1,t2,t3,t4;

## Bug#49322 & bug#58490 are duplicates. However, we include testcases
## for both.
--echo #
--echo # Bug#49322(Duplicate): Server is adding extra NULL row
--echo # on processing a WHERE clause
--echo #

CREATE TABLE h (pk INT NOT NULL, col_int_key INT);
INSERT INTO h VALUES (1,NULL),(4,2),(5,2),(3,4),(2,8);

CREATE TABLE m (pk INT NOT NULL, col_int_key INT);
INSERT INTO m VALUES (1,2),(2,7),(3,5),(4,7),(5,5),(6,NULL),(7,NULL),(8,9);
CREATE TABLE k (pk INT NOT NULL, col_int_key INT);
INSERT INTO k VALUES (1,9),(2,2),(3,5),(4,2),(5,7),(6,0),(7,5);

# Baseline query wo/ 'WHERE ... IS NULL' - was correct
--sorted_result
SELECT TABLE1.pk FROM k TABLE1
RIGHT JOIN h TABLE2 ON TABLE1.col_int_key=TABLE2.col_int_key
RIGHT JOIN m TABLE4 ON TABLE2.col_int_key=TABLE4.col_int_key;

# Adding 'WHERE ... IS NULL' -> incorrect result
--sorted_result
SELECT TABLE1.pk FROM k TABLE1
RIGHT JOIN h TABLE2 ON TABLE1.col_int_key=TABLE2.col_int_key
RIGHT JOIN m TABLE4 ON TABLE2.col_int_key=TABLE4.col_int_key
WHERE TABLE1.pk IS NULL;

DROP TABLE h,m,k;

--echo #
--echo # Bug #11765810	58813: SERVER THREAD HANGS WHEN JOIN + WHERE + GROUP BY
--echo # IS EXECUTED TWICE FROM P
--echo #
CREATE TABLE t1 ( a INT ) ENGINE = MYISAM;
INSERT INTO t1 VALUES (1);
PREPARE prep_stmt FROM '
 SELECT 1 AS f FROM t1
 LEFT JOIN t1 t2
  RIGHT JOIN t1 t3
    JOIN t1 t4
   ON 1
  ON 1
 ON 1
 GROUP BY f';
EXECUTE prep_stmt;
EXECUTE prep_stmt;

DROP TABLE t1;


--echo End of 5.1 tests

--echo #
--echo # Bug#54235 Extra rows with join_cache_level=4,6,8 and two LEFT JOIN
--echo #

CREATE TABLE t1 (a int);
CREATE TABLE t2 (a int);
CREATE TABLE t3 (a int);
CREATE TABLE t4 (a int);

INSERT INTO t1 VALUES (null),(null);

let $query = SELECT t1.a FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.a)
ON 0 WHERE t1.a OR t3.a;

eval explain $query;

eval $query;

let $query = SELECT t1.a FROM t1 LEFT JOIN
(t2 LEFT JOIN (t3 LEFT JOIN t4 ON 1) ON t2.a)
ON 0 WHERE t1.a OR t4.a;

eval explain $query;

eval $query;

DROP TABLE t1,t2,t3,t4;

--echo #
--echo # Bug#56254 Assertion tab->ref.use_count fails in
--echo # join_read_key_unlock_row() on 4-way JOIN
--echo #

CREATE TABLE t1 (
  pk INT NOT NULL,
  col_int_key INT,
  col_int INT,
  PRIMARY KEY (pk),
  KEY col_int_key (col_int_key)
);

INSERT INTO t1 VALUES (6, -448724992, NULL);

CREATE TABLE t2 (
  col_int INT,
  col_varchar_10 VARCHAR(10)
);

INSERT INTO t2 VALUES (6,'afasdkiyum');

CREATE TABLE t3 (
  col_varchar_10 VARCHAR(10),
  col_int INT
);

CREATE TABLE t4 (
  pk INT NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t4 VALUES (1);
INSERT INTO t4 VALUES (2);

SELECT t1.col_int
FROM t1
  LEFT JOIN t2
    LEFT JOIN t3
      JOIN t4
      ON t3.col_int  = t4.pk
    ON t2.col_varchar_10 = t3.col_varchar_10
  ON t2.col_int = t1.pk
WHERE   t1.col_int_key IS NULL OR t4.pk < t3.col_int;

# Demonstrates the case where we put a condition on the top level above
# an outer join with const tables on the left side. The found_match test
# is redundant and should probably be removed if we can.
EXPLAIN FORMAT=tree SELECT t1.col_int
FROM t1
  LEFT JOIN t2
    LEFT JOIN t3
      JOIN t4
      ON t3.col_int  = t4.pk
    ON t2.col_varchar_10 = t3.col_varchar_10
  ON t2.col_int = t1.pk
WHERE   t1.col_int_key IS NULL OR t4.pk < t3.col_int;

DROP TABLE t1,t2,t3,t4;

--echo
--echo # BUG#12567331 - INFINITE LOOP WHEN RESOLVING AN ALIASED COLUMN
--echo # USED IN GROUP BY
--echo 
CREATE TABLE t1 (pk int(11));

PREPARE prep_stmt_9846 FROM '
SELECT alias1.pk AS field1 FROM
t1 AS alias1
LEFT JOIN
( 
  t1 AS alias2
  RIGHT  JOIN
  ( 
    t1 AS alias3
    JOIN t1 AS alias4
    ON 1
  )
  ON 1
)
ON 1
GROUP BY field1';
execute prep_stmt_9846;
execute prep_stmt_9846;
deallocate prepare prep_stmt_9846;
drop table t1;

--echo #
--echo # Bug#13040136 - ASSERT IN PLAN_CHANGE_WATCHDOG::~PLAN_CHANGE_WATCHDOG()
--echo #
CREATE TABLE t1 (
  col_varchar_10 VARCHAR(10),
  col_int_key INTEGER,
  col_varchar_10_key VARCHAR(10),
  pk INTEGER NOT NULL,
  PRIMARY KEY (pk),
  KEY (col_int_key),
  KEY (col_varchar_10_key)
);
INSERT INTO t1 VALUES ('q',NULL,'o',1);

CREATE TABLE t2 (
  pk INTEGER NOT NULL AUTO_INCREMENT,
  col_varchar_10_key VARCHAR(10),
  col_int_key INTEGER,
  col_varchar_10 VARCHAR(10),
  PRIMARY KEY (pk),
  KEY (col_varchar_10_key),
  KEY col_int_key (col_int_key)
);
INSERT INTO t2 VALUES
(1,'r',NULL,'would'),(2,'tell',-655032320,'t'),
(3,'d',9,'a'),(4,'gvafasdkiy',6,'ugvafasdki'),
(5,'that\'s',NULL,'she'),(6,'bwftwugvaf',7,'cbwftwugva'),
(7,'f',-700055552,'mkacbwftwu'),(8,'a',9,'be'),
(9,'d',NULL,'u'),(10,'ckiixcsxmk',NULL,'o');

SELECT DISTINCT t2.col_int_key 
FROM
t1
LEFT JOIN t2
ON t1.col_varchar_10 = t2.col_varchar_10_key 
WHERE t2.pk
ORDER BY t2.col_int_key;

DROP TABLE t1,t2;

--echo #
--echo # Bug#13068506 - QUERY WITH GROUP BY ON NON-AGGR COLUMN RETURNS WRONG RESULT
--echo #
CREATE TABLE t1 (i1 int);
INSERT INTO t1 VALUES (100), (101);

CREATE TABLE t2 (i2 int, i3 int);
INSERT INTO t2 VALUES (20,1),(10,2);

CREATE TABLE t3 (i4 int(11));
INSERT INTO t3 VALUES (1),(2);

let $query= SELECT (
  SELECT MAX( t2.i2 )
  FROM t3 RIGHT JOIN t2 ON ( t2.i3 = 2 )
  WHERE t2.i3 <> t1.i1
) AS field1
FROM t1;

--echo
--eval $query;
--echo
--eval $query GROUP BY field1;

--echo
drop table t1,t2,t3;

--echo # Bug#11766384 - 59487: WRONG RESULT WITH STRAIGHT_JOIN AND RIGHT JOIN

CREATE TABLE t1 (
  pk int(11) NOT NULL,
  col_varchar_10_latin1_key varchar(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t1 VALUES (1,'1');
CREATE TABLE t2 (
  pk int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t2 VALUES (1);
CREATE TABLE t3 (
  pk int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t3 VALUES (1);
CREATE TABLE t4 (
  pk int(11) NOT NULL,
  col_int int(11) DEFAULT NULL,
  col_int_key int(11) DEFAULT NULL,
  col_varchar_10_latin1_key varchar(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t4 VALUES (1,1,1,'1');
CREATE TABLE t5 (
  col_int int(11) DEFAULT NULL,
  col_varchar_10_utf8_key varchar(10) CHARACTER SET utf8 DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t5 VALUES (1,'1');
CREATE TABLE t6 (
  col_int_key int(11) DEFAULT NULL,
  col_varchar_10_latin1_key varchar(10) DEFAULT NULL,
  pk int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t6 VALUES (1,'1',1);

# EXPLAIN of query above (t2 is before t5 in plan)

let $rest_of_query=t6a.pk, t2.pk
FROM
  t6 AS t6a
  LEFT JOIN
  (
    t2
    RIGHT JOIN
    (
      (
        t1
        LEFT JOIN
        (
          t4
          JOIN
          t3
          ON t4.col_int
        )
        ON t4.col_int_key = t1.pk
      )
      LEFT JOIN
      (
        t5
        JOIN
        t6 AS t6b
        ON t5.col_varchar_10_utf8_key = t6b.col_varchar_10_latin1_key
      )
      ON t1.pk = t5.col_int
    )
    ON t4.col_varchar_10_latin1_key = t1.col_varchar_10_latin1_key
       AND t5.col_varchar_10_utf8_key = 0
  )
  ON t6a.pk IS TRUE
WHERE t6b.col_int_key IS TRUE
;

eval SELECT STRAIGHT_JOIN $rest_of_query;
eval EXPLAIN SELECT STRAIGHT_JOIN $rest_of_query;

# right result (same query, just remove STRAIGHT_JOIN):

eval SELECT $rest_of_query;
eval EXPLAIN SELECT $rest_of_query;

# In this case, LEFT JOIN must be converted to inner join:
let $query=
SELECT * FROM t5 LEFT JOIN t6 ON t5.col_int=1000
WHERE t6.col_int_key IS TRUE;
eval EXPLAIN $query;
# but not here
let $query=
SELECT * FROM t5 LEFT JOIN t6 ON t5.col_int=1000
WHERE t6.col_int_key IS NOT TRUE;
eval EXPLAIN $query;
drop table t1,t2,t3,t4,t5,t6;

--echo #
--echo # Verify that the "not exists" optimization works.
--echo #
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT NOT NULL);
INSERT INTO t1 VALUES(1),(2);
INSERT INTO t2 VALUES(1),(2);
let $query=SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a WHERE t2.a IS NULL;
eval EXPLAIN $query;
FLUSH STATUS;
eval $query;
# Without the "not exists" optimization, there would be more read_rnd_next
SHOW STATUS LIKE 'HANDLER_READ%';
DROP TABLE t1,t2;

--echo #
--echo # Bug#13464334 SAME QUERY PRODUCES DIFFERENT RESULTS WHEN USED WITH AND
--echo # WITHOUT UNION ALL
--echo #

CREATE TABLE t1 (p1 INT PRIMARY KEY, a CHAR(1));
CREATE TABLE t2 (p2 INT PRIMARY KEY, b CHAR(1));
INSERT INTO t1 VALUES (1,'a'),(2,'b'),(3,'c');
INSERT INTO t2 VALUES (1,'h'),(2,'i'),(3,'j'),(4,'k');
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE VIEW v2 AS SELECT * FROM t2;
(SELECT p1 FROM v2 LEFT JOIN v1 ON b = a WHERE p2 = 1 GROUP BY p1 ORDER BY p1)
UNION (SELECT NULL LIMIT 0);
DROP VIEW v1, v2;
DROP TABLE t1, t2;

--echo #
--echo # Bug#13980954 Missing data on left join + null value + where..in
--echo #

CREATE TABLE t1 (ik INT, vc varchar(1)) charset utf8mb4 ENGINE=Innodb;

let $query=
SELECT straight_join t1.vc, t1.ik
FROM t1 JOIN t1 AS t2 ON t1.vc=t2.vc LEFT JOIN t1 AS t3 ON t1.vc=t3.vc;

eval explain format=json $query;
eval $query;

DROP TABLE t1;

--echo #
--echo # Bug #18345786 CRASH AROUND ST_JOIN_TABLE::AND_WITH_CONDITION
--echo #

CREATE TABLE t1(a INT) ENGINE=INNODB;
SET @a:=(SELECT ROW(1, 2)=
                ROW((SELECT 1 FROM t1 LEFT JOIN t1 t2 ON 1), 1));
DROP TABLE t1;

--echo #
--echo # Coverage for "unique row not found"
--echo #

create table t1(a int, unique key(a)) engine=innodb;
insert into t1 values(1);
let $query=
select * from t1 left join t1 as t2
              on t2.a=12
         where t1.a=1;
eval explain $query;
eval $query;
drop table t1;

--echo #
--echo # Bug#18717059 MISSING ROWS ON NESTED JOIN WITH SUBQUERY  
--echo #              WITH MYISAM OR MEMORY    
--echo #
CREATE TABLE t1 (
  pk INT,
  col_int_key INT,
  col_varchar_key VARCHAR(1),
  PRIMARY KEY (pk),
  KEY col_varchar_key (col_varchar_key, col_int_key)
) ENGINE=MyISAM;

INSERT INTO t1 VALUES (23,4,'d');
INSERT INTO t1 VALUES (24,8,'g');
INSERT INTO t1 VALUES (25,NULL,'x');
INSERT INTO t1 VALUES (26,NULL,'f');
INSERT INTO t1 VALUES (27,0,'p');
INSERT INTO t1 VALUES (28,NULL,'j');
INSERT INTO t1 VALUES (29,8,'c');

CREATE TABLE t2 (
  pk INT,
  col_int_key INT,
  col_varchar_key VARCHAR(1),
  PRIMARY KEY (pk)
) ENGINE=MyISAM;

let $query=
  SELECT 9
  FROM t1 AS table1
    RIGHT JOIN t1 AS table2
    ON table2.col_int_key = table1.col_int_key
      AND table1.col_varchar_key = (
        SELECT subquery2_t2.col_varchar_key
        FROM t2
          STRAIGHT_JOIN ( t2 AS subquery2_t2
            JOIN t1 AS subquery2_t3
          ) ON ( subquery2_t3.col_int_key = subquery2_t2.pk )
      );

eval $query;      
eval CREATE TABLE where_subselect_table AS
  $query;

set optimizer_switch='condition_fanout_filter=on';
eval SELECT *
FROM where_subselect_table
WHERE (9) IN ( $query )
 /* TRANSFORM_OUTCOME_UNORDERED_MATCH */;

set optimizer_switch='condition_fanout_filter=off';    
eval SELECT *
FROM where_subselect_table
WHERE (9) IN ( $query )
 /* TRANSFORM_OUTCOME_UNORDERED_MATCH */;
 
DROP TABLE t1, t2, where_subselect_table;

--echo # Bug#14358878 Wrong results on table left join view

CREATE TABLE a (id INTEGER);
CREATE TABLE b (id INTEGER);

CREATE ALGORITHM=MERGE VIEW vmerge AS SELECT 1 AS id, id AS b_id FROM b;
CREATE ALGORITHM=TEMPTABLE VIEW vmat AS SELECT 1 AS id, id AS b_id FROM b;

INSERT INTO a(id) VALUES (1);

SELECT *
FROM a LEFT JOIN vmerge AS v ON a.id = v.id;

SELECT *
FROM a LEFT JOIN vmat AS v ON a.id = v.id;

SELECT *
FROM a LEFT JOIN (SELECT 1 AS one, id FROM b) AS v ON a.id = v.id;

SELECT *
FROM a LEFT JOIN (SELECT DISTINCT 1 AS one, id FROM b) AS v ON a.id = v.id;

SELECT *
FROM a LEFT JOIN vmerge AS v ON a.id = v.id
UNION DISTINCT
SELECT *
FROM a LEFT JOIN vmerge AS v ON a.id = v.id;

SELECT *
FROM a LEFT JOIN vmerge AS v ON a.id = v.id
UNION ALL
SELECT *
FROM a LEFT JOIN vmerge AS v ON a.id = v.id;

DROP VIEW vmerge, vmat;
DROP TABLE a, b;

--echo # Bug#15936817 Table left join view, unmatched rows problem where
--echo #              view contains an IF

CREATE TABLE small (
  id INTEGER not null,
  PRIMARY KEY (id)
);

CREATE TABLE big (
  id INTEGER not null,
  PRIMARY KEY (id)
);

INSERT INTO small VALUES (1), (2);
INSERT INTO big VALUES (1), (2), (3), (4);

CREATE VIEW small_view AS
SELECT *, IF (id % 2 = 1, 1, 0) AS is_odd
FROM small;

CREATE VIEW big_view AS
SELECT big.*, small_view.id AS small_id, small_view.is_odd
FROM big LEFT JOIN small_view ON small_view.id = big.id;

SELECT * FROM big_view;

SELECT big.*, small.id AS small_id, small.is_odd
FROM big LEFT JOIN
     (SELECT id, IF (id % 2 = 1, 1, 0) AS is_odd FROM small) AS small
     ON big.id = small.id;

--echo # Check the IS NULL and thruth predicates

SELECT big.*, dt.*
FROM big LEFT JOIN (SELECT id as dt_id,
                           id IS NULL AS nul,
                           id IS NOT NULL AS nnul,
                           id IS TRUE AS t,
                           id IS NOT TRUE AS nt,
                           id IS FALSE AS f,
                           id IS NOT FALSE AS nf,
                           id IS UNKNOWN AS u,
                           id IS NOT UNKNOWN AS nu
                    FROM small) AS dt
     ON big.id=dt.dt_id;

--echo # Check comparison predicates

SELECT big.*, dt.*
FROM big LEFT JOIN (SELECT id as dt_id,
                           id = 1 AS eq,
                           id <> 1 AS ne,
                           id > 1 AS gt,
                           id >= 1 AS ge,
                           id < 1 AS lt,
                           id <= 1 AS le,
                           id <=> 1 AS equal
                    FROM small) AS dt
     ON big.id=dt.dt_id;

--echo # Check CASE, NULLIF and COALESCE

SELECT big.*, dt.*
FROM big LEFT JOIN (SELECT id as dt_id,
                           CASE id WHEN 0 THEN 0 ELSE 1 END AS simple,
                           CASE WHEN id=0 THEN NULL ELSE 1 END AS cond,
                           NULLIF(1, NULL) AS nullif,
                           IFNULL(1, NULL) AS ifnull,
                           COALESCE(id) AS coal,
                           INTERVAL(NULL, 1, 2, 3) as intv,
                           IF (id % 2 = 1, NULL, 1) AS iff
                    FROM small) AS dt
     ON big.id=dt.dt_id;

DROP VIEW small_view, big_view;
DROP TABLE small, big;

 
 --echo #
 --echo # Bug#16893426 OPTIMIZER FAILS TO OPTIMIZE EXPRESSION OF THE
 --echo #              FORM 'FOO' IS NULL
 --echo #
 
 CREATE TABLE t1 (
   id int(11) NOT NULL PRIMARY KEY,
   name varchar(20),
   INDEX (name)
 ) ENGINE=InnoDB;
 
 CREATE TABLE t2 (
   id int(11) NOT NULL PRIMARY KEY,
   f_id int(11),
   FOREIGN KEY (f_id) REFERENCES t2(id)
 ) ENGINE=InnoDB;
 
 INSERT INTO t1 VALUES (1,'A1'),(2,'A2'),(3,'B');
 INSERT INTO t2 VALUES (1,1),(2,2),(3,2),(4,3),(5,3);
 
 -- disable_result_log
 ANALYZE TABLE t1;
 ANALYZE TABLE t2;
 -- enable_result_log
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE t1.name LIKE 'A%';
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE t1.name LIKE 'A%' OR 'ASDFGH' IS NULL;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE 0 OR 0;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE 1 OR 0;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE NOT(NOT (0)) OR 1;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE NOT(NOT (0)) OR 0 = 1;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE 1 IS NOT TRUE AND 0 IS TRUE ;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE 'a' LIKE 1 OR 2 LIKE '2%' ;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE 1 IS NOT NULL;
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE (1<2 AND 2<3) OR (1>1 AND 2<3);
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE (1>=1 AND 2<=2) OR (1=1 AND 2<3);
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 let $query= SELECT * FROM t2 LEFT JOIN t1 ON t2.f_id = t1.id
              WHERE (1<>1 AND 2=2) OR (1 BETWEEN 0 AND 2);
 eval EXPLAIN $query;
 eval $query;
 eval PREPARE stmt FROM "$query";
 EXECUTE stmt;
 
 DROP TABLE t1,t2;
 
 --echo #
 --echo # Bug#22103398 BUG#16893426:SIG11 IN
 --echo # ST_SELECT_LEX::FLATTEN_SUBQUERIES | SQL_RESOLVER.CC
 --echo #
 
 CREATE TABLE t1(c1 INT,	c2 INT,	c3 CHAR(1), KEY(c3))ENGINE=InnoDB;
 CREATE TABLE t2(c1 INT,	c2 INT,	c3 CHAR(1), KEY(c3))ENGINE=InnoDB;
 
 SELECT b.c2 AS f1 FROM (t2 AS a JOIN
                        ((t2 AS b JOIN t2 AS c ON (c.c3=b.c3)))
                        ON (c.c1=b.c2))
     WHERE (c.c3 IN (SELECT subquery1_b.c3 AS subquery1_f1
                     FROM (t1 AS subquery1_a JOIN t2 AS subquery1_b ON
                           (subquery1_b.c1=subquery1_a.c1)))) AND
           (a.c1=a.c1 AND (SELECT''FROM DUAL) IS NULL);
 DROP TABLE t1, t2;
 
 --echo # End of Bug#16893426
 

--echo # Bug#22561937 Wrong result on outer join with multiple join conditions
--echo #              and derived table

CREATE TABLE t1 (
  col_int INT,
  pk INT NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t1 VALUES
 (2,1), (2,2), (6,3), (4,4), (7,5),
 (188,6), (0,7), (6,8), (0,9), (9,10);

CREATE TABLE t2 (
  pk INT NOT NULL,
  col_int INT,
  PRIMARY KEY (pk)
);

INSERT INTO t2 VALUES
 (1,0), (2,0), (3,2), (4,NULL), (5,2),
 (6,3), (7,3), (8,100), (9,3), (10,6);

let $query=
SELECT table2.pk, table1.col_int
FROM t2 AS table1
     LEFT JOIN t1 AS table2
     ON table2.pk < table1.col_int AND
        table2.pk = table1.col_int;

eval explain $query;
eval $query;

let $query=
SELECT table2.pk, table1.col_int
FROM t2 AS table1
     LEFT JOIN (SELECT * FROM t1) AS table2
     ON table2.pk < table1.col_int AND
        table2.pk = table1.col_int;

eval explain $query;
eval $query;

DROP TABLE t1, t2;

--echo # Bug#22671557: Wrong results on JOIN when composite index is present

CREATE TABLE t1 (
  col_int INT DEFAULT NULL,
  col_int_key INT DEFAULT NULL,
  pk INT NOT NULL,
  PRIMARY KEY (pk),
  KEY test_idx (col_int_key,col_int)
);

INSERT INTO t1 VALUES (0, -7, 1), (9, NULL, 15), (182, NULL, 25);

CREATE TABLE t2 (
  col_int INT DEFAULT NULL,
  pk INT NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t2 VALUES (NULL, 4), (-208, 5), (5, 6), (NULL, 75);

CREATE TABLE t3 (
  col_datetime_key DATETIME DEFAULT NULL,
  pk INT NOT NULL,
  PRIMARY KEY (pk)
);

INSERT INTO t3 VALUES ('1970-01-01 00:00:00', 5);

CREATE TABLE t4 (
  col_int INT DEFAULT NULL,
  pk INT NOT NULL,
  col_int_key INT DEFAULT NULL,
  PRIMARY KEY (pk),
  KEY col_int_key (col_int_key)
);

INSERT INTO t4 VALUES (0, 15, 6), (9, 16, 6);

SELECT alias2.col_datetime_key
FROM
    t1 AS alias1
      LEFT JOIN t3 AS alias2
        LEFT JOIN t2 AS alias3
          LEFT JOIN t4 AS alias4
          ON alias3.pk = alias4.col_int_key
        ON alias2.pk = alias3.col_int
      ON alias1.col_int = alias4.col_int
;

DROP TABLE t1, t2, t3, t4;

--echo # Bug#22833364: Left join returns incorrect results on the outer side

CREATE TABLE ta (
  a1 varchar(1024) NOT NULL,
  a2 int NOT NULL,
  KEY user_id(a2)
);

INSERT INTO ta (a1, a2) VALUES ('row1', 4), ('row2', 4);

CREATE TABLE tb (
  b1 int NOT NULL,
  b2 varchar(1024) NOT NULL,
  b3 int NOT NULL,
  PRIMARY KEY (b1)
);

INSERT INTO tb (b1, b2, b3) VALUES
 (1, 'text1', 0), (2, 'text2', 0), (3, 'text3', 1), (4, 'text4', 1);

let $query=
SELECT ta.a1, tb.b1, tb.b2
FROM ta LEFT OUTER JOIN tb
     ON ta.a2 = tb.b1 AND tb.b3 = 0;

eval explain $query;
eval $query;

DROP TABLE ta, tb;

--echo # Bug#23079533: Left join on PK + extra condition doesn't return match

CREATE TABLE m (
  machineid VARCHAR(32) NOT NULL,
  orderid bigint unsigned DEFAULT NULL,
  extra bigint unsigned DEFAULT NULL,
  PRIMARY KEY (machineid)
);

INSERT INTO m (machineid, orderid)
VALUES ('m1', NULL), ('m2', 2), ('m3', NULL), ('m4', NULL);

CREATE TABLE o (
  orderid bigint unsigned NOT NULL,
  machineid VARCHAR(32) DEFAULT NULL,
  PRIMARY KEY (orderid)
);

INSERT INTO o (orderid, machineid)
VALUES (1, 'm2'), (2, 'm2');

SELECT o.*,'|' as sep, m.*
FROM o LEFT JOIN m
     ON m.machineid = o.machineid AND
        m.orderid = o.orderid;

DROP TABLE m, o;

--echo # Bug#23086825: Incorrect query results using left join against derived

CREATE TABLE t1 (
  adslot varchar(5) NOT NULL
);

INSERT INTO t1(adslot) VALUES ('1'), ('2'), ('3');

CREATE TABLE t2 (
  ionumber varchar(20) NOT NULL,
  adslot varchar(5) NOT NULL
);

INSERT INTO t2 (ionumber, adslot) VALUES ('01602', 1), ('01602', 3);

CREATE TABLE t3 (
  ionumber varchar(20) NOT NULL,
  ioattribute varchar(5) NOT NULL,
  PRIMARY KEY (ionumber)
);
INSERT INTO t3 VALUES ('01602', 'BOB'), ('01603', 'SALLY');

SELECT s.adslot, lid.ionumber1, lid.ionumber2, lid.ioattribute
FROM t1 s LEFT JOIN
     (SELECT lid.adslot,
             i.ionumber as ionumber1,
             lid.ionumber as ionumber2,
             i.ioattribute
      FROM t2 lid JOIN t3 i
           USING (ionumber)
     ) AS lid
    USING (adslot);

DROP TABLE t1, t2, t3;

--echo #
--echo # Bug #26432173: INCORRECT SUBQUERY OPTIMIZATION WITH
--echo #                LEFT JOIN(SUBQUERY) AND ORDER BY
--echo #

CREATE TABLE t1 (a INT);
INSERT t1 values (1),(2),(15),(24),(5);
CREATE TABLE t2 (t1_a INT, b VARCHAR(10));

#No temp table is used. So correct result.
let query1=
SELECT t1.a, subq.st_value
FROM t1
LEFT JOIN (SELECT t2.t1_a, 'red' AS st_value
           FROM t2) AS subq
  ON subq.t1_a = t1.a;

#Problematic query where const column is in the inner table of outer join.
let query2=
SELECT t1.a, subq.st_value
FROM t1
LEFT JOIN (SELECT t2.t1_a, 'red' AS st_value
           FROM t2) AS subq
  ON subq.t1_a = t1.a
ORDER BY t1.a;

#fix doesn't apply here since const column is in the outer table of outer join.
let query3=
SELECT t1.a, subq.st_value
FROM (SELECT t2.t1_a, 'red' AS st_value
      FROM t2) AS subq
LEFT JOIN t1
  ON subq.t1_a = t1.a
ORDER BY t1.a;

eval EXPLAIN $query1;
eval EXPLAIN $query2;
eval EXPLAIN $query3;

eval $query1;
eval $query2;
eval $query3;

DROP TABLE t1, t2;

--echo # Bug #18898433: EXTREMELY SLOW PERFORMANCE WITH OUTER JOINS AND JOIN
--echo #                BUFFER.
--echo #

CREATE TABLE t1 (i INT NOT NULL);
INSERT INTO t1 VALUES (0),(2),(3),(4);
CREATE TABLE t2 (i INT NOT NULL);
INSERT INTO t2 VALUES (0),(1),(3),(4);
CREATE TABLE t3 (i INT NOT NULL);
INSERT INTO t3 VALUES (0),(1),(2),(4);
CREATE TABLE t4 (i INT NOT NULL);
INSERT INTO t4 VALUES (0),(1),(2),(3);
let query1=
SELECT *
FROM t1 LEFT JOIN
     (
       (t2 LEFT JOIN t3 ON t3.i= t2.i)
       LEFT JOIN t4 ON t3.i= t4.i
     )ON t2.i= t1.i;

let query2=
SELECT *
FROM t1 LEFT JOIN
     (
       (t2 INNER JOIN t3 ON t3.i= t2.i)
       LEFT JOIN t4 ON t3.i= t4.i
     )ON t2.i= t1.i;

let query3=
SELECT *
FROM t1 LEFT JOIN t2 ON t2.i= t1.i
        LEFT JOIN t3 ON t3.i= t2.i
        LEFT JOIN t4 ON t3.i= t4.i;

eval EXPLAIN $query1;
eval EXPLAIN $query2;
eval EXPLAIN $query3;

flush status;
eval $query1;
SHOW STATUS LIKE 'HANDLER_%';

flush status;
eval $query2;
SHOW STATUS LIKE 'HANDLER_%';

flush status;
eval $query3;
SHOW STATUS LIKE 'HANDLER_%';

DROP TABLE t1, t2, t3, t4;


--echo #
--echo # Bug #26627181: WRONG RESULT WITH LEFT JOIN + DERIVED TABLES
--echo #

CREATE TABLE t1 (id INT);
CREATE TABLE t2 (id INT);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (1);

let query1=
SELECT *
FROM (SELECT id
      FROM t1) AS a
    LEFT JOIN
    (SELECT id, 2 AS tall
     FROM t2) AS b
    ON a.id = b.id
WHERE b.tall IS NOT NULL;

eval EXPLAIN $query1;
eval $query1;

DROP TABLE t1, t2;

--echo #
--echo # Bug #23169204: Left join + merged derived table + group by = bad result
--echo #

CREATE TABLE t1(doc text);
CREATE TABLE t2(a INTEGER DEFAULT NULL);
INSERT INTO t2 VALUES(1);

# Derived table is materialized due to LIMIT.
# t1 is empty so the derived table is empty, so NULL-complementing produces
# NULL for 'je' in the SELECT list.
SELECT je
FROM t2 LEFT JOIN (SELECT 1 AS je FROM t1 LIMIT 1) AS dt ON FALSE;

SELECT je
FROM t2 LEFT JOIN (SELECT 1 AS je FROM t1 LIMIT 1) AS dt ON FALSE
GROUP BY je;

# Remove LIMIT (to have the derived table be merged), produces NULL too.

SELECT je
FROM t2 LEFT JOIN (SELECT 1 AS je FROM t1) AS dt ON FALSE;

SELECT je
FROM t2 LEFT JOIN (SELECT 1 AS je FROM t1) AS dt ON FALSE
GROUP BY je;

DROP TABLE t1, t2;

--echo #
--echo # Bug#22489105 WL#9571 : SIG11 IN ITEM_SUBSELECT::EXEC | SQL/ITEM_SUBSELECT.CC
--echo #
SELECT (SELECT * FROM (SELECT 'a') t) AS f1 HAVING (f1 = 'a' OR TRUE);
SELECT (SELECT * FROM (SELECT 'a') t) + 1 AS f1 HAVING (f1 = 'a' OR TRUE);
SELECT 1 + (SELECT * FROM (SELECT 'a') t) AS f1 HAVING (f1 = 'a' OR TRUE);

--echo #
--echo # Bug#28237111: WL#9571: TABLE FULL ERROR
--echo #

CREATE TABLE t1 (pk INTEGER, f1 INTEGER, primary key(pk));
CREATE TABLE t2 (pk INTEGER, f1 INTEGER, primary key(pk));
CREATE TABLE t3 (pk INTEGER);

INSERT INTO t1 VALUES (1,1),(2,1),(3,1);
INSERT INTO t2 VALUES (1,1),(2,1),(3,1);
INSERT INTO t3 VALUES (1);

SELECT  * FROM (t1 RIGHT JOIN
                (SELECT * FROM t3 WHERE (DAYNAME('1995')))  AS table2 ON
                (( t1.f1 ,t1.pk) IN (SELECT 7,4 UNION SELECT 9,2))) WHERE
(NOT EXISTS (SELECT t1.f1 FROM (t1 INNER JOIN t2 ON (t1.pk=t2.f1))
             WHERE 0 IS NOT NULL)) AND t1.f1 >  50;

DROP TABLE t3,t1,t2;

--echo #
--echo # Bug#28341790: WL#9571: SIG11 IN ITEM_COND::FIX_FIELDS() AT SQL/ITEM_CMPFUNC.CC
--echo #

CREATE TABLE t1 (col_varchar varchar(1) DEFAULT NULL);
INSERT INTO t1 VALUES ('Z') ;
CREATE TABLE t2 (col_varchar varchar(1) DEFAULT NULL);
INSERT INTO t2 VALUES ('Z') ;

PREPARE prep_stmt FROM " SELECT 1 FROM ( ( SELECT * FROM t1 WHERE col_varchar
>= 1 )  AS table1 RIGHT JOIN t2 ON ( ( NULL < NULL ) IS NULL OR 1 = 0 ) ) " ;

EXECUTE prep_stmt ;
EXECUTE prep_stmt ;

DROP TABLE t1,t2;

--echo #
--echo # More coverage for IS TRUE in LEFT JOIN conditions
--echo #

CREATE TABLE t1(c1 INT);
INSERT INTO t1 VALUES(1),(2);
CREATE TABLE t2(c2 INT);
INSERT INTO t2 VALUES(1);
# returns two rows
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2;
# returns one row, c1=2, execute as left join
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE c2 IS NULL;
# returns one row, c1=1, execute as inner join
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE c2 IS NOT NULL;
# returns one row, c1=1, execute as left join
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE (c2 IS NOT NULL) = 1;
# same
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE (c2 IS NOT NULL) IS TRUE;
# returns one row, c1=2, execute as left join
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE (c2 IS NOT NULL) = 0;
# same
SELECT * FROM t1 LEFT JOIN t2 ON c1=c2 WHERE (c2 IS NOT NULL) IS FALSE;

DROP TABLE t1,t2;

--echo #
--echo # Bug#29402481: INCORRECT RESULT FROM OUTER JOIN QUERIES
--echo #

CREATE TABLE t1 (
  pk int primary key auto_increment,
  col_int_unique int unique
) ENGINE=InnoDB;

INSERT INTO t1(col_int_unique) values (6),(7);

CREATE TABLE t2 (
  pk int primary key auto_increment,
  col_int_key int(11) DEFAULT NULL,
  col_int_unique int(11) DEFAULT NULL,
  UNIQUE KEY `ix2` (col_int_key,col_int_unique),
  KEY col_int_key (col_int_key)
) ENGINE=InnoDB;

# t2 intentionally left empty. Insert of values not matching
# join-cond would have had the same effect.

CREATE TABLE t3 (
  pk int NOT NULL
) ENGINE=InnoDB;

INSERT INTO t3(pk) values (6),(7);

# Test case check that last predicate term in join condition for t3
# 't1.col_int_unique = t2.col_int_key', is not eliminated in optimizer
# by test_if_ref(), even if it is 'covered' by the REF join condition
# used by t2: t2 rows may be NULL-complimented when t3 join-cond
# is evaluated, thus it is needed to exclude match on 't2.col_int_key'
# being NULL.

SELECT STRAIGHT_JOIN t1.col_int_unique, t2.col_int_key, t3.pk
  FROM
    (t1 LEFT JOIN t2 ON t1.col_int_unique = t2.col_int_key)
        LEFT JOIN t3 ON t3.pk = t1.col_int_unique AND
	                t1.col_int_unique = t2.col_int_key;


DROP TABLE t1,t2,t3;


--echo #
--echo # Bug#29493830 CONST'IFIED OUTER JOIN RETURN INCORRECT RESULTS
--echo #

CREATE TABLE t1 (
  col_int_unique INT DEFAULT NULL,
  col_int_key INT DEFAULT NULL,
  UNIQUE KEY col_int_unique (col_int_unique)
) ENGINE=InnoDB;

INSERT INTO t1 VALUES (5,0);

CREATE TABLE t2 (
  col_char_16_unique char(16) DEFAULT NULL,
  col_int_key INT DEFAULT NULL,
  col_int_unique INT DEFAULT NULL,
  UNIQUE KEY col_int_unique (col_int_unique)
) ENGINE=InnoDB;

INSERT INTO t2 VALUES ("just",21,5);

CREATE TABLE t3 (
  col_int INT DEFAULT NULL,
  col_char_16_unique CHAR(16) DEFAULT NULL,
  UNIQUE KEY col_char_16_unique (col_char_16_unique)
) ENGINE=InnoDB;

INSERT INTO t3 VALUES (9,"foo");

CREATE TABLE t4 (
  col_int INT DEFAULT NULL,
  col_int_unique INT DEFAULT NULL,
  UNIQUE KEY col_int_unique (col_int_unique)
) ENGINE=InnoDB;

INSERT INTO t4 VALUES (9,5);

# t3 will be marked by the optimizer as 'Impossible ON condition'
# and const optimized as a NULL row. However the optimizer failed
# to set 'TABLE::const_table = true'. When later also const optimizing
# t4, join_read_const_table() failed to evaluate the predicate term
# 't3.col_int = t4.col_int' on t4. -> incorrect result.

let query = SELECT STRAIGHT_JOIN
  t3.col_int, t4.col_int,
  t3.col_int = t4.col_int or t4.col_int IS NULL
  FROM (t1
    LEFT JOIN t2
    ON t1.col_int_key = t2.col_int_key AND
       t1.col_int_unique = t2.col_int_unique
    LEFT JOIN t3
    ON t3.col_char_16_unique = t2.col_char_16_unique
    LEFT JOIN t4
    ON t4.col_int = t3.col_int AND    #Note, this pred term
       t4.col_int_unique = t1.col_int_unique
 ) WHERE t1.col_int_unique = 5;

eval explain $query;
eval $query;

DROP TABLE t1, t2, t3, t4;
