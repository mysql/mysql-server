# General purpose bug fix tests go here : subselect.test too large


--echo #
--echo # Bug #46791: Assertion failed:(table->key_read==0),function unknown
--echo #    function,file sql_base.cc
--echo #

CREATE TABLE t1 (a INT, b INT, KEY(a));
INSERT INTO t1 VALUES (1,1),(2,2);
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES (1,1),(2,2);
CREATE TABLE t3 LIKE t1;

--echo # should have 1 impossible where and 2 dependent subqueries
EXPLAIN
SELECT 1 FROM t1
WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE 1 = (SELECT MIN(t2.b) FROM t3))
ORDER BY count(*);

--echo # should not crash the next statement
SELECT 1 FROM t1
WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE 1 = (SELECT MIN(t2.b) FROM t3))
ORDER BY count(*);

--echo # should not crash: the crash is caused by the previous statement
SELECT 1;

DROP TABLE t1,t2,t3;

--echo #
--echo # Bug #47106: Crash / segfault on adding EXPLAIN to a non-crashing 
--echo # query
--echo #

CREATE TABLE t1 (
  a INT,
  b INT,
  PRIMARY KEY (a),
  KEY b (b)
);
INSERT INTO t1 VALUES (1, 1), (2, 1);

CREATE TABLE t2 LIKE t1;
INSERT INTO t2 SELECT * FROM t1;

CREATE TABLE t3 LIKE t1;
INSERT INTO t3 SELECT * FROM t1;

--echo # Should not crash.
--echo # Should have 1 impossible where and 2 dependent subqs.
EXPLAIN
SELECT
  (SELECT 1 FROM t1,t2 WHERE t2.b > t3.b)
FROM t3 WHERE 1 = 0 GROUP BY 1;

--echo # should return 0 rows
SELECT
  (SELECT 1 FROM t1,t2 WHERE t2.b > t3.b)
FROM t3 WHERE 1 = 0 GROUP BY 1;

DROP TABLE t1,t2,t3;

--echo End of 5.0 tests.
 
--echo #
--echo # BUG#50257: Missing info in REF column of the EXPLAIN 
--echo #            lines for subselects
--echo #

CREATE TABLE t1 (a INT, b INT, INDEX (a));
INSERT INTO t1 VALUES (3, 10), (2, 20), (7, 10), (5, 20);

--echo
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a=7) t;
--echo
EXPLAIN SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE a=7);

--echo
DROP TABLE t1;

--echo End of 5.5 tests.


--echo #
--echo # BUG#46743 "Azalea processing correlated, aggregate SELECT
--echo # subqueries incorrectly"
--echo #
# To see the bug, one would have to undo both the fix for BUG#46743
# and the one for BUG#47123.
CREATE TABLE t1 (c int);
INSERT INTO t1 VALUES (NULL);
CREATE TABLE t2 (d int , KEY (d)); # index is needed for bug
INSERT INTO t2 VALUES (NULL),(NULL); # two rows needed for bug
# we see that subquery returns 0 rows
--echo 0 rows in subquery
SELECT 1 AS RESULT FROM t2,t1 WHERE d = c;
# so here it ends up as NULL
--echo base query
SELECT (SELECT 1 FROM t2 WHERE d = c) AS RESULT FROM t1 ;
EXPLAIN EXTENDED SELECT (SELECT 1 FROM t2 WHERE d = c) AS RESULT FROM t1 ;
--echo first equivalent variant
SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c,NULL)) AS RESULT FROM t1 GROUP BY c ;
EXPLAIN EXTENDED SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c,NULL)) AS RESULT FROM t1 GROUP BY c;
--echo second equivalent variant
# used to fail with 1242: Subquery returns more than 1 row
SELECT (SELECT 1 FROM t2 WHERE d = c) AS RESULT FROM t1 GROUP BY c ;
EXPLAIN EXTENDED SELECT (SELECT 1 FROM t2 WHERE d = c) AS RESULT FROM t1 GROUP BY c ;

DROP TABLE t1,t2;

--echo #
--echo # BUG#45928 "Differing query results depending on MRR and
--echo # engine_condition_pushdown settings"
--echo #

CREATE TABLE `t1` (
  `pk` int(11) NOT NULL AUTO_INCREMENT,
  `time_nokey` time NOT NULL,
  `varchar_key` varchar(1) NOT NULL,
  `varchar_nokey` varchar(1) NOT NULL,
  PRIMARY KEY (`pk`),
  KEY `varchar_key` (`varchar_key`)
) AUTO_INCREMENT=12 DEFAULT CHARSET=latin1;
INSERT INTO `t1` VALUES (10,'00:00:00','i','i'),(11,'00:00:00','','');

set @old_optimizer_switch          = @@session.optimizer_switch;

SET SESSION OPTIMIZER_SWITCH = 'materialization=off,semijoin=off,loosescan=off,firstmatch=off,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=off';

SELECT `time_nokey` G1  FROM t1  WHERE ( `varchar_nokey`  , `varchar_key`  )  IN ( 
SELECT `varchar_nokey`  , `varchar_nokey`  )  AND `varchar_key`  >= 'c' HAVING G1  ORDER 
BY `pk`   ;

set @@session.optimizer_switch          = @old_optimizer_switch;

DROP TABLE t1;

--echo #
--echo # BUG#49630: Segfault in select_describe() with double 
--echo #            nested subquery and materialization
--echo #

CREATE TABLE t1 (t1i int);
CREATE TABLE t2 (t2i int);
CREATE TABLE t3 (t3i int);
CREATE TABLE t4 (t4i int);

INSERT INTO t1 VALUES (1); # Note: t1 must be const table
INSERT INTO t2 VALUES (1),(2);
INSERT INTO t3 VALUES (1),(2);
INSERT INTO t4 VALUES (1),(2);

--echo
EXPLAIN 
SELECT t1i
FROM t1 JOIN t4 ON t1i=t4i  
WHERE (t1i)  IN (  
   SELECT t2i
   FROM t2  
   WHERE (t2i)  IN (  
     SELECT t3i
     FROM t3  
     GROUP BY t3i
     )  
 );

DROP TABLE t1,t2,t3,t4;

--echo #
--echo # BUG#45863 "Assertion failed: (fixed == 0), function fix_fields(),
--echo #            file item.cc, line 4448"
--echo #
--disable_warnings
DROP TABLE IF EXISTS C, BB;
--enable_warnings

CREATE TABLE C (
  varchar_nokey varchar(1) NOT NULL
);
INSERT INTO C VALUES
  ('k'),('a'),(''),('u'),('e'),('v'),('i'),
  ('t'),('u'),('f'),('u'),('m'),('j'),('f'),
  ('v'),('j'),('g'),('e'),('h'),('z');
CREATE TABLE BB (
  varchar_nokey varchar(1) NOT NULL
);
INSERT INTO BB VALUES ('i'),('t');
-- error ER_OPERAND_COLUMNS
SELECT varchar_nokey FROM C
WHERE (varchar_nokey, OUTR) IN (SELECT varchar_nokey
                                FROM BB);
-- error ER_BAD_FIELD_ERROR
SELECT varchar_nokey FROM C
WHERE (varchar_nokey, OUTR) IN (SELECT varchar_nokey, varchar_nokey
                                FROM BB);
DROP TABLE C,BB;

--echo #
--echo # During work with BUG#45863 I had problems with a query that was
--echo # optimized differently in regular and prepared mode.
--echo # Because there was a bug in one of the selected strategies, I became
--echo # aware of the problem. Adding an EXPLAIN query to catch this.

--disable_warnings
DROP TABLE IF EXISTS t1, t2, t3;
--enable_warnings

CREATE TABLE t1
 (EMPNUM   CHAR(3) NOT NULL,
  EMPNAME  CHAR(20),
  GRADE    DECIMAL(4),
  CITY     CHAR(15));

CREATE TABLE t2
 (PNUM     CHAR(3) NOT NULL,
  PNAME    CHAR(20),
  PTYPE    CHAR(6),
  BUDGET   DECIMAL(9),
  CITY     CHAR(15));

CREATE TABLE t3
 (EMPNUM   CHAR(3) NOT NULL,
  PNUM     CHAR(3) NOT NULL,
  HOURS    DECIMAL(5));

INSERT INTO t1 VALUES ('E1','Alice',12,'Deale');
INSERT INTO t1 VALUES ('E2','Betty',10,'Vienna');
INSERT INTO t1 VALUES ('E3','Carmen',13,'Vienna');
INSERT INTO t1 VALUES ('E4','Don',12,'Deale');
INSERT INTO t1 VALUES ('E5','Ed',13,'Akron');

INSERT INTO t2 VALUES ('P1','MXSS','Design',10000,'Deale');
INSERT INTO t2 VALUES ('P2','CALM','Code',30000,'Vienna');
INSERT INTO t2 VALUES ('P3','SDP','Test',30000,'Tampa');
INSERT INTO t2 VALUES ('P4','SDP','Design',20000,'Deale');
INSERT INTO t2 VALUES ('P5','IRM','Test',10000,'Vienna');
INSERT INTO t2 VALUES ('P6','PAYR','Design',50000,'Deale');

INSERT INTO t3 VALUES  ('E1','P1',40);
INSERT INTO t3 VALUES  ('E1','P2',20);
INSERT INTO t3 VALUES  ('E1','P3',80);
INSERT INTO t3 VALUES  ('E1','P4',20);
INSERT INTO t3 VALUES  ('E1','P5',12);
INSERT INTO t3 VALUES  ('E1','P6',12);
INSERT INTO t3 VALUES  ('E2','P1',40);
INSERT INTO t3 VALUES  ('E2','P2',80);
INSERT INTO t3 VALUES  ('E3','P2',20);
INSERT INTO t3 VALUES  ('E4','P2',20);
INSERT INTO t3 VALUES  ('E4','P4',40);
INSERT INTO t3 VALUES  ('E4','P5',80);

SET @old_optimizer_switch = @@session.optimizer_switch;
SET @old_optimizer_join_cache_level = @@session.optimizer_join_cache_level;
SET SESSION optimizer_switch = 'firstmatch=on,loosescan=on,materialization=on,semijoin=on';
SET SESSION optimizer_join_cache_level = 1;

CREATE UNIQUE INDEX t1_IDX ON t1(EMPNUM);

EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'));

PREPARE stmt FROM "EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'))";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

DROP INDEX t1_IDX ON t1;
CREATE INDEX t1_IDX ON t1(EMPNUM);

EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'));

PREPARE stmt FROM "EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'))";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

DROP INDEX t1_IDX ON t1;

EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'));

PREPARE stmt FROM "EXPLAIN SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
   (SELECT EMPNUM
    FROM t3
    WHERE PNUM IN
       (SELECT PNUM
        FROM t2
        WHERE PTYPE = 'Design'))";
EXECUTE stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET SESSION optimizer_switch = @old_optimizer_switch;
SET SESSION optimizer_join_cache_level = @old_optimizer_join_cache_level;

DROP TABLE t1, t2, t3;

--echo #
--echo # BUG#45221 Query SELECT pk FROM C WHERE pk IN (SELECT int_key) failing
--echo #

CREATE TABLE t1 (
  i1_key INT,
  i2 INT,
  i3 INT,
  KEY i1_index (i1_key)
);

INSERT INTO t1 VALUES (9,1,2), (9,2,1);

CREATE TABLE t2 (
  pk INT NOT NULL,
  i1 INT,
  PRIMARY KEY (pk)
);

INSERT INTO t2 VALUES (9,1);

--echo # Enable Index condition pushdown
--replace_column 1 #
SELECT @old_icp:=@@optimizer_switch;
SET optimizer_switch= 'index_condition_pushdown=on';
SELECT pk
FROM t2
WHERE 
   pk IN ( 
     SELECT i1_key
     FROM t1
     WHERE t1.i2 < t1.i3 XOR t2.i1 > 1
     ORDER BY t1.i2 desc);

--echo # Restore old value for Index condition pushdown
SET SESSION optimizer_switch=@old_icp;

DROP TABLE t1,t2;

--echo #
--echo # BUG#50361 Doublenested noncorrelated subquery with FirstMatch and join cache wrong result
--echo #

CREATE TABLE t1(
  id INTEGER
  );
INSERT INTO t1 VALUES(10),(20);
create table t2 select * from t1;
create table t3 select * from t1;

SELECT *
FROM t1
WHERE 1 IN(SELECT 1
             FROM t2
             WHERE 1 IN(SELECT 1
                          FROM t3));

explain extended SELECT *
FROM t1
WHERE 1 IN(SELECT 1
             FROM t2
             WHERE 1 IN(SELECT 1
                          FROM t3));

delete from t2;
delete from t3;

INSERT INTO t1 VALUES(30),(40),(50),(60),(70),(80),(90);
insert into t2 select * from t1;
insert into t3 select * from t1;
create table t4 select * from t1;

SELECT *
FROM t1
WHERE 1 IN(SELECT 1
           FROM t2
           WHERE 1 IN(SELECT 1
                      FROM t3
                      WHERE 1 IN(SELECT 1
                                 FROM t4)));

explain SELECT *
FROM t1
WHERE 1 IN(SELECT 1
           FROM t2
           WHERE 1 IN(SELECT 1
                      FROM t3
                      WHERE 1 IN(SELECT 1
                                 FROM t4)));

SELECT *
FROM t1
WHERE 1 IN(SELECT 1
           FROM t1
           WHERE 1 IN(SELECT 1
                      FROM t1
                      WHERE 1 IN(SELECT 1
                                 FROM t1)));

drop table t1,t2,t3,t4;

--echo #
--echo # Bug#53236 Segfault in DTCollation::set(DTCollation&)
--echo #

CREATE TABLE t1 (
  pk INTEGER AUTO_INCREMENT,
  col_varchar VARCHAR(1),
  PRIMARY KEY (pk)
)
;

INSERT INTO t1 (col_varchar) 
VALUES
('w'),
('m')
;

SELECT  table1.pk
FROM ( t1 AS table1 JOIN t1 AS table2 ON (table1.col_varchar =
                                          table2.col_varchar) ) 
WHERE ( 1, 2 ) IN ( SELECT SUBQUERY1_t1.pk AS SUBQUERY1_field1,
                           SUBQUERY1_t1.pk AS SUBQUERY1_field2
                    FROM ( t1 AS SUBQUERY1_t1 JOIN t1 AS SUBQUERY1_t2
                           ON (SUBQUERY1_t2.col_varchar =
                               SUBQUERY1_t1.col_varchar) ) ) 
;

drop table t1;

--echo #
--echo # BUG#53298 "wrong result with semijoin (no semijoin strategy chosen)"
--echo #

create table t1 (uid int, fid int);
insert into t1 values (1,1), (3,1);

create table t2 (uid int, name varchar(128));
insert into t2 values (1, "A"), (2, "B");

create table t3 (uid int, fid int, index(uid));
insert into t3 values (1,3), (1,3);

create table t4 (uid int);
insert into t4 values (3);

explain select t2.uid from t2, t1 
  where t1.uid in (select t4.uid from t4, t3 where t3.uid=1 and t4.uid=t3.fid)
        and t2.uid=t1.fid;

--sorted_result
select t2.uid from t2, t1 
  where t1.uid in (select t4.uid from t4, t3 where t3.uid=1 and t4.uid=t3.fid)
        and t2.uid=t1.fid;

drop table t1,t2,t3,t4;

--echo #
--echo # BUG#53103: MTR test ps crashes in optimize_cond() 
--echo #            when running with --debug
--echo #

CREATE TABLE t1(track varchar(15));

INSERT INTO t1 VALUES ('CAD'), ('CAD');

PREPARE STMT FROM
"SELECT 1 FROM t1
  WHERE
        track IN (SELECT track FROM t1
                                    GROUP BY track 
                                      HAVING track>='CAD')";
EXECUTE STMT ;
EXECUTE STMT ;

DEALLOCATE PREPARE STMT;
DROP TABLE t1; 

--echo # End of BUG#53103
