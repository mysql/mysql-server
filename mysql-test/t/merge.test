#
# Test of MERGE TABLES
#

--disable_warnings
drop table if exists t1,t2,t3,t4,t5,t6;
drop database if exists mysqltest;
--enable_warnings

create table t1 (a int not null primary key auto_increment, message char(20));
create table t2 (a int not null primary key auto_increment, message char(20));
INSERT INTO t1 (message) VALUES ("Testing"),("table"),("t1");
INSERT INTO t2 (message) VALUES ("Testing"),("table"),("t2");
create table t3 (a int not null, b char(20), key(a)) engine=MERGE UNION=(t1,t2);
select * from t3;
select * from t3 order by a desc;
drop table t3;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
create table t3 (a int not null, b char(20), key(a)) engine=MERGE UNION=(test.t1,test.t2);
explain select * from t3 where a < 10;
explain select * from t3 where a > 10 and a < 20;
select * from t3 where a = 10;
select * from t3 where a < 10;
select * from t3 where a > 10 and a < 20;
explain select a from t3 order by a desc limit 10;
select a from t3 order by a desc limit 10;
select a from t3 order by a desc limit 300,10;
delete from t3 where a=3;
select * from t3 where a < 10;
delete from t3 where a >= 6 and a <= 8;
select * from t3 where a < 10;
update t3 set a=3 where a=9;
select * from t3 where a < 10;
update t3 set a=6 where a=7;
select * from t3 where a < 10;
show create table t3;

# The following should give errors
create table t4 (a int not null, b char(10), key(a)) engine=MERGE UNION=(t1,t2);
--error 1168
select * from t4;
--error 1168
alter table t4 add column c int;
flush tables;
--error 1168
select * from t4;

#
# Test tables in different databases
#
create database mysqltest;
create table mysqltest.t6 (a int not null primary key auto_increment, message char(20));
create table t5 (a int not null, b char(20), key(a)) engine=MERGE UNION=(test.t1,mysqltest.t6);
show create table t5;
alter table t5 engine=myisam;
drop table t5, mysqltest.t6;
drop database mysqltest;

# Because of windows, it's important that we drop the merge tables first!
drop table t4,t3,t1,t2;
  
create table t1 (c char(10)) engine=myisam;
create table t2 (c char(10)) engine=myisam;
create table t3 (c char(10)) union=(t1,t2) engine=merge;
insert into t1 (c) values ('test1');
insert into t1 (c) values ('test1');
insert into t1 (c) values ('test1');
insert into t2 (c) values ('test2');
insert into t2 (c) values ('test2');
insert into t2 (c) values ('test2');
select * from t3;
select * from t3;
delete from t3 where 1=1;
select * from t3;
select * from t1;
drop table t3,t2,t1;

#
# Test 2
#

CREATE TABLE t1 (incr int not null, othr int not null, primary key(incr));
CREATE TABLE t2 (incr int not null, othr int not null, primary key(incr));
CREATE TABLE t3 (incr int not null, othr int not null, primary key(incr))
ENGINE=MERGE UNION=(t1,t2);

SELECT * from t3;

INSERT INTO t1 VALUES ( 1,10),( 3,53),( 5,21),( 7,12),( 9,17);
INSERT INTO t2 VALUES ( 2,24),( 4,33),( 6,41),( 8,26),( 0,32);
INSERT INTO t1 VALUES (11,20),(13,43),(15,11),(17,22),(19,37);
INSERT INTO t2 VALUES (12,25),(14,31),(16,42),(18,27),(10,30);

SELECT * from t3 where incr in (1,2,3,4) order by othr;
alter table t3 UNION=(t1);
select count(*) from t3;
alter table t3 UNION=(t1,t2);
select count(*) from t3;
alter table t3 ENGINE=MYISAM;
select count(*) from t3;

# Test that ALTER TABLE rembers the old UNION

drop table t3;
CREATE TABLE t3 (incr int not null, othr int not null, primary key(incr))
ENGINE=MERGE UNION=(t1,t2);
show create table t3;
alter table t3 drop primary key;
show create table t3;

drop table t3,t2,t1;

#
# Test table without unions
#
create table t1 (a int not null, key(a)) engine=merge;
--error 1030
select * from t1;
drop table t1;

#
# Bug in flush tables combined with MERGE tables
#

create table t1 (a int not null, b int not null, key(a,b));
create table t2 (a int not null, b int not null, key(a,b));
create table t3 (a int not null, b int not null, key(a,b)) ENGINE=MERGE UNION=(t1,t2);
insert into t1 values (1,2),(2,1),(0,0),(4,4),(5,5),(6,6);
insert into t2 values (1,1),(2,2),(0,0),(4,4),(5,5),(6,6);
flush tables;
select * from t3 where a=1 order by b limit 2;
drop table t3,t1,t2;

#
# [phi] testing INSERT_METHOD stuff
#

# first testing of common stuff with new parameters
create table t1 (a int not null, b int not null auto_increment, primary key(a,b));
create table t2 (a int not null, b int not null auto_increment, primary key(a,b));
create table t3 (a int not null, b int not null, key(a,b)) UNION=(t1,t2) INSERT_METHOD=NO;
create table t4 (a int not null, b int not null, key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=NO;
create table t5 (a int not null, b int not null auto_increment, primary key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=FIRST;
create table t6 (a int not null, b int not null auto_increment, primary key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;
show create table t3;
show create table t4;
show create table t5;
show create table t6;
insert into t1 values (1,NULL),(1,NULL),(1,NULL),(1,NULL);
insert into t2 values (2,NULL),(2,NULL),(2,NULL),(2,NULL);
select * from t3 order by b,a limit 3;
select * from t4 order by b,a limit 3;
select * from t5 order by b,a limit 3,3;
select * from t6 order by b,a limit 6,3;
# now testing inserts and where the data gets written
insert into t5 values (5,1),(5,2);
insert into t6 values (6,1),(6,2);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t4 order by a,b;
# preperation for next test
insert into t3 values (3,1),(3,2),(3,3),(3,4);
select * from t3 order by a,b;
# now testing whether options are kept by alter table
alter table t4 UNION=(t1,t2,t3);
show create table t4;
select * from t4 order by a,b;
# testing switching off insert method and inserts again
alter table t4 INSERT_METHOD=FIRST;
show create table t4;
insert into t4 values (4,1),(4,2);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t3 order by a,b;
select * from t4 order by a,b;
select * from t5 order by a,b;
# auto_increment
select 1;
insert into t5 values (1,NULL),(5,NULL);
insert into t6 values (2,NULL),(6,NULL);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t5 order by a,b;
select * from t6 order by a,b;
insert into t1 values (99,NULL);
select * from t4 where a+0 > 90;
# bug#4008 - cannot determine a unique key that caused "dupl. key error"
--error ER_DUP_ENTRY
insert t5 values (1,1);
--error ER_DUP_ENTRY
insert t6 values (2,1);
insert t5 values (1,1) on duplicate key update b=b+10;
insert t6 values (2,1) on duplicate key update b=b+20;
select * from t5 where a < 3;
drop table t6, t5, t4, t3, t2, t1;

CREATE TABLE t1 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  PRIMARY KEY  (a,b)) ENGINE=MyISAM;
INSERT INTO t1 VALUES (1,1), (2,1);
CREATE TABLE t2 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  PRIMARY KEY  (a,b)) ENGINE=MyISAM;
INSERT INTO t2 VALUES (1,2), (2,2);
CREATE TABLE t3 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  KEY a (a,b)) ENGINE=MRG_MyISAM UNION=(t1,t2);
select max(b) from t3 where a = 2;
select max(b) from t1 where a = 2;
drop table t3,t1,t2;

#
# temporary merge tables
#
create table t1 (a int not null);
create table t2 (a int not null);
insert into t1 values (1);
insert into t2 values (2);
create temporary table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
create temporary table t4 (a int not null);
create temporary table t5 (a int not null);
insert into t4 values (1);
insert into t5 values (2);
create temporary table t6 (a int not null) ENGINE=MERGE UNION=(t4,t5);
select * from t6;
drop table t6, t3, t1, t2, t4, t5;
#
# Bug#19627 - temporary merge table locking
# MERGE table and its children must match in temporary type.
# Forbid temporary merge on non-temporary children: shown above.
# Forbid non-temporary merge on temporary children:
create temporary table t1 (a int not null);
create temporary table t2 (a int not null);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3, t2, t1;
# Forbid children mismatch in temporary:
create table t1 (a int not null);
create temporary table t2 (a int not null);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3;
create temporary table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3, t2, t1;
--echo # CREATE...SELECT is not implemented for MERGE tables.
CREATE TEMPORARY TABLE t1 (c1 INT NOT NULL);
CREATE TEMPORARY TABLE t2 (c1 INT NOT NULL);
CREATE TABLE t3 (c1 INT NOT NULL);
INSERT INTO t3 VALUES (3), (33);
LOCK TABLES t3 READ;
--error ER_WRONG_OBJECT
CREATE TEMPORARY TABLE t4 (c1 INT NOT NULL) ENGINE=MERGE UNION=(t1,t2)
  INSERT_METHOD=LAST SELECT * FROM t3;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t4;
UNLOCK TABLES;
CREATE TEMPORARY TABLE t4 (c1 INT NOT NULL) ENGINE=MERGE UNION=(t1,t2)
  INSERT_METHOD=LAST;
INSERT INTO t4 SELECT * FROM t3;
--echo # Alter temporary MERGE table.
ALTER TABLE t4 UNION=(t1);
LOCK TABLES t4 WRITE;
--echo # Alter temporary MERGE table under LOCk tables.
ALTER TABLE t4 UNION=(t1,t2);
UNLOCK TABLES;
--echo # MERGE table and function.
CREATE FUNCTION f1 () RETURNS INT RETURN (SELECT max(c1) FROM t3);
SELECT * FROM t4 WHERE c1 < f1();
DROP FUNCTION f1;
DROP TABLE t4, t3, t2, t1;

#
# testing merge::records_in_range and optimizer
#

CREATE TABLE t1 (
  fileset_id tinyint(3) unsigned NOT NULL default '0',
  file_code varchar(32) NOT NULL default '',
  fileset_root_id tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (fileset_id,file_code),
  KEY files (fileset_id,fileset_root_id)
) ENGINE=MyISAM;
INSERT INTO t1 VALUES (2, '0000000111', 1), (2, '0000000112', 1), (2, '0000000113', 1),
(2, '0000000114', 1), (2, '0000000115', 1), (2, '0000000116', 1), (2, '0000000117', 1),
(2, '0000000118', 1), (2, '0000000119', 1), (2, '0000000120', 1);
CREATE TABLE t2 (
  fileset_id tinyint(3) unsigned NOT NULL default '0',
  file_code varchar(32) NOT NULL default '',
  fileset_root_id tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (fileset_id,file_code),
  KEY files (fileset_id,fileset_root_id)
) ENGINE=MRG_MyISAM UNION=(t1);

EXPLAIN SELECT * FROM t2 IGNORE INDEX (files) WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t2 WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t1 WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t2 WHERE fileset_id = 2
AND file_code = '0000000115' LIMIT 1;
DROP TABLE t2, t1;

#
# Test of ORDER BY DESC on key (Bug #515)
#

create table t1 (x int, y int, index xy(x, y));
create table t2 (x int, y int, index xy(x, y));
create table t3 (x int, y int, index xy(x, y)) engine=merge union=(t1,t2);
insert into t1 values(1, 2);
insert into t2 values(1, 3);
select * from t3 where x = 1 and y < 5 order by y;
# Bug is that followng query returns empty set while it must be same as above
select * from t3 where x = 1 and y < 5 order by y desc;
drop table t1,t2,t3;

#
# Bug#5232: CREATE TABLE ... SELECT
#

create table t1 (a int);
create table t2 (a int);
insert into t1 values (0);
insert into t2 values (1);
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select * from t1;
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select * from t2;
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select (select max(a) from t2);
drop table t1, t2;

#
# Bug#9112 - Merge table with composite index producing invalid results with some queries
# This test case will fail only without the bugfix and some
# non-deterministic circumstances. It depends on properly initialized
# "un-initialized" memory. At the time it happens with a standard
# non-debug build. But there is no guarantee that this will be always so.
#
create table t1 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=merge union=(t2,t3);

create table t2 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=myisam;

create table t3 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=myisam;

insert into t2 values ( null, '');
insert into t2 values ( 9999999999.999, '');
insert into t3 select * from t2;
select min(a), max(a) from t1;
flush tables;
select min(a), max(a) from t1;
drop table t1, t2, t3;
# BUG#6699 : no sorting on 'ref' retrieval 
create table t1 (a int,b int,c int, index (a,b,c));
create table t2 (a int,b int,c int, index (a,b,c));
create table t3 (a int,b int,c int, index (a,b,c))
  engine=merge union=(t1 ,t2);
insert into t1 (a,b,c) values (1,1,0),(1,2,0);
insert into t2 (a,b,c) values (1,1,1),(1,2,1);

explain select a,b,c from t3 force index (a) where a=1 order by a,b,c;
select a,b,c from t3 force index (a) where a=1 order by a,b,c;

# this actually wasn't affected:
explain select a,b,c from t3 force index (a) where a=1 order by a desc, b desc, c desc;
select a,b,c from t3 force index (a) where a=1 order by a desc, b desc, c desc;

# BUG#7377 SHOW index on MERGE table crashes debug server
show index from t3;

drop table t1, t2, t3;

#
# Bug#10400 - Improperly-defined MERGE table crashes with INSERT ... ON DUPLICATE KEY UPDATE
#
CREATE TABLE t1 ( a INT AUTO_INCREMENT PRIMARY KEY, b VARCHAR(10), UNIQUE (b) )
  ENGINE=MyISAM;
CREATE TABLE t2 ( a INT AUTO_INCREMENT, b VARCHAR(10), INDEX (a), INDEX (b) )
  ENGINE=MERGE UNION (t1) INSERT_METHOD=FIRST;
INSERT INTO t2 (b) VALUES (1) ON DUPLICATE KEY UPDATE b=2;
INSERT INTO t2 (b) VALUES (1) ON DUPLICATE KEY UPDATE b=3;
SELECT b FROM t2;
DROP TABLE t1, t2;


#
# BUG#5390 - problems with merge tables
# Problem #1: INSERT...SELECT
#
#drop table if exists t1, t2, t3;
create table t1(a int);
create table t2(a int);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int) engine=merge union=(t1, t2) insert_method=first;
select * from t3;
#
insert t2 select * from t2;
select * from t2;
#
insert t3 select * from t1;
select * from t3;
#
insert t1 select * from t3;
select * from t1;
select * from t2;
select * from t3;
check table t1, t2;
drop table t1, t2, t3;

#
# BUG#21617 - crash when selecting from merge table with inconsistent
# indexes
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES(2),(1);
CREATE TABLE t2(a INT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM t2 WHERE a=2;
DROP TABLE t1, t2;

#
# BUG#10974 - No error message if merge table based on union of innodb,
# memory
#
CREATE TABLE t1(a INT) ENGINE=MEMORY;
CREATE TABLE t2(a INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM t2;
DROP TABLE t1, t2;
CREATE TABLE t2(a INT) ENGINE=MERGE UNION=(t3);
--error ER_NO_SUCH_TABLE
SELECT * FROM t2;
DROP TABLE t2;

#
# Underlying table definition conformance tests.
#
CREATE TABLE t1(a INT, b TEXT);
CREATE TABLE tm1(a TEXT, b INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT);
CREATE TABLE tm1(a INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT, KEY(a, b));
CREATE TABLE tm1(a SMALLINT, b SMALLINT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT, KEY(b));
CREATE TABLE tm1(a SMALLINT, b SMALLINT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;


# BUG#26881 - Large MERGE tables report incorrect specification when no
#             differences in tables
#
CREATE TABLE t1(c1 VARCHAR(1));
CREATE TABLE m1 LIKE t1;
ALTER TABLE m1 ENGINE=MERGE UNION=(t1);
SELECT * FROM m1;
DROP TABLE t1, m1;

CREATE TABLE t1(c1 VARCHAR(4), c2 TINYINT, c3 TINYINT, c4 TINYINT,
                c5 TINYINT, c6 TINYINT, c7 TINYINT, c8 TINYINT, c9 TINYINT);
CREATE TABLE m1 LIKE t1;
ALTER TABLE m1 ENGINE=MERGE UNION=(t1);
SELECT * FROM m1;
DROP TABLE t1, m1;

#
# BUG#24342 - Incorrect results with query over MERGE table
#
CREATE TABLE t1 (a VARCHAR(255) CHARACTER SET latin1 COLLATE latin1_german2_ci,
                 b INT, INDEX(a,b));
CREATE TABLE t2 LIKE t1;
CREATE TABLE t3 LIKE t1;
ALTER TABLE t3 ENGINE=MERGE UNION=(t1,t2);
INSERT INTO t1 VALUES ('ss',1);
INSERT INTO t2 VALUES ('ss',2),(0xDF,2);
SELECT COUNT(*) FROM t3 WHERE a=0xDF AND b=2;
DROP TABLE t1,t2,t3;

# End of 4.1 tests

#
# BUG#19648 - Merge table does not work with bit types
#
create table t1 (b bit(1));
create table t2 (b bit(1));
create table tm (b bit(1)) engine = merge union = (t1,t2);
select * from tm;
drop table tm, t1, t2;

#
# Bug #17766: The server accepts to create MERGE tables which cannot work
#
create table t1 (a int) insert_method = last engine = merge;
--error ER_OPEN_AS_READONLY
insert into t1 values (1);
create table t2 (a int) engine = myisam;
alter table t1 union (t2);
insert into t1 values (1);
alter table t1 insert_method = no;
--error ER_OPEN_AS_READONLY
insert into t1 values (1);
drop table t2;
drop table t1;

#
# BUG#26976 - Missing table in merge not noted in related error msg + SHOW
#             CREATE TABLE fails
#
CREATE TABLE tm1(a INT) ENGINE=MERGE UNION=(t1, t2);
--error ER_NO_SUCH_TABLE
SELECT * FROM tm1;
CHECK TABLE tm1;
CREATE TABLE t1(a INT);
--error ER_NO_SUCH_TABLE
SELECT * FROM tm1;
CHECK TABLE tm1;
CREATE TABLE t2(a BLOB);
--error 1168
SELECT * FROM tm1;
CHECK TABLE tm1;
ALTER TABLE t2 MODIFY a INT;
SELECT * FROM tm1;
CHECK TABLE tm1;
DROP TABLE tm1, t1, t2;

#
# Bug#15522 - create ... select and with merge tables
#
# This was fixed together with Bug#20662 (Infinite loop in CREATE TABLE
# IF NOT EXISTS ... SELECT with locked tables).
# The new behavior for MERGE tables is consistent with the
# CREATE TABLE SELECT behavior for ordinary tables.
#
CREATE TABLE t1(c1 INT);
CREATE TABLE t2 (c1 INT) ENGINE=MERGE UNION=(t1) INSERT_METHOD=FIRST;
--error ER_UPDATE_TABLE_USED
CREATE TABLE IF NOT EXISTS t1 SELECT * FROM t2;
DROP TABLE t1, t2;

--echo End of 5.0 tests

#
# Bug #8306: TRUNCATE leads to index corruption 
#
create table t1 (c1 int, index(c1));
create table t2 (c1 int, index(c1)) engine=merge union=(t1);
insert into t1 values (1);
# Close all tables.
flush tables;
# Open t2 and (implicitly) t1.
select * from t2;
# Truncate after flush works (unless another threads reopens t2 in between).
flush tables;
truncate table t1;
insert into t1 values (1);
# Close all tables.
flush tables;
# Open t2 and (implicitly) t1.
select * from t2;
# Truncate t1, wich was not recognized as open without the bugfix.
# After fix for Bug#8306 and before fix for Bug#26379,
# it should fail with a table-in-use error message, otherwise succeed.
truncate table t1;
# The insert used to fail on the crashed table.
insert into t1 values (1);
drop table t1,t2;
--echo #
--echo # Extra tests for TRUNCATE.
--echo #
--echo # Truncate MERGE table.
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1));
CREATE TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate child table.
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
TRUNCATE TABLE t1;
SELECT * FROM t3;
--echo #
--echo # Truncate MERGE table under locked tables.
LOCK TABLE t1 WRITE, t2 WRITE, t3 WRITE;
INSERT INTO t1 VALUES (1);
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate child table under locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t1;
SELECT * FROM t3;
UNLOCK TABLES;
DROP TABLE t1, t2, t3;
--echo #
--echo # Truncate temporary MERGE table.
CREATE TEMPORARY TABLE t1 (c1 INT, INDEX(c1));
CREATE TEMPORARY TABLE t2 (c1 INT, INDEX(c1));
CREATE TEMPORARY TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary child table.
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
TRUNCATE TABLE t1;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary MERGE table under locked tables.
INSERT INTO t1 VALUES (1);
CREATE TABLE t4 (c1 INT, INDEX(c1));
LOCK TABLE t4 WRITE;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary child table under locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t1;
SELECT * FROM t3;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;

#
# Bug#26379 - Combination of FLUSH TABLE and REPAIR TABLE corrupts a MERGE table
# Preparation
connect (con1,localhost,root,,);
connect (con2,localhost,root,,);
connection default;
#
# Bug#26379 - Combination of FLUSH TABLE and REPAIR TABLE corrupts a MERGE table
# Problem #1
# A thread trying to lock a MERGE table performed busy waiting while
# REPAIR TABLE or a similar table administration task was ongoing on one or
# more of its MyISAM tables.
# To allow for observability it was necessary to enter a multi-second sleep
# in mysql_admin_table() after remove_table_from_cache(), which comes after
# mysql_abort_lock(). The sleep faked a long running operation. One could
# watch a high CPU load during the sleep time.
# The problem was that mysql_abort_lock() upgrades the write lock to
# TL_WRITE_ONLY. This lock type persisted until the final unlock at the end
# of the administration task. The effect of TL_WRITE_ONLY is to reject any
# attempt to lock the table. The trying thread must close the table and wait
# until it is no longer used. Unfortunately there is no way to detect that
# one of the MyISAM tables of a MERGE table is in use. When trying to lock
# the MERGE table, all MyISAM tables are locked. If one fails on
# TL_WRITE_ONLY, all locks are aborted and wait_for_tables() is entered.
# But this doesn't see the MERGE table as used, so it seems appropriate to
# retry a lock...
#
CREATE TABLE t1 (c1 INT) ENGINE= MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE= MRG_MYISAM UNION= (t1) INSERT_METHOD= LAST;
send REPAIR TABLE t1;
    connection con1;
    sleep 1; # let repair run into its sleep
    INSERT INTO t2 VALUES (1);
connection default;
reap;
DROP TABLE t1, t2;
#
# Bug#26379 - Combination of FLUSH TABLE and REPAIR TABLE corrupts a MERGE table
# Problem #2
# A thread trying to lock a MERGE table performed busy waiting until all
# threads that did REPAIR TABLE or similar table administration tasks on
# one or more of its MyISAM tables in LOCK TABLES segments did
# UNLOCK TABLES.
# The difference against problem #1 is that the busy waiting took place
# *after* the administration task. It was terminated by UNLOCK TABLES only.
#
# This is the same test case as for
# Bug#26867 - LOCK TABLES + REPAIR + merge table result in memory/cpu hogging
#
#
CREATE TABLE t1 (c1 INT) ENGINE= MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE= MRG_MYISAM UNION= (t1) INSERT_METHOD= LAST;
LOCK TABLE t1 WRITE;
    connection con1;
    send INSERT INTO t2 VALUES (1);
connection default;
sleep 1; # Let INSERT go into thr_multi_lock().
REPAIR TABLE t1;
sleep 2; # con1 performs busy waiting during this sleep.
UNLOCK TABLES;
    connection con1;
    reap;
connection default;
DROP TABLE t1, t2;
#
# Bug#26379 - Combination of FLUSH TABLE and REPAIR TABLE corrupts a MERGE table
# Problem #3
# Two FLUSH TABLES within a LOCK TABLES segment could invalidate the lock.
# This did *not* require a MERGE table.
# To increase reproducibility it was necessary to enter a sleep of 2 seconds
# at the end of wait_for_tables() after unlock of LOCK_open. In 5.0 and 5.1
# the sleep must be inserted in open_and_lock_tables() after open_tables()
# instead. wait_for_tables() is not used in this case.
# The problem was that FLUSH TABLES releases LOCK_open while having unlocked
# and closed all tables. When this happened while a thread was in the loop in
# mysql_lock_tables() right after wait_for_tables() and before retrying to
# lock, the thread got the lock.  (Translate to similar code places in 5.0
# and 5.1). And it did not notice that the table needed a refresh. So it
# executed its statement on the table.
# The first FLUSH TABLES kicked the INSERT out of thr_multi_lock() and let
# it wait in wait_for_tables(). (open_table() in 5.0 and 5.1). The second
# FLUSH TABLES must happen while the INSERT was on its way from
# wait_for_tables() to the next call of thr_multi_lock(). This needed to be
# supported by a sleep to make it repeatable.
#
CREATE TABLE t1 (c1 INT) ENGINE= MyISAM;
LOCK TABLE t1 WRITE;
    connection con1;
    send INSERT INTO t1 VALUES (1);
connection default;
sleep 1; # Let INSERT go into thr_multi_lock().
FLUSH TABLES;
sleep 1; # Let INSERT go through wait_for_tables() where it sleeps.
FLUSH TABLES;
# This should give no result. But it will with sleep(2) at the right place.
SELECT * FROM t1;
UNLOCK TABLES;
    connection con1;
    reap;
connection default;
DROP TABLE t1;
#
# Bug#26379 - Combination of FLUSH TABLE and REPAIR TABLE corrupts a MERGE table
# Cleanup
disconnect con1;
disconnect con2;
#
--echo #
--echo # Extra tests for Bug#26379 - Combination of FLUSH TABLE and
--echo #                             REPAIR TABLE corrupts a MERGE table
#
--echo #
--echo # CREATE ... SELECT is disabled for MERGE tables.
--echo #
CREATE TABLE t1(c1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
--error ER_OPEN_AS_READONLY
CREATE TABLE t3 ENGINE=MRG_MYISAM INSERT_METHOD=LAST SELECT * FROM t2;
--error ER_NO_SUCH_TABLE
SHOW CREATE TABLE t3;
--error ER_WRONG_OBJECT
CREATE TABLE t3 ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST
  SELECT * FROM t2;
--error ER_NO_SUCH_TABLE
SHOW CREATE TABLE t3;
DROP TABLE t1, t2;
#
--echo #
--echo # CREATE ... LIKE
--echo #
--echo # 1. Create like.
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE TABLE t3 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2)
  INSERT_METHOD=LAST;
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
CREATE TABLE t4 LIKE t3;
SHOW CREATE TABLE t4;
--error ER_OPEN_AS_READONLY
INSERT INTO t4 VALUES (4);
DROP TABLE t4;
--echo #
--echo # 1. Create like with locked tables.
LOCK TABLES t3 WRITE, t2 WRITE, t1 WRITE;
CREATE TABLE t4 LIKE t3;
--error ER_TABLE_NOT_LOCKED
SHOW CREATE TABLE t4;
--error ER_TABLE_NOT_LOCKED
INSERT INTO t4 VALUES (4);
UNLOCK TABLES;
SHOW CREATE TABLE t4;
--error ER_OPEN_AS_READONLY
INSERT INTO t4 VALUES (4);
DROP TABLE t4;
#
--echo #
--echo # Rename child.
--echo #
--echo # 1. Normal rename of non-MERGE table.
CREATE TABLE t4 (c1 INT);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
RENAME TABLE t4 TO t5;
SELECT * FROM t5 ORDER BY c1;
RENAME TABLE t5 TO t4;
SELECT * FROM t4 ORDER BY c1;
DROP TABLE t4;
--echo #
--echo # 2. Normal rename.
SELECT * FROM t3 ORDER BY c1;
RENAME TABLE t2 TO t5;
--error ER_NO_SUCH_TABLE
SELECT * FROM t3 ORDER BY c1;
RENAME TABLE t5 TO t2;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 3. Normal rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t2 TO t5;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t5 TO t2;
SELECT * FROM t3 ORDER BY c1;
UNLOCK TABLES;
--echo #
--echo # 4. Alter table rename.
ALTER TABLE t2 RENAME TO t5;
--error ER_NO_SUCH_TABLE
SELECT * FROM t3 ORDER BY c1;
ALTER TABLE t5 RENAME TO t2;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 5. Alter table rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
ALTER TABLE t2 RENAME TO t5;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t3 ORDER BY c1;
--error ER_TABLE_NOT_LOCKED
ALTER TABLE t5 RENAME TO t2;
UNLOCK TABLES;
ALTER TABLE t5 RENAME TO t2;
SELECT * FROM t3 ORDER BY c1;
#
--echo #
--echo # Rename parent.
--echo #
--echo # 1. Normal rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t3 TO t5;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t5 TO t3;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 5. Alter table rename with locked tables.
ALTER TABLE t3 RENAME TO t5;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t5 ORDER BY c1;
--error ER_TABLE_NOT_LOCKED
ALTER TABLE t5 RENAME TO t3;
UNLOCK TABLES;
ALTER TABLE t5 RENAME TO t3;
SELECT * FROM t3 ORDER BY c1;
DROP TABLE t1, t2, t3;
#
--echo #
--echo # Drop locked tables.
--echo #
--echo # 1. Drop parent.
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
LOCK TABLES t1 WRITE, t2 WRITE;
INSERT INTO t1 VALUES (1);
DROP TABLE t2;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t2;
SELECT * FROM t1;
UNLOCK TABLES;
--echo # 2. Drop child.
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
LOCK TABLES t1 WRITE, t2 WRITE;
INSERT INTO t1 VALUES (1);
DROP TABLE t1;
--error ER_NO_SUCH_TABLE
SELECT * FROM t2;
--error ER_NO_SUCH_TABLE
SELECT * FROM t1;
UNLOCK TABLES;
DROP TABLE t2;
#
--echo #
--echo # ALTER TABLE. Change child list.
--echo #
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1));
CREATE TABLE t3 (c1 INT, INDEX(c1));
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
CREATE TABLE t4 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t3,t2)
  INSERT_METHOD=LAST;
--echo # Shrink child list.
ALTER TABLE t4 UNION=(t3);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
--echo # Extend child list.
ALTER TABLE t4 UNION=(t3,t2);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Change child list.
--echo #
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE;
--echo # Shrink child list.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3);
--echo # Extend child list within locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3,t2);
--echo # Extend child list beyond locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3,t2,t1);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t4;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Grave change, table re-creation.
--echo #
CREATE TABLE t4 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2,t3)
  INSERT_METHOD=LAST;
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Simple change, no re-creation.
--echo #
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE TABLE t3 (c1 INT);
CREATE TABLE t4 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2,t3)
  INSERT_METHOD=LAST;
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # FLUSH TABLE under LOCK TABLES.
--echo #
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Triggers
--echo #
--echo # Trigger on parent
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t4_ai AFTER INSERT ON t4 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t4_ai;
--echo # Trigger on parent under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t4_ai AFTER INSERT ON t4 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t4_ai;
UNLOCK TABLES;
--echo #
--echo # Trigger on child
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
INSERT INTO t3 VALUES (33);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t3_ai;
--echo # Trigger on child under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
INSERT INTO t3 VALUES (33);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DELETE FROM t4 WHERE c1 = 33;
DROP TRIGGER t3_ai;
--echo #
--echo # Trigger with table use on child
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW INSERT INTO t2 VALUES(22);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
INSERT INTO t3 VALUES (33);
SELECT * FROM t4 ORDER BY c1;
DELETE FROM t4 WHERE c1 = 22;
DELETE FROM t4 WHERE c1 = 33;
DROP TRIGGER t3_ai;
--echo # Trigger with table use on child under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW INSERT INTO t2 VALUES(22);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
INSERT INTO t3 VALUES (33);
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t3_ai;
DELETE FROM t4 WHERE c1 = 22;
DELETE FROM t4 WHERE c1 = 33;
UNLOCK TABLES;
#
--echo #
--echo # Repair
--echo #
REPAIR TABLE t4;
REPAIR TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
REPAIR TABLE t4;
REPAIR TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Optimize
--echo #
OPTIMIZE TABLE t4;
OPTIMIZE TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
OPTIMIZE TABLE t4;
OPTIMIZE TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Checksum
--echo #
CHECKSUM TABLE t4;
CHECKSUM TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CHECKSUM TABLE t4;
CHECKSUM TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Insert delayed
--echo #
# See also Bug#26464 - insert delayed + update + merge = corruption
# Succeeds in embedded server - is converted to normal insert
# Fails in normal server, ps-protocol - not supported by engine
# Fails in normal server, normal protocol - not a base table
--error 0, ER_ILLEGAL_HA, ER_WRONG_OBJECT
INSERT DELAYED INTO t4 VALUES(44);
# Get rid of row in embedded server
DELETE FROM t4 WHERE c1 = 44;
INSERT DELAYED INTO t3 VALUES(33);
  let $wait_cmd= SHOW STATUS LIKE 'Not_flushed_delayed_rows';
  let $run= query_get_value($wait_cmd, Value, 1);
  while ($run)
  {
    let $run= query_get_value($wait_cmd, Value, 1);
  }
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
--error ER_DELAYED_INSERT_TABLE_LOCKED, ER_ILLEGAL_HA
INSERT DELAYED INTO t4 VALUES(444);
--error ER_DELAYED_INSERT_TABLE_LOCKED, ER_ILLEGAL_HA
INSERT DELAYED INTO t3 VALUES(333);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;
#
--echo #
--echo # Recursive inclusion of merge tables in their union clauses.
--echo #
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t2,t1)
  INSERT_METHOD=LAST;
ALTER TABLE t2 UNION=(t3,t1);
--error ER_ADMIN_WRONG_MRG_TABLE
SELECT * FROM t2;
DROP TABLE t1, t2, t3;


#
# Bug#25038 - Waiting TRUNCATE
#
# Show that truncate of child table after use of parent table works.
CREATE TABLE t1 (c1 INT) ENGINE= MyISAM; 
CREATE TABLE t2 (c1 INT) ENGINE= MyISAM; 
CREATE TABLE t3 (c1 INT) ENGINE= MRG_MYISAM UNION= (t1, t2); 
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t1;
SELECT * FROM t3;
DROP TABLE t1, t2, t3;
#
# Show that truncate of child table waits while parent table is used.
# (test partly borrowed from count_distinct3.)
CREATE TABLE t1 (id INTEGER, grp TINYINT, id_rev INTEGER);
SET @rnd_max= 2147483647;
let $1 = 10;
while ($1)
{
  SET @rnd= RAND();
  SET @id = CAST(@rnd * @rnd_max AS UNSIGNED);
  SET @id_rev= @rnd_max - @id;
  SET @grp= CAST(127.0 * @rnd AS UNSIGNED); 
  INSERT INTO t1 (id, grp, id_rev) VALUES (@id, @grp, @id_rev); 
  dec $1;
}
set @@read_buffer_size=2*1024*1024;
CREATE TABLE t2 SELECT * FROM t1;
INSERT INTO t1 (id, grp, id_rev) SELECT id, grp, id_rev FROM t2;
INSERT INTO t2 (id, grp, id_rev) SELECT id, grp, id_rev FROM t1;
INSERT INTO t1 (id, grp, id_rev) SELECT id, grp, id_rev FROM t2;
INSERT INTO t2 (id, grp, id_rev) SELECT id, grp, id_rev FROM t1;
INSERT INTO t1 (id, grp, id_rev) SELECT id, grp, id_rev FROM t2;
CREATE TABLE t3 (id INTEGER, grp TINYINT, id_rev INTEGER)
  ENGINE= MRG_MYISAM UNION= (t1, t2);
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t2;
SELECT COUNT(*) FROM t3;
connect (con1,localhost,root,,);
    # As t3 contains random numbers, results are different from test to test. 
    # That's okay, because we test only that select doesn't yield an
    # error. Note, that --disable_result_log doesn't suppress error output.
    --disable_result_log
    send SELECT COUNT(DISTINCT a1.id) FROM t3 AS a1, t3 AS a2
      WHERE a1.id = a2.id GROUP BY a2.grp;
connection default;
sleep 1;
TRUNCATE TABLE t1;
    connection con1;
    reap;
    --enable_result_log
    disconnect con1;
connection default;
SELECT COUNT(*) FROM t1;
SELECT COUNT(*) FROM t2;
SELECT COUNT(*) FROM t3;
DROP TABLE t1, t2, t3;

#
# Bug#25700 - merge base tables get corrupted by optimize/analyze/repair table
#
# Using FLUSH TABLES before REPAIR.
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
INSERT INTO t2 VALUES (1);
SELECT * FROM t2;
LOCK TABLES t2 WRITE, t1 WRITE;
FLUSH TABLES;
REPAIR TABLE t1;
CHECK TABLE t1;
REPAIR TABLE t1;
UNLOCK TABLES;
CHECK TABLE t1 EXTENDED;
#
# Not using FLUSH TABLES before REPAIR.
LOCK TABLES t2 WRITE, t1 WRITE;
REPAIR TABLE t1;
CHECK TABLE t1;
REPAIR TABLE t1;
UNLOCK TABLES;
CHECK TABLE t1 EXTENDED;
DROP TABLE t1, t2;

#
# Bug#26377 - Deadlock with MERGE and FLUSH TABLE
#
CREATE TABLE t1 ( a INT ) ENGINE=MyISAM;
CREATE TABLE m1 ( a INT ) ENGINE=MRG_MYISAM UNION=(t1);
# Lock t1 first. This did always work.
LOCK TABLES t1 WRITE, m1 WRITE;
FLUSH TABLE t1;
UNLOCK TABLES;
DROP TABLE m1, t1;
#
CREATE TABLE t1 ( a INT ) ENGINE=MyISAM;
CREATE TABLE m1 ( a INT ) ENGINE=MRG_MYISAM UNION=(t1);
# Lock m1 first. This did deadlock.
LOCK TABLES m1 WRITE, t1 WRITE;
FLUSH TABLE t1;
UNLOCK TABLES;
DROP TABLE m1, t1;

#
# Bug#27660 - Falcon: merge table possible
#
# Normal MyISAM MERGE operation.
CREATE TABLE t1 (c1 INT, c2 INT) ENGINE= MyISAM;
CREATE TABLE t2 (c1 INT, c2 INT) ENGINE= MyISAM;
CREATE TABLE t3 (c1 INT, c2 INT) ENGINE= MRG_MYISAM UNION(t1, t2);
INSERT INTO t1 VALUES (1, 1);
INSERT INTO t2 VALUES (2, 2);
SELECT * FROM t3;
# Try an unsupported engine.
ALTER TABLE t1 ENGINE= MEMORY;
INSERT INTO t1 VALUES (0, 0);
# Before fixing, this succeeded, but (0, 0) was missing.
--error 1168
SELECT * FROM t3;
DROP TABLE t1, t2, t3;

#
# Bug#30275 - Merge tables: flush tables or unlock tables causes server to crash
#
CREATE TABLE t1 (c1 INT, KEY(c1));
CREATE TABLE t2 (c1 INT, KEY(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=FIRST;
LOCK TABLE t1 WRITE, t2 WRITE;
FLUSH TABLES t2, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES t1;
UNLOCK TABLES;
#
FLUSH TABLES;
INSERT INTO t1 VALUES (1);
LOCK TABLE t1 WRITE, t2 WRITE;
FLUSH TABLES t2, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES t1;
UNLOCK TABLES;
DROP TABLE t1, t2;

#
# Test derived from test program for
# Bug#30273 - merge tables: Can't lock file (errno: 155)
#
CREATE TABLE t1 (ID INT) ENGINE=MYISAM;
CREATE TABLE m1 (ID INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=FIRST;
INSERT INTO t1 VALUES ();
INSERT INTO m1 VALUES ();
LOCK TABLE t1 WRITE, m1 WRITE;
FLUSH TABLES m1, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES m1, t1;
UNLOCK TABLES;
DROP TABLE t1, m1;

