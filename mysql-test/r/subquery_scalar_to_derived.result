SET optimizer_switch='subquery_to_derived=on';
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
#
# Tests for WL#12885 Add ability to transform scalar subqueries to inner
# derived table
#
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4);
INSERT INTO t2 VALUES (1),(2);
CREATE TABLE t0 AS SELECT * FROM t1;
CREATE TABLE t3(a INT, b INT);
INSERT INTO t3 VALUES (1,3), (2,3);
ANALYZE TABLE t1, t2, t0, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t0	analyze	status	OK
test.t3	analyze	status	OK
#
# 1. W H E R E  clause subqueries
#
# Implicitly grouped scalar subquery in WHERE clause.
# Automatic transformation to LEFT OUTER join. It is then
# transformed to inner join, and finally the derived table is
# evaluated at optimize or execution time, depending on
# optimization mode.
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Equivalent manually recrafted query: same plan as previous
SELECT t1.* FROM t1 LEFT OUTER JOIN
(SELECT COUNT(a) AS cnt FROM t2) AS derived
ON TRUE
WHERE t1.a > derived.cnt;
a
3
4
explain SELECT t1.* FROM t1 LEFT OUTER JOIN
(SELECT COUNT(a) AS cnt FROM t2) AS derived
ON TRUE
WHERE t1.a > derived.cnt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived` where (`test`.`t1`.`a` > `derived`.`cnt`)
# Implicitly grouped scalar subquery in WHERE clause of joined
# query, here with LEFT JOIN.
# Query 1: Simplified to inner join
SELECT t0.*, t1.* FROM t0 LEFT OUTER JOIN t1 ON t0.a != t1.a
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2);
a	a
1	3
1	4
2	3
2	4
3	4
4	3
explain SELECT t0.*, t1.* FROM t0 LEFT OUTER JOIN t1 ON t0.a != t1.a
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	t0	NULL	ALL	NULL	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t0`.`a` AS `a`,`test`.`t1`.`a` AS `a` from `test`.`t0` join `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived_1_2` where ((`test`.`t1`.`a` > `derived_1_2`.`cnt`) and (`test`.`t0`.`a` <> `test`.`t1`.`a`))
# Query 2: Not simplified to inner join
SELECT * FROM t0 LEFT OUTER JOIN t1 on t0.a = t1.a
WHERE t0.a > (SELECT COUNT(a) AS cnt FROM t2);
a	a
3	3
4	4
explain SELECT * FROM t0 LEFT OUTER JOIN t1 on t0.a = t1.a
WHERE t0.a > (SELECT COUNT(a) AS cnt FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t0	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t0`.`a` AS `a`,`test`.`t1`.`a` AS `a` from `test`.`t0` left join `test`.`t1` on((`test`.`t1`.`a` = `test`.`t0`.`a`)) join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived_1_2` where (`test`.`t0`.`a` > `derived_1_2`.`cnt`)
# Equivalent manually recrafted query: same plan as previous
SELECT t0.*, t1.* FROM (t0 LEFT OUTER JOIN t1 ON t0.a != t1.a) LEFT OUTER JOIN
(SELECT COUNT(a) AS cnt FROM t2) AS derived
ON TRUE
WHERE t1.a > derived.cnt;
a	a
1	3
1	4
2	3
2	4
3	4
4	3
explain SELECT t0.*, t1.* FROM (t0 LEFT OUTER JOIN t1 ON t0.a != t1.a) LEFT OUTER JOIN
(SELECT COUNT(a) AS cnt FROM t2) AS derived
ON TRUE
WHERE t1.a > derived.cnt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	t0	NULL	ALL	NULL	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t0`.`a` AS `a`,`test`.`t1`.`a` AS `a` from `test`.`t0` join `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived` where ((`test`.`t1`.`a` > `derived`.`cnt`) and (`test`.`t0`.`a` <> `test`.`t1`.`a`))
# With deeper nested subquery (subquery inside an OR)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) OR t1.a = 2;
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) OR t1.a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` left join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived_1_2` on(true) where ((`test`.`t1`.`a` > `derived_1_2`.`cnt`) or (`test`.`t1`.`a` = 2))
# More than one subquery in the WHERE condition:
SELECT t1.* FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) AND
t1.a < (SELECT MAX(a) * 4 AS mx FROM t2);
a
3
4
explain SELECT t1.* FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2) AND
t1.a < (SELECT MAX(a) * 4 AS mx FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `derived_1_2` join (/* select#3 */ select (max(`test`.`t2`.`a`) * 4) AS `mx` from `test`.`t2`) `derived_1_3` where ((`test`.`t1`.`a` > `derived_1_2`.`cnt`) and (`test`.`t1`.`a` < `derived_1_3`.`mx`))
# Equivalent manually recrafted query: same plan as previous
SELECT t1.* FROM t1
LEFT JOIN (SELECT COUNT(a) AS cnt FROM t2) AS lj1 ON TRUE
LEFT JOIN (SELECT MAX(a) * 4 AS mx FROM t2) AS lj2 ON TRUE
WHERE t1.a > cnt AND t1.a < mx;
a
3
4
explain SELECT t1.* FROM t1
LEFT JOIN (SELECT COUNT(a) AS cnt FROM t2) AS lj1 ON TRUE
LEFT JOIN (SELECT MAX(a) * 4 AS mx FROM t2) AS lj2 ON TRUE
WHERE t1.a > cnt AND t1.a < mx;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`) `lj1` join (/* select#3 */ select (max(`test`.`t2`.`a`) * 4) AS `mx` from `test`.`t2`) `lj2` where ((`test`.`t1`.`a` > `lj1`.`cnt`) and (`test`.`t1`.`a` < `lj2`.`mx`))
# If we have an implicit grouping we we know that cardinality
# of result set is one, so no need for runtime checking of the
# cardinality of the derived tables
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t3`.`a`) AS `cnt` from `test`.`t3`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# If not, detect if we see more than one row in subquery
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3 GROUP BY a);
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t3 GROUP BY a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t3`.`a`) AS `cnt` from `test`.`t3` group by `test`.`t3`.`a`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1);
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Should work, {2} \ {1} == {2}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 EXCEPT SELECT 1);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 EXCEPT SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	EXCEPT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	EXCEPT RESULT	<except2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` except /* select#3 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Should fail, {2} U {3} \ {1} == {2, 3}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 3 EXCEPT SELECT 1);
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 3 EXCEPT SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
5	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
4	EXCEPT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
6	EXCEPT RESULT	<except5,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join ((/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 3 AS `3`) except /* select#4 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Should return no rows, since the intersection is the empty set
# {2} ∩ {1} == {}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT SELECT 1);
a
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	INTERSECT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	INTERSECT RESULT	<intersect2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` intersect /* select#3 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Should return no rows, since the result is the empty set
# {2} \ {2} == {}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 EXCEPT SELECT 2);
a
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 EXCEPT SELECT 2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	EXCEPT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	EXCEPT RESULT	<except2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` except /* select#3 */ select 2 AS `2`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# This should give one row: {2} ∩ {2} == {2}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT SELECT 2);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT SELECT 2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	INTERSECT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	INTERSECT RESULT	<intersect2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` intersect /* select#3 */ select 2 AS `2`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# This should give one row: {2} ∩ {2} == {2}
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT ALL SELECT 2);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 INTERSECT ALL SELECT 2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	INTERSECT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	INTERSECT RESULT	<intersect2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` intersect all /* select#3 */ select 2 AS `2`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# This should remove the duplicate: {1, 1} ∩ALL {1} == {1}, so ok
SELECT * FROM t1
WHERE t1.a > ((SELECT COUNT(a) AS cnt FROM t2 GROUP BY a LIMIT 2) INTERSECT ALL SELECT 1);
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > ((SELECT COUNT(a) AS cnt FROM t2 GROUP BY a LIMIT 2) INTERSECT ALL SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
3	INTERSECT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	INTERSECT RESULT	<intersect2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join ((/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` group by `test`.`t2`.`a` limit 2) intersect all /* select#3 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# ditto
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 GROUP BY a  INTERSECT ALL SELECT 1);
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 GROUP BY a  INTERSECT ALL SELECT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
3	INTERSECT	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	INTERSECT RESULT	<intersect2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` group by `test`.`t2`.`a` intersect all /* select#3 */ select 1 AS `1`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Empty scalar subquery
SELECT * FROM t1
WHERE t1.a > (SELECT a from t1 WHERE false);
a
explain SELECT * FROM t1
WHERE t1.a > (SELECT a from t1 WHERE false);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	0	0.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where false) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`a`)
SELECT a + (SELECT a from t1 WHERE false) FROM t1;
a + (SELECT a from t1 WHERE false)
NULL
NULL
NULL
NULL
explain SELECT a + (SELECT a from t1 WHERE false) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	0	0.00	Using where; Using join buffer (hash join)
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`a` + `derived_1_2`.`a`) AS `a + (SELECT a from t1 WHERE false)` from `test`.`t1` left join (/* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where false) `derived_1_2` on(true) where true
# If we limit the cardinality, it should work:
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1` limit 1) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
# Check that offset/limit doesn't fool us:
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 1);
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1` limit 1,1) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 0);
a
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 1 OFFSET 0);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1` limit 0,1) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 0);
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 0);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1` limit 0,2) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 1);
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION SELECT 1 LIMIT 2 OFFSET 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union /* select#3 */ select 1 AS `1` limit 1,2) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION (SELECT 1 LIMIT 1));
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2 UNION (SELECT 1 LIMIT 1));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	UNION	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2` union (/* select#3 */ select 1 AS `1` limit 1)) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`cnt`)
Without aggregation
SELECT * FROM t1
WHERE t1.a > (SELECT a FROM t2 LIMIT 1);
a
2
3
4
explain SELECT * FROM t1
WHERE t1.a > (SELECT a FROM t2 LIMIT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select `test`.`t2`.`a` AS `a` from `test`.`t2` limit 1) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`a`)
SELECT * FROM t1
WHERE t1.a > (SELECT a FROM t2);
ERROR 21000: Subquery returns more than 1 row
explain SELECT * FROM t1
WHERE t1.a > (SELECT a FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`) `derived_1_2` where (`test`.`t1`.`a` > `derived_1_2`.`a`)
In the below, the query block under consideration for transformation is
the outer subquery. It

a) contains a scalar subquery in its select list
b) is implicitly grouped, cf. SUM(a)

so we trigger an attempt to put the grouping into a separate derived
table.  But we also see that it contains an aggregate that has an outer
reference, SUM(t3.a), so we leave it untouched.
EXPLAIN
SELECT (SELECT SUM(a) + (SELECT SUM(t1.a) FROM t1) + SUM(t3.a) FROM t2) FROM t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DEPENDENT SUBQUERY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
5	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
4	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t3.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select ((`derived_2_4`.`tmp_aggr_1` + `derived_2_5`.`SUM(t1.a)`) + sum(`test`.`t3`.`a`)) from (/* select#4 */ select sum(`test`.`t2`.`a`) AS `tmp_aggr_1` from `test`.`t2`) `derived_2_4` left join (/* select#5 */ select sum(`test`.`t1`.`a`) AS `SUM(t1.a)` from `test`.`t1`) `derived_2_5` on(true) where true) AS `(SELECT SUM(a) + (SELECT SUM(t1.a) FROM t1) + SUM(t3.a) FROM t2)` from `test`.`t3`
Don't try transform grouping into a derived table if we have a reference
to the scalar subquery in the HAVING clause
EXPLAIN
SELECT SUM(a), (SELECT SUM(b) FROM t3) scalar FROM t1 HAVING SUM(a) > scalar;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select sum(`test`.`t1`.`a`) AS `SUM(a)`,(/* select#2 */ select sum(`test`.`t3`.`b`) from `test`.`t3`) AS `scalar` from `test`.`t1` having (sum(`test`.`t1`.`a`) > `scalar`)
#
# Check that we disable transform if we set a user variable in the query
# cf. WL#12885 requirement FR#6.
#
EXPLAIN SELECT t1.a + (@foo:=3) FROM t1
WHERE t1.a > (SELECT COUNT(a) AS cnt FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	33.33	Using where
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
Note	1003	/* select#1 */ select (`test`.`t1`.`a` + (@foo:=3)) AS `t1.a + (@foo:=3)` from `test`.`t1` where (`test`.`t1`.`a` > (/* select#2 */ select count(`test`.`t2`.`a`) AS `cnt` from `test`.`t2`))
#
# Check that RAND precludes transform
#
explain SELECT DISTINCT 3 + (SELECT COUNT(a) + RAND() FROM t1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
2	UNCACHEABLE SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select distinct (3 + (/* select#2 */ select (count(`test`.`t1`.`a`) + rand()) from `test`.`t1`)) AS `3 + (SELECT COUNT(a) + RAND() FROM t1)` from `test`.`t1`
SELECT COUNT(*) > 1 FROM (SELECT DISTINCT 3 + (SELECT COUNT(a) + RAND() FROM t1) FROM t1) AS dt;
COUNT(*) > 1
1
#
# 1.1  J O I N   C O N D I T I O N  containing scalar subquery
#
SELECT t1.a, t2.a
FROM t1
JOIN t2
ON t1.a+t2.a = (SELECT COUNT(*) FROM t1);
a	a
2	2
3	1
explain SELECT t1.a, t2.a
FROM t1
JOIN t2
ON t1.a+t2.a = (SELECT COUNT(*) FROM t1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` join `test`.`t2` where ((`test`.`t1`.`a` + `test`.`t2`.`a`) = `derived_1_2`.`COUNT(*)`)
SELECT t1.a, t2.a, t3.a
FROM t1
JOIN t2
ON t1.a+t2.a = (SELECT COUNT(*) FROM t1)
JOIN t3
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
a	a	a
2	2	1
2	2	2
explain SELECT t1.a, t2.a, t3.a
FROM t1
JOIN t2
ON t1.a+t2.a = (SELECT COUNT(*) FROM t1)
JOIN t3
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (hash join)
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a`,`test`.`t3`.`a` AS `a` from `test`.`t1` join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` join `test`.`t2` join (/* select#3 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`) `derived_1_3` join `test`.`t3` where (((`test`.`t1`.`a` + `derived_1_3`.`MIN(a)`) = `test`.`t3`.`b`) and ((`test`.`t1`.`a` + `test`.`t2`.`a`) = `derived_1_2`.`COUNT(*)`))
OUTER join
SELECT t1.a, t2.a, t3.a
FROM t1
LEFT JOIN ( t2
JOIN t3
ON t2.a = (SELECT COUNT(*) FROM t1) )
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
a	a	a
1	NULL	NULL
2	NULL	NULL
3	NULL	NULL
4	NULL	NULL
explain SELECT t1.a, t2.a, t3.a
FROM t1
LEFT JOIN ( t2
JOIN t3
ON t2.a = (SELECT COUNT(*) FROM t1) )
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a`,`test`.`t3`.`a` AS `a` from `test`.`t1` left join (/* select#3 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`) `derived_1_3` on(true) left join (`test`.`t2` join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` join `test`.`t3`) on((((`test`.`t1`.`a` + `derived_1_3`.`MIN(a)`) = `test`.`t3`.`b`) and (`test`.`t2`.`a` = `derived_1_2`.`COUNT(*)`))) where true
SET optimizer_switch='subquery_to_derived=default';
SELECT t1.a, t2.a, t3.a
FROM t1
LEFT JOIN ( t2
JOIN t3
ON t2.a = (SELECT COUNT(*) FROM t1) )
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
a	a	a
1	NULL	NULL
2	NULL	NULL
3	NULL	NULL
4	NULL	NULL
SET optimizer_switch='subquery_to_derived=on';
This is a manually transformed version of the above.
SELECT t1.a, t2.a, t3.a
FROM t1
LEFT JOIN (SELECT MIN(a) FROM t1) derived_1
ON TRUE
LEFT JOIN ( t2
LEFT JOIN (SELECT COUNT(*) FROM t1) AS derived_2
ON TRUE
JOIN t3
ON t2.a = derived_2.`COUNT(*)` )
ON t1.a + derived_1.`MIN(a)` = t3.b;
a	a	a
1	NULL	NULL
2	NULL	NULL
3	NULL	NULL
4	NULL	NULL
explain SELECT t1.a, t2.a, t3.a
FROM t1
LEFT JOIN (SELECT MIN(a) FROM t1) derived_1
ON TRUE
LEFT JOIN ( t2
LEFT JOIN (SELECT COUNT(*) FROM t1) AS derived_2
ON TRUE
JOIN t3
ON t2.a = derived_2.`COUNT(*)` )
ON t1.a + derived_1.`MIN(a)` = t3.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a`,`test`.`t3`.`a` AS `a` from `test`.`t1` left join (/* select#2 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`) `derived_1` on(true) left join (`test`.`t2` join (/* select#3 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_2` join `test`.`t3`) on((((`test`.`t1`.`a` + `derived_1`.`MIN(a)`) = `test`.`t3`.`b`) and (`test`.`t2`.`a` = `derived_2`.`COUNT(*)`))) where true
SELECT t1.a, t2.a, t3.a
FROM t1
STRAIGHT_JOIN ( t2
STRAIGHT_JOIN t3
ON t2.a = (SELECT COUNT(*) FROM t1) )
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
a	a	a
explain SELECT t1.a, t2.a, t3.a
FROM t1
STRAIGHT_JOIN ( t2
STRAIGHT_JOIN t3
ON t2.a = (SELECT COUNT(*) FROM t1) )
ON t1.a + (SELECT MIN(a) FROM t1) = t3.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a`,`test`.`t3`.`a` AS `a` from `test`.`t1` join (/* select#3 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`) `derived_1_3` join `test`.`t2` join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` straight_join `test`.`t3` where (((`test`.`t1`.`a` + `derived_1_3`.`MIN(a)`) = `test`.`t3`.`b`) and (`test`.`t2`.`a` = `derived_1_2`.`COUNT(*)`))
#
# 2. S E L E C T  list expression subqueries
#
SELECT a + (SELECT -SUM(a) FROM t1) AS cnt FROM t2;
cnt
-9
-8
explain SELECT a + (SELECT -SUM(a) FROM t1) AS cnt FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t2`.`a` + `derived_1_2`.`-SUM(a)`) AS `cnt` from `test`.`t2` left join (/* select#2 */ select -(sum(`test`.`t1`.`a`)) AS `-SUM(a)` from `test`.`t1`) `derived_1_2` on(true) where true
# Equivalent manually recrafted query: same plan as previous
SELECT a + derived.cnt
FROM t2
LEFT OUTER JOIN (SELECT -SUM(a) AS cnt FROM t1) AS derived
ON TRUE;
a + derived.cnt
-8
-9
explain SELECT a + derived.cnt
FROM t2
LEFT OUTER JOIN (SELECT -SUM(a) AS cnt FROM t1) AS derived
ON TRUE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t2`.`a` + `derived`.`cnt`) AS `a + derived.cnt` from `test`.`t2` left join (/* select#2 */ select -(sum(`test`.`t1`.`a`)) AS `cnt` from `test`.`t1`) `derived` on(true) where true
#
# 2.1  S E L E C T  list expression subqueries and UNION
#
SELECT a + (SELECT SUM(a) FROM t1) FROM t1 UNION ALL
SELECT a + (SELECT SUM(a) FROM t1) FROM t1;
a + (SELECT SUM(a) FROM t1)
11
12
13
14
11
12
13
14
explain SELECT a + (SELECT SUM(a) FROM t1) FROM t1 UNION ALL
SELECT a + (SELECT SUM(a) FROM t1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
3	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
3	UNION	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`a` + `derived_1_2`.`SUM(a)`) AS `a + (SELECT SUM(a) FROM t1)` from `test`.`t1` left join (/* select#2 */ select sum(`test`.`t1`.`a`) AS `SUM(a)` from `test`.`t1`) `derived_1_2` on(true) where true union all /* select#3 */ select (`test`.`t1`.`a` + `derived_3_4`.`SUM(a)`) AS `a + (SELECT SUM(a) FROM t1)` from `test`.`t1` left join (/* select#4 */ select sum(`test`.`t1`.`a`) AS `SUM(a)` from `test`.`t1`) `derived_3_4` on(true) where true
#
# 3. N E S T E D  scalar subqueries
#
SELECT a + (SELECT SUM(a) + (SELECT COUNT(a) FROM t1) FROM t1) AS cnt FROM t2;
cnt
15
16
explain SELECT a + (SELECT SUM(a) + (SELECT COUNT(a) FROM t1) FROM t1) AS cnt FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
2	DERIVED	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DERIVED	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
5	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t2`.`a` + `derived_1_2`.`SUM(a) + (SELECT COUNT(a) FROM t1)`) AS `cnt` from `test`.`t2` left join (/* select#2 */ select (`derived_2_4`.`tmp_aggr_1` + `derived_2_5`.`COUNT(a)`) AS `SUM(a) + (SELECT COUNT(a) FROM t1)` from (/* select#4 */ select sum(`test`.`t1`.`a`) AS `tmp_aggr_1` from `test`.`t1`) `derived_2_4` left join (/* select#5 */ select count(`test`.`t1`.`a`) AS `COUNT(a)` from `test`.`t1`) `derived_2_5` on(true) where true) `derived_1_2` on(true) where true
# Equivalent manually recrafted query: same plan as previous
SELECT (t2.a + derived_1_0.sum_plus_cnt) AS cnt
FROM t2
LEFT JOIN (SELECT (derived_2_0.tmp_aggr_1 + derived_2_1.count_a) AS sum_plus_cnt
FROM (SELECT STRAIGHT_JOIN SUM(t1.a) AS tmp_aggr_1 from t1) derived_2_0
LEFT JOIN (SELECT COUNT(t1.a) AS count_a from t1) derived_2_1
ON TRUE) derived_1_0
ON TRUE;
cnt
15
16
explain SELECT (t2.a + derived_1_0.sum_plus_cnt) AS cnt
FROM t2
LEFT JOIN (SELECT (derived_2_0.tmp_aggr_1 + derived_2_1.count_a) AS sum_plus_cnt
FROM (SELECT STRAIGHT_JOIN SUM(t1.a) AS tmp_aggr_1 from t1) derived_2_0
LEFT JOIN (SELECT COUNT(t1.a) AS count_a from t1) derived_2_1
ON TRUE) derived_1_0
ON TRUE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t2`.`a` + (`derived_2_0`.`tmp_aggr_1` + `derived_2_1`.`count_a`)) AS `cnt` from `test`.`t2` left join ((/* select#3 */ select straight_join sum(`test`.`t1`.`a`) AS `tmp_aggr_1` from `test`.`t1`) `derived_2_0` left join (/* select#4 */ select count(`test`.`t1`.`a`) AS `count_a` from `test`.`t1`) `derived_2_1` on(true)) on(true) where true
SELECT a + (SELECT SUM(a) + (SELECT COUNT(a) FROM t1)
FROM (SELECT * from t1) t11) AS cnt FROM t2;
cnt
15
16
SELECT AVG(a) OVER () AS `avg`,
a + (SELECT SUM(a) + (SELECT COUNT(a) FROM t1)
FROM (SELECT * from t1) t11) AS cnt FROM t2;
avg	cnt
1.5000	15
1.5000	16
DROP TABLE t0, t1, t2, t3;
#
# 4. C O R R E L A T E D   query to derived with LATERAL
#
# Note: this feature has been disabled for WL#12885.
# The tests are kept in case we re-enable this transformation
#
CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 (a) VALUES (1), (2);
CREATE TABLE t2 SELECT * FROM t1;
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
SELECT (WITH RECURSIVE dt AS (SELECT t1.a AS a UNION
SELECT a+1 FROM dt WHERE a<10)
SELECT t1.a * CONCAT(COUNT(*), '.', FLOOR(AVG(dt.a)))
FROM dt) AS subq
FROM t1;
subq
10.5
19.2
explain SELECT (WITH RECURSIVE dt AS (SELECT t1.a AS a UNION
SELECT a+1 FROM dt WHERE a<10)
SELECT t1.a * CONCAT(COUNT(*), '.', FLOOR(AVG(dt.a)))
FROM dt) AS subq
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DEPENDENT DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNCACHEABLE UNION	dt	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Recursive; Using where
6	UNION RESULT	<union3,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (with recursive `dt` as (/* select#3 */ select `test`.`t1`.`a` AS `a` union /* select#4 */ select (`dt`.`a` + 1) AS `a+1` from `dt` where (`dt`.`a` < 10)) /* select#2 */ select (`test`.`t1`.`a` * concat(count(0),'.',floor(avg(`dt`.`a`)))) from `dt`) AS `subq` from `test`.`t1`
# Equivalent manually recrafted query: same plan as previous
SELECT derived0.cnct AS subq
FROM t1
LEFT JOIN LATERAL (WITH RECURSIVE dt AS (SELECT t1.a AS a UNION
SELECT (dt.a + 1)
FROM dt WHERE dt.a < 10)
SELECT t1.a * CONCAT(COUNT(0), '.', FLOOR(AVG(dt.a))) AS cnct
FROM dt) derived0
ON TRUE;
subq
10.5
19.2
explain SELECT derived0.cnct AS subq
FROM t1
LEFT JOIN LATERAL (WITH RECURSIVE dt AS (SELECT t1.a AS a UNION
SELECT (dt.a + 1)
FROM dt WHERE dt.a < 10)
SELECT t1.a * CONCAT(COUNT(0), '.', FLOOR(AVG(dt.a))) AS cnct
FROM dt) derived0
ON TRUE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Rematerialize (<derived2>)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
2	DEPENDENT DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DEPENDENT DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
4	UNCACHEABLE UNION	dt	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Recursive; Using where
6	UNION RESULT	<union3,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	Using temporary
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `derived0`.`cnct` AS `subq` from `test`.`t1` left join lateral (with recursive `dt` as (/* select#3 */ select `test`.`t1`.`a` AS `a` union /* select#4 */ select (`dt`.`a` + 1) AS `(dt.a + 1)` from `dt` where (`dt`.`a` < 10)) /* select#2 */ select (`test`.`t1`.`a` * concat(count(0),'.',floor(avg(`dt`.`a`)))) AS `cnct` from `dt`) `derived0` on(true) where true
DROP TABLE t1, t2;
# Detect correlation outside of transformed query block which
# is not caught by the scalar aggregate function inspection in
# Item_singlerow_subselect::collect_scalar_subqueries. If there
# is such a subquery, we skip transformation of that block.
CREATE TABLE t1(i INT);
CREATE TABLE t2(a INT);
CREATE TABLE t3(x INT);
ANALYZE TABLE t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN
SELECT (
SELECT (SELECT COUNT(*) FROM t2) +
(SELECT AVG(a)
FROM t2
WHERE t2.a = t3.x) AS aggs
FROM t1
) AS bignest
FROM t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t3.x' of SELECT #4 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select (`derived_2_3`.`COUNT(*)` + (/* select#4 */ select avg(`test`.`t2`.`a`) from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t3`.`x`))) AS `aggs` from `test`.`t1` left join (/* select#3 */ select count(0) AS `COUNT(*)` from `test`.`t2`) `derived_2_3` on(true) where true) AS `bignest` from `test`.`t3`
# Without that subquery, we transform the level 2 query block,
# but the the outermost still contains its subquery.
EXPLAIN
SELECT (
SELECT (SELECT COUNT(*) FROM t2) AS aggs
FROM t1
) AS bignest
FROM t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `derived_1_2`.`aggs` AS `bignest` from `test`.`t3` left join (/* select#2 */ select `derived_2_3`.`COUNT(*)` AS `aggs` from `test`.`t1` left join (/* select#3 */ select count(0) AS `COUNT(*)` from `test`.`t2`) `derived_2_3` on(true) where true) `derived_1_2` on(true) where true
DROP TABLE t1, t2, t3;
#
# 5.  S U B Q U E R Y   I N   S E L E C T   L I S T   +   G R O U P E D
#     O U T E R   Q U E R Y
#
CREATE TABLE t1 (a INT NOT NULL, b SMALLINT);
INSERT INTO t1 VALUES (12,12);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
# subquery is separate in SELECT list
SELECT (SELECT COUNT(*)
FROM t1
WHERE a=11725) AS tot,
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE false;
tot	mx
0	6
explain SELECT (SELECT COUNT(*)
FROM t1
WHERE a=11725) AS tot,
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE false;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
3	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `derived_1_4`.`COUNT(*)` AS `tot`,((ifnull(`derived_1_3`.`MAX(b)`,0) + 1) + 5) AS `mx` from (/* select#3 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1` where false) `derived_1_3` left join (/* select#4 */ select count(0) AS `COUNT(*)` from `test`.`t1` where (`test`.`t1`.`a` = 11725)) `derived_1_4` on(true) where true
# subquery is part of expression with aggregate in SELECT list
SELECT (SELECT COUNT(*)
FROM t1
WHERE a=11725) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE false;
mx
6
explain SELECT (SELECT COUNT(*)
FROM t1
WHERE a=11725) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE false;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
3	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select (((`derived_1_4`.`COUNT(*)` + ifnull(`derived_1_3`.`MAX(b)`,0)) + 1) + 5) AS `mx` from (/* select#3 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1` where false) `derived_1_3` left join (/* select#4 */ select count(0) AS `COUNT(*)` from `test`.`t1` where (`test`.`t1`.`a` = 11725)) `derived_1_4` on(true) where true
INSERT INTO t1 VALUES (13, 12);
# outer query has DISTINCT, verify it is retained
SELECT DISTINCT (SELECT COUNT(*)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE a > 5
GROUP BY a;
mx
20
explain SELECT DISTINCT (SELECT COUNT(*)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
WHERE a > 5
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select distinct (((`derived_1_2`.`COUNT(*)` + ifnull(max(`test`.`t1`.`b`),0)) + 1) + 5) AS `mx` from `test`.`t1` left join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` on(true) where (`test`.`t1`.`a` > 5) group by `test`.`t1`.`a`
# outer query has LIMIT: verify it is retained
SELECT (SELECT COUNT(*)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
GROUP BY a LIMIT 1;
mx
20
explain SELECT (SELECT COUNT(*)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1
GROUP BY a LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (((`derived_1_2`.`COUNT(*)` + ifnull(max(`test`.`t1`.`b`),0)) + 1) + 5) AS `mx` from `test`.`t1` left join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_1_2` on(true) where true group by `test`.`t1`.`a` limit 1
# The subquery under under consideration for transformation contains a
# aggregate function (MIN(t1_outer.a) and we have no explicit grouping,
# so it would a priori be a candidate putting in a derived table.  But
# here, the aggregation function is aggregated in a query block outer to
# the one being transformed.  This means we do not need to push it into a
# derived table.
SELECT
(SELECT (SELECT COUNT(*)
FROM t1) +
MAX(t1.b) + MIN(t1_outer.a) AS tot
FROM t1) FROM t1 AS t1_outer;
(SELECT (SELECT COUNT(*)
FROM t1) +
MAX(t1.b) + MIN(t1_outer.a) AS tot
FROM t1)
26
explain SELECT
(SELECT (SELECT COUNT(*)
FROM t1) +
MAX(t1.b) + MIN(t1_outer.a) AS tot
FROM t1) FROM t1 AS t1_outer;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1_outer	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DEPENDENT SUBQUERY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
5	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1_outer.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select ((`derived_2_5`.`COUNT(*)` + `derived_2_4`.`tmp_aggr_1`) + min(`test`.`t1_outer`.`a`)) AS `tot` from (/* select#4 */ select max(`test`.`t1`.`b`) AS `tmp_aggr_1` from `test`.`t1`) `derived_2_4` left join (/* select#5 */ select count(0) AS `COUNT(*)` from `test`.`t1`) `derived_2_5` on(true) where true) AS `(SELECT (SELECT COUNT(*)
FROM t1) +
MAX(t1.b) + MIN(t1_outer.a) AS tot
FROM t1)` from `test`.`t1` `t1_outer`
# Aggregate aggregates in the transformation query block, but is
# contained in a subquery. Currently, this blocks transformation, but can
# be fixed if we let Item::transform visit subqueries.
SELECT (SELECT COUNT(*)
FROM t1) +
MAX(b) +
(SELECT MIN(a) + AVG(top.a) FROM t1)
AS tot
FROM t1 top;
tot
38.5000
explain SELECT (SELECT COUNT(*)
FROM t1) +
MAX(b) +
(SELECT MIN(a) + AVG(top.a) FROM t1)
AS tot
FROM t1 top;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	top	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.top.a' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select (((/* select#2 */ select count(0) from `test`.`t1`) + max(`test`.`top`.`b`)) + (/* select#3 */ select (min(`test`.`t1`.`a`) + avg(`test`.`top`.`a`)) from `test`.`t1`)) AS `tot` from `test`.`t1` `top`
# correlated version:
# explicit grouping, no need for moving the grouping down into a
# derived table
SELECT (SELECT COUNT(*) + `outer`.a
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1 AS `outer`
GROUP BY a;
mx
32
33
explain SELECT (SELECT COUNT(*) + `outer`.a
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1 AS `outer`
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	outer	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
2	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.outer.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select ((((/* select#2 */ select (count(0) + `test`.`outer`.`a`) from `test`.`t1`) + ifnull(max(`test`.`outer`.`b`),0)) + 1) + 5) AS `mx` from `test`.`t1` `outer` group by `test`.`outer`.`a`
Translated first step by hand
SELECT (SELECT COUNT(*) + derived_1.d_1 FROM t1) +
IFNULL(derived_1.`MAX(b)`,0) + 1 + 5 AS mx
FROM (SELECT STRAIGHT_JOIN MAX(outer_t.b) AS `MAX(b)`,
outer_t.a AS d_1
FROM t1 outer_t
GROUP BY outer_t.a) derived_1;
mx
32
33
Translated by hand
SELECT (derived_1.`COUNT(*) + outer_t.a` +
IFNULL(derived_0.`MAX(b)`,0)) + 1 + 5 AS mx
FROM (SELECT STRAIGHT_JOIN MAX(outer_t.b) AS `MAX(b)`,
outer_t.a AS d_1
FROM t1 outer_t
GROUP BY outer_t.a) derived_0
LEFT JOIN LATERAL (SELECT (COUNT(0) + derived_0.d_1)
AS `COUNT(*) + outer_t.a`
                        FROM t1) derived_1
ON(true)
WHERE true;
mx
32
33
# correlated version, with outer aggregate, not transformed
SELECT (SELECT COUNT(*) + MAX(outer_t.b)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1 AS outer_t
GROUP BY a;
mx
32
32
explain SELECT (SELECT COUNT(*) + MAX(outer_t.b)
FROM t1) +
IFNULL(MAX(b),0)+1 + 5 AS mx
FROM t1 AS outer_t
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	outer_t	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
2	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.outer_t.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select ((((/* select#2 */ select (count(0) + max(`test`.`outer_t`.`b`)) from `test`.`t1`) + ifnull(max(`test`.`outer_t`.`b`),0)) + 1) + 5) AS `mx` from `test`.`t1` `outer_t` group by `test`.`outer_t`.`a`
DROP TABLE t1;
#
# More complex example
#
CREATE VIEW events_digest AS
SELECT * FROM performance_schema.events_statements_summary_by_digest;
SELECT s2.avg_us avg_us,
IFNULL(SUM(s1.cnt)/NULLIF((SELECT COUNT(*) FROM
events_digest), 0), 0) percentile
FROM sys.`x$ps_digest_avg_latency_distribution` AS s1
JOIN sys.`x$ps_digest_avg_latency_distribution` AS s2
ON s1.avg_us <= s2.avg_us
GROUP BY s2.avg_us
HAVING IFNULL(SUM(s1.cnt)/ NULLIF((SELECT COUNT(*) FROM events_digest), 0), 0) > 0.95
ORDER BY percentile LIMIT 1;
avg_us	percentile
xxxxx	xxxxx
EXPLAIN
SELECT s2.avg_us avg_us,
IFNULL(SUM(s1.cnt)/NULLIF((SELECT COUNT(*) FROM
events_digest), 0), 0) percentile
FROM sys.`x$ps_digest_avg_latency_distribution` AS s1
JOIN sys.`x$ps_digest_avg_latency_distribution` AS s2
ON s1.avg_us <= s2.avg_us
GROUP BY s2.avg_us
HAVING IFNULL(SUM(s1.cnt)/ NULLIF((SELECT COUNT(*) FROM events_digest), 0), 0) > 0.95
ORDER BY percentile LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary; Using filesort
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	200	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary
4	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary
3	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	NULL
2	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `sys`.`s2`.`avg_us` AS `avg_us`,ifnull((sum(`sys`.`s1`.`cnt`) / nullif(`derived_1_2`.`COUNT(*)`,0)),0) AS `percentile` from `sys`.`x$ps_digest_avg_latency_distribution` `s1` join `sys`.`x$ps_digest_avg_latency_distribution` `s2` left join (/* select#2 */ select count(0) AS `COUNT(*)` from `performance_schema`.`events_statements_summary_by_digest`) `derived_1_2` on(true) left join (/* select#3 */ select count(0) AS `COUNT(*)` from `performance_schema`.`events_statements_summary_by_digest`) `derived_1_3` on(true) where (`sys`.`s1`.`avg_us` <= `sys`.`s2`.`avg_us`) group by `sys`.`s2`.`avg_us` having (ifnull((sum(`sys`.`s1`.`cnt`) / nullif(`derived_1_3`.`COUNT(*)`,0)),0) > 0.95) order by `percentile` limit 1
# Manually translated, equivalent query (except we need to
# include the derived_1_1.`COUNT(*)` in the select list for it
# to be resolvable in the HAVING clause), and we need to
# disable strict group checking: safe, but not recognized as
# such by server..
SET sql_mode='';
EXPLAIN
SELECT s2.avg_us AS avg_us,
IFNULL((SUM(s1.cnt) / NULLIF(derived_1_0.`COUNT(*)`,0)),0) AS percentile,
derived_1_1.`COUNT(*)`
FROM sys.`x$ps_digest_avg_latency_distribution` s1 JOIN
sys.`x$ps_digest_avg_latency_distribution` s2 LEFT JOIN
(SELECT COUNT(0) AS `COUNT(*)`
      FROM performance_schema.events_statements_summary_by_digest) derived_1_0
ON(TRUE) LEFT JOIN
(SELECT COUNT(0) AS `COUNT(*)`
      FROM performance_schema.events_statements_summary_by_digest) derived_1_1
ON(TRUE)
WHERE (s1.avg_us <= s2.avg_us)
GROUP BY s2.avg_us
HAVING (IFNULL((SUM(s1.cnt) / NULLIF(derived_1_1.`COUNT(*)`,0)),0) > 0.95)
ORDER BY percentile LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary; Using filesort
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	200	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
5	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary
4	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	Using temporary
3	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	NULL
2	DERIVED	events_statements_summary_by_digest	NULL	ALL	NULL	NULL	NULL	NULL	200	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `sys`.`s2`.`avg_us` AS `avg_us`,ifnull((sum(`sys`.`s1`.`cnt`) / nullif(`derived_1_0`.`COUNT(*)`,0)),0) AS `percentile`,`derived_1_1`.`COUNT(*)` AS `COUNT(*)` from `sys`.`x$ps_digest_avg_latency_distribution` `s1` join `sys`.`x$ps_digest_avg_latency_distribution` `s2` left join (/* select#2 */ select count(0) AS `COUNT(*)` from `performance_schema`.`events_statements_summary_by_digest`) `derived_1_0` on(true) left join (/* select#3 */ select count(0) AS `COUNT(*)` from `performance_schema`.`events_statements_summary_by_digest`) `derived_1_1` on(true) where (`sys`.`s1`.`avg_us` <= `sys`.`s2`.`avg_us`) group by `sys`.`s2`.`avg_us` having (ifnull((sum(`sys`.`s1`.`cnt`) / nullif(`derived_1_1`.`COUNT(*)`,0)),0) > 0.95) order by `percentile` limit 1
SET sql_mode=default;
# outer query has window: verify it is retained on outer level
SELECT AVG(s2.avg_us) OVER () + 3 AS avgsum,
s2.avg_us avg_us,
s2.avg_us avg_us2,
SUM(s2.avg_us) OVER () + 3 AS avgsum2,
IFNULL(SUM(s1.cnt)/NULLIF((SELECT COUNT(*) FROM
events_digest), 0), 0) percentile
FROM sys.`x$ps_digest_avg_latency_distribution` AS s1
JOIN sys.`x$ps_digest_avg_latency_distribution` AS s2
ON s1.avg_us <= s2.avg_us
GROUP BY s2.avg_us
HAVING IFNULL(SUM(s1.cnt)/ NULLIF((SELECT COUNT(*) FROM events_digest), 0), 0) > 0.95
ORDER BY percentile LIMIT 1;
avgsum	avg_us	avg_us2	avgsum2	percentile
xxxxx	xxxxx	xxxxx	xxxxx	xxxxx
DROP VIEW events_digest;
# An example with aggregates in ORDER BY and HAVING not seen in SELECT list
CREATE TABLE t1 (
school_name VARCHAR(45) NOT NULL,
country     VARCHAR(45) NOT NULL,
funds_requested FLOAT NOT NULL,
schooltype  VARCHAR(45) NOT NULL
);
INSERT INTO t1 VALUES ("the school", "USA", 1200, "Human");
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT COUNT(country) AS countrycount,
SUM(funds_requested) AS smcnt,
country,
(SELECT SUM(funds_requested) FROM t1) AS total_funds,
ROW_NUMBER() OVER (ORDER BY STDDEV_POP(funds_requested)) AS rn
FROM t1
GROUP BY country
HAVING AVG(funds_requested) > 0
ORDER BY SUM(ABS(funds_requested));
countrycount	smcnt	country	total_funds	rn
1	1200	USA	1200	1
EXPLAIN SELECT COUNT(country) AS countrycount,
SUM(funds_requested) AS smcnt,
country,
(SELECT SUM(funds_requested) FROM t1) AS total_funds,
ROW_NUMBER() OVER (ORDER BY STDDEV_POP(funds_requested)) AS rn
FROM t1
GROUP BY country
HAVING AVG(funds_requested) > 0
ORDER BY SUM(ABS(funds_requested));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary; Using filesort
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	3598	To get information about window functions use EXPLAIN FORMAT=JSON
Note	1003	/* select#1 */ select count(`test`.`t1`.`country`) AS `countrycount`,sum(`test`.`t1`.`funds_requested`) AS `smcnt`,`test`.`t1`.`country` AS `country`,`derived_1_2`.`SUM(funds_requested)` AS `total_funds`,row_number() OVER (ORDER BY std(`test`.`t1`.`funds_requested`) )  AS `rn` from `test`.`t1` left join (/* select#2 */ select sum(`test`.`t1`.`funds_requested`) AS `SUM(funds_requested)` from `test`.`t1`) `derived_1_2` on(true) where true group by `test`.`t1`.`country` having (avg(`test`.`t1`.`funds_requested`) > 0) order by sum(abs(`test`.`t1`.`funds_requested`))
SET sql_mode='';
SELECT COUNT(country) AS countrycount,
SUM(funds_requested) AS smcnt,
country,
(SELECT SUM(funds_requested) FROM t1) AS total_funds,
ROW_NUMBER() OVER (ORDER BY STDDEV_POP(funds_requested)) AS rn
FROM t1
HAVING AVG(funds_requested) > 0
ORDER BY SUM(ABS(funds_requested));
countrycount	smcnt	country	total_funds	rn
1	1200	USA	1200	1
EXPLAIN SELECT COUNT(country) AS countrycount,
SUM(funds_requested) AS smcnt,
country,
(SELECT SUM(funds_requested) FROM t1) AS total_funds,
ROW_NUMBER() OVER (ORDER BY STDDEV_POP(funds_requested)) AS rn
FROM t1
HAVING AVG(funds_requested) > 0
ORDER BY SUM(ABS(funds_requested));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	3598	To get information about window functions use EXPLAIN FORMAT=JSON
Note	1003	/* select#1 */ select `derived_1_3`.`countrycount` AS `countrycount`,`derived_1_3`.`smcnt` AS `smcnt`,`derived_1_3`.`Name_exp_1` AS `country`,`derived_1_4`.`SUM(funds_requested)` AS `total_funds`,row_number() OVER (ORDER BY `derived_1_3`.`tmp_aggr_2` )  AS `rn` from (/* select#3 */ select count(`test`.`t1`.`country`) AS `countrycount`,sum(`test`.`t1`.`funds_requested`) AS `smcnt`,avg(`test`.`t1`.`funds_requested`) AS `tmp_aggr_1`,std(`test`.`t1`.`funds_requested`) AS `tmp_aggr_2`,`test`.`t1`.`country` AS `Name_exp_1` from `test`.`t1` having (avg(`test`.`t1`.`funds_requested`) > 0)) `derived_1_3` left join (/* select#4 */ select sum(`test`.`t1`.`funds_requested`) AS `SUM(funds_requested)` from `test`.`t1`) `derived_1_4` on(true) where true
Manually translated
SELECT derived_1_0.countrycount AS countrycount,
derived_1_0.smcnt AS smcnt,
derived_1_0.d_1 AS country,
derived_1_1.`SUM(funds_requested)` AS total_funds,
row_number() OVER (ORDER BY derived_1_1.`SUM(funds_requested)` )  AS rn
FROM (SELECT COUNT(t1.country) AS countrycount,
SUM(t1.funds_requested) AS smcnt,
AVG(t1.funds_requested) AS tmp_aggr_1,
STD(t1.funds_requested) AS tmp_aggr_2,
t1.country AS d_1
FROM t1
HAVING (AVG(t1.funds_requested) > 0)) derived_1_0
LEFT JOIN
(SELECT SUM(t1.funds_requested) AS `SUM(funds_requested)`
      FROM t1) derived_1_1
ON(TRUE);
countrycount	smcnt	country	total_funds	rn
1	1200	USA	1200	1
SET sql_mode=default;
DROP TABLE t1;
# Cause for introducing TABLE_LIST::m_was_grouped2derived:
# EXECUTE would assert if we didn't have it.
CREATE TABLE cc (i INT);
INSERT INTO cc VALUES (1);
ANALYZE TABLE cc;
Table	Op	Msg_type	Msg_text
test.cc	analyze	status	OK
SELECT (SELECT COUNT(i) FROM cc AS cc_alias
WHERE (cc.i IN (SELECT cc_alias.i FROM cc))) AS cnt
FROM cc
GROUP BY i;
cnt
1
EXPLAIN SELECT (SELECT COUNT(i) FROM cc AS cc_alias
WHERE (cc.i IN (SELECT cc_alias.i FROM cc))) AS cnt
FROM cc
GROUP BY i;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	cc	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.cc.i	2	100.00	NULL
2	DERIVED	cc_alias	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary
2	DERIVED	cc	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(cc_alias); Using join buffer (hash join)
Warnings:
Note	1276	Field or reference 'test.cc_alias.i' of SELECT #3 was resolved in SELECT #2
Note	1276	Field or reference 'test.cc.i' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select coalesce(`derived_1_2`.`COUNT(i)`,0) AS `cnt` from `test`.`cc` left join (/* select#2 */ select count(`test`.`cc_alias`.`i`) AS `COUNT(i)`,`test`.`cc_alias`.`i` AS `i` from `test`.`cc` `cc_alias` semi join (`test`.`cc`) group by `test`.`cc_alias`.`i`) `derived_1_2` on((`derived_1_2`.`i` = `test`.`cc`.`i`)) where true group by `test`.`cc`.`i`
DROP TABLE cc;
# Test: detect correlated aggregates deep inside scalar subquery (was
# missed before we let has_correlated_aggregate walk subqueries
CREATE TABLE t (a INT);
INSERT INTO t VALUES (1);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
# should be left untouched, since COUNT(q.i) aggregates in the
# outermost SELECT
EXPLAIN SELECT (
SELECT GROUP_CONCAT((SELECT COUNT(q.i) FROM t))
FROM t) AS i
FROM (SELECT a AS i FROM t) q;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	t	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
3	DEPENDENT SUBQUERY	t	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1276	Field or reference 'q.i' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select group_concat((/* select#3 */ select count(`test`.`t`.`a`) from `test`.`t`) separator ',') from `test`.`t`) AS `i` from `test`.`t`
DROP TABLE t;

# IN to EXISTS transformation makes us skip subquery_to_derived.

CREATE TABLE t1 (a INT NOT NULL, b INT NOT NULL);
CREATE TABLE t2 (c INT NOT NULL, d INT NOT NULL);
CREATE TABLE t3 (e INT NOT NULL);
INSERT INTO t1 VALUES (1,10), (2,10), (1,20), (2,20), (3,20), (2,30), (4,40);
INSERT INTO t2 VALUES (2,10), (2,20), (4,10), (5,10), (3,20), (2,40);
INSERT INTO t3 VALUES (10), (30), (10), (20);
ANALYZE TABLE t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
SELECT * FROM t1 AS ta
WHERE ta.a IN (SELECT c FROM t2 AS tb
WHERE (SELECT MIN(e) FROM t3 as tc
WHERE tc.e IS NOT NULL) < SOME(SELECT e FROM t3 as tc
WHERE ta.b=tc.e));
a	b
2	20
3	20
2	30
EXPLAIN SELECT * FROM t1 AS ta
WHERE ta.a IN (SELECT c FROM t2 AS tb
WHERE (SELECT MIN(e) FROM t3 as tc
WHERE tc.e IS NOT NULL) < SOME(SELECT e FROM t3 as tc
WHERE ta.b=tc.e));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	tb	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Start temporary
1	PRIMARY	ta	NULL	ALL	NULL	NULL	NULL	NULL	7	14.29	Using where; End temporary; Using join buffer (hash join)
4	DEPENDENT SUBQUERY	tc	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where
3	SUBQUERY	tc	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.ta.b' of SELECT #4 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`ta`.`a` AS `a`,`test`.`ta`.`b` AS `b` from `test`.`t1` `ta` semi join (`test`.`t2` `tb`) where ((`test`.`ta`.`a` = `test`.`tb`.`c`) and <nop>(<in_optimizer>((/* select#3 */ select min(`test`.`tc`.`e`) from `test`.`t3` `tc` where true),<exists>(/* select#4 */ select `test`.`tc`.`e` from `test`.`t3` `tc` where ((`test`.`ta`.`b` = `test`.`tc`.`e`) and <if>(outer_field_is_not_null, (<cache>((/* select#3 */ select min(`test`.`tc`.`e`) from `test`.`t3` `tc` where true)) < `test`.`tc`.`e`), true))))))
#
# Two parallel scalar subqueries + grouping to derived table
#
SELECT SUM(t1.a) + (SELECT SUM(t2.c)
FROM t2),
(SELECT COUNT(t3.e) FROM t3)
FROM t1;
SUM(t1.a) + (SELECT SUM(t2.c)
FROM t2)	(SELECT COUNT(t3.e) FROM t3)
33	4
EXPLAIN SELECT SUM(t1.a) + (SELECT SUM(t2.c)
FROM t2),
(SELECT COUNT(t3.e) FROM t3)
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
5	DERIVED	t3	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	7	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (`derived_1_4`.`tmp_aggr_1` + `derived_1_6`.`SUM(t2.c)`) AS `SUM(t1.a) + (SELECT SUM(t2.c)
FROM t2)`,`derived_1_5`.`COUNT(t3.e)` AS `(SELECT COUNT(t3.e) FROM t3)` from (/* select#4 */ select sum(`test`.`t1`.`a`) AS `tmp_aggr_1` from `test`.`t1`) `derived_1_4` left join (/* select#6 */ select sum(`test`.`t2`.`c`) AS `SUM(t2.c)` from `test`.`t2`) `derived_1_6` on(true) left join (/* select#5 */ select count(`test`.`t3`.`e`) AS `COUNT(t3.e)` from `test`.`t3`) `derived_1_5` on(true) where true
DROP TABLE t1, t2, t3;
# Bug discovered from running rapid.cp_i_subquery.test What is
# different here is that we have a combination of an implicitly
# grouped query + a scalar subquery in the select list + the top block
# has an IN subquery in the WHERE clause. The WHERE clause gets
# moved into the derived table for the grouping, but this move didn't
# account for the semijoin already determined for the top level, which
also has to go into the new derived table.
CREATE TABLE t1(
pedcompralote INT NOT NULL,
pedcompraseq SMALLINT
);
INSERT INTO t1 VALUES (12,12);
CREATE TABLE t2(
cod INT NOT NULL,
ped INT,
PRIMARY KEY (cod),
KEY ped (ped)
);
INSERT INTO t2 VALUES
(11724,1779), (11725,1779), (11726,1779), (11727,1779),
(11728,1779), (11729,1779), (11730,1779), (11731,1779);
SELECT (SELECT COUNT(*)
FROM t1
WHERE pedcompralote=11725) AS tot,
IFNULL(MAX(pedcompraseq),0)+1 AS newcode
FROM t1
WHERE pedcompralote IN (SELECT cod FROM t2 WHERE ped=1779);
tot	newcode
0	1
DROP TABLE t1, t2;
#
# 6.  S U B Q U E R Y   I N   H A V I N G   C L A U S E
#
CREATE TABLE t1(i int, j int);
CREATE TABLE t2(i int);
INSERT INTO t1 VALUES (1, 10);
INSERT INTO t1 VALUES (1, 20);
INSERT INTO t1 VALUES (1, 30);
INSERT INTO t1 VALUES (2, 11);
INSERT INTO t1 VALUES (2, 20);
INSERT INTO t1 VALUES (2, 30);
INSERT INTO t2 VALUES (25);
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
Implicit grouping, HAVING: no transform
SELECT SUM(j) FROM t1
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
SUM(j)
121
EXPLAIN SELECT SUM(j) FROM t1
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select sum(`test`.`t1`.`j`) AS `SUM(j)` from `test`.`t1` having (sum(`test`.`t1`.`j`) > (/* select#2 */ select sum(`test`.`t2`.`i`) from `test`.`t2`))
Only HAVING is ok to transform, no implicit grouping
SELECT j FROM t1
HAVING j > (SELECT MIN(t2.i) FROM t2);
j
30
30
EXPLAIN SELECT j FROM t1
HAVING j > (SELECT MIN(t2.i) FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`j` AS `j` from `test`.`t1` left join (/* select#2 */ select min(`test`.`t2`.`i`) AS `MIN(t2.i)` from `test`.`t2`) `derived_1_2` on(true) where true having (`test`.`t1`.`j` > `derived_1_2`.`MIN(t2.i)`)
HAVING and GROUP BY, also ok
SELECT i, j FROM t1
GROUP BY i, j
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
i	j
1	30
2	30
EXPLAIN SELECT i, j FROM t1
GROUP BY i, j
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,`test`.`t1`.`j` AS `j` from `test`.`t1` left join (/* select#2 */ select sum(`test`.`t2`.`i`) AS `SUM(t2.i)` from `test`.`t2`) `derived_1_2` on(true) where true group by `test`.`t1`.`i`,`test`.`t1`.`j` having (sum(`test`.`t1`.`j`) > `derived_1_2`.`SUM(t2.i)`)
HAVING, GROUP BY and ROLLUP
SELECT i, j FROM t1
GROUP BY i, j WITH ROLLUP
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
i	j
1	30
1	NULL
2	30
2	NULL
NULL	NULL
EXPLAIN SELECT i, j FROM t1
GROUP BY i, j WITH ROLLUP
HAVING SUM(j) > (SELECT SUM(t2.i) FROM t2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using temporary; Using filesort
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,`test`.`t1`.`j` AS `j` from `test`.`t1` left join (/* select#2 */ select sum(`test`.`t2`.`i`) AS `SUM(t2.i)` from `test`.`t2`) `derived_1_2` on(true) where true group by `test`.`t1`.`i`,`test`.`t1`.`j` with rollup having (rollup_sum_switcher(sum(`j`)) > `derived_1_2`.`SUM(t2.i)`)
DROP TABLE t1, t2;
Bigger example (TPC-H Q11) where we get a scalar transformation
in the grouping derived table also, i.e. nested scalar to
derived transformation.
CREATE TABLE supplier (
s_suppkey INT NOT NULL,
s_nationkey BIGINT NOT NULL,
PRIMARY KEY (s_suppkey)
);
CREATE TABLE nation (
n_nationkey INT NOT NULL,
n_name CHAR(25) DEFAULT NULL,
PRIMARY KEY (n_nationkey)
);
CREATE TABLE partsupp (
ps_partkey BIGINT NOT NULL,
ps_suppkey BIGINT NOT NULL,
ps_availqty INT DEFAULT NULL,
ps_supplycost DECIMAL(10,0) DEFAULT NULL,
PRIMARY KEY (ps_partkey, ps_suppkey)
);
INSERT INTO nation VALUES (1, 'germany'),
(2, 'norway'),
(3, 'u.k.');
INSERT INTO supplier VALUES (1, 1);
INSERT INTO partsupp VALUES
(1, 1, 10, 555),
(2, 1, 1, 2222),
(3, 1, 300, 700),
(4, 1, 259, 400),
(5, 1, 20,  400),
(6, 1, 1000, 300),
(7, 1, 30, 700);
ANALYZE TABLE supplier, nation, partsupp;
Table	Op	Msg_type	Msg_text
test.supplier	analyze	status	OK
test.nation	analyze	status	OK
test.partsupp	analyze	status	OK
SELECT
ps_partkey,
SUM(ps_supplycost * ps_availqty) AS value
FROM
partsupp,
supplier,
nation
WHERE
ps_suppkey = s_suppkey AND
s_nationkey = n_nationkey AND
n_name = 'germany'
GROUP BY
ps_partkey HAVING
SUM(ps_supplycost * ps_availqty) > (
SELECT
SUM(ps_supplycost * ps_availqty) * 0.1
FROM
partsupp,
supplier,
nation
WHERE
ps_suppkey = s_suppkey AND
s_nationkey = n_nationkey AND
n_name = 'germany'
        )
ORDER BY value DESC;
ps_partkey	value
6	300000
3	210000
4	103600
EXPLAIN SELECT
ps_partkey,
SUM(ps_supplycost * ps_availqty) AS value
FROM
partsupp,
supplier,
nation
WHERE
ps_suppkey = s_suppkey AND
s_nationkey = n_nationkey AND
n_name = 'germany'
GROUP BY
ps_partkey HAVING
SUM(ps_supplycost * ps_availqty) > (
SELECT
SUM(ps_supplycost * ps_availqty) * 0.1
FROM
partsupp,
supplier,
nation
WHERE
ps_suppkey = s_suppkey AND
s_nationkey = n_nationkey AND
n_name = 'germany'
        )
ORDER BY value DESC;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	supplier	NULL	ALL	PRIMARY	NULL	NULL	NULL	1	100.00	Using temporary; Using filesort
1	PRIMARY	nation	NULL	eq_ref	PRIMARY	PRIMARY	4	test.supplier.s_nationkey	1	33.33	Using where
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	partsupp	NULL	ALL	PRIMARY	NULL	NULL	NULL	7	14.29	Using where; Using join buffer (hash join)
2	DERIVED	supplier	NULL	ALL	PRIMARY	NULL	NULL	NULL	1	100.00	NULL
2	DERIVED	nation	NULL	eq_ref	PRIMARY	PRIMARY	4	test.supplier.s_nationkey	1	33.33	Using where
2	DERIVED	partsupp	NULL	ALL	NULL	NULL	NULL	NULL	7	14.29	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`partsupp`.`ps_partkey` AS `ps_partkey`,sum((`test`.`partsupp`.`ps_supplycost` * `test`.`partsupp`.`ps_availqty`)) AS `value` from `test`.`partsupp` join `test`.`supplier` join `test`.`nation` left join (/* select#2 */ select (sum((`test`.`partsupp`.`ps_supplycost` * `test`.`partsupp`.`ps_availqty`)) * 0.1) AS `SUM(ps_supplycost * ps_availqty) * 0.1` from `test`.`partsupp` join `test`.`supplier` join `test`.`nation` where ((`test`.`nation`.`n_name` = 'germany') and (`test`.`partsupp`.`ps_suppkey` = `test`.`supplier`.`s_suppkey`) and (`test`.`supplier`.`s_nationkey` = `test`.`nation`.`n_nationkey`))) `derived_1_2` on(true) where ((`test`.`nation`.`n_name` = 'germany') and (`test`.`partsupp`.`ps_suppkey` = `test`.`supplier`.`s_suppkey`) and (`test`.`supplier`.`s_nationkey` = `test`.`nation`.`n_nationkey`)) group by `test`.`partsupp`.`ps_partkey` having (sum((`test`.`partsupp`.`ps_supplycost` * `test`.`partsupp`.`ps_availqty`)) > `derived_1_2`.`SUM(ps_supplycost * ps_availqty) * 0.1`) order by `value` desc
DROP TABLE partsupp, nation, supplier;
Bugs discovered during full regression suite runs with
transformation enabled, selectively repeated here, since we
won't be running InnoDB with transformation enabled normally.
Bug 1
CREATE TABLE tbl1 (
login INT NOT NULL,
numb DECIMAL(15,2) NOT NULL DEFAULT '0.00',
PRIMARY KEY (login),
KEY numb (numb)
);
CREATE TABLE tbl2 (
login INT NOT NULL,
cmd TINYINT NOT NULL,
nump DECIMAL(15,2) NOT NULL DEFAULT '0.00',
KEY cmd (cmd),
KEY login (login)
);
SET autocommit = 0;
START TRANSACTION;
insert into tbl1 values(500, '500.');
insert into tbl1 values(499, '499.');
insert into tbl1 values(498, '498.');
insert into tbl1 values(497, '497.');
insert into tbl1 values(496, '496.');
insert into tbl1 values(495, '495.');
insert into tbl1 values(494, '494.');
insert into tbl1 values(493, '493.');
insert into tbl1 values(492, '492.');
insert into tbl1 values(491, '491.');
insert into tbl1 values(490, '490.');
insert into tbl1 values(489, '489.');
insert into tbl1 values(488, '488.');
insert into tbl1 values(487, '487.');
insert into tbl1 values(486, '486.');
insert into tbl1 values(485, '485.');
insert into tbl1 values(484, '484.');
insert into tbl1 values(483, '483.');
insert into tbl1 values(482, '482.');
insert into tbl1 values(481, '481.');
insert into tbl1 values(480, '480.');
insert into tbl1 values(479, '479.');
insert into tbl1 values(478, '478.');
insert into tbl1 values(477, '477.');
insert into tbl1 values(476, '476.');
insert into tbl1 values(475, '475.');
insert into tbl1 values(474, '474.');
insert into tbl1 values(473, '473.');
insert into tbl1 values(472, '472.');
insert into tbl1 values(471, '471.');
insert into tbl1 values(470, '470.');
insert into tbl1 values(469, '469.');
insert into tbl1 values(468, '468.');
insert into tbl1 values(467, '467.');
insert into tbl1 values(466, '466.');
insert into tbl1 values(465, '465.');
insert into tbl1 values(464, '464.');
insert into tbl1 values(463, '463.');
insert into tbl1 values(462, '462.');
insert into tbl1 values(461, '461.');
insert into tbl1 values(460, '460.');
insert into tbl1 values(459, '459.');
insert into tbl1 values(458, '458.');
insert into tbl1 values(457, '457.');
insert into tbl1 values(456, '456.');
insert into tbl1 values(455, '455.');
insert into tbl1 values(454, '454.');
insert into tbl1 values(453, '453.');
insert into tbl1 values(452, '452.');
insert into tbl1 values(451, '451.');
insert into tbl1 values(450, '450.');
insert into tbl1 values(449, '449.');
insert into tbl1 values(448, '448.');
insert into tbl1 values(447, '447.');
insert into tbl1 values(446, '446.');
insert into tbl1 values(445, '445.');
insert into tbl1 values(444, '444.');
insert into tbl1 values(443, '443.');
insert into tbl1 values(442, '442.');
insert into tbl1 values(441, '441.');
insert into tbl1 values(440, '440.');
insert into tbl1 values(439, '439.');
insert into tbl1 values(438, '438.');
insert into tbl1 values(437, '437.');
insert into tbl1 values(436, '436.');
insert into tbl1 values(435, '435.');
insert into tbl1 values(434, '434.');
insert into tbl1 values(433, '433.');
insert into tbl1 values(432, '432.');
insert into tbl1 values(431, '431.');
insert into tbl1 values(430, '430.');
insert into tbl1 values(429, '429.');
insert into tbl1 values(428, '428.');
insert into tbl1 values(427, '427.');
insert into tbl1 values(426, '426.');
insert into tbl1 values(425, '425.');
insert into tbl1 values(424, '424.');
insert into tbl1 values(423, '423.');
insert into tbl1 values(422, '422.');
insert into tbl1 values(421, '421.');
insert into tbl1 values(420, '420.');
insert into tbl1 values(419, '419.');
insert into tbl1 values(418, '418.');
insert into tbl1 values(417, '417.');
insert into tbl1 values(416, '416.');
insert into tbl1 values(415, '415.');
insert into tbl1 values(414, '414.');
insert into tbl1 values(413, '413.');
insert into tbl1 values(412, '412.');
insert into tbl1 values(411, '411.');
insert into tbl1 values(410, '410.');
insert into tbl1 values(409, '409.');
insert into tbl1 values(408, '408.');
insert into tbl1 values(407, '407.');
insert into tbl1 values(406, '406.');
insert into tbl1 values(405, '405.');
insert into tbl1 values(404, '404.');
insert into tbl1 values(403, '403.');
insert into tbl1 values(402, '402.');
insert into tbl1 values(401, '401.');
insert into tbl1 values(400, '400.');
insert into tbl1 values(399, '399.');
insert into tbl1 values(398, '398.');
insert into tbl1 values(397, '397.');
insert into tbl1 values(396, '396.');
insert into tbl1 values(395, '395.');
insert into tbl1 values(394, '394.');
insert into tbl1 values(393, '393.');
insert into tbl1 values(392, '392.');
insert into tbl1 values(391, '391.');
insert into tbl1 values(390, '390.');
insert into tbl1 values(389, '389.');
insert into tbl1 values(388, '388.');
insert into tbl1 values(387, '387.');
insert into tbl1 values(386, '386.');
insert into tbl1 values(385, '385.');
insert into tbl1 values(384, '384.');
insert into tbl1 values(383, '383.');
insert into tbl1 values(382, '382.');
insert into tbl1 values(381, '381.');
insert into tbl1 values(380, '380.');
insert into tbl1 values(379, '379.');
insert into tbl1 values(378, '378.');
insert into tbl1 values(377, '377.');
insert into tbl1 values(376, '376.');
insert into tbl1 values(375, '375.');
insert into tbl1 values(374, '374.');
insert into tbl1 values(373, '373.');
insert into tbl1 values(372, '372.');
insert into tbl1 values(371, '371.');
insert into tbl1 values(370, '370.');
insert into tbl1 values(369, '369.');
insert into tbl1 values(368, '368.');
insert into tbl1 values(367, '367.');
insert into tbl1 values(366, '366.');
insert into tbl1 values(365, '365.');
insert into tbl1 values(364, '364.');
insert into tbl1 values(363, '363.');
insert into tbl1 values(362, '362.');
insert into tbl1 values(361, '361.');
insert into tbl1 values(360, '360.');
insert into tbl1 values(359, '359.');
insert into tbl1 values(358, '358.');
insert into tbl1 values(357, '357.');
insert into tbl1 values(356, '356.');
insert into tbl1 values(355, '355.');
insert into tbl1 values(354, '354.');
insert into tbl1 values(353, '353.');
insert into tbl1 values(352, '352.');
insert into tbl1 values(351, '351.');
insert into tbl1 values(350, '350.');
insert into tbl1 values(349, '349.');
insert into tbl1 values(348, '348.');
insert into tbl1 values(347, '347.');
insert into tbl1 values(346, '346.');
insert into tbl1 values(345, '345.');
insert into tbl1 values(344, '344.');
insert into tbl1 values(343, '343.');
insert into tbl1 values(342, '342.');
insert into tbl1 values(341, '341.');
insert into tbl1 values(340, '340.');
insert into tbl1 values(339, '339.');
insert into tbl1 values(338, '338.');
insert into tbl1 values(337, '337.');
insert into tbl1 values(336, '336.');
insert into tbl1 values(335, '335.');
insert into tbl1 values(334, '334.');
insert into tbl1 values(333, '333.');
insert into tbl1 values(332, '332.');
insert into tbl1 values(331, '331.');
insert into tbl1 values(330, '330.');
insert into tbl1 values(329, '329.');
insert into tbl1 values(328, '328.');
insert into tbl1 values(327, '327.');
insert into tbl1 values(326, '326.');
insert into tbl1 values(325, '325.');
insert into tbl1 values(324, '324.');
insert into tbl1 values(323, '323.');
insert into tbl1 values(322, '322.');
insert into tbl1 values(321, '321.');
insert into tbl1 values(320, '320.');
insert into tbl1 values(319, '319.');
insert into tbl1 values(318, '318.');
insert into tbl1 values(317, '317.');
insert into tbl1 values(316, '316.');
insert into tbl1 values(315, '315.');
insert into tbl1 values(314, '314.');
insert into tbl1 values(313, '313.');
insert into tbl1 values(312, '312.');
insert into tbl1 values(311, '311.');
insert into tbl1 values(310, '310.');
insert into tbl1 values(309, '309.');
insert into tbl1 values(308, '308.');
insert into tbl1 values(307, '307.');
insert into tbl1 values(306, '306.');
insert into tbl1 values(305, '305.');
insert into tbl1 values(304, '304.');
insert into tbl1 values(303, '303.');
insert into tbl1 values(302, '302.');
insert into tbl1 values(301, '301.');
insert into tbl1 values(300, '300.');
insert into tbl1 values(299, '299.');
insert into tbl1 values(298, '298.');
insert into tbl1 values(297, '297.');
insert into tbl1 values(296, '296.');
insert into tbl1 values(295, '295.');
insert into tbl1 values(294, '294.');
insert into tbl1 values(293, '293.');
insert into tbl1 values(292, '292.');
insert into tbl1 values(291, '291.');
insert into tbl1 values(290, '290.');
insert into tbl1 values(289, '289.');
insert into tbl1 values(288, '288.');
insert into tbl1 values(287, '287.');
insert into tbl1 values(286, '286.');
insert into tbl1 values(285, '285.');
insert into tbl1 values(284, '284.');
insert into tbl1 values(283, '283.');
insert into tbl1 values(282, '282.');
insert into tbl1 values(281, '281.');
insert into tbl1 values(280, '280.');
insert into tbl1 values(279, '279.');
insert into tbl1 values(278, '278.');
insert into tbl1 values(277, '277.');
insert into tbl1 values(276, '276.');
insert into tbl1 values(275, '275.');
insert into tbl1 values(274, '274.');
insert into tbl1 values(273, '273.');
insert into tbl1 values(272, '272.');
insert into tbl1 values(271, '271.');
insert into tbl1 values(270, '270.');
insert into tbl1 values(269, '269.');
insert into tbl1 values(268, '268.');
insert into tbl1 values(267, '267.');
insert into tbl1 values(266, '266.');
insert into tbl1 values(265, '265.');
insert into tbl1 values(264, '264.');
insert into tbl1 values(263, '263.');
insert into tbl1 values(262, '262.');
insert into tbl1 values(261, '261.');
insert into tbl1 values(260, '260.');
insert into tbl1 values(259, '259.');
insert into tbl1 values(258, '258.');
insert into tbl1 values(257, '257.');
insert into tbl1 values(256, '256.');
insert into tbl1 values(255, '255.');
insert into tbl1 values(254, '254.');
insert into tbl1 values(253, '253.');
insert into tbl1 values(252, '252.');
insert into tbl1 values(251, '251.');
insert into tbl1 values(250, '250.');
insert into tbl1 values(249, '249.');
insert into tbl1 values(248, '248.');
insert into tbl1 values(247, '247.');
insert into tbl1 values(246, '246.');
insert into tbl1 values(245, '245.');
insert into tbl1 values(244, '244.');
insert into tbl1 values(243, '243.');
insert into tbl1 values(242, '242.');
insert into tbl1 values(241, '241.');
insert into tbl1 values(240, '240.');
insert into tbl1 values(239, '239.');
insert into tbl1 values(238, '238.');
insert into tbl1 values(237, '237.');
insert into tbl1 values(236, '236.');
insert into tbl1 values(235, '235.');
insert into tbl1 values(234, '234.');
insert into tbl1 values(233, '233.');
insert into tbl1 values(232, '232.');
insert into tbl1 values(231, '231.');
insert into tbl1 values(230, '230.');
insert into tbl1 values(229, '229.');
insert into tbl1 values(228, '228.');
insert into tbl1 values(227, '227.');
insert into tbl1 values(226, '226.');
insert into tbl1 values(225, '225.');
insert into tbl1 values(224, '224.');
insert into tbl1 values(223, '223.');
insert into tbl1 values(222, '222.');
insert into tbl1 values(221, '221.');
insert into tbl1 values(220, '220.');
insert into tbl1 values(219, '219.');
insert into tbl1 values(218, '218.');
insert into tbl1 values(217, '217.');
insert into tbl1 values(216, '216.');
insert into tbl1 values(215, '215.');
insert into tbl1 values(214, '214.');
insert into tbl1 values(213, '213.');
insert into tbl1 values(212, '212.');
insert into tbl1 values(211, '211.');
insert into tbl1 values(210, '210.');
insert into tbl1 values(209, '209.');
insert into tbl1 values(208, '208.');
insert into tbl1 values(207, '207.');
insert into tbl1 values(206, '206.');
insert into tbl1 values(205, '205.');
insert into tbl1 values(204, '204.');
insert into tbl1 values(203, '203.');
insert into tbl1 values(202, '202.');
insert into tbl1 values(201, '201.');
insert into tbl1 values(200, '200.');
insert into tbl1 values(199, '199.');
insert into tbl1 values(198, '198.');
insert into tbl1 values(197, '197.');
insert into tbl1 values(196, '196.');
insert into tbl1 values(195, '195.');
insert into tbl1 values(194, '194.');
insert into tbl1 values(193, '193.');
insert into tbl1 values(192, '192.');
insert into tbl1 values(191, '191.');
insert into tbl1 values(190, '190.');
insert into tbl1 values(189, '189.');
insert into tbl1 values(188, '188.');
insert into tbl1 values(187, '187.');
insert into tbl1 values(186, '186.');
insert into tbl1 values(185, '185.');
insert into tbl1 values(184, '184.');
insert into tbl1 values(183, '183.');
insert into tbl1 values(182, '182.');
insert into tbl1 values(181, '181.');
insert into tbl1 values(180, '180.');
insert into tbl1 values(179, '179.');
insert into tbl1 values(178, '178.');
insert into tbl1 values(177, '177.');
insert into tbl1 values(176, '176.');
insert into tbl1 values(175, '175.');
insert into tbl1 values(174, '174.');
insert into tbl1 values(173, '173.');
insert into tbl1 values(172, '172.');
insert into tbl1 values(171, '171.');
insert into tbl1 values(170, '170.');
insert into tbl1 values(169, '169.');
insert into tbl1 values(168, '168.');
insert into tbl1 values(167, '167.');
insert into tbl1 values(166, '166.');
insert into tbl1 values(165, '165.');
insert into tbl1 values(164, '164.');
insert into tbl1 values(163, '163.');
insert into tbl1 values(162, '162.');
insert into tbl1 values(161, '161.');
insert into tbl1 values(160, '160.');
insert into tbl1 values(159, '159.');
insert into tbl1 values(158, '158.');
insert into tbl1 values(157, '157.');
insert into tbl1 values(156, '156.');
insert into tbl1 values(155, '155.');
insert into tbl1 values(154, '154.');
insert into tbl1 values(153, '153.');
insert into tbl1 values(152, '152.');
insert into tbl1 values(151, '151.');
insert into tbl1 values(150, '150.');
insert into tbl1 values(149, '149.');
insert into tbl1 values(148, '148.');
insert into tbl1 values(147, '147.');
insert into tbl1 values(146, '146.');
insert into tbl1 values(145, '145.');
insert into tbl1 values(144, '144.');
insert into tbl1 values(143, '143.');
insert into tbl1 values(142, '142.');
insert into tbl1 values(141, '141.');
insert into tbl1 values(140, '140.');
insert into tbl1 values(139, '139.');
insert into tbl1 values(138, '138.');
insert into tbl1 values(137, '137.');
insert into tbl1 values(136, '136.');
insert into tbl1 values(135, '135.');
insert into tbl1 values(134, '134.');
insert into tbl1 values(133, '133.');
insert into tbl1 values(132, '132.');
insert into tbl1 values(131, '131.');
insert into tbl1 values(130, '130.');
insert into tbl1 values(129, '129.');
insert into tbl1 values(128, '128.');
insert into tbl1 values(127, '127.');
insert into tbl1 values(126, '126.');
insert into tbl1 values(125, '125.');
insert into tbl1 values(124, '124.');
insert into tbl1 values(123, '123.');
insert into tbl1 values(122, '122.');
insert into tbl1 values(121, '121.');
insert into tbl1 values(120, '120.');
insert into tbl1 values(119, '119.');
insert into tbl1 values(118, '118.');
insert into tbl1 values(117, '117.');
insert into tbl1 values(116, '116.');
insert into tbl1 values(115, '115.');
insert into tbl1 values(114, '114.');
insert into tbl1 values(113, '113.');
insert into tbl1 values(112, '112.');
insert into tbl1 values(111, '111.');
insert into tbl1 values(110, '110.');
insert into tbl1 values(109, '109.');
insert into tbl1 values(108, '108.');
insert into tbl1 values(107, '107.');
insert into tbl1 values(106, '106.');
insert into tbl1 values(105, '105.');
insert into tbl1 values(104, '104.');
insert into tbl1 values(103, '103.');
insert into tbl1 values(102, '102.');
insert into tbl1 values(101, '101.');
insert into tbl1 values(100, '100.');
insert into tbl1 values(99, '99.');
insert into tbl1 values(98, '98.');
insert into tbl1 values(97, '97.');
insert into tbl1 values(96, '96.');
insert into tbl1 values(95, '95.');
insert into tbl1 values(94, '94.');
insert into tbl1 values(93, '93.');
insert into tbl1 values(92, '92.');
insert into tbl1 values(91, '91.');
insert into tbl1 values(90, '90.');
insert into tbl1 values(89, '89.');
insert into tbl1 values(88, '88.');
insert into tbl1 values(87, '87.');
insert into tbl1 values(86, '86.');
insert into tbl1 values(85, '85.');
insert into tbl1 values(84, '84.');
insert into tbl1 values(83, '83.');
insert into tbl1 values(82, '82.');
insert into tbl1 values(81, '81.');
insert into tbl1 values(80, '80.');
insert into tbl1 values(79, '79.');
insert into tbl1 values(78, '78.');
insert into tbl1 values(77, '77.');
insert into tbl1 values(76, '76.');
insert into tbl1 values(75, '75.');
insert into tbl1 values(74, '74.');
insert into tbl1 values(73, '73.');
insert into tbl1 values(72, '72.');
insert into tbl1 values(71, '71.');
insert into tbl1 values(70, '70.');
insert into tbl1 values(69, '69.');
insert into tbl1 values(68, '68.');
insert into tbl1 values(67, '67.');
insert into tbl1 values(66, '66.');
insert into tbl1 values(65, '65.');
insert into tbl1 values(64, '64.');
insert into tbl1 values(63, '63.');
insert into tbl1 values(62, '62.');
insert into tbl1 values(61, '61.');
insert into tbl1 values(60, '60.');
insert into tbl1 values(59, '59.');
insert into tbl1 values(58, '58.');
insert into tbl1 values(57, '57.');
insert into tbl1 values(56, '56.');
insert into tbl1 values(55, '55.');
insert into tbl1 values(54, '54.');
insert into tbl1 values(53, '53.');
insert into tbl1 values(52, '52.');
insert into tbl1 values(51, '51.');
insert into tbl1 values(50, '50.');
insert into tbl1 values(49, '49.');
insert into tbl1 values(48, '48.');
insert into tbl1 values(47, '47.');
insert into tbl1 values(46, '46.');
insert into tbl1 values(45, '45.');
insert into tbl1 values(44, '44.');
insert into tbl1 values(43, '43.');
insert into tbl1 values(42, '42.');
insert into tbl1 values(41, '41.');
insert into tbl1 values(40, '40.');
insert into tbl1 values(39, '39.');
insert into tbl1 values(38, '38.');
insert into tbl1 values(37, '37.');
insert into tbl1 values(36, '36.');
insert into tbl1 values(35, '35.');
insert into tbl1 values(34, '34.');
insert into tbl1 values(33, '33.');
insert into tbl1 values(32, '32.');
insert into tbl1 values(31, '31.');
insert into tbl1 values(30, '30.');
insert into tbl1 values(29, '29.');
insert into tbl1 values(28, '28.');
insert into tbl1 values(27, '27.');
insert into tbl1 values(26, '26.');
insert into tbl1 values(25, '25.');
insert into tbl1 values(24, '24.');
insert into tbl1 values(23, '23.');
insert into tbl1 values(22, '22.');
insert into tbl1 values(21, '21.');
insert into tbl1 values(20, '20.');
insert into tbl1 values(19, '19.');
insert into tbl1 values(18, '18.');
insert into tbl1 values(17, '17.');
insert into tbl1 values(16, '16.');
insert into tbl1 values(15, '15.');
insert into tbl1 values(14, '14.');
insert into tbl1 values(13, '13.');
insert into tbl1 values(12, '12.');
insert into tbl1 values(11, '11.');
insert into tbl1 values(10, '10.');
insert into tbl1 values(9, '9.');
insert into tbl1 values(8, '8.');
insert into tbl1 values(7, '7.');
insert into tbl1 values(6, '6.');
insert into tbl1 values(5, '5.');
insert into tbl1 values(4, '4.');
insert into tbl1 values(3, '3.');
insert into tbl1 values(2, '2.');
insert into tbl1 values(1, '1.');
insert into tbl2 values(500, 500%127,'500.');
insert into tbl2 values(499, 499%127,'499.');
insert into tbl2 values(498, 498%127,'498.');
insert into tbl2 values(497, 497%127,'497.');
insert into tbl2 values(496, 496%127,'496.');
insert into tbl2 values(495, 495%127,'495.');
insert into tbl2 values(494, 494%127,'494.');
insert into tbl2 values(493, 493%127,'493.');
insert into tbl2 values(492, 492%127,'492.');
insert into tbl2 values(491, 491%127,'491.');
insert into tbl2 values(490, 490%127,'490.');
insert into tbl2 values(489, 489%127,'489.');
insert into tbl2 values(488, 488%127,'488.');
insert into tbl2 values(487, 487%127,'487.');
insert into tbl2 values(486, 486%127,'486.');
insert into tbl2 values(485, 485%127,'485.');
insert into tbl2 values(484, 484%127,'484.');
insert into tbl2 values(483, 483%127,'483.');
insert into tbl2 values(482, 482%127,'482.');
insert into tbl2 values(481, 481%127,'481.');
insert into tbl2 values(480, 480%127,'480.');
insert into tbl2 values(479, 479%127,'479.');
insert into tbl2 values(478, 478%127,'478.');
insert into tbl2 values(477, 477%127,'477.');
insert into tbl2 values(476, 476%127,'476.');
insert into tbl2 values(475, 475%127,'475.');
insert into tbl2 values(474, 474%127,'474.');
insert into tbl2 values(473, 473%127,'473.');
insert into tbl2 values(472, 472%127,'472.');
insert into tbl2 values(471, 471%127,'471.');
insert into tbl2 values(470, 470%127,'470.');
insert into tbl2 values(469, 469%127,'469.');
insert into tbl2 values(468, 468%127,'468.');
insert into tbl2 values(467, 467%127,'467.');
insert into tbl2 values(466, 466%127,'466.');
insert into tbl2 values(465, 465%127,'465.');
insert into tbl2 values(464, 464%127,'464.');
insert into tbl2 values(463, 463%127,'463.');
insert into tbl2 values(462, 462%127,'462.');
insert into tbl2 values(461, 461%127,'461.');
insert into tbl2 values(460, 460%127,'460.');
insert into tbl2 values(459, 459%127,'459.');
insert into tbl2 values(458, 458%127,'458.');
insert into tbl2 values(457, 457%127,'457.');
insert into tbl2 values(456, 456%127,'456.');
insert into tbl2 values(455, 455%127,'455.');
insert into tbl2 values(454, 454%127,'454.');
insert into tbl2 values(453, 453%127,'453.');
insert into tbl2 values(452, 452%127,'452.');
insert into tbl2 values(451, 451%127,'451.');
insert into tbl2 values(450, 450%127,'450.');
insert into tbl2 values(449, 449%127,'449.');
insert into tbl2 values(448, 448%127,'448.');
insert into tbl2 values(447, 447%127,'447.');
insert into tbl2 values(446, 446%127,'446.');
insert into tbl2 values(445, 445%127,'445.');
insert into tbl2 values(444, 444%127,'444.');
insert into tbl2 values(443, 443%127,'443.');
insert into tbl2 values(442, 442%127,'442.');
insert into tbl2 values(441, 441%127,'441.');
insert into tbl2 values(440, 440%127,'440.');
insert into tbl2 values(439, 439%127,'439.');
insert into tbl2 values(438, 438%127,'438.');
insert into tbl2 values(437, 437%127,'437.');
insert into tbl2 values(436, 436%127,'436.');
insert into tbl2 values(435, 435%127,'435.');
insert into tbl2 values(434, 434%127,'434.');
insert into tbl2 values(433, 433%127,'433.');
insert into tbl2 values(432, 432%127,'432.');
insert into tbl2 values(431, 431%127,'431.');
insert into tbl2 values(430, 430%127,'430.');
insert into tbl2 values(429, 429%127,'429.');
insert into tbl2 values(428, 428%127,'428.');
insert into tbl2 values(427, 427%127,'427.');
insert into tbl2 values(426, 426%127,'426.');
insert into tbl2 values(425, 425%127,'425.');
insert into tbl2 values(424, 424%127,'424.');
insert into tbl2 values(423, 423%127,'423.');
insert into tbl2 values(422, 422%127,'422.');
insert into tbl2 values(421, 421%127,'421.');
insert into tbl2 values(420, 420%127,'420.');
insert into tbl2 values(419, 419%127,'419.');
insert into tbl2 values(418, 418%127,'418.');
insert into tbl2 values(417, 417%127,'417.');
insert into tbl2 values(416, 416%127,'416.');
insert into tbl2 values(415, 415%127,'415.');
insert into tbl2 values(414, 414%127,'414.');
insert into tbl2 values(413, 413%127,'413.');
insert into tbl2 values(412, 412%127,'412.');
insert into tbl2 values(411, 411%127,'411.');
insert into tbl2 values(410, 410%127,'410.');
insert into tbl2 values(409, 409%127,'409.');
insert into tbl2 values(408, 408%127,'408.');
insert into tbl2 values(407, 407%127,'407.');
insert into tbl2 values(406, 406%127,'406.');
insert into tbl2 values(405, 405%127,'405.');
insert into tbl2 values(404, 404%127,'404.');
insert into tbl2 values(403, 403%127,'403.');
insert into tbl2 values(402, 402%127,'402.');
insert into tbl2 values(401, 401%127,'401.');
insert into tbl2 values(400, 400%127,'400.');
insert into tbl2 values(399, 399%127,'399.');
insert into tbl2 values(398, 398%127,'398.');
insert into tbl2 values(397, 397%127,'397.');
insert into tbl2 values(396, 396%127,'396.');
insert into tbl2 values(395, 395%127,'395.');
insert into tbl2 values(394, 394%127,'394.');
insert into tbl2 values(393, 393%127,'393.');
insert into tbl2 values(392, 392%127,'392.');
insert into tbl2 values(391, 391%127,'391.');
insert into tbl2 values(390, 390%127,'390.');
insert into tbl2 values(389, 389%127,'389.');
insert into tbl2 values(388, 388%127,'388.');
insert into tbl2 values(387, 387%127,'387.');
insert into tbl2 values(386, 386%127,'386.');
insert into tbl2 values(385, 385%127,'385.');
insert into tbl2 values(384, 384%127,'384.');
insert into tbl2 values(383, 383%127,'383.');
insert into tbl2 values(382, 382%127,'382.');
insert into tbl2 values(381, 381%127,'381.');
insert into tbl2 values(380, 380%127,'380.');
insert into tbl2 values(379, 379%127,'379.');
insert into tbl2 values(378, 378%127,'378.');
insert into tbl2 values(377, 377%127,'377.');
insert into tbl2 values(376, 376%127,'376.');
insert into tbl2 values(375, 375%127,'375.');
insert into tbl2 values(374, 374%127,'374.');
insert into tbl2 values(373, 373%127,'373.');
insert into tbl2 values(372, 372%127,'372.');
insert into tbl2 values(371, 371%127,'371.');
insert into tbl2 values(370, 370%127,'370.');
insert into tbl2 values(369, 369%127,'369.');
insert into tbl2 values(368, 368%127,'368.');
insert into tbl2 values(367, 367%127,'367.');
insert into tbl2 values(366, 366%127,'366.');
insert into tbl2 values(365, 365%127,'365.');
insert into tbl2 values(364, 364%127,'364.');
insert into tbl2 values(363, 363%127,'363.');
insert into tbl2 values(362, 362%127,'362.');
insert into tbl2 values(361, 361%127,'361.');
insert into tbl2 values(360, 360%127,'360.');
insert into tbl2 values(359, 359%127,'359.');
insert into tbl2 values(358, 358%127,'358.');
insert into tbl2 values(357, 357%127,'357.');
insert into tbl2 values(356, 356%127,'356.');
insert into tbl2 values(355, 355%127,'355.');
insert into tbl2 values(354, 354%127,'354.');
insert into tbl2 values(353, 353%127,'353.');
insert into tbl2 values(352, 352%127,'352.');
insert into tbl2 values(351, 351%127,'351.');
insert into tbl2 values(350, 350%127,'350.');
insert into tbl2 values(349, 349%127,'349.');
insert into tbl2 values(348, 348%127,'348.');
insert into tbl2 values(347, 347%127,'347.');
insert into tbl2 values(346, 346%127,'346.');
insert into tbl2 values(345, 345%127,'345.');
insert into tbl2 values(344, 344%127,'344.');
insert into tbl2 values(343, 343%127,'343.');
insert into tbl2 values(342, 342%127,'342.');
insert into tbl2 values(341, 341%127,'341.');
insert into tbl2 values(340, 340%127,'340.');
insert into tbl2 values(339, 339%127,'339.');
insert into tbl2 values(338, 338%127,'338.');
insert into tbl2 values(337, 337%127,'337.');
insert into tbl2 values(336, 336%127,'336.');
insert into tbl2 values(335, 335%127,'335.');
insert into tbl2 values(334, 334%127,'334.');
insert into tbl2 values(333, 333%127,'333.');
insert into tbl2 values(332, 332%127,'332.');
insert into tbl2 values(331, 331%127,'331.');
insert into tbl2 values(330, 330%127,'330.');
insert into tbl2 values(329, 329%127,'329.');
insert into tbl2 values(328, 328%127,'328.');
insert into tbl2 values(327, 327%127,'327.');
insert into tbl2 values(326, 326%127,'326.');
insert into tbl2 values(325, 325%127,'325.');
insert into tbl2 values(324, 324%127,'324.');
insert into tbl2 values(323, 323%127,'323.');
insert into tbl2 values(322, 322%127,'322.');
insert into tbl2 values(321, 321%127,'321.');
insert into tbl2 values(320, 320%127,'320.');
insert into tbl2 values(319, 319%127,'319.');
insert into tbl2 values(318, 318%127,'318.');
insert into tbl2 values(317, 317%127,'317.');
insert into tbl2 values(316, 316%127,'316.');
insert into tbl2 values(315, 315%127,'315.');
insert into tbl2 values(314, 314%127,'314.');
insert into tbl2 values(313, 313%127,'313.');
insert into tbl2 values(312, 312%127,'312.');
insert into tbl2 values(311, 311%127,'311.');
insert into tbl2 values(310, 310%127,'310.');
insert into tbl2 values(309, 309%127,'309.');
insert into tbl2 values(308, 308%127,'308.');
insert into tbl2 values(307, 307%127,'307.');
insert into tbl2 values(306, 306%127,'306.');
insert into tbl2 values(305, 305%127,'305.');
insert into tbl2 values(304, 304%127,'304.');
insert into tbl2 values(303, 303%127,'303.');
insert into tbl2 values(302, 302%127,'302.');
insert into tbl2 values(301, 301%127,'301.');
insert into tbl2 values(300, 300%127,'300.');
insert into tbl2 values(299, 299%127,'299.');
insert into tbl2 values(298, 298%127,'298.');
insert into tbl2 values(297, 297%127,'297.');
insert into tbl2 values(296, 296%127,'296.');
insert into tbl2 values(295, 295%127,'295.');
insert into tbl2 values(294, 294%127,'294.');
insert into tbl2 values(293, 293%127,'293.');
insert into tbl2 values(292, 292%127,'292.');
insert into tbl2 values(291, 291%127,'291.');
insert into tbl2 values(290, 290%127,'290.');
insert into tbl2 values(289, 289%127,'289.');
insert into tbl2 values(288, 288%127,'288.');
insert into tbl2 values(287, 287%127,'287.');
insert into tbl2 values(286, 286%127,'286.');
insert into tbl2 values(285, 285%127,'285.');
insert into tbl2 values(284, 284%127,'284.');
insert into tbl2 values(283, 283%127,'283.');
insert into tbl2 values(282, 282%127,'282.');
insert into tbl2 values(281, 281%127,'281.');
insert into tbl2 values(280, 280%127,'280.');
insert into tbl2 values(279, 279%127,'279.');
insert into tbl2 values(278, 278%127,'278.');
insert into tbl2 values(277, 277%127,'277.');
insert into tbl2 values(276, 276%127,'276.');
insert into tbl2 values(275, 275%127,'275.');
insert into tbl2 values(274, 274%127,'274.');
insert into tbl2 values(273, 273%127,'273.');
insert into tbl2 values(272, 272%127,'272.');
insert into tbl2 values(271, 271%127,'271.');
insert into tbl2 values(270, 270%127,'270.');
insert into tbl2 values(269, 269%127,'269.');
insert into tbl2 values(268, 268%127,'268.');
insert into tbl2 values(267, 267%127,'267.');
insert into tbl2 values(266, 266%127,'266.');
insert into tbl2 values(265, 265%127,'265.');
insert into tbl2 values(264, 264%127,'264.');
insert into tbl2 values(263, 263%127,'263.');
insert into tbl2 values(262, 262%127,'262.');
insert into tbl2 values(261, 261%127,'261.');
insert into tbl2 values(260, 260%127,'260.');
insert into tbl2 values(259, 259%127,'259.');
insert into tbl2 values(258, 258%127,'258.');
insert into tbl2 values(257, 257%127,'257.');
insert into tbl2 values(256, 256%127,'256.');
insert into tbl2 values(255, 255%127,'255.');
insert into tbl2 values(254, 254%127,'254.');
insert into tbl2 values(253, 253%127,'253.');
insert into tbl2 values(252, 252%127,'252.');
insert into tbl2 values(251, 251%127,'251.');
insert into tbl2 values(250, 250%127,'250.');
insert into tbl2 values(249, 249%127,'249.');
insert into tbl2 values(248, 248%127,'248.');
insert into tbl2 values(247, 247%127,'247.');
insert into tbl2 values(246, 246%127,'246.');
insert into tbl2 values(245, 245%127,'245.');
insert into tbl2 values(244, 244%127,'244.');
insert into tbl2 values(243, 243%127,'243.');
insert into tbl2 values(242, 242%127,'242.');
insert into tbl2 values(241, 241%127,'241.');
insert into tbl2 values(240, 240%127,'240.');
insert into tbl2 values(239, 239%127,'239.');
insert into tbl2 values(238, 238%127,'238.');
insert into tbl2 values(237, 237%127,'237.');
insert into tbl2 values(236, 236%127,'236.');
insert into tbl2 values(235, 235%127,'235.');
insert into tbl2 values(234, 234%127,'234.');
insert into tbl2 values(233, 233%127,'233.');
insert into tbl2 values(232, 232%127,'232.');
insert into tbl2 values(231, 231%127,'231.');
insert into tbl2 values(230, 230%127,'230.');
insert into tbl2 values(229, 229%127,'229.');
insert into tbl2 values(228, 228%127,'228.');
insert into tbl2 values(227, 227%127,'227.');
insert into tbl2 values(226, 226%127,'226.');
insert into tbl2 values(225, 225%127,'225.');
insert into tbl2 values(224, 224%127,'224.');
insert into tbl2 values(223, 223%127,'223.');
insert into tbl2 values(222, 222%127,'222.');
insert into tbl2 values(221, 221%127,'221.');
insert into tbl2 values(220, 220%127,'220.');
insert into tbl2 values(219, 219%127,'219.');
insert into tbl2 values(218, 218%127,'218.');
insert into tbl2 values(217, 217%127,'217.');
insert into tbl2 values(216, 216%127,'216.');
insert into tbl2 values(215, 215%127,'215.');
insert into tbl2 values(214, 214%127,'214.');
insert into tbl2 values(213, 213%127,'213.');
insert into tbl2 values(212, 212%127,'212.');
insert into tbl2 values(211, 211%127,'211.');
insert into tbl2 values(210, 210%127,'210.');
insert into tbl2 values(209, 209%127,'209.');
insert into tbl2 values(208, 208%127,'208.');
insert into tbl2 values(207, 207%127,'207.');
insert into tbl2 values(206, 206%127,'206.');
insert into tbl2 values(205, 205%127,'205.');
insert into tbl2 values(204, 204%127,'204.');
insert into tbl2 values(203, 203%127,'203.');
insert into tbl2 values(202, 202%127,'202.');
insert into tbl2 values(201, 201%127,'201.');
insert into tbl2 values(200, 200%127,'200.');
insert into tbl2 values(199, 199%127,'199.');
insert into tbl2 values(198, 198%127,'198.');
insert into tbl2 values(197, 197%127,'197.');
insert into tbl2 values(196, 196%127,'196.');
insert into tbl2 values(195, 195%127,'195.');
insert into tbl2 values(194, 194%127,'194.');
insert into tbl2 values(193, 193%127,'193.');
insert into tbl2 values(192, 192%127,'192.');
insert into tbl2 values(191, 191%127,'191.');
insert into tbl2 values(190, 190%127,'190.');
insert into tbl2 values(189, 189%127,'189.');
insert into tbl2 values(188, 188%127,'188.');
insert into tbl2 values(187, 187%127,'187.');
insert into tbl2 values(186, 186%127,'186.');
insert into tbl2 values(185, 185%127,'185.');
insert into tbl2 values(184, 184%127,'184.');
insert into tbl2 values(183, 183%127,'183.');
insert into tbl2 values(182, 182%127,'182.');
insert into tbl2 values(181, 181%127,'181.');
insert into tbl2 values(180, 180%127,'180.');
insert into tbl2 values(179, 179%127,'179.');
insert into tbl2 values(178, 178%127,'178.');
insert into tbl2 values(177, 177%127,'177.');
insert into tbl2 values(176, 176%127,'176.');
insert into tbl2 values(175, 175%127,'175.');
insert into tbl2 values(174, 174%127,'174.');
insert into tbl2 values(173, 173%127,'173.');
insert into tbl2 values(172, 172%127,'172.');
insert into tbl2 values(171, 171%127,'171.');
insert into tbl2 values(170, 170%127,'170.');
insert into tbl2 values(169, 169%127,'169.');
insert into tbl2 values(168, 168%127,'168.');
insert into tbl2 values(167, 167%127,'167.');
insert into tbl2 values(166, 166%127,'166.');
insert into tbl2 values(165, 165%127,'165.');
insert into tbl2 values(164, 164%127,'164.');
insert into tbl2 values(163, 163%127,'163.');
insert into tbl2 values(162, 162%127,'162.');
insert into tbl2 values(161, 161%127,'161.');
insert into tbl2 values(160, 160%127,'160.');
insert into tbl2 values(159, 159%127,'159.');
insert into tbl2 values(158, 158%127,'158.');
insert into tbl2 values(157, 157%127,'157.');
insert into tbl2 values(156, 156%127,'156.');
insert into tbl2 values(155, 155%127,'155.');
insert into tbl2 values(154, 154%127,'154.');
insert into tbl2 values(153, 153%127,'153.');
insert into tbl2 values(152, 152%127,'152.');
insert into tbl2 values(151, 151%127,'151.');
insert into tbl2 values(150, 150%127,'150.');
insert into tbl2 values(149, 149%127,'149.');
insert into tbl2 values(148, 148%127,'148.');
insert into tbl2 values(147, 147%127,'147.');
insert into tbl2 values(146, 146%127,'146.');
insert into tbl2 values(145, 145%127,'145.');
insert into tbl2 values(144, 144%127,'144.');
insert into tbl2 values(143, 143%127,'143.');
insert into tbl2 values(142, 142%127,'142.');
insert into tbl2 values(141, 141%127,'141.');
insert into tbl2 values(140, 140%127,'140.');
insert into tbl2 values(139, 139%127,'139.');
insert into tbl2 values(138, 138%127,'138.');
insert into tbl2 values(137, 137%127,'137.');
insert into tbl2 values(136, 136%127,'136.');
insert into tbl2 values(135, 135%127,'135.');
insert into tbl2 values(134, 134%127,'134.');
insert into tbl2 values(133, 133%127,'133.');
insert into tbl2 values(132, 132%127,'132.');
insert into tbl2 values(131, 131%127,'131.');
insert into tbl2 values(130, 130%127,'130.');
insert into tbl2 values(129, 129%127,'129.');
insert into tbl2 values(128, 128%127,'128.');
insert into tbl2 values(127, 127%127,'127.');
insert into tbl2 values(126, 126%127,'126.');
insert into tbl2 values(125, 125%127,'125.');
insert into tbl2 values(124, 124%127,'124.');
insert into tbl2 values(123, 123%127,'123.');
insert into tbl2 values(122, 122%127,'122.');
insert into tbl2 values(121, 121%127,'121.');
insert into tbl2 values(120, 120%127,'120.');
insert into tbl2 values(119, 119%127,'119.');
insert into tbl2 values(118, 118%127,'118.');
insert into tbl2 values(117, 117%127,'117.');
insert into tbl2 values(116, 116%127,'116.');
insert into tbl2 values(115, 115%127,'115.');
insert into tbl2 values(114, 114%127,'114.');
insert into tbl2 values(113, 113%127,'113.');
insert into tbl2 values(112, 112%127,'112.');
insert into tbl2 values(111, 111%127,'111.');
insert into tbl2 values(110, 110%127,'110.');
insert into tbl2 values(109, 109%127,'109.');
insert into tbl2 values(108, 108%127,'108.');
insert into tbl2 values(107, 107%127,'107.');
insert into tbl2 values(106, 106%127,'106.');
insert into tbl2 values(105, 105%127,'105.');
insert into tbl2 values(104, 104%127,'104.');
insert into tbl2 values(103, 103%127,'103.');
insert into tbl2 values(102, 102%127,'102.');
insert into tbl2 values(101, 101%127,'101.');
insert into tbl2 values(100, 100%127,'100.');
insert into tbl2 values(99, 99%127,'99.');
insert into tbl2 values(98, 98%127,'98.');
insert into tbl2 values(97, 97%127,'97.');
insert into tbl2 values(96, 96%127,'96.');
insert into tbl2 values(95, 95%127,'95.');
insert into tbl2 values(94, 94%127,'94.');
insert into tbl2 values(93, 93%127,'93.');
insert into tbl2 values(92, 92%127,'92.');
insert into tbl2 values(91, 91%127,'91.');
insert into tbl2 values(90, 90%127,'90.');
insert into tbl2 values(89, 89%127,'89.');
insert into tbl2 values(88, 88%127,'88.');
insert into tbl2 values(87, 87%127,'87.');
insert into tbl2 values(86, 86%127,'86.');
insert into tbl2 values(85, 85%127,'85.');
insert into tbl2 values(84, 84%127,'84.');
insert into tbl2 values(83, 83%127,'83.');
insert into tbl2 values(82, 82%127,'82.');
insert into tbl2 values(81, 81%127,'81.');
insert into tbl2 values(80, 80%127,'80.');
insert into tbl2 values(79, 79%127,'79.');
insert into tbl2 values(78, 78%127,'78.');
insert into tbl2 values(77, 77%127,'77.');
insert into tbl2 values(76, 76%127,'76.');
insert into tbl2 values(75, 75%127,'75.');
insert into tbl2 values(74, 74%127,'74.');
insert into tbl2 values(73, 73%127,'73.');
insert into tbl2 values(72, 72%127,'72.');
insert into tbl2 values(71, 71%127,'71.');
insert into tbl2 values(70, 70%127,'70.');
insert into tbl2 values(69, 69%127,'69.');
insert into tbl2 values(68, 68%127,'68.');
insert into tbl2 values(67, 67%127,'67.');
insert into tbl2 values(66, 66%127,'66.');
insert into tbl2 values(65, 65%127,'65.');
insert into tbl2 values(64, 64%127,'64.');
insert into tbl2 values(63, 63%127,'63.');
insert into tbl2 values(62, 62%127,'62.');
insert into tbl2 values(61, 61%127,'61.');
insert into tbl2 values(60, 60%127,'60.');
insert into tbl2 values(59, 59%127,'59.');
insert into tbl2 values(58, 58%127,'58.');
insert into tbl2 values(57, 57%127,'57.');
insert into tbl2 values(56, 56%127,'56.');
insert into tbl2 values(55, 55%127,'55.');
insert into tbl2 values(54, 54%127,'54.');
insert into tbl2 values(53, 53%127,'53.');
insert into tbl2 values(52, 52%127,'52.');
insert into tbl2 values(51, 51%127,'51.');
insert into tbl2 values(50, 50%127,'50.');
insert into tbl2 values(49, 49%127,'49.');
insert into tbl2 values(48, 48%127,'48.');
insert into tbl2 values(47, 47%127,'47.');
insert into tbl2 values(46, 46%127,'46.');
insert into tbl2 values(45, 45%127,'45.');
insert into tbl2 values(44, 44%127,'44.');
insert into tbl2 values(43, 43%127,'43.');
insert into tbl2 values(42, 42%127,'42.');
insert into tbl2 values(41, 41%127,'41.');
insert into tbl2 values(40, 40%127,'40.');
insert into tbl2 values(39, 39%127,'39.');
insert into tbl2 values(38, 38%127,'38.');
insert into tbl2 values(37, 37%127,'37.');
insert into tbl2 values(36, 36%127,'36.');
insert into tbl2 values(35, 35%127,'35.');
insert into tbl2 values(34, 34%127,'34.');
insert into tbl2 values(33, 33%127,'33.');
insert into tbl2 values(32, 32%127,'32.');
insert into tbl2 values(31, 31%127,'31.');
insert into tbl2 values(30, 30%127,'30.');
insert into tbl2 values(29, 29%127,'29.');
insert into tbl2 values(28, 28%127,'28.');
insert into tbl2 values(27, 27%127,'27.');
insert into tbl2 values(26, 26%127,'26.');
insert into tbl2 values(25, 25%127,'25.');
insert into tbl2 values(24, 24%127,'24.');
insert into tbl2 values(23, 23%127,'23.');
insert into tbl2 values(22, 22%127,'22.');
insert into tbl2 values(21, 21%127,'21.');
insert into tbl2 values(20, 20%127,'20.');
insert into tbl2 values(19, 19%127,'19.');
insert into tbl2 values(18, 18%127,'18.');
insert into tbl2 values(17, 17%127,'17.');
insert into tbl2 values(16, 16%127,'16.');
insert into tbl2 values(15, 15%127,'15.');
insert into tbl2 values(14, 14%127,'14.');
insert into tbl2 values(13, 13%127,'13.');
insert into tbl2 values(12, 12%127,'12.');
insert into tbl2 values(11, 11%127,'11.');
insert into tbl2 values(10, 10%127,'10.');
insert into tbl2 values(9, 9%127,'9.');
insert into tbl2 values(8, 8%127,'8.');
insert into tbl2 values(7, 7%127,'7.');
insert into tbl2 values(6, 6%127,'6.');
insert into tbl2 values(5, 5%127,'5.');
insert into tbl2 values(4, 4%127,'4.');
insert into tbl2 values(3, 3%127,'3.');
insert into tbl2 values(2, 2%127,'2.');
insert into tbl2 values(1, 1%127,'1.');
COMMIT;
SET autocommit = default;
ANALYZE TABLE tbl1, tbl2;
Table	Op	Msg_type	Msg_text
test.tbl1	analyze	status	OK
test.tbl2	analyze	status	OK
SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
LIMIT 5;
tlogin	sp
1	-1.00
2	-2.00
3	-3.00
4	-4.00
5	-5.00
EXPLAIN SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	PRIMARY,numb	PRIMARY	4	NULL	1	100.00	NULL
1	PRIMARY	t2	NULL	ref	login	login	4	test.t1.login	1	100.00	Using index
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
1	PRIMARY	<derived3>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
3	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
2	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.login' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.login' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`login` AS `tlogin`,((`test`.`t1`.`numb` - ifnull(`derived_1_2`.`sum(nump)`,0)) - ifnull(`derived_1_3`.`sum(nump)`,0)) AS `sp` from `test`.`tbl1` `t1` join `test`.`tbl2` `t2` left join (/* select#2 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_2` on((`derived_1_2`.`login` = `test`.`t1`.`login`)) left join (/* select#3 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_3` on((`derived_1_3`.`login` = `test`.`t1`.`login`)) where (`test`.`t2`.`login` = `test`.`t1`.`login`) group by `test`.`t1`.`login` limit 5
SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
ORDER BY sp
LIMIT 5;
tlogin	sp
500	-500.00
499	-499.00
498	-498.00
497	-497.00
496	-496.00
EXPLAIN SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
ORDER BY sp
LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	PRIMARY,numb	PRIMARY	4	NULL	500	100.00	Using temporary; Using filesort
1	PRIMARY	t2	NULL	ref	login	login	4	test.t1.login	1	100.00	Using index
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
1	PRIMARY	<derived3>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
3	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
2	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.login' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.login' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`login` AS `tlogin`,((`test`.`t1`.`numb` - ifnull(`derived_1_2`.`sum(nump)`,0)) - ifnull(`derived_1_3`.`sum(nump)`,0)) AS `sp` from `test`.`tbl1` `t1` join `test`.`tbl2` `t2` left join (/* select#2 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_2` on((`derived_1_2`.`login` = `test`.`t1`.`login`)) left join (/* select#3 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_3` on((`derived_1_3`.`login` = `test`.`t1`.`login`)) where (`test`.`t2`.`login` = `test`.`t1`.`login`) group by `test`.`t1`.`login` order by `sp` limit 5
SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
ORDER BY numb - IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0)
- IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0)
LIMIT 5;
tlogin	sp
500	-500.00
499	-499.00
498	-498.00
497	-497.00
496	-496.00
EXPLAIN SELECT
t1.login AS tlogin,
numb -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) -
IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0) as sp
FROM tbl1 t1, tbl2 t2
WHERE t1.login=t2.login
GROUP BY t1.login
ORDER BY numb - IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0)
- IFNULL((SELECT sum(nump) FROM tbl2 WHERE login=t1.login), 0)
LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	PRIMARY,numb	PRIMARY	4	NULL	500	100.00	Using temporary; Using filesort
1	PRIMARY	t2	NULL	ref	login	login	4	test.t1.login	1	100.00	Using index
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
1	PRIMARY	<derived3>	NULL	ref	<auto_key0>	<auto_key0>	4	test.t1.login	10	100.00	NULL
3	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
2	DERIVED	tbl2	NULL	index	login	login	4	NULL	500	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.login' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.login' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`login` AS `tlogin`,((`test`.`t1`.`numb` - ifnull(`derived_1_2`.`sum(nump)`,0)) - ifnull(`derived_1_3`.`sum(nump)`,0)) AS `sp` from `test`.`tbl1` `t1` join `test`.`tbl2` `t2` left join (/* select#2 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_2` on((`derived_1_2`.`login` = `test`.`t1`.`login`)) left join (/* select#3 */ select sum(`test`.`tbl2`.`nump`) AS `sum(nump)`,`test`.`tbl2`.`login` AS `login` from `test`.`tbl2` group by `test`.`tbl2`.`login`) `derived_1_3` on((`derived_1_3`.`login` = `test`.`t1`.`login`)) where (`test`.`t2`.`login` = `test`.`t1`.`login`) group by `test`.`t1`.`login` order by ((`test`.`t1`.`numb` - ifnull(`derived_1_2`.`sum(nump)`,0)) - ifnull(`derived_1_3`.`sum(nump)`,0)) limit 5
DROP TABLE tbl1, tbl2;
Bug 2
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE t4 (a INT NOT NULL, b INT NOT NULL);
INSERT INTO t2 VALUES (1, 7), (2, 7), (2,10);
INSERT INTO t4 VALUES (4, 8), (3, 8), (5, 9), (12, 7), (1, 7),
(10, 9), (9, 6), (7, 6), (3, 9), (1, 10);
ANALYZE TABLE t2, t4;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
test.t4	analyze	status	OK
SELECT b, MAX(a) AS ma FROM t4
GROUP BY b HAVING ma < (SELECT MAX(t2.a) FROM t2 WHERE t2.b=t4.b);
b	ma
10	1
EXPLAIN SELECT b, MAX(a) AS ma FROM t4
GROUP BY b HAVING ma < (SELECT MAX(t2.a) FROM t2 WHERE t2.b=t4.b);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t4	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using temporary
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using temporary
Warnings:
Note	1276	Field or reference 'test.t4.b' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t4.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t4`.`b` AS `b`,max(`test`.`t4`.`a`) AS `ma` from `test`.`t4` left join (/* select#2 */ select max(`test`.`t2`.`a`) AS `MAX(t2.a)`,`test`.`t2`.`b` AS `b` from `test`.`t2` group by `test`.`t2`.`b`) `derived_1_2` on((`derived_1_2`.`b` = `test`.`t4`.`b`)) where true group by `test`.`t4`.`b` having (`ma` < `derived_1_2`.`MAX(t2.a)`)
DROP TABLE t2, t4;
Bug 3

This query was caused an issue at one point, while we
still tried to moved explicit grouping into a derived table.
Should work fine now.
CREATE TEMPORARY TABLE tmp_digests (
schema_name VARCHAR(64) DEFAULT NULL,
digest VARCHAR(64) DEFAULT NULL,
digest_text LONGTEXT,
count_star BIGINT UNSIGNED NOT NULL,
sum_timer_wait BIGINT UNSIGNED NOT NULL,
min_timer_wait BIGINT UNSIGNED NOT NULL,
avg_timer_wait BIGINT UNSIGNED NOT NULL,
max_timer_wait BIGINT UNSIGNED NOT NULL,
sum_lock_time BIGINT UNSIGNED NOT NULL,
sum_errors BIGINT UNSIGNED NOT NULL,
sum_warnings BIGINT UNSIGNED NOT NULL,
sum_rows_affected BIGINT UNSIGNED NOT NULL,
sum_rows_sent BIGINT UNSIGNED NOT NULL,
sum_rows_examined BIGINT UNSIGNED NOT NULL,
sum_created_tmp_disk_tables BIGINT UNSIGNED NOT NULL,
sum_created_tmp_tables BIGINT UNSIGNED NOT NULL,
sum_select_full_join BIGINT UNSIGNED NOT NULL,
sum_select_full_range_join BIGINT UNSIGNED NOT NULL,
sum_select_range BIGINT UNSIGNED NOT NULL,
sum_select_range_check BIGINT UNSIGNED NOT NULL,
sum_select_scan BIGINT UNSIGNED NOT NULL,
sum_sort_merge_passes BIGINT UNSIGNED NOT NULL,
sum_sort_range BIGINT UNSIGNED NOT NULL,
sum_sort_rows BIGINT UNSIGNED NOT NULL,
sum_sort_scan BIGINT UNSIGNED NOT NULL,
sum_no_index_used BIGINT UNSIGNED NOT NULL,
sum_no_good_index_used BIGINT UNSIGNED NOT NULL,
sum_cpu_time BIGINT UNSIGNED NOT NULL,
max_controlled_memory BIGINT UNSIGNED NOT NULL,
max_total_memory BIGINT UNSIGNED NOT NULL,
count_secondary BIGINT UNSIGNED NOT NULL,
first_seen TIMESTAMP NULL DEFAULT NULL,
last_seen TIMESTAMP NULL DEFAULT NULL,
quantile_95 BIGINT UNSIGNED NOT NULL,
quantile_99 BIGINT UNSIGNED NOT NULL,
quantile_999 BIGINT UNSIGNED NOT NULL,
query_sample_text longtext,
query_sample_seen TIMESTAMP NULL DEFAULT NULL,
query_sample_timer_wait BIGINT UNSIGNED NOT NULL,
INDEX (schema_name, digest)
) DEFAULT CHARSET=utf8mb4;
INSERT INTO tmp_digests SELECT * FROM performance_schema.events_statements_summary_by_digest;
CREATE TEMPORARY TABLE tmp_digest_avg_latency_distribution1 (
cnt BIGINT UNSIGNED NOT NULL,
avg_us DECIMAL(21,0) NOT NULL,
PRIMARY KEY (avg_us)
) ENGINE=InnoDB;
CREATE TEMPORARY TABLE tmp_digest_avg_latency_distribution2 (
cnt BIGINT UNSIGNED NOT NULL,
avg_us DECIMAL(21,0) NOT NULL,
PRIMARY KEY (avg_us)
) ENGINE=InnoDB;
INSERT INTO tmp_digest_avg_latency_distribution1
SELECT COUNT(*) cnt,
ROUND(avg_timer_wait/1000000) AS avg_us
FROM tmp_digests
GROUP BY avg_us;
INSERT INTO tmp_digest_avg_latency_distribution2 SELECT * FROM tmp_digest_avg_latency_distribution1;
CREATE TEMPORARY TABLE tmp_digest_95th_percentile_by_avg_us (
avg_us decimal(21,0) NOT NULL,
percentile decimal(46,4) NOT NULL,
PRIMARY KEY (avg_us)
) ENGINE=InnoDB;
ANALYZE TABLE tmp_digests;
Table	Op	Msg_type	Msg_text
test.tmp_digests	analyze	status	OK
ANALYZE TABLE tmp_digest_avg_latency_distribution1;
Table	Op	Msg_type	Msg_text
test.tmp_digest_avg_latency_distribution1	analyze	status	OK
ANALYZE TABLE tmp_digest_avg_latency_distribution2;
Table	Op	Msg_type	Msg_text
test.tmp_digest_avg_latency_distribution2	analyze	status	OK
ANALYZE TABLE tmp_digest_95th_percentile_by_avg_us;
Table	Op	Msg_type	Msg_text
test.tmp_digest_95th_percentile_by_avg_us	analyze	status	OK
PREPARE p from 'INSERT INTO tmp_digest_95th_percentile_by_avg_us
SELECT s2.avg_us avg_us,
IFNULL(SUM(s1.cnt)/
NULLIF((SELECT COUNT(*) FROM tmp_digests), 0), 0) percentile
FROM tmp_digest_avg_latency_distribution1 AS s1
JOIN tmp_digest_avg_latency_distribution2 AS s2
ON s1.avg_us <= s2.avg_us
GROUP BY s2.avg_us
HAVING percentile > 0.95
ORDER BY percentile
LIMIT 1';
EXECUTE p;
SELECT * from tmp_digest_95th_percentile_by_avg_us;
avg_us	percentile
xxxxx	xxxxx
EXPLAIN INSERT INTO tmp_digest_95th_percentile_by_avg_us
SELECT s2.avg_us avg_us,
IFNULL(SUM(s1.cnt)/
NULLIF((SELECT COUNT(*) FROM tmp_digests), 0), 0) percentile
FROM tmp_digest_avg_latency_distribution1 AS s1
JOIN tmp_digest_avg_latency_distribution2 AS s2
ON s1.avg_us <= s2.avg_us
GROUP BY s2.avg_us
HAVING percentile > 0.95
ORDER BY percentile
LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	INSERT	tmp_digest_95th_percentile_by_avg_us	NULL	ALL	NULL	NULL	NULL	NULL	xxx	NULL	NULL
1	PRIMARY	s2	NULL	index	PRIMARY	PRIMARY	10	NULL	xxx	100.00	Using index; Using temporary; Using filesort
1	PRIMARY	s1	NULL	ALL	PRIMARY	NULL	NULL	NULL	xxx	33.33	Range checked for each record (index map: 0x1)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	xxx	100.00	Using where; Using join buffer (hash join)
2	DERIVED	tmp_digests	NULL	index	NULL	schema_name	518	NULL	xxx	100.00	Using index
Warnings:
Note	1003	insert into `test`.`tmp_digest_95th_percentile_by_avg_us` /* select#1 */ select `test`.`s2`.`avg_us` AS `avg_us`,ifnull((sum(`test`.`s1`.`cnt`) / nullif(`derived_1_2`.`COUNT(*)`,0)),0) AS `percentile` from `test`.`tmp_digest_avg_latency_distribution1` `s1` join `test`.`tmp_digest_avg_latency_distribution2` `s2` left join (/* select#2 */ select count(0) AS `COUNT(*)` from `test`.`tmp_digests`) `derived_1_2` on(true) where (`test`.`s1`.`avg_us` <= `test`.`s2`.`avg_us`) group by `test`.`s2`.`avg_us` having (`percentile` > 0.95) order by `percentile` limit 1
DROP PREPARE p;
DROP TEMPORARY TABLE tmp_digest_95th_percentile_by_avg_us;
DROP TEMPORARY TABLE tmp_digest_avg_latency_distribution2;
DROP TEMPORARY TABLE tmp_digest_avg_latency_distribution1;
DROP TEMPORARY TABLE tmp_digests;
Bug 4

Nested query with transformable scalar subquery at both levels:
interference with semijoin: 1) derived table name not unique
after flattening, 2) flattening needs to happen after
transforming scalar subqueries to derived tables (on the top
level here we got problems).
CREATE TABLE t1 (col_int_key int, KEY col_int_key (col_int_key));
INSERT INTO t1 VALUES (0),(8),(1),(8);
CREATE TABLE where_subselect_20070
SELECT table2 .col_int_key AS field1,
( SELECT COUNT( col_int_key )
FROM t1
)
FROM t1 AS table1
JOIN t1 AS table2
ON table2.col_int_key = table1.col_int_key;
ANALYZE TABLE t1, where_subselect_20070;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.where_subselect_20070	analyze	status	OK
SELECT *
FROM where_subselect_20070
WHERE (field1, ( SELECT COUNT( col_int_key ) FROM t1 )) IN (
SELECT table2 .col_int_key AS field1,
( SELECT COUNT( col_int_key )
FROM t1
)
FROM t1 AS table1
JOIN t1 AS table2
ON table2.col_int_key = table1.col_int_key
);
field1	( SELECT COUNT( col_int_key )
)
0	4
1	4
8	4
8	4
8	4
8	4
FROM t1
EXPLAIN SELECT *
FROM where_subselect_20070
WHERE (field1, ( SELECT COUNT( col_int_key ) FROM t1 )) IN (
SELECT table2 .col_int_key AS field1,
( SELECT COUNT( col_int_key )
FROM t1
)
FROM t1 AS table1
JOIN t1 AS table2
ON table2.col_int_key = table1.col_int_key
);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	PRIMARY	where_subselect_20070	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<subquery3>	NULL	eq_ref	<auto_distinct_key>	<auto_distinct_key>	14	test.where_subselect_20070.field1,derived_1_2.COUNT( col_int_key )	1	100.00	NULL
3	MATERIALIZED	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
3	MATERIALIZED	table1	NULL	index	col_int_key	col_int_key	5	NULL	4	100.00	Using where; Using index; Using join buffer (hash join)
3	MATERIALIZED	table2	NULL	ref	col_int_key	col_int_key	5	test.table1.col_int_key	1	100.00	Using index
4	DERIVED	t1	NULL	index	NULL	col_int_key	5	NULL	4	100.00	Using index
2	DERIVED	t1	NULL	index	NULL	col_int_key	5	NULL	4	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`where_subselect_20070`.`field1` AS `field1`,`test`.`where_subselect_20070`.`( SELECT COUNT( col_int_key )
FROM t1
)` AS `( SELECT COUNT( col_int_key )
FROM t1
)` from `test`.`where_subselect_20070` join (/* select#2 */ select count(`test`.`t1`.`col_int_key`) AS `COUNT( col_int_key )` from `test`.`t1`) `derived_1_2` semi join (`test`.`t1` `table1` join `test`.`t1` `table2` join (/* select#4 */ select count(`test`.`t1`.`col_int_key`) AS `COUNT( col_int_key )` from `test`.`t1`) `derived_3_4`) where ((`<subquery3>`.`( SELECT COUNT( col_int_key )
FROM t1
)` = `derived_1_2`.`COUNT( col_int_key )`) and (`<subquery3>`.`field1` = `test`.`where_subselect_20070`.`field1`) and (`test`.`table2`.`col_int_key` = `test`.`table1`.`col_int_key`))
DROP TABLE t1, where_subselect_20070;
Bug 5

We used to not get the error: the GROUP BY transformation into a
derived table didn't see outer reference "outr.a"
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1), (1,2), (1,3);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT COUNT(*), (SELECT count(*) FROM t1 inr WHERE inr.a = outr.a)
FROM t1 outr;
ERROR 42000: In aggregated query without GROUP BY, expression #2 of SELECT list contains nonaggregated column 'test.outr.a'; this is incompatible with sql_mode=only_full_group_by
DROP TABLE t1;
Bug, cf requirement FR#4 addendum: If a prepared statement was
prepared with the transformation enabled, it will also be
executed with the transformation.
CREATE TABLE t1(a DATETIME NOT NULL);
INSERT INTO t1 VALUES ('20060606155555');
PREPARE s FROM
'SELECT a FROM t1 WHERE a=(SELECT MAX(a) FROM t1) AND (a="20060606155555")';
SET optimizer_switch='subquery_to_derived=off';
EXECUTE s;
a
2006-06-06 15:55:55
Try the other way too. Transform will not happen on EXECUTE
as it can be performed only on PREPARE.
PREPARE s FROM
'SELECT a FROM t1 WHERE a=(SELECT MAX(a) FROM t1) AND (a="20060606155555")';
SET optimizer_switch='subquery_to_derived=on';
EXECUTE s;
a
2006-06-06 15:55:55
DROP TABLE t1;
#
# Bug fix: we transformed a query which cannot be transformed
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SET optimizer_switch='subquery_to_derived=off';
SELECT (SELECT MIN(a) FROM t1) a, MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
a	mx
1	NULL
SELECT MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
mx
NULL
SET optimizer_switch='subquery_to_derived=on';
SELECT (SELECT MIN(a) FROM t1) a, MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
a	mx
1	NULL
EXPLAIN SELECT (SELECT MIN(a) FROM t1) a, MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
3	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select min(`test`.`t1`.`a`) from `test`.`t1`) AS `a`,max(`test`.`t1`.`a`) AS `mx` from `test`.`t1` where false having ((/* select#3 */ select min(`test`.`t1`.`a`) from `test`.`t1`) > 0)
SELECT MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
mx
NULL
EXPLAIN SELECT MAX(a) AS mx
FROM t1
WHERE FALSE
HAVING (SELECT MIN(a) FROM t1) > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`a`) AS `mx` from `test`.`t1` where false having ((/* select#2 */ select min(`test`.`t1`.`a`) from `test`.`t1`) > 0)
DROP TABLE t1;
#
# Bug#30616646 WL#12885: SIG 6 IN JOIN::MAKE_JOIN_PLAN() AT SQL/SQL_OPTIMIZER.CC
#
CREATE TABLE tab1(pk int PRIMARY KEY);
SELECT *
FROM tab1 AS table1
LEFT JOIN
( tab1 AS table2 JOIN
tab1 AS table3
ON 1 <= (SELECT COUNT(pk) FROM tab1) )
ON 1
WHERE (SELECT MIN(pk) FROM tab1);
pk	pk	pk
EXPLAIN SELECT *
FROM tab1 AS table1
LEFT JOIN
( tab1 AS table2 JOIN
tab1 AS table3
ON 1 <= (SELECT COUNT(pk) FROM tab1) )
ON 1
WHERE (SELECT MIN(pk) FROM tab1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	table1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
1	PRIMARY	table2	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
1	PRIMARY	table3	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
3	DERIVED	tab1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
2	DERIVED	tab1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`table1`.`pk` AS `pk`,`test`.`table2`.`pk` AS `pk`,`test`.`table3`.`pk` AS `pk` from `test`.`tab1` `table1` left join (`test`.`tab1` `table2` join (/* select#2 */ select count(`test`.`tab1`.`pk`) AS `COUNT(pk)` from `test`.`tab1`) `derived_1_2` join `test`.`tab1` `table3`) on(((1 <= `derived_1_2`.`COUNT(pk)`))) join (/* select#3 */ select min(`test`.`tab1`.`pk`) AS `MIN(pk)` from `test`.`tab1` having (0 <> min(`test`.`tab1`.`pk`))) `derived_1_3` where true
DROP TABLE tab1;
#
# Bug#30617216 WL#12885 SIG6 IN JOIN::ADD_HAVING_AS_TMP_TABLE_COND() AT SQL/SQL_SELECT.CC
#
# ANY/ALL/SOME transformation makes us skip subquery to derived
# transformation
#
CREATE TABLE c2 (col_varchar_key VARCHAR(1));
SELECT alias1.col_varchar_key
FROM c2 AS alias1
HAVING   alias1.col_varchar_key > SOME (SELECT col_varchar_key FROM c2)
ORDER BY alias1.col_varchar_key;
col_varchar_key
EXPLAIN SELECT alias1.col_varchar_key
FROM c2 AS alias1
HAVING   alias1.col_varchar_key > SOME (SELECT col_varchar_key FROM c2)
ORDER BY alias1.col_varchar_key;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using filesort
2	SUBQUERY	c2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`alias1`.`col_varchar_key` AS `col_varchar_key` from `test`.`c2` `alias1` having <nop>((`test`.`alias1`.`col_varchar_key` > (/* select#2 */ select min(`test`.`c2`.`col_varchar_key`) from `test`.`c2`))) order by `test`.`alias1`.`col_varchar_key`
DROP TABLE c2;
#
# Bug#30622834 WL#12885: ASSERTION `SELECT_LEX->IS_RECURSIVE()' FAILED
# Update: these are no longer transformed after Bug#31566339
CREATE TABLE t1(col_int INT);
SELECT *
FROM ((t1 AS a2
LEFT JOIN
t1 AS a1
ON  1 <= SOME (SELECT COUNT(*) FROM t1))
LEFT JOIN
t1
ON true);
col_int	col_int	col_int
EXPLAIN SELECT *
FROM ((t1 AS a2
LEFT JOIN
t1 AS a1
ON  1 <= SOME (SELECT COUNT(*) FROM t1))
LEFT JOIN
t1
ON true);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	a2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	a1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`a2`.`col_int` AS `col_int`,`test`.`a1`.`col_int` AS `col_int`,`test`.`t1`.`col_int` AS `col_int` from `test`.`t1` `a2` left join `test`.`t1` `a1` on(<nop>((1 <= <max>(/* select#2 */ select count(0) from `test`.`t1`)))) left join `test`.`t1` on(true) where true
SELECT *
FROM ((t1 AS a2
LEFT JOIN
t1 AS a1
ON  1 <= ALL (SELECT COUNT(*) FROM t1))
LEFT JOIN
t1
ON true);
col_int	col_int	col_int
EXPLAIN SELECT *
FROM ((t1 AS a2
LEFT JOIN
t1 AS a1
ON  1 <= ALL (SELECT COUNT(*) FROM t1))
LEFT JOIN
t1
ON true);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	a2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	a1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`a2`.`col_int` AS `col_int`,`test`.`a1`.`col_int` AS `col_int`,`test`.`t1`.`col_int` AS `col_int` from `test`.`t1` `a2` left join `test`.`t1` `a1` on(<not>((1 > <min>(/* select#2 */ select count(0) from `test`.`t1`)))) left join `test`.`t1` on(true) where true
SELECT *
FROM (t1
RIGHT JOIN
(t1 AS a1
RIGHT JOIN
t1 AS a2
ON  1 <= SOME (SELECT COUNT(*) FROM t1))
ON true);
col_int	col_int	col_int
EXPLAIN SELECT *
FROM (t1
RIGHT JOIN
(t1 AS a1
RIGHT JOIN
t1 AS a2
ON  1 <= SOME (SELECT COUNT(*) FROM t1))
ON true);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	a2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	a1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`col_int` AS `col_int`,`test`.`a1`.`col_int` AS `col_int`,`test`.`a2`.`col_int` AS `col_int` from `test`.`t1` `a2` left join `test`.`t1` `a1` on(<nop>((1 <= <max>(/* select#2 */ select count(0) from `test`.`t1`)))) left join `test`.`t1` on(true) where true
DROP TABLE t1;
#
# Bug#30626975 WL#12885: WL#12885: SIG 6 IN SELECT_LEX::SYNTHESIZE_DERIVED() AT SQL/SQL_RESOLVER.CC
# Update: ANY/ALL/SOME rejected.
CREATE TABLE t1(pk int PRIMARY KEY);
Simplified repro, requires -ps-protocol to fail before fix
SELECT t1.pk
FROM t1 LEFT JOIN ( SELECT t1.pk AS pk
FROM t1
WHERE (1 <= (SELECT MAX(t1.pk)
FROM t1)) ) alias2
ON true;
pk
EXPLAIN SELECT t1.pk
FROM t1 LEFT JOIN ( SELECT t1.pk AS pk
FROM t1
WHERE (1 <= (SELECT MAX(t1.pk)
FROM t1)) ) alias2
ON true;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
1	PRIMARY	t1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk` from `test`.`t1` left join (`test`.`t1` join (/* select#3 */ select max(`test`.`t1`.`pk`) AS `MAX(t1.pk)` from `test`.`t1`) `derived_2_3`) on(((1 <= `derived_2_3`.`MAX(t1.pk)`))) where true
Another mode of the bug: exercises has_scalar_to_derived_transform
which also needs to look inside join nest
PREPARE p FROM "SELECT t1.pk
FROM t1 LEFT JOIN ( SELECT t1.pk AS pk
FROM t1
WHERE (1 <= (SELECT MAX(t1.pk)
FROM t1)) ) alias2
ON true";
EXECUTE p;
pk
SET optimizer_switch='subquery_to_derived=off';
EXECUTE p;
pk
SET optimizer_switch='subquery_to_derived=on';
EXECUTE p;
pk
original repro, requires -ps-protocol to fail before fix)
SELECT alias1.pk
FROM t1 AS alias1 LEFT JOIN
t1 AS alias2 LEFT JOIN
(SELECT *
FROM t1
WHERE 1 <= ANY (SELECT c_sq1_alias1.pk
FROM t1 AS c_sq1_alias1 JOIN t1 AS c_sq1_alias2
ON TRUE
)
) AS alias3
ON TRUE
ON TRUE;
pk
EXPLAIN SELECT alias1.pk
FROM t1 AS alias1 LEFT JOIN
t1 AS alias2 LEFT JOIN
(SELECT *
FROM t1
WHERE 1 <= ANY (SELECT c_sq1_alias1.pk
FROM t1 AS c_sq1_alias1 JOIN t1 AS c_sq1_alias2
ON TRUE
)
) AS alias3
ON TRUE
ON TRUE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
1	PRIMARY	alias2	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using where; Using index; Using join buffer (hash join)
1	PRIMARY	t1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using where; Using index; Using join buffer (hash join)
3	SUBQUERY	c_sq1_alias1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
3	SUBQUERY	c_sq1_alias2	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`alias1`.`pk` AS `pk` from `test`.`t1` `alias1` left join (`test`.`t1` `alias2` left join (`test`.`t1`) on((<nop>((1 <= (/* select#3 */ select max(`test`.`c_sq1_alias1`.`pk`) from `test`.`t1` `c_sq1_alias1` join `test`.`t1` `c_sq1_alias2` where true)))))) on(true) where true
DROP TABLE t1;
#
# Bug#30627570 WL#12885 SIG11 IN ITEM_SUBSELECT::PLACE() AT SQL/ITEM_SUBSELECT.H
# Solved by fix for Bug#30626975. Included here for completeness.
#
CREATE TABLE X (col_varchar_key VARCHAR(1));
SET OPTIMIZER_SWITCH='subquery_to_derived=on';
PREPARE prep_stmt FROM
'SELECT col_varchar_key
 FROM (SELECT * FROM X
       WHERE X.col_varchar_key > (SELECT MIN(col_varchar_key)
                                  FROM X)) AS table1';
EXECUTE prep_stmt;
col_varchar_key
DROP TABLE X;
#
# Bug#30632595 WL#12885 SIG11 IN SELECT_LEX::NEST_DERIVED() AT SQL/SQL_RESOLVER.CC
#
CREATE TABLE n(col_int INT);
INSERT INTO n VALUES (1), (2), (3);
ANALYZE TABLE n;
Table	Op	Msg_type	Msg_text
test.n	analyze	status	OK
SELECT alias2.col_int
FROM (SELECT * FROM n) AS alias1
JOIN
(SELECT * FROM n) AS alias2
JOIN n
ON alias2.col_int < (SELECT MAX(col_int) FROM n)
ON TRUE;
col_int
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
2
2
2
EXPLAIN SELECT alias2.col_int
FROM (SELECT * FROM n) AS alias1
JOIN
(SELECT * FROM n) AS alias2
JOIN n
ON alias2.col_int < (SELECT MAX(col_int) FROM n)
ON TRUE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	n	NULL	ALL	NULL	NULL	NULL	NULL	3	33.33	Using where; Using join buffer (hash join)
1	PRIMARY	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
1	PRIMARY	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
4	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`n`.`col_int` AS `col_int` from `test`.`n` join `test`.`n` join (/* select#4 */ select max(`test`.`n`.`col_int`) AS `MAX(col_int)` from `test`.`n`) `derived_1_4` join `test`.`n` where (`test`.`n`.`col_int` < `derived_1_4`.`MAX(col_int)`)
DROP TABLE n;
#
# Bug#30644900 WL#12885 SIG 11 IN SELECT_LEX::TRANSFORM_SCALAR_SUBQUERIES_TO_DERIVED()
#
CREATE TABLE x(col_int_key INT);
# Don't transform this due to user variable (normally this would be ok,
# but here we get RAND_TABLE_BIT due to user variable here due because
# engine->uncacheable() sets UNCACHEABLE_RAND for user variable read, and
# not just assigment. And engine->uncacheable() propagates into
# used_tables as RAND_TABLE_BIT.
SELECT table1.col_int_key AS field1
FROM ((SELECT * FROM x
WHERE col_int_key <= (SELECT SUM(col_int_key)
FROM x
WHERE col_int_key < @var1)) AS table1
JOIN
x AS table2);
field1
EXPLAIN SELECT table1.col_int_key AS field1
FROM ((SELECT * FROM x
WHERE col_int_key <= (SELECT SUM(col_int_key)
FROM x
WHERE col_int_key < @var1)) AS table1
JOIN
x AS table2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	x	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	UNCACHEABLE SUBQUERY	x	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`x`.`col_int_key` AS `field1` from `test`.`x` join `test`.`x` `table2` where (`test`.`x`.`col_int_key` <= (/* select#3 */ select sum(`test`.`x`.`col_int_key`) from `test`.`x` where (`test`.`x`.`col_int_key` < <cache>((@`var1`)))))
# Transform if no user variable
SELECT table1.col_int_key AS field1
FROM ((SELECT * FROM x
WHERE col_int_key <= (SELECT SUM(col_int_key)
FROM x
WHERE col_int_key < 1)) AS table1
JOIN
x AS table2);
field1
EXPLAIN SELECT table1.col_int_key AS field1
FROM ((SELECT * FROM x
WHERE col_int_key <= (SELECT SUM(col_int_key)
FROM x
WHERE col_int_key < 1)) AS table1
JOIN
x AS table2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	x	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
3	DERIVED	x	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`x`.`col_int_key` AS `field1` from `test`.`x` join (/* select#3 */ select sum(`test`.`x`.`col_int_key`) AS `SUM(col_int_key)` from `test`.`x` where (`test`.`x`.`col_int_key` < 1)) `derived_2_3` join `test`.`x` `table2` where (`test`.`x`.`col_int_key` <= `derived_2_3`.`SUM(col_int_key)`)
DROP TABLE x;
#
# Bug#30645426 WL#12885: SIG11 AT TABLE_LIST::CREATE_MATERIALIZED_TABLE() AT SQL/TABLE.H
# Used to fails with -ps-protocol
#
CREATE TABLE t1(col_varchar VARCHAR(1));
SELECT (SELECT COUNT(*)
FROM t1
WHERE 1 <> table1.col_varchar)
FROM ((SELECT a2.*
FROM (t1 AS a1
JOIN
t1 AS a2
ON (1 <> ( SELECT COUNT(*)
FROM t1)))) AS table1
JOIN
t1
ON 1);
(SELECT COUNT(*)
FROM t1
WHERE 1 <> table1.col_varchar)
EXPLAIN SELECT (SELECT COUNT(*)
FROM t1
WHERE 1 <> table1.col_varchar)
FROM ((SELECT a2.*
FROM (t1 AS a1
JOIN
t1 AS a2
ON (1 <> ( SELECT COUNT(*)
FROM t1)))) AS table1
JOIN
t1
ON 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	a1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	a2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
4	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1276	Field or reference 'table1.col_varchar' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select count(0) from `test`.`t1` where (1 <> `test`.`a2`.`col_varchar`)) AS `(SELECT COUNT(*)
FROM t1
WHERE 1 <> table1.col_varchar)` from `test`.`t1` `a1` join (/* select#4 */ select count(0) AS `COUNT(*)` from `test`.`t1` having (1 <> count(0))) `derived_3_4` join `test`.`t1` `a2` join `test`.`t1`
DROP TABLE t1;
#
# Bug#30650326 WL#12885 SIG 11 IN ADD_KEY_FIELDS() AT SQL/SQL_OPTIMIZER.CC
#
CREATE TABLE a(i INT);
CREATE TABLE b(i INT);
CREATE TABLE c(i INT);
SELECT *
FROM b
WHERE EXISTS (SELECT *
FROM (b
JOIN
(a AS sq1_alias2
JOIN
c
ON (sq1_alias2.i >= (SELECT MAX(i)
FROM b)))
ON (6 IN (SELECT i
FROM b))));
i
EXPLAIN SELECT *
FROM b
WHERE EXISTS (SELECT *
FROM (b
JOIN
(a AS sq1_alias2
JOIN
c
ON (sq1_alias2.i >= (SELECT MAX(i)
FROM b)))
ON (6 IN (SELECT i
FROM b))));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	b	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	b	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	sq1_alias2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	c	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	PRIMARY	b	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(b)
3	DERIVED	b	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`b`.`i` AS `i` from `test`.`b` semi join (`test`.`b` join `test`.`a` `sq1_alias2` join (/* select#3 */ select max(`test`.`b`.`i`) AS `MAX(i)` from `test`.`b`) `derived_2_3` join `test`.`c` join `test`.`b`) where ((`test`.`b`.`i` = 6) and (`test`.`sq1_alias2`.`i` >= `derived_2_3`.`MAX(i)`))
DROP TABLE a, b, c;
#
# Bug#30727021 WL#12885 SIG 6 IN SELECT_LEX::SYNTHESIZE_DERIVED() AT SQL/SQL_RESOLVER.CC
# Update: ANY/ALL/SOME rejected.
CREATE TABLE n(i INT);
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table1.i <= ANY (SELECT i FROM n)))
WHERE (EXISTS ((SELECT i FROM n)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table1.i <= ANY (SELECT i FROM n)))
WHERE (EXISTS ((SELECT i FROM n)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	PRIMARY	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(table2); Using join buffer (hash join)
3	SUBQUERY	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
2	SUBQUERY	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select avg(`test`.`n`.`i`) from `test`.`n`) AS `feild1`,sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join `test`.`n` `table2` semi join (`test`.`n`) where <nop>((`test`.`table1`.`i` <= (/* select#3 */ select max(`test`.`n`.`i`) from `test`.`n`)))
These (manually transformed the ANY) trigger the error as
well. Semi-join complication.
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table1.i <= (select MAX(`n`.`i`) from `n`)))
WHERE (EXISTS ((SELECT i FROM n)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table1.i <= (select MAX(`n`.`i`) from `n`)))
WHERE (EXISTS ((SELECT i FROM n)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
5	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
5	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
5	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(table2); Using join buffer (hash join)
5	DERIVED	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
7	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `derived_1_8`.`AVG(n.i)` AS `feild1`,`derived_1_5`.`SUM(table1.i)` AS `SUM(table1.i)` from (/* select#5 */ select sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join (/* select#7 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_5_7` join `test`.`n` `table2` semi join (`test`.`n`) where (`test`.`table1`.`i` <= `derived_5_7`.`MAX(``n``.``i``)`)) `derived_1_5` left join (/* select#8 */ select avg(`test`.`n`.`i`) AS `AVG(n.i)` from `test`.`n`) `derived_1_8` on(true) where true
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN
n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN
n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived14>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
14	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
8	DERIVED	table3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(table3); Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
8	DERIVED	<derived12>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
8	DERIVED	<derived13>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
13	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
12	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `derived_1_14`.`AVG(n.i)` AS `feild1`,`derived_1_8`.`SUM(table1.i)` AS `SUM(table1.i)` from (/* select#8 */ select sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join (/* select#13 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_8_13` join `test`.`n` `table2` join (/* select#12 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_8_12` join `test`.`n` `table3` semi join (`test`.`n`) semi join (`test`.`n`) semi join (`test`.`n`) where ((`test`.`n`.`i` = 7) and (`test`.`n`.`i` = 5) and (`test`.`table1`.`i` <= `derived_8_12`.`MAX(``n``.``i``)`) and (`test`.`table2`.`i` <= `derived_8_13`.`MAX(``n``.``i``)`))) `derived_1_8` left join (/* select#14 */ select avg(`test`.`n`.`i`) AS `AVG(n.i)` from `test`.`n`) `derived_1_14` on(true) where true
Follow-up fix.
Anti-join complication.
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table2.i <= (select MAX(`n`.`i`) from `n`)))
JOIN n AS table3
ON (table1.i <= (select MAX(`n`.`i`) from `n`))
WHERE (NOT EXISTS ((SELECT n1.i
FROM n n1, n n2
WHERE n1.i > n2.i)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON (table2.i <= (select MAX(`n`.`i`) from `n`)))
JOIN n AS table3
ON (table1.i <= (select MAX(`n`.`i`) from `n`))
WHERE (NOT EXISTS ((SELECT n1.i
FROM n n1, n n2
WHERE n1.i > n2.i)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived10>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
10	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
6	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
6	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
6	DERIVED	table3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
6	DERIVED	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	<derived9>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Not exists; Using join buffer (hash join)
9	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
7	DERIVED	n1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary
7	DERIVED	n2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `derived_1_10`.`AVG(n.i)` AS `feild1`,`derived_1_6`.`SUM(table1.i)` AS `SUM(table1.i)` from (/* select#6 */ select sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join (/* select#9 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_6_9` join `test`.`n` `table2` join (/* select#8 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_6_8` join `test`.`n` `table3` left join (/* select#7 */ select distinct 1 AS `Name_exp_1` from `test`.`n` `n1` join `test`.`n` `n2` where (`test`.`n1`.`i` > `test`.`n2`.`i`)) `derived_6_7` on(true) where ((`derived_6_7`.`Name_exp_1` is null) and (`test`.`table1`.`i` <= `derived_6_8`.`MAX(``n``.``i``)`) and (`test`.`table2`.`i` <= `derived_6_9`.`MAX(``n``.``i``)`))) `derived_1_6` left join (/* select#10 */ select avg(`test`.`n`.`i`) AS `AVG(n.i)` from `test`.`n`) `derived_1_10` on(true) where true
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN
n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN
n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN
n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived14>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
14	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
8	DERIVED	table3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(table3); Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
8	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
8	DERIVED	<derived12>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
8	DERIVED	<derived13>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
13	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
12	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `derived_1_14`.`AVG(n.i)` AS `feild1`,`derived_1_8`.`SUM(table1.i)` AS `SUM(table1.i)` from (/* select#8 */ select sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join (/* select#13 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_8_13` join `test`.`n` `table2` join (/* select#12 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_8_12` join `test`.`n` `table3` semi join (`test`.`n`) semi join (`test`.`n`) semi join (`test`.`n`) where ((`test`.`n`.`i` = 7) and (`test`.`n`.`i` = 5) and (`test`.`table1`.`i` <= `derived_8_12`.`MAX(``n``.``i``)`) and (`test`.`table2`.`i` <= `derived_8_13`.`MAX(``n``.``i``)`))) `derived_1_8` left join (/* select#14 */ select avg(`test`.`n`.`i`) AS `AVG(n.i)` from `test`.`n`) `derived_1_14` on(true) where true
Mix of semi-join and anti-join complications.
SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
NOT EXISTS ((SELECT i FROM n WHERE i = 4)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)) AND
NOT EXISTS ((SELECT i FROM n WHERE i = 3)));
feild1	SUM(table1.i)
NULL	NULL
EXPLAIN SELECT (SELECT AVG(n.i)
FROM n) AS feild1,
SUM(table1.i)
FROM (n AS table1
JOIN n AS table2
ON  (table2.i <=  (select MAX(`n`.`i`) from `n`)))
JOIN n AS table3
ON (table1.i <=  (select MAX(`n`.`i`) from `n`))
WHERE (EXISTS ((SELECT i FROM n)) AND
NOT EXISTS ((SELECT i FROM n WHERE i = 4)) AND
EXISTS ((SELECT i FROM n WHERE i = 5)) AND
EXISTS ((SELECT i FROM n WHERE i = 7)) AND
NOT EXISTS ((SELECT i FROM n WHERE i = 3)));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived10>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived18>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
18	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
10	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
10	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
10	DERIVED	table3	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
10	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(table3); Using join buffer (hash join)
10	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
10	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(n); Using join buffer (hash join)
10	DERIVED	<derived16>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
10	DERIVED	<derived17>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
10	DERIVED	<derived14>	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Not exists; Using join buffer (hash join)
10	DERIVED	<derived11>	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Not exists; Using join buffer (hash join)
17	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
16	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
14	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using temporary
11	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using temporary
Warnings:
Note	1003	/* select#1 */ select `derived_1_18`.`AVG(n.i)` AS `feild1`,`derived_1_10`.`SUM(table1.i)` AS `SUM(table1.i)` from (/* select#10 */ select sum(`test`.`table1`.`i`) AS `SUM(table1.i)` from `test`.`n` `table1` join (/* select#17 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_10_17` join `test`.`n` `table2` join (/* select#16 */ select max(`test`.`n`.`i`) AS `MAX(``n``.``i``)` from `test`.`n`) `derived_10_16` join `test`.`n` `table3` left join (/* select#14 */ select distinct 1 AS `Name_exp_1` from `test`.`n` where (`test`.`n`.`i` = 4)) `derived_10_14` on(true) left join (/* select#11 */ select distinct 1 AS `Name_exp_1` from `test`.`n` where (`test`.`n`.`i` = 3)) `derived_10_11` on(true) semi join (`test`.`n`) semi join (`test`.`n`) semi join (`test`.`n`) where ((`test`.`n`.`i` = 7) and (`test`.`n`.`i` = 5) and (`derived_10_14`.`Name_exp_1` is null) and (`derived_10_11`.`Name_exp_1` is null) and (`test`.`table1`.`i` <= `derived_10_16`.`MAX(``n``.``i``)`) and (`test`.`table2`.`i` <= `derived_10_17`.`MAX(``n``.``i``)`))) `derived_1_10` left join (/* select#18 */ select avg(`test`.`n`.`i`) AS `AVG(n.i)` from `test`.`n`) `derived_1_18` on(true) where true
DROP TABLE n;
#
# Bug#30736475 WL#12885 SIG 6 IN ITEM_FIELD::FIX_FIELDS() AT SQL/ITEM.CC
#
CREATE TABLE m(pk INT);
CREATE VIEW view_m AS SELECT * FROM m;
PREPARE prep_stmt FROM
'SELECT (SELECT t2.pk FROM (m AS t1
                            JOIN
                            (m AS t2
                             JOIN m AS t3))),
        (SELECT SUM(pk) FROM m),
        MIN(table1.pk)
 FROM (m AS table1 JOIN
       ((view_m AS table2
         JOIN
         m AS table3))
       ON (table3.pk = table2.pk))';
EXECUTE prep_stmt;
(SELECT t2.pk FROM (m AS t1
                            JOIN
                            (m AS t2
                             JOIN m AS t3)))	(SELECT SUM(pk) FROM m)	MIN(table1.pk)
NULL	NULL	NULL
DROP VIEW view_m;
DROP TABLE m;
#
# Bug#30757306 WL#12885: ASSERTION `FILE' FAILED AT TABLE::SET_KEYREAD
# Issue with INSERT, tweaks the from list which is transformed by us.
CREATE TABLE t1(field1 INT, field2 VARCHAR(1));
SET optimizer_switch='subquery_to_derived=on';
CREATE TABLE cc1(pk INT NOT NULL,
col_varchar_key VARCHAR(1) DEFAULT NULL,
PRIMARY KEY (pk));
SELECT COUNT(table1.pk),
(SELECT MIN(col_varchar_key) FROM cc1 )
FROM (cc1 AS table1
JOIN (cc1 JOIN
cc1 AS table3
ON true)
ON true)
WHERE (1 <> (SELECT COUNT(*) FROM cc1));
COUNT(table1.pk)	(SELECT MIN(col_varchar_key) FROM cc1 )
0	NULL
EXPLAIN SELECT COUNT(table1.pk),
(SELECT MIN(col_varchar_key) FROM cc1 )
FROM (cc1 AS table1
JOIN (cc1 JOIN
cc1 AS table3
ON true)
ON true)
WHERE (1 <> (SELECT COUNT(*) FROM cc1));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	cc1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
4	DERIVED	table1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
4	DERIVED	cc1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
4	DERIVED	table3	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
4	DERIVED	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
5	DERIVED	cc1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `derived_1_4`.`COUNT(table1.pk)` AS `COUNT(table1.pk)`,`derived_1_6`.`MIN(col_varchar_key)` AS `(SELECT MIN(col_varchar_key) FROM cc1 )` from (/* select#4 */ select count(`test`.`table1`.`pk`) AS `COUNT(table1.pk)` from `test`.`cc1` `table1` join `test`.`cc1` join `test`.`cc1` `table3` join (/* select#5 */ select count(0) AS `COUNT(*)` from `test`.`cc1` having (1 <> count(0))) `derived_4_5`) `derived_1_4` left join (/* select#6 */ select min(`test`.`cc1`.`col_varchar_key`) AS `MIN(col_varchar_key)` from `test`.`cc1`) `derived_1_6` on(true) where true
INSERT INTO t1 SELECT COUNT(table1.pk),
(SELECT MIN(col_varchar_key) FROM cc1 )
FROM (cc1 AS table1
JOIN (cc1 JOIN
cc1 AS table3
ON true)
ON true)
WHERE (1 <> (SELECT COUNT(*) FROM cc1));
EXPLAIN INSERT INTO t1 SELECT COUNT(table1.pk),
(SELECT MIN(col_varchar_key) FROM cc1 )
FROM (cc1 AS table1
JOIN (cc1 JOIN
cc1 AS table3
ON true)
ON true)
WHERE (1 <> (SELECT COUNT(*) FROM cc1));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	INSERT	t1	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
6	DERIVED	cc1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
4	DERIVED	table1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
4	DERIVED	cc1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
4	DERIVED	table3	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
4	DERIVED	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
5	DERIVED	cc1	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
Warnings:
Note	1003	insert into `test`.`t1` /* select#1 */ select `derived_1_4`.`COUNT(table1.pk)` AS `COUNT(table1.pk)`,`derived_1_6`.`MIN(col_varchar_key)` AS `(SELECT MIN(col_varchar_key) FROM cc1 )` from (/* select#4 */ select count(`test`.`table1`.`pk`) AS `COUNT(table1.pk)` from `test`.`cc1` `table1` join `test`.`cc1` join `test`.`cc1` `table3` join (/* select#5 */ select count(0) AS `COUNT(*)` from `test`.`cc1` having (1 <> count(0))) `derived_4_5`) `derived_1_4` left join (/* select#6 */ select min(`test`.`cc1`.`col_varchar_key`) AS `MIN(col_varchar_key)` from `test`.`cc1`) `derived_1_6` on(true) where true
SELECT * from t1;
field1	field2
0	NULL
Test this also for coverage
CREATE TABLE t2 AS SELECT COUNT(table1.pk),
(SELECT MIN(col_varchar_key) FROM cc1 )
FROM (cc1 AS table1
JOIN (cc1 JOIN
cc1 AS table3
ON true)
ON true)
WHERE (1 <> (SELECT COUNT(*) FROM cc1));
DROP TABLE t1, cc1, t2;
#
# Bug#30755759 WL#12885 SIG6 IN HASH_JOIN_BUFFER::STOREFROMTABLEBUFFERS()
# Issue with covering indexes.
#
CREATE TABLE a (
pk INTEGER
);
CREATE TABLE bb (
col_varchar VARCHAR(1)
);
CREATE TABLE cc (
pk INTEGER,
col_int INTEGER,
col_int_key INTEGER,
col_time TIME,
col_time_key TIME,
col_datetime DATETIME,
col_datetime_key DATETIME,
col_varchar VARCHAR(1),
col_varchar_key VARCHAR(1),
PRIMARY KEY (pk)
);
CREATE INDEX idx_cc_col_varchar_key ON cc(col_varchar_key);
INSERT INTO cc VALUES (1,764578610,1400450503,'04:58:13','15:43:36',
'1977-07-20 14:44:30','1998-10-04 17:29:04','0','N');
INSERT INTO cc VALUES (2,-1430323290,761341340,'17:39:46','10:22:47',
'2027-06-26 01:50:30','1983-11-11 03:33:36','z','a');
ANALYZE TABLE a, bb, cc;
Table	Op	Msg_type	Msg_text
test.a	analyze	status	OK
test.bb	analyze	status	OK
test.cc	analyze	status	OK
Without the patch this plan would use an index scan on cc, but this
is not covering.
EXPLAIN FORMAT=tree
SELECT
AVG(cc.col_varchar_key),
(
SELECT SUM(cc.col_int_key)
FROM cc,a
)
FROM cc STRAIGHT_JOIN bb ON bb.col_varchar = cc.col_varchar_key
WHERE cc.col_varchar <> 'w';
EXPLAIN
-> Left hash join (no condition)  (cost=6.23 rows=1)
    -> Table scan on derived_1_3  (cost=3.51..3.51 rows=1)
        -> Materialize  (cost=1.00..1.00 rows=1)
            -> Aggregate: avg(cc.col_varchar_key)  (cost=0.90 rows=1)
                -> Inner hash join (bb.col_varchar = cc.col_varchar_key)  (cost=0.80 rows=1)
                    -> Table scan on bb  (cost=0.35 rows=1)
                    -> Hash
                        -> Filter: (cc.col_varchar <> 'w')  (cost=0.45 rows=1)
                            -> Table scan on cc  (cost=0.45 rows=2)
    -> Hash
        -> Table scan on derived_1_4  (cost=3.61..3.61 rows=1)
            -> Materialize  (cost=1.10..1.10 rows=1)
                -> Aggregate: sum(cc.col_int_key)  (cost=1.00 rows=1)
                    -> Inner hash join (no condition)  (cost=0.80 rows=2)
                        -> Table scan on cc  (cost=0.45 rows=2)
                        -> Hash
                            -> Table scan on a  (cost=0.35 rows=1)

DROP TABLE a, bb, cc;
#
# Bug#30774730 WL#12885 SIG 6 IN ITEM_FIELD::FIX_FIELDS() AT SQL/ITEM.CC
#
CREATE TABLE n(i INT);
CREATE VIEW view_n AS SELECT * FROM n;
PREPARE p FROM
'SELECT (SELECT MAX(i) FROM n) AS field2,
        COUNT(table1.i) AS field3 ,
        (SELECT AVG(i) FROM n) AS field4
 FROM (n AS table1
       JOIN
       ( view_n AS table2
         JOIN
         n AS table3
         ON true )
       ON (table2.i = table2.i))';
EXECUTE p;
field2	field3	field4
NULL	0	NULL
DROP VIEW view_n;
DROP TABLE n;
#
# Bug#30775902 WL#12885 SIG6 IN HASH_JOIN_BUFFER::STOREFROMTABLEBUFFERS()
#
CREATE TABLE cc (
pk int NOT NULL AUTO_INCREMENT,
col_int int DEFAULT NULL,
col_int_key int DEFAULT NULL,
col_varchar varchar(1) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
PRIMARY KEY (pk),
KEY idx_cc_col_int_key (col_int_key),
KEY idx_cc_col_varchar_key (col_varchar_key)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
INSERT INTO cc VALUES
(1,   1375472775,   262188886, 'I', 'b'),
(2,  -1851648474,   130471446, 'o', '7'),
(3,    503688873,   259988235, 'L', 't'),
(4,    995143874,   -60832670, 'Q', 'K'),
(5,  -1440599261, -1669741488, 'k', '7'),
(6,  -1534014276,  1760407196, 'c', 'Z'),
(7,    808084535,   311457905, 'B', 'j'),
(8,    731883185,  -571871645, 'd', 'm'),
(9,   1445888442,  1903365311, 'w', 's'),
(10,   222313615,  -404576744, 'n', 'V'),
(11, -1320350569, -1496644593, 'y', 'o'),
(12,  2033205532,  1376480867, 'x', '4'),
(13,  -101883317,  -857422791, 'A', '7'),
(14,   867688302,  1410896813, 'J', 'c'),
(15, -1961088920, -2019664999, 'v', '1'),
(16, -1850585486, -1872043099, '1', 'o'),
(17,  -603486188,   901895823, 'G', 'q'),
(18, -1381157785, -1613624643, 'Z', 'E'),
(19,  -270976631,   288433409, 'r', 'Z'),
(20,  2113722977,   409698731, 'n', 'd');
ANALYZE TABLE cc;
Table	Op	Msg_type	Msg_text
test.cc	analyze	status	OK
CREATE VIEW view_cc AS SELECT * FROM cc;
SELECT AVG(table2.col_int) AS field1 ,
( SELECT COUNT(subquery1_t1.col_varchar_key ) AS subquery1_field1
FROM ( cc AS subquery1_t1
LEFT OUTER JOIN
( cc AS subquery1_t2
INNER JOIN view_cc AS subquery1_t3
ON ( subquery1_t3.col_varchar = subquery1_t2.col_varchar_key ) )
ON ( subquery1_t3.col_int_key = subquery1_t2.col_int  ) )
WHERE subquery1_t1.col_varchar_key != subquery1_t2.col_varchar ) AS field2
FROM ( cc AS table1
STRAIGHT_JOIN
cc AS table2
ON ( table1.col_varchar_key = table1.col_varchar_key ) )
WHERE ( table1.pk = 1 ) AND
( table1.col_varchar_key = 'D' OR
table1.col_varchar_key = table1.col_varchar_key) OR
table1.col_varchar_key < 'O'
ORDER BY table1.col_varchar ASC, field2, field1
LIMIT 1000 OFFSET 2;
field1	field2
EXPLAIN FORMAT=tree SELECT AVG(table2.col_int) AS field1 ,
( SELECT COUNT(subquery1_t1.col_varchar_key ) AS subquery1_field1
FROM ( cc AS subquery1_t1
LEFT OUTER JOIN
( cc AS subquery1_t2
INNER JOIN view_cc AS subquery1_t3
ON ( subquery1_t3.col_varchar = subquery1_t2.col_varchar_key ) )
ON ( subquery1_t3.col_int_key = subquery1_t2.col_int  ) )
WHERE subquery1_t1.col_varchar_key != subquery1_t2.col_varchar ) AS field2
FROM ( cc AS table1
STRAIGHT_JOIN
cc AS table2
ON ( table1.col_varchar_key = table1.col_varchar_key ) )
WHERE ( table1.pk = 1 ) AND
( table1.col_varchar_key = 'D' OR
table1.col_varchar_key = table1.col_varchar_key) OR
table1.col_varchar_key < 'O'
ORDER BY table1.col_varchar ASC, field2, field1
LIMIT 1000 OFFSET 2;
EXPLAIN
-> Limit/Offset: 1000/2 row(s)  (cost=177.33 rows=0)
    -> Left hash join (no condition)  (cost=177.33 rows=1)
        -> Table scan on derived_1_4  (cost=9.11..9.11 rows=1)
            -> Materialize  (cost=6.60..6.60 rows=1)
                -> Aggregate: avg(table2.col_int)  (cost=6.50 rows=1)
                    -> Inner hash join (no condition)  (cost=4.50 rows=20)
                        -> Table scan on table2  (cost=2.25 rows=20)
                        -> Hash
                            -> Filter: ((((table1.pk = 1) and ((table1.col_varchar_key = 'D') or (table1.col_varchar_key = table1.col_varchar_key))) or (table1.col_varchar_key < 'O')) and (table1.col_varchar_key = table1.col_varchar_key))  (cost=2.25 rows=1)
                                -> Table scan on table1  (cost=2.25 rows=20)
        -> Hash
            -> Table scan on derived_1_5  (cost=174.71..174.71 rows=1)
                -> Materialize  (cost=172.20..172.20 rows=1)
                    -> Aggregate: count(subquery1_t1.col_varchar_key)  (cost=172.10 rows=1)
                        -> Nested loop inner join  (cost=168.50 rows=36)
                            -> Filter: (subquery1_t1.col_varchar_key <> subquery1_t2.col_varchar)  (cost=42.50 rows=360)
                                -> Inner hash join (no condition)  (cost=42.50 rows=360)
                                    -> Table scan on subquery1_t2  (cost=0.10 rows=20)
                                    -> Hash
                                        -> Covering index scan on subquery1_t1 using idx_cc_col_varchar_key  (cost=2.25 rows=20)
                            -> Filter: (cc.col_varchar = subquery1_t2.col_varchar_key)  (cost=0.25 rows=0.1)
                                -> Index lookup on cc using idx_cc_col_int_key (col_int_key=subquery1_t2.col_int)  (cost=0.25 rows=1)

DROP VIEW view_cc;
DROP TABLE cc;
#
# Bug#30781925 WL#12885 SIG11 IN GETITERATORFORDERIVEDTABLE() AT SQL/SQL_EXECUTOR.CC
#
CREATE TABLE m(col_int INT);
SELECT MIN(table1.col_int)           AS field1,
( SELECT COUNT(col_int )
FROM m AS t1 )              AS field2,
AVG(table1.col_int)           AS field4,
( SELECT MAX(t1.col_int)
FROM ( m AS t1 JOIN
( m AS t2
JOIN
m AS t3 ) ) ) AS field5
FROM ( m AS table1
JOIN ( ( m AS table2
JOIN
( SELECT COUNT(col_int) FROM m ) AS table3 ) ) ) ;
field1	field2	field4	field5
NULL	0	NULL	NULL
DROP TABLE m;
#
# Bug#30786714 WL#12885 SIG6 IN ITEM_FIELD::FIX_FIELDS() AT SQL/ITEM.CC
#
# Missing treatment of view references in transformed block by
# transform_grouped_to_derived, e.g. table2.col_int below.
# Used to fail with prepared statement
CREATE TABLE n(col_int INT);
INSERT INTO n VALUES (1), (2), (3);
ANALYZE TABLE n;
Table	Op	Msg_type	Msg_text
test.n	analyze	status	OK
CREATE VIEW view_n AS SELECT * FROM n;
SET sql_mode="";
SELECT table_b.col_int               AS field_a,
(SELECT MAX(col_int) FROM n)  AS field_b,
COUNT(table_a.col_int)        AS field_c,
(SELECT AVG(col_int) FROM n)  AS field_d
FROM ( n AS table_a
JOIN ( view_n AS table_b
JOIN n AS table_c) );
field_a	field_b	field_c	field_d
1	1	27	2.0000
EXPLAIN SELECT table_b.col_int               AS field_a,
(SELECT MAX(col_int) FROM n)  AS field_b,
COUNT(table_a.col_int)        AS field_c,
(SELECT AVG(col_int) FROM n)  AS field_d
FROM ( n AS table_a
JOIN ( view_n AS table_b
JOIN n AS table_c) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
7	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
6	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	table_a	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
5	DERIVED	table_c	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `derived_1_5`.`Name_exp_1` AS `field_a`,`derived_1_7`.`MAX(col_int)` AS `field_b`,`derived_1_5`.`field_c` AS `field_c`,`derived_1_6`.`AVG(col_int)` AS `field_d` from (/* select#5 */ select count(`test`.`table_a`.`col_int`) AS `field_c`,`test`.`n`.`col_int` AS `Name_exp_1` from `test`.`n` `table_a` join `test`.`n` join `test`.`n` `table_c`) `derived_1_5` left join (/* select#7 */ select max(`test`.`n`.`col_int`) AS `MAX(col_int)` from `test`.`n`) `derived_1_7` on(true) left join (/* select#6 */ select avg(`test`.`n`.`col_int`) AS `AVG(col_int)` from `test`.`n`) `derived_1_6` on(true) where true
DROP VIEW view_n;
CREATE VIEW view_n(col_int2) AS SELECT col_int + 1 FROM n;
More complex view featuring an expression and now also
two equivalent view references
SELECT  table_b.col_int2              AS field_e,
table_a.col_int,
(SELECT MAX(col_int) FROM n)  AS field_a,
COUNT(table_a.col_int )       AS field_b,
(SELECT AVG(col_int) FROM n)  AS field_c,
table_b.col_int2              AS field_d
FROM ( n AS table_a
JOIN (view_n AS table_b
JOIN n AS table_c) );
field_e	col_int	field_a	field_b	field_c	field_d
2	1	3	27	2.0000	2
EXPLAIN SELECT  table_b.col_int2              AS field_e,
table_a.col_int,
(SELECT MAX(col_int) FROM n)  AS field_a,
COUNT(table_a.col_int )       AS field_b,
(SELECT AVG(col_int) FROM n)  AS field_c,
table_b.col_int2              AS field_d
FROM ( n AS table_a
JOIN (view_n AS table_b
JOIN n AS table_c) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
7	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
6	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	table_a	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	n	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
5	DERIVED	table_c	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `derived_1_5`.`Name_exp_1` AS `field_e`,`derived_1_5`.`Name_exp_2` AS `col_int`,`derived_1_7`.`MAX(col_int)` AS `field_a`,`derived_1_5`.`field_b` AS `field_b`,`derived_1_6`.`AVG(col_int)` AS `field_c`,`derived_1_5`.`Name_exp_1` AS `field_d` from (/* select#5 */ select count(`test`.`table_a`.`col_int`) AS `field_b`,(`test`.`n`.`col_int` + 1) AS `Name_exp_1`,`test`.`table_a`.`col_int` AS `Name_exp_2` from `test`.`n` `table_a` join `test`.`n` join `test`.`n` `table_c`) `derived_1_5` left join (/* select#7 */ select max(`test`.`n`.`col_int`) AS `MAX(col_int)` from `test`.`n`) `derived_1_7` on(true) left join (/* select#6 */ select avg(`test`.`n`.`col_int`) AS `AVG(col_int)` from `test`.`n`) `derived_1_6` on(true) where true
SET sql_mode=default;
DROP VIEW view_n;
DROP TABLE n;
#
# Bug#30786266 WL#12885 SIG 6 IN QEP_TAB::PUSH_INDEX_COND() AT SQL/SQL_SELECT.CC
#
CREATE TABLE c (pk INTEGER AUTO_INCREMENT,
col_int INT ,
col_int_key INT ,
col_varchar VARCHAR(1) ,
col_varchar_key VARCHAR(1) ,
PRIMARY KEY(pk));
CREATE INDEX idx_c_col_int_key ON c(col_int_key);
CREATE TABLE cc (pk INTEGER AUTO_INCREMENT,
col_int INT ,
col_int_key INT ,
col_varchar VARCHAR(1) ,
col_varchar_key VARCHAR(1) ,
PRIMARY KEY(pk));
INSERT INTO cc VALUES (DEFAULT,1750627978,-2052557260,'0','o');
INSERT INTO c values
(DEFAULT,809266110,-169779076,'C','O'),
(DEFAULT,3049998,1973362945,'2','O'),
(DEFAULT,912437770,-1109570817,'W','G'),
(DEFAULT,-1655291083,-1761323512,'q','9'),
(DEFAULT,-1276272795,-591291338,'3','O'),
(DEFAULT,-1297781203,-970713309,'q','r'),
(DEFAULT,-261602165,-2083959767,'7','O'),
(DEFAULT,357530836,-746109993,'6','i'),
(DEFAULT,1553746652,-1607882572,'G','Y'),
(DEFAULT,-1620551574,381511992,'5','n'),
(DEFAULT,-1221888549,-1127778040,'l','U'),
(DEFAULT,1048455957,-1830777487,'U','T'),
(DEFAULT,-541641553,-1731661529,'A','Q'),
(DEFAULT,1482963294,-1570976962,'0','s');
ANALYZE TABLES c, cc;
Table	Op	Msg_type	Msg_text
test.c	analyze	status	OK
test.cc	analyze	status	OK
EXPLAIN
SELECT MIN( table2.col_int ) AS field1 ,
SUM( table2.col_int ) AS field2 ,
( SELECT MAX( subquery1_t1.pk ) AS subquery1_field1
FROM ( cc AS subquery1_t1
INNER JOIN
cc AS subquery1_t2
ON ( subquery1_t2.col_varchar_key =
subquery1_t1.col_varchar_key ) ) ) AS field3
FROM ( c AS table1
RIGHT JOIN
( ( cc AS table2
STRAIGHT_JOIN
c AS table3
ON ( table2.pk = table2.col_int ) ) )
ON ( table2.col_varchar_key = table2.col_varchar AND
table1.col_int_key > ( SELECT 9 FROM cc ) ) )
WHERE ( EXISTS ( SELECT subquery3_t1.col_int AS subquery3_field1
FROM c AS subquery3_t1
WHERE subquery3_t1.col_int_key = table1.pk ) ) AND
table1.col_varchar_key <> table2.col_varchar;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
8	DERIVED	subquery1_t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
8	DERIVED	subquery1_t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
5	DERIVED	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
5	DERIVED	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using join buffer (hash join)
5	DERIVED	table1	NULL	ALL	PRIMARY,idx_c_col_int_key	NULL	NULL	NULL	14	30.00	Range checked for each record (index map: 0x3)
5	DERIVED	subquery3_t1	NULL	ref	idx_c_col_int_key	idx_c_col_int_key	5	test.table1.pk	1	100.00	FirstMatch(table1)
5	DERIVED	table3	NULL	index	NULL	idx_c_col_int_key	5	NULL	14	100.00	Using index; Using join buffer (hash join)
7	DERIVED	cc	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
Warnings:
Note	1276	Field or reference 'test.table1.pk' of SELECT #4 was resolved in SELECT #1
Note	1003	/* select#1 */ select `derived_1_5`.`field1` AS `field1`,`derived_1_5`.`field2` AS `field2`,`derived_1_8`.`subquery1_field1` AS `field3` from (/* select#5 */ select min(`test`.`table2`.`col_int`) AS `field1`,sum(`test`.`table2`.`col_int`) AS `field2` from `test`.`cc` `table2` straight_join `test`.`c` `table3` join (/* select#7 */ select 9 AS `9` from `test`.`cc`) `derived_5_7` join `test`.`c` `table1` semi join (`test`.`c` `subquery3_t1`) where ((`test`.`table2`.`col_int` = `test`.`table2`.`pk`) and (`test`.`table2`.`col_varchar` = `test`.`table2`.`col_varchar_key`) and (`test`.`subquery3_t1`.`col_int_key` = `test`.`table1`.`pk`) and (`test`.`table1`.`col_varchar_key` <> `test`.`table2`.`col_varchar`) and (`test`.`table1`.`col_int_key` > `derived_5_7`.`9`))) `derived_1_5` left join (/* select#8 */ select max(`test`.`subquery1_t1`.`pk`) AS `subquery1_field1` from `test`.`cc` `subquery1_t1` join `test`.`cc` `subquery1_t2` where (`test`.`subquery1_t2`.`col_varchar_key` = `test`.`subquery1_t1`.`col_varchar_key`)) `derived_1_8` on(true) where true
DROP TABLE c, cc;
#
# Bug#30818896 WL#12885: ASSERTION FAILURE IN TEMPTABLE::COLUMN::READ_STD_USER_DATA()
# Refinement of view references in transformed block by
# transform_grouped_to_derived. Cf. Bug#30786714. We replaced too many.
CREATE TABLE b (
pk int NOT NULL AUTO_INCREMENT,
col_int int DEFAULT NULL,
col_int_key int DEFAULT NULL,
col_varchar varchar(1) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
PRIMARY KEY (pk),
KEY idx_b_col_int_key (col_int_key),
KEY idx_b_col_varchar_key (col_varchar_key)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
INSERT INTO b VALUES (1,-1155099828,-1879439976,'N','a');
CREATE TABLE c (
pk int NOT NULL AUTO_INCREMENT,
col_int int DEFAULT NULL,
col_int_key int DEFAULT NULL,
col_varchar varchar(1) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
PRIMARY KEY (pk),
KEY idx_c_col_int_key (col_int_key),
KEY idx_c_col_varchar_key (col_varchar_key)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
INSERT INTO c VALUES
(1,     -3666739,   177583826, 'm', 'j'),
(2,   1904347123,  1743248268, '2', 'P'),
(3,   -469827848,  1376980829, 'i', 'A'),
(4,   1433595053,  1819090851, 'L', 'M'),
(5,    726547892,  1068584791, 'T', 'j'),
(6,   1439902652, -1277159531, 'S', 'r'),
(7,  -1897073668,  -282803609, 'x', '7'),
(8,   1220936946,   170773463, '8', 'z'),
(9,   2127527772,  1049703732, 'i', 'y'),
(10,   673031799,   609105572, 'h', 'a'),
(11,  -479585417,  1317141227, 'w', 'k'),
(12,  -688521145,  -684371590, 'S', 'y'),
(13,     2841986,  -721059140, 'E', 'I'),
(14,    58615730,   496153244, '2', 'U'),
(15,  1139572680,  1532132699, '2', 'n'),
(16,  -842003748,  1189460625, 'I', 'P'),
(17, -1177191130, -1717792127, 'y', 'n'),
(18, -1108396995,   313282977, 'N', 'a'),
(19,  -361562994,   419341930, 'd', 'C'),
(20,   743792160,   984757597, 'e', '2');
CREATE TABLE cc (
pk int NOT NULL AUTO_INCREMENT,
col_int int DEFAULT NULL,
col_int_key int DEFAULT NULL,
col_varchar varchar(1) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
PRIMARY KEY (pk),
KEY idx_cc_col_int_key (col_int_key),
KEY idx_cc_col_varchar_key (col_varchar_key)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
INSERT INTO cc VALUES
(1,  1375472775,   262188886, 'I', 'b'),
(2, -1851648474,   130471446, 'o', '7'),
(3,   503688873,   259988235, 'L', 't'),
(4,   995143874,   -60832670, 'Q', 'K'),
(5, -1440599261, -1669741488, 'k', '7'),
(6, -1534014276,  1760407196, 'c', 'Z'),
(7,   808084535,   311457905, 'B', 'j'),
(8,   731883185,  -571871645, 'd', 'm'),
(9,  1445888442,  1903365311, 'w', 's'),
(10,  222313615,  -404576744, 'n', 'V'),
(11,-1320350569, -1496644593, 'y', 'o'),
(12, 2033205532,  1376480867, 'x', '4'),
(13, -101883317,  -857422791, 'A', '7'),
(14,  867688302,  1410896813, 'J', 'c'),
(15,-1961088920, -2019664999, 'v', '1'),
(16,-1850585486, -1872043099, '1', 'o'),
(17, -603486188,   901895823, 'G', 'q'),
(18,-1381157785, -1613624643, 'Z', 'E'),
(19, -270976631,   288433409, 'r', 'Z'),
(20, 2113722977,   409698731, 'n', 'd');
CREATE VIEW  view_cc AS
SELECT cc.col_int_key AS col_int_key,
cc.col_varchar AS col_varchar,
cc.col_varchar_key AS col_varchar_key from cc;
ANALYZE TABLES b, c, cc;
Table	Op	Msg_type	Msg_text
test.b	analyze	status	OK
test.c	analyze	status	OK
test.cc	analyze	status	OK
SET sql_mode='';
SELECT STRAIGHT_JOIN
( SELECT AVG(subquery1_t1.col_int) AS subquery1_field1
FROM c AS subquery1_t1
WHERE EXISTS ( SELECT subquery1_t1.pk AS child_subquery1_field1
FROM ( view_cc  AS child_subquery1_t1
LEFT JOIN
b AS child_subquery1_t2
ON child_subquery1_t2.pk = child_subquery1_t1.col_int_key )
WHERE child_subquery1_t1.col_varchar_key > subquery1_t1.col_varchar OR
child_subquery1_t1.col_varchar_key < child_subquery1_t1.col_varchar))
AS field1,
table1.col_int_key          AS field2,
SUM(table1.col_varchar_key) AS field3,
MAX(table2.col_int)         AS field4
FROM ( cc AS table1
INNER JOIN
( b AS table2
INNER JOIN
cc AS table3
ON table3.col_int = table2.col_int_key )
ON ( table3.col_varchar_key = table2.col_varchar_key ) )
WHERE ( NOT EXISTS ( ( SELECT subquery2_t1.col_varchar AS subquery2_field1
FROM c AS subquery2_t1 ) ) )   AND
table1.col_varchar_key = table2.col_varchar_key AND
( table2.col_varchar_key >= 'v'                 AND
table1.col_varchar <= table2.col_varchar_key )
ORDER BY field2 DESC, table1.col_int_key, table2 .pk ASC, field1, field2, field3, field4
LIMIT 1;
field1	field2	field3	field4
222144105.4500	NULL	NULL	NULL
EXPLAIN SELECT STRAIGHT_JOIN
( SELECT AVG(subquery1_t1.col_int) AS subquery1_field1
FROM c AS subquery1_t1
WHERE EXISTS ( SELECT subquery1_t1.pk AS child_subquery1_field1
FROM ( view_cc  AS child_subquery1_t1
LEFT JOIN
b AS child_subquery1_t2
ON child_subquery1_t2.pk = child_subquery1_t1.col_int_key )
WHERE child_subquery1_t1.col_varchar_key > subquery1_t1.col_varchar OR
child_subquery1_t1.col_varchar_key < child_subquery1_t1.col_varchar))
AS field1,
table1.col_int_key          AS field2,
SUM(table1.col_varchar_key) AS field3,
MAX(table2.col_int)         AS field4
FROM ( cc AS table1
INNER JOIN
( b AS table2
INNER JOIN
cc AS table3
ON table3.col_int = table2.col_int_key )
ON ( table3.col_varchar_key = table2.col_varchar_key ) )
WHERE ( NOT EXISTS ( ( SELECT subquery2_t1.col_varchar AS subquery2_field1
FROM c AS subquery2_t1 ) ) )   AND
table1.col_varchar_key = table2.col_varchar_key AND
( table2.col_varchar_key >= 'v'                 AND
table1.col_varchar <= table2.col_varchar_key )
ORDER BY field2 DESC, table1.col_int_key, table2 .pk ASC, field1, field2, field3, field4
LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived6>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	<derived8>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
8	DERIVED	subquery1_t1	NULL	ALL	NULL	NULL	NULL	NULL	20	100.00	NULL
8	DERIVED	cc	NULL	ALL	idx_cc_col_varchar_key	NULL	NULL	NULL	20	55.55	Using where
8	DERIVED	child_subquery1_t2	NULL	eq_ref	PRIMARY	PRIMARY	4	func	1	100.00	Using where; Using index; FirstMatch(subquery1_t1)
6	DERIVED	table2	NULL	range	idx_b_col_int_key,idx_b_col_varchar_key	idx_b_col_varchar_key	7	NULL	1	100.00	Using index condition
6	DERIVED	table3	NULL	ref	idx_cc_col_varchar_key	idx_cc_col_varchar_key	7	test.table2.col_varchar_key	1	10.00	Using where
6	DERIVED	table1	NULL	ref	idx_cc_col_varchar_key	idx_cc_col_varchar_key	7	test.table2.col_varchar_key	1	33.33	Using where
6	DERIVED	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	20	10.00	Using where; Not exists; Using join buffer (hash join)
7	DERIVED	subquery2_t1	NULL	ALL	NULL	NULL	NULL	NULL	20	100.00	Using temporary
Warnings:
Note	1276	Field or reference 'test.subquery1_t1.pk' of SELECT #3 was resolved in SELECT #2
Note	1276	Field or reference 'test.subquery1_t1.col_varchar' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select straight_join `derived_1_8`.`subquery1_field1` AS `field1`,`derived_1_6`.`Name_exp_1` AS `field2`,`derived_1_6`.`field3` AS `field3`,`derived_1_6`.`field4` AS `field4` from (/* select#6 */ select sum(`test`.`table1`.`col_varchar_key`) AS `field3`,max(`test`.`table2`.`col_int`) AS `field4`,`test`.`table1`.`col_int_key` AS `Name_exp_1` from `test`.`cc` `table1` join `test`.`b` `table2` join `test`.`cc` `table3` left join (/* select#7 */ select distinct 1 AS `Name_exp_1` from `test`.`c` `subquery2_t1`) `derived_6_7` on(true) where ((`test`.`table3`.`col_int` = `test`.`table2`.`col_int_key`) and (`test`.`table3`.`col_varchar_key` = `test`.`table2`.`col_varchar_key`) and (`test`.`table1`.`col_varchar_key` = `test`.`table2`.`col_varchar_key`) and (`derived_6_7`.`Name_exp_1` is null) and (`test`.`table2`.`col_varchar_key` >= 'v') and (`test`.`table1`.`col_varchar` <= `test`.`table2`.`col_varchar_key`))) `derived_1_6` left join (/* select#8 */ select avg(`test`.`subquery1_t1`.`col_int`) AS `subquery1_field1` from `test`.`c` `subquery1_t1` semi join (`test`.`cc` left join `test`.`b` `child_subquery1_t2` on((`test`.`child_subquery1_t2`.`pk` = `test`.`cc`.`col_int_key`))) where ((`test`.`cc`.`col_varchar_key` > `test`.`subquery1_t1`.`col_varchar`) or (`test`.`cc`.`col_varchar_key` < `test`.`cc`.`col_varchar`))) `derived_1_8` on(true) where true limit 1
DROP VIEW view_cc;
DROP TABLES b, c, cc;
SET sql_mode=default;

Bug found while running RAPID mtr (rapid.view, rapid.subselect) with
PS-protocol

CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER);
INSERT INTO t1 VALUES
(1, 10),
(2, 20), (2, 21),
(3, NULL),
(4, 40), (4, 41), (4, 42), (4, 43), (4, 44);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (NULL);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
CREATE VIEW v1 AS SELECT a, b, (SELECT COUNT(*) FROM t2) AS c FROM t1;
SELECT * FROM v1;
a	b	c
1	10	6
2	20	6
2	21	6
3	NULL	6
4	40	6
4	41	6
4	42	6
4	43	6
4	44	6
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	9	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`derived_2_3`.`count(0)` AS `c` from `test`.`t1` left join (/* select#3 */ select count(0) AS `count(0)` from `test`.`t2`) `derived_2_3` on(true) where true
The select does not reference the scalar subquery
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
EXPLAIN SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	9	100.00	NULL
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` left join (/* select#3 */ select count(0) AS `count(0)` from `test`.`t2`) `derived_2_3` on(true) where true
set sql_mode='';
SELECT a,c FROM v1 GROUP BY b HAVING c > 0;
a	c
1	6
2	6
2	6
3	6
4	6
4	6
4	6
4	6
4	6
EXPLAIN SELECT a,c FROM v1 GROUP BY b HAVING c > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	9	100.00	Using temporary
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`derived_2_3`.`count(0)` AS `c` from `test`.`t1` left join (/* select#3 */ select count(0) AS `count(0)` from `test`.`t2`) `derived_2_3` on(true) where true group by `test`.`t1`.`b` having (`derived_2_3`.`count(0)` > 0)
set sql_mode=default;
The select references the scalar subquery from the view, but not in select list
SELECT a FROM v1 WHERE c > 0;
a
1
2
2
3
4
4
4
4
4
EXPLAIN SELECT a FROM v1 WHERE c > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	9	100.00	Using join buffer (hash join)
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join (/* select#3 */ select count(0) AS `count(0)` from `test`.`t2` having (count(0) > 0)) `derived_2_3`
DROP VIEW v1;
DROP TABLE t1, t2;
#
# Bug#30922236 WL#13851 SIG 11 IN OPTIMIZE_KEYUSE() AT SQL/SQL_OPTIMIZER.CC
# Incomplete fix for commit 941056f2c "WL#12885: view bug 2"
CREATE TABLE c (
pk int NOT NULL AUTO_INCREMENT,
col_int int DEFAULT NULL,
col_int_key int DEFAULT NULL,
col_date date DEFAULT NULL,
col_date_key date DEFAULT NULL,
col_time time DEFAULT NULL,
col_time_key time DEFAULT NULL,
col_datetime datetime DEFAULT NULL,
col_datetime_key datetime DEFAULT NULL,
col_varchar varchar(1) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
PRIMARY KEY (pk),
KEY idx_cc_col_int_key (col_int_key),
KEY idx_cc_col_date_key (col_date_key),
KEY idx_cc_col_time_key (col_time_key),
KEY idx_cc_col_datetime_key (col_datetime_key),
KEY idx_cc_col_varchar_key (col_varchar_key)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
CREATE VIEW view_c AS
SELECT alias1.col_int
FROM ( c AS alias1
JOIN
( ( c AS alias2
JOIN
c AS alias3
ON(1)) )
ON ( alias2.col_int >= ( SELECT MIN( sq1_alias1.col_int ) AS sq1_field1
FROM ( c AS sq1_alias1, c AS sq1_alias2 ) ) ) )
WHERE (  EXISTS ( ( SELECT sq2_alias1.col_int
FROM ( c AS sq2_alias1
JOIN
c AS sq2_alias2
ON ( sq2_alias2.col_int = sq2_alias1.pk ) )) ) ) ;
SELECT * FROM view_c;
col_int
EXPLAIN SELECT * FROM view_c;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	alias2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	alias3	NULL	index	NULL	idx_cc_col_date_key	4	NULL	1	100.00	Using index; Using join buffer (hash join)
1	PRIMARY	<derived4>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	sq2_alias2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	PRIMARY	sq2_alias1	NULL	eq_ref	PRIMARY	PRIMARY	4	test.sq2_alias2.col_int	1	100.00	FirstMatch(<derived4>)
4	DERIVED	sq1_alias1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
4	DERIVED	sq1_alias2	NULL	index	NULL	idx_cc_col_date_key	4	NULL	1	100.00	Using index; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`alias1`.`col_int` AS `col_int` from `test`.`c` `alias1` join (/* select#4 */ select min(`test`.`sq1_alias1`.`col_int`) AS `sq1_field1` from `test`.`c` `sq1_alias1` join `test`.`c` `sq1_alias2`) `derived_2_4` join `test`.`c` `alias2` join `test`.`c` `alias3` semi join (`test`.`c` `sq2_alias1` join `test`.`c` `sq2_alias2`) where ((`test`.`sq2_alias1`.`pk` = `test`.`sq2_alias2`.`col_int`) and (`test`.`alias2`.`col_int` >= `derived_2_4`.`sq1_field1`))
DROP VIEW view_c;
DROP TABLE c;
#
# Bug#31535523 WL#13686: SIG6 HEADER::NUMBER_OF_USED_CHUNKS() == 0 AT TEMPTABLE/BLOCK.H
# This query used to fail during server shutdown, cf. bug issue for how to run.
# In a single mtr run, look in var/log/mysqld.1.err for the stack trace before the fix.
CREATE TABLE t1 (i int);
CREATE TABLE t2 (i int);
SELECT t2.i FROM t2
WHERE ( false ) AND
( t2.i  IN ( SELECT t1.i FROM t1
WHERE t1.i <= SOME ( SELECT 8 UNION  SELECT 3 ) ) );
i
DROP TABLE t1, t2;
#
# WL#13686 Transformation of constant scalar subquery with DUAL causes
#          assert.
#
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1), (2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT a FROM t1 WHERE (SELECT 1 FROM DUAL WHERE 1=0) IS NULL;
a
1
2
EXPLAIN SELECT a FROM t1 WHERE (SELECT 1 FROM DUAL WHERE 1=0) IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where true
DROP TABLE t1;
#
# Bug#31462120 ASSERTION `NESTED_JOIN_LIST->SIZE() == 2' FAILED AT SQL/SQL_RESOLVER.CC
#
CREATE TABLE a (col_varchar_key varchar(1));
SELECT table1.col_varchar_key
FROM ( SELECT sub1_t2.*
FROM (a
JOIN
(a AS sub1_t2)
ON sub1_t2.col_varchar_key IN (SELECT col_varchar_key FROM a))
WHERE EXISTS (SELECT sub2_t1.col_varchar_key
FROM a AS sub2_t1))  AS table1
JOIN
(a AS table2
JOIN
a
ON 1 >= (SELECT MIN( col_varchar_key) FROM a))
ON true;
col_varchar_key
EXPLAIN SELECT table1.col_varchar_key
FROM ( SELECT sub1_t2.*
FROM (a
JOIN
(a AS sub1_t2)
ON sub1_t2.col_varchar_key IN (SELECT col_varchar_key FROM a))
WHERE EXISTS (SELECT sub2_t1.col_varchar_key
FROM a AS sub2_t1))  AS table1
JOIN
(a AS table2
JOIN
a
ON 1 >= (SELECT MIN( col_varchar_key) FROM a))
ON true;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	a	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	PRIMARY	sub1_t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	sub2_t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	FirstMatch(sub1_t2); Using join buffer (hash join)
1	PRIMARY	a	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(sub2_t1); Using join buffer (hash join)
1	PRIMARY	table2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	a	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
1	PRIMARY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (hash join)
5	DERIVED	a	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`sub1_t2`.`col_varchar_key` AS `col_varchar_key` from `test`.`a` join `test`.`a` `sub1_t2` semi join (`test`.`a`) semi join (`test`.`a` `sub2_t1`) join `test`.`a` `table2` join (/* select#5 */ select min(`test`.`a`.`col_varchar_key`) AS `MIN( col_varchar_key)` from `test`.`a` having (1 >= min(`test`.`a`.`col_varchar_key`))) `derived_1_5` join `test`.`a` where (`test`.`a`.`col_varchar_key` = `test`.`sub1_t2`.`col_varchar_key`)
DROP TABLE a;
#
# Bug#31566339 WRONG RESULT WITH OPTIMIZER_SWITCH SUBQUERY_TO_DERIVED ON: ANY
#
CREATE TABLE t1(pk int primary key);
INSERT INTO t1 VALUES(1),(2),(3),(4),(5);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
# Used to return NULL
SELECT SUM(pk) FROM t1 WHERE ( pk >= ANY ( SELECT MAX(1) FROM DUAL) );
SUM(pk)
15
DROP TABLE t1;
#
# Bug #32859025: MYSQLD CRASH - ASSERTION `N < M_SIZE' FAILED|SQL/SQL_ARRAY.H
#
CREATE TABLE t1 ( pk INTEGER );
SELECT
(SELECT COUNT(*) FROM t1) AS f1,
(SELECT COUNT(*) FROM t1) AS f2
FROM t1
GROUP BY f1, f2 WITH ROLLUP;
f1	f2
DROP TABLE t1;
#
# Bug#33057397: FIELD NAMES ARE DISPLAYED INCORRECTLY WITH ROLLUP AND
#               SUBQUERY_TO_DERIVED
CREATE TABLE t1 ( f1 INTEGER);
INSERT INTO t1 VALUES (0);
SELECT (SELECT MIN(f1) AS min FROM t1 ) AS field1 FROM t1 GROUP BY
field1 WITH ROLLUP;
field1
0
NULL
DROP TABLE t1;
#
# Bug#33104036: ASSERTION FAILURE IN FIND_SUBQUERY_IN_SELECT_LIST AT
#               ../SQL/ITEM_SUBSELECT.CC
CREATE TABLE t1 (f1 INTEGER);
SELECT (SELECT SUM(f1) AS SQ1_field1 FROM t1) as field1
FROM t1 GROUP BY f1 WITH ROLLUP ORDER BY f1;
field1
DROP TABLE t1;
Original repro case
CREATE TABLE t1 (pk integer auto_increment,
col_int int ,
col_datetime datetime ,
col_char_255 char(255) ,
col_smallint smallint ,
col_decimal_10_8 decimal(10,8),
primary key(pk)) ;
set sql_mode='';
SELECT alias1.col_decimal_10_8 AS field1 ,
( SELECT SUM(table1.col_smallint ) AS SQ1_field1
FROM ( t1 as table1 RIGHT JOIN t1 as table2 ON 1 )
) AS field2 ,
GROUPING( LOG(alias1.col_int) ) AS field3
FROM ( t1 AS alias1
JOIN
t1 AS alias2 ON 1  )
WHERE alias2.pk IN ( SELECT col_char_255 FROM t1 )
GROUP BY field1, field2, LOG(alias1.col_int)
WITH ROLLUP
ORDER BY alias1.col_datetime, field1, field2, LOG(alias1.col_int) ;
field1	field2	field3
EXPLAIN SELECT alias1.col_decimal_10_8 AS field1 ,
( SELECT SUM(table1.col_smallint ) AS SQ1_field1
FROM ( t1 as table1 RIGHT JOIN t1 as table2 ON 1 )
) AS field2 ,
GROUPING( LOG(alias1.col_int) ) AS field3
FROM ( t1 AS alias1
JOIN
t1 AS alias2 ON 1  )
WHERE alias2.pk IN ( SELECT col_char_255 FROM t1 )
GROUP BY field1, field2, LOG(alias1.col_int)
WITH ROLLUP
ORDER BY alias1.col_datetime, field1, field2, LOG(alias1.col_int) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary; Using filesort
1	PRIMARY	alias2	NULL	index	PRIMARY	PRIMARY	4	NULL	1	100.00	Using index; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(<derived2>); Using join buffer (hash join)
2	DERIVED	table2	NULL	index	NULL	PRIMARY	4	NULL	1	100.00	Using index
2	DERIVED	table1	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`alias1`.`col_decimal_10_8` AS `field1`,`derived_1_2`.`SQ1_field1` AS `field2`,grouping(rollup_group_item(`rollup_group_item(log(alias1.col_int),2)`,2)) AS `field3` from `test`.`t1` `alias1` join `test`.`t1` `alias2` left join (/* select#2 */ select sum(`test`.`table1`.`col_smallint`) AS `SQ1_field1` from `test`.`t1` `table2` left join `test`.`t1` `table1` on(true) where true) `derived_1_2` on(true) semi join (`test`.`t1`) where (cast(`test`.`alias2`.`pk` as double) = cast(`test`.`t1`.`col_char_255` as double)) group by `field1`,`field2`,log(`test`.`alias1`.`col_int`) with rollup order by `test`.`alias1`.`col_datetime`,`field1`,`field2`,log(`test`.`alias1`.`col_int`)
set sql_mode=default;
DROP TABLE t1;
#
# Bug#33079592: ASSERTION `SELECT->BASE_REF_ITEMS[ITEM_IDX] == ITEM' FAILED
#
CREATE TABLE t1 (f1 INTEGER);
SET optimizer_switch='subquery_to_derived=default';
SELECT SUM(f1), ROW_NUMBER() OVER (PARTITION BY f1), (SELECT MIN(f1) FROM t1) FROM t1;
ERROR 42000: In aggregated query without GROUP BY, expression #1 of PARTITION BY or ORDER BY clause of window '<unnamed window>' contains nonaggregated column 'test.t1.f1'; this is incompatible with sql_mode=only_full_group_by
SELECT SUM(f1), ROW_NUMBER() OVER (), (SELECT MIN(f1) FROM t1) FROM t1 ORDER BY f1;
SUM(f1)	ROW_NUMBER() OVER ()	(SELECT MIN(f1) FROM t1)
NULL	1	NULL
SET optimizer_switch='subquery_to_derived=on';
SELECT SUM(f1), ROW_NUMBER() OVER (PARTITION BY f1), (SELECT MIN(f1) FROM t1) FROM t1;
ERROR 42000: In aggregated query without GROUP BY, expression #2 of SELECT list contains nonaggregated column 'test.t1.f1'; this is incompatible with sql_mode=only_full_group_by
SELECT SUM(f1), ROW_NUMBER() OVER (), (SELECT MIN(f1) FROM t1) FROM t1 ORDER BY f1;
ERROR 42000: In aggregated query without GROUP BY, expression #2 of SELECT list contains nonaggregated column 'test.t1.f1'; this is incompatible with sql_mode=only_full_group_by
SELECT SUM(f1), SUM(f1) OVER (), f1, (SELECT MIN(f1) FROM t1) sq FROM t1 ORDER BY f1;
ERROR 42000: In aggregated query without GROUP BY, expression #2 of SELECT list contains nonaggregated column 'test.t1.f1'; this is incompatible with sql_mode=only_full_group_by
DROP TABLE t1;
#
# Bug#33910786 Scalar subquery transformation combined with
# WHERE clause optimization lead to reject_multiple_rows being
# ineffective
#
CREATE TABLE t(i INT);
INSERT INTO t VALUES (1);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
SELECT 1 AS one FROM t WHERE 1=(SELECT 1 UNION SELECT 2);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN FORMAT=tree SELECT 1 AS one FROM t WHERE 1=(SELECT 1 UNION SELECT 2);
EXPLAIN
-> Nested loop inner join  (cost=0.80 rows=2)
    -> Table scan on t  (cost=0.35 rows=1)
    -> Constant row from derived_1_2  (cost=0.55..0.55 rows=1)
        -> Union materialize with deduplication  (cost=0.20..0.20 rows=2)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

DROP TABLE t;
SET optimizer_switch='subquery_to_derived=default';
