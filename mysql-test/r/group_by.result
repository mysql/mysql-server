drop table if exists t1,t2,t3;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
SELECT 1 FROM (SELECT 1) as a  GROUP BY SUM(1);
ERROR HY000: Invalid use of group function
CREATE TABLE t1 (
spID int(10) unsigned,
userID int(10) unsigned,
score smallint(5) unsigned,
lsg char(40),
date date
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,1,1,'','0000-00-00');
INSERT INTO t1 VALUES (2,2,2,'','0000-00-00');
INSERT INTO t1 VALUES (2,1,1,'','0000-00-00');
INSERT INTO t1 VALUES (3,3,3,'','0000-00-00');
CREATE TABLE t2 (
userID int(10) unsigned NOT NULL auto_increment,
niName char(15),
passwd char(8),
mail char(50),
isAukt enum('N','Y') DEFAULT 'N',
vName char(30),
nName char(40),
adr char(60),
plz char(5),
ort char(35),
land char(20),
PRIMARY KEY (userID)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (1,'name','pass','mail','Y','v','n','adr','1','1','1');
INSERT INTO t2 VALUES (2,'name','pass','mail','Y','v','n','adr','1','1','1');
INSERT INTO t2 VALUES (3,'name','pass','mail','Y','v','n','adr','1','1','1');
INSERT INTO t2 VALUES (4,'name','pass','mail','Y','v','n','adr','1','1','1');
INSERT INTO t2 VALUES (5,'name','pass','mail','Y','v','n','adr','1','1','1');
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN FORMAT=tree SELECT t2.userid, MIN(t1.score) FROM t1, t2 WHERE t1.userID=t2.userID GROUP BY t2.userid;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Nested loop inner join  (cost=2.05 rows=4)
            -> Filter: (t1.userID is not null)  (cost=0.65 rows=4)
                -> Table scan on t1  (cost=0.65 rows=4)
            -> Single-row covering index lookup on t2 using PRIMARY (userID=t1.userID)  (cost=0.28 rows=1)

SELECT t2.userid, MIN(t1.score) FROM t1, t2 WHERE t1.userID=t2.userID GROUP BY t2.userid;
userid	MIN(t1.score)
1	1
2	2
3	3
SELECT t2.userid, MIN(t1.score) FROM t1, t2 WHERE t1.userID=t2.userID GROUP BY t2.userid ORDER BY NULL;
userid	MIN(t1.score)
1	1
2	2
3	3
SELECT t2.userid, MIN(t1.score) FROM t1, t2 WHERE t1.userID=t2.userID AND t1.spID=2  GROUP BY t2.userid;
userid	MIN(t1.score)
1	1
2	2
SELECT t2.userid, MIN(t1.score+0.0) FROM t1, t2 WHERE t1.userID=t2.userID AND t1.spID=2  GROUP BY t2.userid;
userid	MIN(t1.score+0.0)
1	1.0
2	2.0
SELECT t2.userid, MIN(t1.score+0.0) FROM t1, t2 WHERE t1.userID=t2.userID AND t1.spID=2  GROUP BY t2.userid ORDER BY NULL;
userid	MIN(t1.score+0.0)
1	1.0
2	2.0
EXPLAIN SELECT t2.userid, MIN(t1.score+0.0) FROM t1, t2 WHERE t1.userID=t2.userID AND t1.spID=2  GROUP BY t2.userid ORDER BY NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where; Using temporary
1	SIMPLE	t2	NULL	eq_ref	PRIMARY	PRIMARY	4	test.t1.userID	1	100.00	Using index
Note	1003	/* select#1 */ select `test`.`t2`.`userID` AS `userid`,min((`test`.`t1`.`score` + 0.0)) AS `MIN(t1.score+0.0)` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`spID` = 2) and (`test`.`t2`.`userID` = `test`.`t1`.`userID`)) group by `test`.`t2`.`userID` order by NULL
Warnings:
drop table t1,t2;
CREATE TABLE t1 (
PID int(10) unsigned NOT NULL auto_increment,
payDate date DEFAULT '0000-00-00' NOT NULL,
recDate datetime DEFAULT '0000-00-00 00:00:00' NOT NULL,
URID int(10) unsigned DEFAULT '0' NOT NULL,
CRID int(10) unsigned DEFAULT '0' NOT NULL,
amount int(10) unsigned DEFAULT '0' NOT NULL,
operator int(10) unsigned,
method enum('unknown','cash','dealer','check','card','lazy','delayed','test') DEFAULT 'unknown' NOT NULL,
DIID int(10) unsigned,
reason char(1) binary DEFAULT '' NOT NULL,
code_id int(10) unsigned,
qty mediumint(8) unsigned DEFAULT '0' NOT NULL,
PRIMARY KEY (PID),
KEY URID (URID),
KEY reason (reason),
KEY method (method),
KEY payDate (payDate)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1287	'BINARY as attribute of a type' is deprecated and will be removed in a future release. Please use a CHARACTER SET clause with _bin collation instead
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,'1970-01-01','1997-10-17 00:00:00',2529,1,21000,11886,'check',0,'F',16200,6);
SELECT COUNT(P.URID),SUM(P.amount),P.method, MIN(PP.recdate+0) > 19980501000000   AS IsNew FROM t1 AS P JOIN t1 as PP WHERE P.URID = PP.URID GROUP BY method,IsNew;
ERROR 42000: Can't group on 'IsNew'
drop table t1;
CREATE TABLE t1 (
cid mediumint(9) NOT NULL auto_increment,
firstname varchar(32) DEFAULT '' NOT NULL,
surname varchar(32) DEFAULT '' NOT NULL,
PRIMARY KEY (cid)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,'That','Guy');
INSERT INTO t1 VALUES (2,'Another','Gent');
CREATE TABLE t2 (
call_id mediumint(8) NOT NULL auto_increment,
contact_id mediumint(8) DEFAULT '0' NOT NULL,
PRIMARY KEY (call_id),
KEY contact_id (contact_id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
lock tables t1 read,t2 write;
INSERT INTO t2 VALUES (10,2);
INSERT INTO t2 VALUES (18,2);
INSERT INTO t2 VALUES (62,2);
INSERT INTO t2 VALUES (91,2);
INSERT INTO t2 VALUES (92,2);
SELECT cid, CONCAT(firstname, ' ', surname), COUNT(call_id) FROM t1 LEFT JOIN t2 ON cid=contact_id WHERE firstname like '%foo%' GROUP BY cid;
cid	CONCAT(firstname, ' ', surname)	COUNT(call_id)
SELECT cid, CONCAT(firstname, ' ', surname), COUNT(call_id) FROM t1 LEFT JOIN t2 ON cid=contact_id WHERE firstname like '%foo%' GROUP BY cid ORDER BY NULL;
cid	CONCAT(firstname, ' ', surname)	COUNT(call_id)
SELECT HIGH_PRIORITY cid, CONCAT(firstname, ' ', surname), COUNT(call_id) FROM t1 LEFT JOIN t2 ON cid=contact_id WHERE firstname like '%foo%' GROUP BY cid ORDER BY surname, firstname;
cid	CONCAT(firstname, ' ', surname)	COUNT(call_id)
drop table t2;
unlock tables;
drop table t1;
CREATE TABLE t1 (
bug_id mediumint(9) NOT NULL auto_increment,
groupset bigint(20) DEFAULT '0' NOT NULL,
assigned_to mediumint(9) DEFAULT '0' NOT NULL,
bug_file_loc text,
bug_severity enum('blocker','critical','major','normal','minor','trivial','enhancement') DEFAULT 'blocker' NOT NULL,
bug_status enum('','NEW','ASSIGNED','REOPENED','RESOLVED','VERIFIED','CLOSED') DEFAULT 'NEW' NOT NULL,
creation_ts datetime DEFAULT '0000-00-00 00:00:00' NOT NULL,
delta_ts timestamp,
short_desc mediumtext,
long_desc mediumtext,
op_sys enum('All','Windows 3.1','Windows 95','Windows 98','Windows NT','Windows 2000','Linux','other') DEFAULT 'All' NOT NULL,
priority enum('P1','P2','P3','P4','P5') DEFAULT 'P1' NOT NULL,
product varchar(64) DEFAULT '' NOT NULL,
rep_platform enum('All','PC','VTD-8','Other'),
reporter mediumint(9) DEFAULT '0' NOT NULL,
version varchar(16) DEFAULT '' NOT NULL,
component varchar(50) DEFAULT '' NOT NULL,
resolution enum('','FIXED','INVALID','WONTFIX','LATER','REMIND','DUPLICATE','WORKSFORME') DEFAULT '' NOT NULL,
target_milestone varchar(20) DEFAULT '' NOT NULL,
qa_contact mediumint(9) DEFAULT '0' NOT NULL,
status_whiteboard mediumtext NOT NULL,
votes mediumint(9) DEFAULT '0' NOT NULL,
PRIMARY KEY (bug_id),
KEY assigned_to (assigned_to),
KEY creation_ts (creation_ts),
KEY delta_ts (delta_ts),
KEY bug_severity (bug_severity),
KEY bug_status (bug_status),
KEY op_sys (op_sys),
KEY priority (priority),
KEY product (product),
KEY reporter (reporter),
KEY version (version),
KEY component (component),
KEY resolution (resolution),
KEY target_milestone (target_milestone),
KEY qa_contact (qa_contact),
KEY votes (votes)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,0,0,'','normal','','2000-02-10 09:25:12',20000321114747,'','','Linux','P1','TestProduct','PC',3,'other','TestComponent','','M1',0,'',0);
INSERT INTO t1 VALUES (9,0,0,'','enhancement','','2000-03-10 11:49:36',20000321114747,'','','All','P5','AAAAA','PC',3,'2.00 CD - Pre','BBBBBBBBBBBBB - conversion','','',0,'',0);
INSERT INTO t1 VALUES (10,0,0,'','enhancement','','2000-03-10 18:10:16',20000321114747,'','','All','P4','AAAAA','PC',3,'2.00 CD - Pre','BBBBBBBBBBBBB - conversion','','',0,'',0);
INSERT INTO t1 VALUES (7,0,0,'','critical','','2000-03-09 10:50:21',20000321114747,'','','All','P1','AAAAA','PC',3,'2.00 CD - Pre','BBBBBBBBBBBBB - generic','','',0,'',0);
INSERT INTO t1 VALUES (6,0,0,'','normal','','2000-03-09 10:42:44',20000321114747,'','','All','P2','AAAAA','PC',3,'2.00 CD - Pre','kkkkkkkkkkk lllllllllll','','',0,'',0);
INSERT INTO t1 VALUES (8,0,0,'','major','','2000-03-09 11:32:14',20000321114747,'','','All','P3','AAAAA','PC',3,'2.00 CD - Pre','kkkkkkkkkkk lllllllllll','','',0,'',0);
INSERT INTO t1 VALUES (5,0,0,'','enhancement','','2000-03-09 10:38:59',20000321114747,'','','All','P5','CCC/CCCCCC','PC',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (4,0,0,'','normal','','2000-03-08 18:32:14',20000321114747,'','','other','P2','TestProduct','Other',3,'other','TestComponent2','','',0,'',0);
INSERT INTO t1 VALUES (3,0,0,'','normal','','2000-03-08 18:30:52',20000321114747,'','','other','P2','TestProduct','Other',3,'other','TestComponent','','',0,'',0);
INSERT INTO t1 VALUES (2,0,0,'','enhancement','','2000-03-08 18:24:51',20000321114747,'','','All','P2','TestProduct','Other',4,'other','TestComponent2','','',0,'',0);
INSERT INTO t1 VALUES (11,0,0,'','blocker','','2000-03-13 09:43:41',20000321114747,'','','All','P2','CCC/CCCCCC','PC',5,'7.00','DDDDDDDDD','','',0,'',0);
INSERT INTO t1 VALUES (12,0,0,'','normal','','2000-03-13 16:14:31',20000321114747,'','','All','P2','AAAAA','PC',3,'2.00 CD - Pre','kkkkkkkkkkk lllllllllll','','',0,'',0);
INSERT INTO t1 VALUES (13,0,0,'','normal','','2000-03-15 16:20:44',20000321114747,'','','other','P2','TestProduct','Other',3,'other','TestComponent','','',0,'',0);
INSERT INTO t1 VALUES (14,0,0,'','blocker','','2000-03-15 18:13:47',20000321114747,'','','All','P1','AAAAA','PC',3,'2.00 CD - Pre','BBBBBBBBBBBBB - generic','','',0,'',0);
INSERT INTO t1 VALUES (15,0,0,'','minor','','2000-03-16 18:03:28',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','DDDDDDDDD','','',0,'',0);
INSERT INTO t1 VALUES (16,0,0,'','normal','','2000-03-16 18:33:41',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (17,0,0,'','normal','','2000-03-16 18:34:18',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (18,0,0,'','normal','','2000-03-16 18:34:56',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (19,0,0,'','enhancement','','2000-03-16 18:35:34',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (20,0,0,'','enhancement','','2000-03-16 18:36:23',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (21,0,0,'','enhancement','','2000-03-16 18:37:23',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (22,0,0,'','enhancement','','2000-03-16 18:38:16',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','Administration','','',0,'',0);
INSERT INTO t1 VALUES (23,0,0,'','normal','','2000-03-16 18:58:12',20000321114747,'','','All','P2','CCC/CCCCCC','Other',5,'7.00','DDDDDDDDD','','',0,'',0);
INSERT INTO t1 VALUES (24,0,0,'','normal','','2000-03-17 11:08:10',20000321114747,'','','All','P2','AAAAAAAA-AAA','PC',3,'2.8','Web Interface','','',0,'',0);
INSERT INTO t1 VALUES (25,0,0,'','normal','','2000-03-17 11:10:45',20000321114747,'','','All','P2','AAAAAAAA-AAA','PC',3,'2.8','Web Interface','','',0,'',0);
INSERT INTO t1 VALUES (26,0,0,'','normal','','2000-03-17 11:15:47',20000321114747,'','','All','P2','AAAAAAAA-AAA','PC',3,'2.8','Web Interface','','',0,'',0);
INSERT INTO t1 VALUES (27,0,0,'','normal','','2000-03-17 17:45:41',20000321114747,'','','All','P2','CCC/CCCCCC','PC',5,'7.00','DDDDDDDDD','','',0,'',0);
INSERT INTO t1 VALUES (28,0,0,'','normal','','2000-03-20 09:51:45',20000321114747,'','','Windows NT','P2','TestProduct','PC',8,'other','TestComponent','','',0,'',0);
INSERT INTO t1 VALUES (29,0,0,'','normal','','2000-03-20 11:15:09',20000321114747,'','','All','P5','AAAAAAAA-AAA','PC',3,'2.8','Web Interface','','',0,'',0);
CREATE TABLE t2 (
value tinytext,
program varchar(64),
initialowner tinytext NOT NULL,
initialqacontact tinytext NOT NULL,
description mediumtext NOT NULL
);
INSERT INTO t2 VALUES ('TestComponent','TestProduct','id0001','','');
INSERT INTO t2 VALUES ('BBBBBBBBBBBBB - conversion','AAAAA','id0001','','');
INSERT INTO t2 VALUES ('BBBBBBBBBBBBB - generic','AAAAA','id0001','','');
INSERT INTO t2 VALUES ('TestComponent2','TestProduct','id0001','','');
INSERT INTO t2 VALUES ('BBBBBBBBBBBBB - eeeeeeeee','AAAAA','id0001','','');
INSERT INTO t2 VALUES ('kkkkkkkkkkk lllllllllll','AAAAA','id0001','','');
INSERT INTO t2 VALUES ('Test Procedures','AAAAA','id0001','','');
INSERT INTO t2 VALUES ('Documentation','AAAAA','id0003','','');
INSERT INTO t2 VALUES ('DDDDDDDDD','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Eeeeeeee Lite','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Eeeeeeee Full','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Administration','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Distribution','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Setup','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Unspecified','CCC/CCCCCC','id0002','','');
INSERT INTO t2 VALUES ('Web Interface','AAAAAAAA-AAA','id0001','','');
INSERT INTO t2 VALUES ('Host communication','AAAAA','id0001','','');
select value,description,bug_id from t2 left join t1 on t2.program=t1.product and t2.value=t1.component where program="AAAAA";
value	description	bug_id
BBBBBBBBBBBBB - conversion		10
BBBBBBBBBBBBB - conversion		9
BBBBBBBBBBBBB - eeeeeeeee		NULL
BBBBBBBBBBBBB - generic		14
BBBBBBBBBBBBB - generic		7
Documentation		NULL
Host communication		NULL
Test Procedures		NULL
kkkkkkkkkkk lllllllllll		12
kkkkkkkkkkk lllllllllll		6
kkkkkkkkkkk lllllllllll		8
select value,description,COUNT(bug_id) from t2 left join t1 on t2.program=t1.product and t2.value=t1.component where program="AAAAA" group by value;
value	description	COUNT(bug_id)
BBBBBBBBBBBBB - conversion		2
BBBBBBBBBBBBB - eeeeeeeee		0
BBBBBBBBBBBBB - generic		2
Documentation		0
Host communication		0
Test Procedures		0
kkkkkkkkkkk lllllllllll		3
select value,description,COUNT(bug_id) from t2 left join t1 on t2.program=t1.product and t2.value=t1.component where program="AAAAA" group by value having COUNT(bug_id) IN (0,2);
value	description	COUNT(bug_id)
BBBBBBBBBBBBB - conversion		2
BBBBBBBBBBBBB - eeeeeeeee		0
BBBBBBBBBBBBB - generic		2
Documentation		0
Host communication		0
Test Procedures		0
select row_number() over (), value,description,COUNT(DISTINCT bug_id) from t2 left join t1 on t2.program=t1.product and t2.value=t1.component where program="AAAAA" group by value having COUNT(DISTINCT bug_id) IN (0,2);
row_number() over ()	value	description	COUNT(DISTINCT bug_id)
1	BBBBBBBBBBBBB - conversion		2
2	BBBBBBBBBBBBB - eeeeeeeee		0
3	BBBBBBBBBBBBB - generic		2
4	Documentation		0
5	Host communication		0
6	Test Procedures		0
drop table t1,t2;
create table t1 (foo int);
insert into t1 values (1);
select 1+1, "a",count(*) from t1 where foo in (2);
1+1	a	count(*)
2	a	0
insert into t1 values (1);
select 1+1,"a",count(*) from t1 where foo in (2);
1+1	a	count(*)
2	a	0
drop table t1;
CREATE TABLE t1 (
spID int(10) unsigned,
userID int(10) unsigned,
score smallint(5) unsigned,
key (spid),
key (score)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,1,1),(2,2,2),(2,1,1),(3,3,3),(4,3,3),(5,3,3),(6,3,3),(7,3,3);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
explain select userid,count(*) from t1 group by userid order by userid desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	8	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`userID` AS `userid`,count(0) AS `count(*)` from `test`.`t1` group by `test`.`t1`.`userID` desc order by `test`.`t1`.`userID` desc
explain select userid,count(*) from t1 group by userid order by null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	8	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`userID` AS `userid`,count(0) AS `count(*)` from `test`.`t1` group by `test`.`t1`.`userID` order by NULL
select userid,count(*) from t1 group by userid order by userid desc;
userid	count(*)
3	5
2	1
1	2
select userid,count(*) from t1 group by userid having (count(*)+1) IN (4,3) order by userid desc;
userid	count(*)
1	2
select userid,count(*) from t1 group by userid having 3  IN (1,COUNT(*)) order by userid desc;
userid	count(*)
explain select spid,count(*) from t1 where spid between 1 and 2 group by spid order by spid desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	spID	spID	5	NULL	3	100.00	Using where; Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`spID` AS `spid`,count(0) AS `count(*)` from `test`.`t1` where (`test`.`t1`.`spID` between 1 and 2) group by `test`.`t1`.`spID` desc order by `test`.`t1`.`spID` desc
explain select spid,count(*) from t1 where spid between 1 and 2 group by spid;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	spID	spID	5	NULL	3	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`spID` AS `spid`,count(0) AS `count(*)` from `test`.`t1` where (`test`.`t1`.`spID` between 1 and 2) group by `test`.`t1`.`spID`
explain select spid,count(*) from t1 where spid between 1 and 2 group by spid order by null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	spID	spID	5	NULL	3	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`spID` AS `spid`,count(0) AS `count(*)` from `test`.`t1` where (`test`.`t1`.`spID` between 1 and 2) group by `test`.`t1`.`spID` order by NULL
select spid,count(*) from t1 where spid between 1 and 2 group by spid;
spid	count(*)
1	1
2	2
select spid,count(*) from t1 where spid between 1 and 2 group by spid order by spid desc;
spid	count(*)
2	2
1	1
explain select sql_big_result spid,sum(userid) from t1 group by spid order by spid desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	spID	NULL	NULL	NULL	8	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`spID` AS `spid`,sum(`test`.`t1`.`userID`) AS `sum(userid)` from `test`.`t1` group by `test`.`t1`.`spID` desc order by `test`.`t1`.`spID` desc
explain select sql_big_result spid,sum(userid) from t1 group by spid order by null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	spID	NULL	NULL	NULL	8	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`spID` AS `spid`,sum(`test`.`t1`.`userID`) AS `sum(userid)` from `test`.`t1` group by `test`.`t1`.`spID` order by NULL
select sql_big_result spid,sum(userid) from t1 group by spid order by spid desc;
spid	sum(userid)
7	3
6	3
5	3
4	3
3	3
2	3
1	1
explain select sql_big_result score,count(*) from t1 group by score order by score desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	score	score	3	NULL	8	100.00	Using index; Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`score` AS `score`,count(0) AS `count(*)` from `test`.`t1` group by `test`.`t1`.`score` desc order by `test`.`t1`.`score` desc
explain select sql_big_result score,count(*) from t1 group by score order by null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	score	score	3	NULL	8	100.00	Using index; Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`score` AS `score`,count(0) AS `count(*)` from `test`.`t1` group by `test`.`t1`.`score` order by NULL
select sql_big_result score,count(*) from t1 group by score order by score desc;
score	count(*)
3	5
2	1
1	2
drop table t1;
create table t1 (a date default null, b date default null);
insert t1 values ('1999-10-01','2000-01-10'), ('1997-01-01','1998-10-01');
select a,min(b) c,count(distinct rand()) from t1 group by a having c<a + interval 1 day;
a	c	count(distinct rand())
drop table t1;
CREATE TABLE t1 (a char(1));
INSERT INTO t1 VALUES ('A'),('B'),('A'),('B'),('A'),('B'),(NULL),('a'),('b'),(NULL),('A'),('B'),(NULL);
SELECT a FROM t1 GROUP BY a;
a
A
B
NULL
SELECT a,count(*) FROM t1 GROUP BY a;
a	count(*)
A	5
B	5
NULL	3
SELECT a FROM t1 GROUP BY binary a;
a
A
B
NULL
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a
b
SELECT a,count(*) FROM t1 GROUP BY binary a;
a	count(*)
A	4
B	4
NULL	3
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a	1
b	1
SELECT binary a FROM t1 GROUP BY 1;
binary a
A
B
NULL
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a
b
SELECT binary a,count(*) FROM t1 GROUP BY 1;
binary a	count(*)
A	4
B	4
NULL	3
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a	1
b	1
SET BIG_TABLES=1;
SELECT a FROM t1 GROUP BY a ORDER BY a;
a
A
B
NULL
SELECT a,count(*) FROM t1 GROUP BY a ORDER BY a;
a	count(*)
A	5
B	5
NULL	3
SELECT a FROM t1 GROUP BY binary a ORDER BY binary a;
a
A
B
NULL
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a
b
SELECT a,count(*) FROM t1 GROUP BY binary a ORDER BY binary a;
a	count(*)
A	4
B	4
NULL	3
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a	1
b	1
SELECT binary a FROM t1 GROUP BY 1 ORDER BY 1;
binary a
A
B
NULL
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a
b
SELECT binary a,count(*) FROM t1 GROUP BY 1 ORDER BY 1;
binary a	count(*)
A	4
B	4
NULL	3
Warning	1287	'BINARY expr' is deprecated and will be removed in a future release. Please use CAST instead
Warnings:
a	1
b	1
SET BIG_TABLES=0;
drop table t1;
CREATE TABLE t1 (
`a` char(193) default NULL,
`b` char(63) default NULL
);
INSERT INTO t1 VALUES ('abc','def'),('hij','klm');
SELECT CONCAT(a, b) FROM t1 GROUP BY 1;
CONCAT(a, b)
abcdef
hijklm
SELECT CONCAT(a, b),count(*) FROM t1 GROUP BY 1;
CONCAT(a, b)	count(*)
abcdef	1
hijklm	1
SELECT CONCAT(a, b),count(distinct a) FROM t1 GROUP BY 1;
CONCAT(a, b)	count(distinct a)
abcdef	1
hijklm	1
SELECT 1 FROM t1 GROUP BY CONCAT(a, b);
1
1
1
INSERT INTO t1 values ('hij','klm');
SELECT CONCAT(a, b),count(*) FROM t1 GROUP BY 1;
CONCAT(a, b)	count(*)
abcdef	1
hijklm	2
DROP TABLE t1;
create table t1 (One int unsigned, Two int unsigned, Three int unsigned, Four int unsigned);
insert into t1 values (1,2,1,4),(1,2,2,4),(1,2,3,4),(1,2,4,4),(1,1,1,4),(1,1,2,4),(1,1,3,4),(1,1,4,4),(1,3,1,4),(1,3,2,4),(1,3,3,4),(1,3,4,4);
select One, Two, sum(Four) from t1 group by One,Two;
One	Two	sum(Four)
1	1	16
1	2	16
1	3	16
drop table t1;
create table t1 (id integer primary key not null auto_increment, gender char(1));
insert into t1 values (NULL, 'M'), (NULL, 'F'),(NULL, 'F'),(NULL, 'F'),(NULL, 'M');
create table t2 (user_id integer not null, date date);
insert into t2 values (1, '2002-06-09'),(2, '2002-06-09'),(1, '2002-06-09'),(3, '2002-06-09'),(4, '2002-06-09'),(4, '2002-06-09');
select u.gender as gender, count(distinct  u.id) as dist_count, (count(distinct u.id)/5*100) as percentage from t1 u, t2 l where l.user_id = u.id group by u.gender;
gender	dist_count	percentage
F	3	60.0000
M	1	20.0000
select u.gender as  gender, count(distinct  u.id) as dist_count, (count(distinct u.id)/5*100) as percentage from t1 u, t2 l where l.user_id = u.id group by u.gender  order by percentage;
gender	dist_count	percentage
M	1	20.0000
F	3	60.0000
drop table t1,t2;
CREATE TABLE t1 (ID1 int, ID2 int, ID int NOT NULL AUTO_INCREMENT,PRIMARY KEY(ID
));
insert into t1 values (1,244,NULL),(2,243,NULL),(134,223,NULL),(185,186,NULL);
select S.ID as xID, S.ID1 as xID1 from t1 as S left join t1 as yS  on S.ID1 between yS.ID1 and yS.ID2;
xID	xID1
1	1
2	2
2	2
3	134
3	134
3	134
4	185
4	185
4	185
4	185
select S.ID as xID, S.ID1 as xID1, repeat('*',count(distinct yS.ID)) as Level from t1 as S left join t1 as yS  on S.ID1 between yS.ID1 and yS.ID2 group by xID order by xID1;
xID	xID1	Level
1	1	*
2	2	**
3	134	***
4	185	****
drop table t1;
CREATE TABLE t1 (
pid int(11) unsigned NOT NULL default '0',
c1id int(11) unsigned default NULL,
c2id int(11) unsigned default NULL,
value int(11) unsigned NOT NULL default '0',
UNIQUE KEY pid2 (pid,c1id,c2id),
UNIQUE KEY pid (pid,value)
) ENGINE=INNODB;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1, 1, NULL, 1),(1, 2, NULL, 2),(1, NULL, 3, 3),(1, 4, NULL, 4),(1, 5, NULL, 5);
CREATE TABLE t2 (
id int(11) unsigned NOT NULL default '0',
active enum('Yes','No') NOT NULL default 'Yes',
PRIMARY KEY  (id)
) ENGINE=INNODB;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (1, 'Yes'),(2, 'No'),(4, 'Yes'),(5, 'No');
CREATE TABLE t3 (
id int(11) unsigned NOT NULL default '0',
active enum('Yes','No') NOT NULL default 'Yes',
PRIMARY KEY  (id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t3 VALUES (3, 'Yes');
select * from t1 AS m LEFT JOIN t2 AS c1 ON m.c1id = 
c1.id AND c1.active = 'Yes' LEFT JOIN t3 AS c2 ON m.c2id = c2.id AND 
c2.active = 'Yes' WHERE m.pid=1  AND (c1.id IS NOT NULL OR c2.id IS NOT NULL);
pid	c1id	c2id	value	id	active	id	active
1	1	NULL	1	1	Yes	NULL	NULL
1	4	NULL	4	4	Yes	NULL	NULL
1	NULL	3	3	NULL	NULL	3	Yes
select max(value) from t1 AS m LEFT JOIN t2 AS c1 ON 
m.c1id = c1.id AND c1.active = 'Yes' LEFT JOIN t3 AS c2 ON m.c2id = 
c2.id AND c2.active = 'Yes' WHERE m.pid=1  AND (c1.id IS NOT NULL OR c2.id IS 
NOT NULL);
max(value)
4
drop table t1,t2,t3;
create table t1 (a blob null);
insert into t1 values (NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(NULL),(""),(""),(""),("b");
select a,count(*) from t1 group by a;
a	count(*)
NULL	9
	3
b	1
set big_tables=1;
select a,count(*) from t1 group by a;
a	count(*)
NULL	9
	3
b	1
drop table t1;
create table t1 (a int not null, b int not null);
insert into t1 values (1,1),(1,2),(3,1),(3,2),(2,2),(2,1);
create table t2 (a int not null, b int not null, key(a));
insert into t2 values (1,3),(3,1),(2,2),(1,1);
analyze table t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
select t1.a,t2.b from t1,t2 where t1.a=t2.a group by t1.a,t2.b;
a	b
1	1
1	3
2	2
3	1
select t1.a,t2.b from t1,t2 where t1.a=t2.a group by t1.a,t2.b ORDER BY NULL;
a	b
1	1
1	3
2	2
3	1
explain select t1.a,t2.b from t1,t2 where t1.a=t2.a group by t1.a,t2.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	a	NULL	NULL	NULL	#	#	Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t1`.`a` = `test`.`t2`.`a`) group by `test`.`t1`.`a`,`test`.`t2`.`b`
explain select t1.a,t2.b from t1,t2 where t1.a=t2.a group by t1.a,t2.b ORDER BY NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	a	NULL	NULL	NULL	#	#	Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t1`.`a` = `test`.`t2`.`a`) group by `test`.`t1`.`a`,`test`.`t2`.`b` order by NULL
drop table t1,t2;
create table t1 (a int, b int);
insert into t1 values (1, 4),(10, 40),(1, 4),(10, 43),(1, 4),(10, 41),(1, 4),(10, 43),(1, 4);
select a, MAX(b), INTERVAL (MAX(b), 1,3,10,30,39,40,50,60,100,1000) from t1 group by a;
a	MAX(b)	INTERVAL (MAX(b), 1,3,10,30,39,40,50,60,100,1000)
1	4	2
10	43	6
select a, MAX(b), CASE MAX(b) when 4 then 4 when 43 then 43 else 0 end from t1 group by a;
a	MAX(b)	CASE MAX(b) when 4 then 4 when 43 then 43 else 0 end
1	4	4
10	43	43
select a, MAX(b), FIELD(MAX(b), '43', '4', '5') from t1 group by a;
a	MAX(b)	FIELD(MAX(b), '43', '4', '5')
1	4	2
10	43	1
select a, MAX(b), CONCAT_WS(MAX(b), '43', '4', '5') from t1 group by a;
a	MAX(b)	CONCAT_WS(MAX(b), '43', '4', '5')
1	4	434445
10	43	43434435
select a, MAX(b), ELT(MAX(b), 'a', 'b', 'c', 'd', 'e', 'f') from t1 group by a;
a	MAX(b)	ELT(MAX(b), 'a', 'b', 'c', 'd', 'e', 'f')
1	4	d
10	43	NULL
select a, MAX(b), MAKE_SET(MAX(b), 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h') from t1 group by a;
a	MAX(b)	MAKE_SET(MAX(b), 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')
1	4	c
10	43	a,b,d,f
drop table t1;
create table t1 (id int not null, qty int not null);
insert into t1 values (1,2),(1,3),(2,4),(2,5);
select id, sum(qty) as sqty, count(qty) as cqty from t1 group by id having sum(qty)>2 and cqty>1;
id	sqty	cqty
1	5	2
2	9	2
select id, sum(qty) as sqty from t1 group by id having sqty>2 and count(qty)>1;
id	sqty
1	5
2	9
select id, sum(qty) as sqty, count(qty) as cqty from t1 group by id having sqty>2 and cqty>1;
id	sqty	cqty
1	5	2
2	9	2
select id, sum(qty) as sqty, count(qty) as cqty from t1 group by id having sum(qty)>2 and count(qty)>1;
id	sqty	cqty
1	5	2
2	9	2
select count(*), case interval(qty,2,3,4,5,6,7,8) when -1 then NULL when 0 then "zero" when 1 then "one" when 2 then "two" end as category from t1 group by category;
count(*)	category
2	NULL
1	one
1	two
select count(*), interval(qty,2,3,4,5,6,7,8) as category from t1 group by category;
count(*)	category
1	1
1	2
1	3
1	4
drop table t1;
CREATE TABLE t1 (
userid int(10) unsigned,
score smallint(5) unsigned,
key (score)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,1),(2,2),(1,1),(3,3),(3,3),(3,3),(3,3),(3,3);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT userid,count(*) FROM t1 GROUP BY userid ORDER BY userid DESC;
userid	count(*)
3	5
2	1
1	2
EXPLAIN SELECT userid,count(*) FROM t1 GROUP BY userid ORDER BY userid DESC;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	8	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`userid` AS `userid`,count(0) AS `count(*)` from `test`.`t1` group by `test`.`t1`.`userid` desc order by `test`.`t1`.`userid` desc
DROP TABLE t1;
CREATE TABLE t1 (
i int(11) default NULL,
j int(11) default NULL
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,2),(2,3),(4,5),(3,5),(1,5),(23,5);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT i, COUNT(DISTINCT(i)) FROM t1 GROUP BY j ORDER BY NULL;
i	COUNT(DISTINCT(i))
1	1
2	1
4	4
explain SELECT i, COUNT(DISTINCT(i)) FROM t1 GROUP BY j ORDER BY NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	6	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,count(distinct `test`.`t1`.`i`) AS `COUNT(DISTINCT(i))` from `test`.`t1` group by `test`.`t1`.`j` order by NULL
DROP TABLE t1;
create table t1 (a int);
insert into t1 values(null);
select min(a) is null from t1;
min(a) is null
1
select min(a) is null or null from t1;
min(a) is null or null
1
select 1 and min(a) is null from t1;
1 and min(a) is null
1
drop table t1;
create table t1 ( col1 int, col2 int );
insert into t1 values (1,1),(1,2),(1,3),(2,1),(2,2);
select group_concat( distinct col1 ) as alias from t1
group by col2 having alias like '%';
alias
1,2
1,2
1
drop table t1;
CREATE TABLE t1 (a INTEGER, b INTEGER, c INTEGER);
INSERT INTO t1 (a,b) VALUES (1,2),(1,3),(2,5);
SELECT a, 0.1*0+1 r2, SUM(1) r1 FROM t1 WHERE a = 1 GROUP BY a HAVING r1>1 AND r2=1;
a	r2	r1
1	1.0	2
SELECT a, ROUND(RAND(100)*10) r2, SUM(1) r1 FROM t1 GROUP BY a;
a	r2	r1
1	2	2
2	7	1
SELECT a, ROUND(RAND(100)*10) r2, SUM(1) r1 FROM t1 GROUP BY a
HAVING r1>=1 AND r2<=7 AND r2 > 0;
a	r2	r1
1	2	2
2	7	1
SELECT a, ROUND(RAND(100)*10) r2, SUM(1) r1 FROM t1 GROUP BY a
HAVING r1>=1 AND (SELECT r2<=7 AND r2 > 0 FROM t1 AS t2 LIMIT 1);
a	r2	r1
1	2	2
2	7	1
SELECT a, ROUND(RAND(100)*10) r2, SUM(1) r1 FROM t1 WHERE a = 1
GROUP BY a HAVING r1>1 AND r2<=2;
a	r2	r1
1	7	2
SELECT a, ROUND(RAND(100)*10) r2, SUM(1) r1 FROM t1 WHERE a = 1
GROUP BY a HAVING r1>1 AND r2<=2 ORDER BY a+r2+r1;
a	r2	r1
1	7	2
SELECT a,SUM(b) FROM t1 WHERE a=1 GROUP BY c;
a	SUM(b)
1	5
SELECT a*SUM(b) FROM t1 WHERE a=1 GROUP BY c;
a*SUM(b)
5
SELECT SUM(a)*SUM(b) FROM t1 WHERE a=1 GROUP BY c;
SUM(a)*SUM(b)
10
SELECT a,SUM(b) FROM t1 WHERE a=1 GROUP BY c HAVING a=1;
a	SUM(b)
1	5
SELECT a AS d,SUM(b) FROM t1 WHERE a=1 GROUP BY c HAVING d=1;
d	SUM(b)
1	5
SELECT SUM(a)*SUM(b) AS d FROM t1 WHERE a=1 GROUP BY c HAVING d > 0;
d
10
SELECT a, ROUND(RAND(100)*10) r2 FROM t1;
a	r2
1	2
1	7
2	10
SELECT ROUND(RAND(100)*10) r2 FROM t1 GROUP BY r2;
r2
2
7
10
DROP TABLE t1;
CREATE TABLE t1(i INT);
INSERT INTO t1 VALUES (NULL),(1);
SELECT DISTINCT STD(i)+0 as splus0, i+0 as plain FROM t1 GROUP BY i ;
splus0	plain
NULL	NULL
0	1
DROP TABLE t1;
create table t1(a int) ENGINE=INNODB;
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(8),(9);
create table t2 (
a int,
b varchar(200) NOT NULL,
c varchar(50) NOT NULL,
d varchar(100) NOT NULL,
primary key (a,b(132),c,d),
key a (a,b)
) ENGINE=INNODB charset=utf8;
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
insert into t2 select 
x3.a,  -- 3
concat('val-', x3.a + 3*x4.a), -- 12
concat('val-', @a:=x3.a + 3*x4.a + 12*C.a), -- 120
concat('val-', @a + 120*D.a)
from t1 x3, t1 x4, t1 C, t1 D where x3.a < 3 and x4.a < 4 and D.a < 4
order by x3.a, x4.a, C.a, D.a;
Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
delete from t2  where a = 2 and b = 'val-2' order by a,b,c,d limit 30;
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
explain select c from t2 where a = 2 and b = 'val-2' group by c;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	PRIMARY,a	PRIMARY	402	const,const	6	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`c` AS `c` from `test`.`t2` where ((`test`.`t2`.`a` = 2) and (`test`.`t2`.`b` = 'val-2')) group by `test`.`t2`.`c`
select c from t2 where a = 2 and b = 'val-2' group by c;
c
val-74
val-98
drop table t1,t2;
create table t1 (b int4 unsigned not null);
insert into t1 values(3000000000);
select * from t1;
b
3000000000
select min(b) from t1;
min(b)
3000000000
drop table t1;
CREATE TABLE t1 (id int PRIMARY KEY, user_id int, hostname longtext);
INSERT INTO t1 VALUES
(1, 7, 'cache-dtc-af05.proxy.aol.com'),
(2, 3, 'what.ever.com'),
(3, 7, 'cache-dtc-af05.proxy.aol.com'),
(4, 7, 'cache-dtc-af05.proxy.aol.com');
SELECT hostname, COUNT(DISTINCT user_id) as no FROM t1
WHERE hostname LIKE '%aol%'
    GROUP BY hostname;
hostname	no
cache-dtc-af05.proxy.aol.com	1
DROP TABLE t1;
CREATE TABLE t1 (a  int, b int);
INSERT INTO t1 VALUES (1,2), (1,3);
SELECT a, b FROM t1 GROUP BY 'const';
a	b
1	2
SELECT DISTINCT a, b FROM t1 GROUP BY 'const';
a	b
1	2
DROP TABLE t1;
CREATE TABLE t1 (id INT, dt DATETIME);
INSERT INTO t1 VALUES ( 1, '2005-05-01 12:30:00' );
INSERT INTO t1 VALUES ( 1, '2005-05-01 12:30:00' );
INSERT INTO t1 VALUES ( 1, '2005-05-01 12:30:00' );
INSERT INTO t1 VALUES ( 1, '2005-05-01 12:30:00' );
SELECT dt DIV 1 AS f, id FROM t1 GROUP BY f;
f	id
20050501123000	1
DROP TABLE t1;
CREATE TABLE t1 (id varchar(20) NOT NULL);
INSERT INTO t1 VALUES ('trans1'), ('trans2');
CREATE TABLE t2 (id varchar(20) NOT NULL, err_comment blob NOT NULL);
INSERT INTO t2 VALUES ('trans1', 'a problem');
SELECT COUNT(DISTINCT(t1.id)), LEFT(err_comment, 256) AS comment
FROM t1 LEFT JOIN t2 ON t1.id=t2.id GROUP BY comment;
COUNT(DISTINCT(t1.id))	comment
1	NULL
1	a problem
DROP TABLE t1, t2;
create table t1 (f1 date);
insert into t1 values('2005-06-06');
insert into t1 values('2005-06-06');
select date(left(f1+0,8)) from t1 group by 1;
date(left(f1+0,8))
2005-06-06
drop table t1;
CREATE TABLE t1 (n int);
INSERT INTO t1 VALUES (1);
SELECT n+1 AS n FROM t1 GROUP BY n;
n
2
Warnings:
Warning	1052	Column 'n' in group statement is ambiguous
DROP TABLE t1;
create table t1(f1 varchar(5) key);
insert into t1 values (1),(2);
select sql_buffer_result max(f1) is null from t1;
max(f1) is null
0
select sql_buffer_result max(f1)+1 from t1;
max(f1)+1
3
drop table t1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1),(2);
SELECT a FROM t1 GROUP BY 'a';
a
1
SELECT a FROM t1 GROUP BY "a";
a
1
SELECT a FROM t1 GROUP BY `a`;
a
1
2
set sql_mode=ANSI_QUOTES;
SELECT a FROM t1 GROUP BY "a";
a
1
2
SELECT a FROM t1 GROUP BY 'a';
a
1
SELECT a FROM t1 GROUP BY `a`;
a
1
2
set sql_mode=DEFAULT;
SELECT a FROM t1 HAVING 'a' > 1;
a
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'a'
SELECT a FROM t1 HAVING "a" > 1;
a
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'a'
SELECT a FROM t1 HAVING `a` > 1;
a
2
SELECT a FROM t1 ORDER BY 'a' DESC;
a
1
2
SELECT a FROM t1 ORDER BY "a" DESC;
a
1
2
SELECT a FROM t1 ORDER BY `a` DESC;
a
2
1
DROP TABLE t1;
CREATE TABLE t1 (
f1 int(10) unsigned NOT NULL auto_increment primary key,
f2 varchar(100) NOT NULL default ''
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (
f1 varchar(10) NOT NULL default '',
f2 char(3) NOT NULL default '',
PRIMARY KEY  (`f1`),
KEY `k1` (`f2`,`f1`)
);
INSERT INTO t1 values(NULL, '');
INSERT INTO `t2` VALUES ('486878','WDT'),('486910','WDT');
SELECT SQL_BUFFER_RESULT avg(t2.f1) FROM t1, t2 where t2.f2 = 'SIR' GROUP BY t1.f1;
avg(t2.f1)
SELECT avg(t2.f1) FROM t1, t2 where t2.f2 = 'SIR' GROUP BY t1.f1;
avg(t2.f1)
DROP TABLE t1, t2;
create table t1 (c1 char(3), c2 char(3));
create table t2 (c3 char(3), c4 char(3));
insert into t1 values ('aaa', 'bb1'), ('aaa', 'bb2');
insert into t2 values ('aaa', 'bb1'), ('aaa', 'bb2');
select t1.c1 as c2 from t1, t2 where t1.c2 = t2.c4
group by c2;
c2
aaa
aaa
Warnings:
Warning	1052	Column 'c2' in group statement is ambiguous
select t1.c1 as c2 from t1, t2 where t1.c2 = t2.c4
group by t1.c1;
c2
aaa
drop table t1, t2;
CREATE TABLE t1 (a tinyint(3), b varchar(255), PRIMARY KEY  (a));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,'-----'), (6,'Allemagne'), (17,'Autriche'), 
(25,'Belgique'), (54,'Danemark'), (62,'Espagne'), (68,'France');
CREATE TABLE t2 (a tinyint(3), b tinyint(3), PRIMARY KEY  (a), KEY b (b));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (1,1), (2,1), (6,6), (18,17), (15,25), (16,25),
(17,25), (10,54), (5,62),(3,68);
CREATE VIEW v1 AS select t1.a, concat(t1.b,'') AS b, t1.b as real_b from t1;
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
explain 
SELECT straight_join v1.a, v1.b, v1.real_b from t2, v1
where t2.b=v1.a GROUP BY t2.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	b	b	2	NULL	#	100.00	Using where; Using index
1	SIMPLE	t1	NULL	eq_ref	PRIMARY	PRIMARY	1	test.t2.b	#	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select straight_join `test`.`t1`.`a` AS `a`,concat(`test`.`t1`.`b`,'') AS `b`,`test`.`t1`.`b` AS `real_b` from `test`.`t2` join `test`.`t1` where (`test`.`t1`.`a` = `test`.`t2`.`b`) group by `test`.`t2`.`b`
SELECT straight_join v1.a, v1.b, v1.real_b from t2, v1
where t2.b=v1.a GROUP BY t2.b;
a	b	real_b
1	-----	-----
6	Allemagne	Allemagne
17	Autriche	Autriche
25	Belgique	Belgique
54	Danemark	Danemark
62	Espagne	Espagne
68	France	France
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (a INT PRIMARY KEY, b INT, key (b));
INSERT INTO t1 VALUES (1,      1);
INSERT INTO t1 SELECT  a + 1 , MOD(a + 1 , 20) FROM t1;
INSERT INTO t1 SELECT  a + 2 , MOD(a + 2 , 20) FROM t1;
INSERT INTO t1 SELECT  a + 4 , MOD(a + 4 , 20) FROM t1;
INSERT INTO t1 SELECT  a + 8 , MOD(a + 8 , 20) FROM t1;
INSERT INTO t1 SELECT  a + 16, MOD(a + 16, 20) FROM t1;
INSERT INTO t1 SELECT  a + 32, MOD(a + 32, 20) FROM t1;
INSERT INTO t1 SELECT  a + 64, MOD(a + 64, 20) FROM t1;
SELECT MIN(b), MAX(b) from t1;
MIN(b)	MAX(b)
0	19
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT b, sum(1) FROM t1 GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	b	b	5	NULL	128	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`b` AS `b`,sum(1) AS `sum(1)` from `test`.`t1` group by `test`.`t1`.`b`
EXPLAIN SELECT SQL_BIG_RESULT b, sum(1) FROM t1 GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	b	b	5	NULL	128	100.00	Using index; Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`b` AS `b`,sum(1) AS `sum(1)` from `test`.`t1` group by `test`.`t1`.`b`
SELECT b, sum(1) FROM t1 GROUP BY b;
b	sum(1)
0	6
1	7
2	7
3	7
4	7
5	7
6	7
7	7
8	7
9	6
10	6
11	6
12	6
13	6
14	6
15	6
16	6
17	6
18	6
19	6
SELECT SQL_BIG_RESULT b, sum(1) FROM t1 GROUP BY b;
b	sum(1)
0	6
1	7
2	7
3	7
4	7
5	7
6	7
7	7
8	7
9	6
10	6
11	6
12	6
13	6
14	6
15	6
16	6
17	6
18	6
19	6
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1),(2,1),(3,2),(4,2),(5,3),(6,3);
SET SQL_MODE = 'ONLY_FULL_GROUP_BY';
SELECT MAX(a)-MIN(a) FROM t1 GROUP BY b;
MAX(a)-MIN(a)
1
1
1
SELECT CEILING(MIN(a)) FROM t1 GROUP BY b;
CEILING(MIN(a))
1
3
5
SELECT CASE WHEN AVG(a)>=0 THEN 'Positive' ELSE 'Negative' END FROM t1 
GROUP BY b;
CASE WHEN AVG(a)>=0 THEN 'Positive' ELSE 'Negative' END
Positive
Positive
Positive
SELECT a + 1 FROM t1 GROUP BY a;
a + 1
2
3
4
5
6
7
SELECT a + b FROM t1 GROUP BY b;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT (SELECT t1_outer.a FROM t1 AS t1_inner GROUP BY b LIMIT 1) 
FROM t1 AS t1_outer;
(SELECT t1_outer.a FROM t1 AS t1_inner GROUP BY b LIMIT 1)
1
2
3
4
5
6
SELECT 1 FROM t1 as t1_outer GROUP BY a 
HAVING (SELECT t1_outer.a FROM t1 AS t1_inner GROUP BY b LIMIT 1);
1
1
1
1
1
1
1
SELECT (SELECT t1_outer.a FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1_outer.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT 1 FROM t1 as t1_outer GROUP BY a 
HAVING (SELECT t1_outer.b FROM t1 AS t1_inner LIMIT 1);
ERROR 42S22: Unknown column 'test.t1_outer.b' in 'field list'
SELECT (SELECT SUM(t1_inner.a) FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
(SELECT SUM(t1_inner.a) FROM t1 AS t1_inner LIMIT 1)
21
21
21
SELECT (SELECT SUM(t1_inner.a) FROM t1 AS t1_inner GROUP BY t1_inner.b LIMIT 1)
FROM t1 AS t1_outer;
(SELECT SUM(t1_inner.a) FROM t1 AS t1_inner GROUP BY t1_inner.b LIMIT 1)
3
3
3
3
3
3
SELECT (SELECT SUM(t1_outer.a) FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
(SELECT SUM(t1_outer.a) FROM t1 AS t1_inner LIMIT 1)
3
7
11
SET SQL_MODE = '';
SELECT (SELECT SUM(t1_outer.a) FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
(SELECT SUM(t1_outer.a) FROM t1 AS t1_inner LIMIT 1)
3
7
11
SET SQL_MODE = 'ONLY_FULL_GROUP_BY';
SELECT (SELECT SUM(t1_outer.a+0*t1_inner.a) FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1_outer.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SET SQL_MODE = '';
SELECT (SELECT SUM(t1_outer.a+0*t1_inner.a) FROM t1 AS t1_inner LIMIT 1) 
FROM t1 AS t1_outer GROUP BY t1_outer.b;
(SELECT SUM(t1_outer.a+0*t1_inner.a) FROM t1 AS t1_inner LIMIT 1)
6
18
30
SET SQL_MODE = 'ONLY_FULL_GROUP_BY';
SELECT 1 FROM t1 as t1_outer 
WHERE (SELECT t1_outer.b FROM t1 AS t1_inner GROUP BY t1_inner.b LIMIT 1);
1
1
1
1
1
1
1
SELECT b FROM t1 GROUP BY b HAVING CEILING(b) > 0;
b
1
2
3
SELECT 1 FROM t1 GROUP BY b HAVING b = 2 OR b = 3 OR SUM(a) > 12;
1
1
1
SELECT 1 FROM t1 GROUP BY b HAVING ROW (b,b) = ROW (1,1);
1
1
SELECT 1 FROM t1 GROUP BY b HAVING a = 2;
ERROR 42S22: Unknown column 'a' in 'having clause'
SELECT 1 FROM t1 GROUP BY SUM(b);
ERROR HY000: Invalid use of group function
SELECT b FROM t1 AS t1_outer GROUP BY a HAVING t1_outer.a IN 
(SELECT SUM(t1_inner.b)+t1_outer.b FROM t1 AS t1_inner GROUP BY t1_inner.a
HAVING SUM(t1_inner.b)+t1_outer.b > 5);
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1_outer.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
DROP TABLE t1;
SET SQL_MODE = '';
SET SQL_MODE = 'ONLY_FULL_GROUP_BY';
create table t1(f1 int, f2 int);
select * from t1 group by f1;
ERROR 42000: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1.f2' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
select * from t1 group by f2;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1.f1' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
select * from t1 group by f1, f2;
f1	f2
select t1.f1,t.* from t1, t1 t group by 1;
ERROR 42000: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t.f1' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
drop table t1;
SET SQL_MODE = DEFAULT;
CREATE TABLE t1(
id INT AUTO_INCREMENT PRIMARY KEY, 
c1 INT NOT NULL, 
c2 INT NOT NULL,
UNIQUE KEY (c2,c1));
INSERT INTO t1(c1,c2) VALUES (5,1), (4,1), (3,5), (2,3), (1,3);
SELECT * FROM t1 ORDER BY c1;
id	c1	c2
5	1	3
4	2	3
3	3	5
2	4	1
1	5	1
SELECT * FROM t1 GROUP BY id ORDER BY c1;
id	c1	c2
5	1	3
4	2	3
3	3	5
2	4	1
1	5	1
SELECT * FROM t1 GROUP BY id ORDER BY id DESC;
id	c1	c2
5	1	3
4	2	3
3	3	5
2	4	1
1	5	1
SELECT * FROM t1 GROUP BY c2 ,c1, id ORDER BY c2, c1;
id	c1	c2
2	4	1
1	5	1
5	1	3
4	2	3
3	3	5
SELECT * FROM t1 GROUP BY c2, c1, id ORDER BY c2 DESC, c1;
id	c1	c2
3	3	5
5	1	3
4	2	3
2	4	1
1	5	1
SELECT * FROM t1 GROUP BY c2, c1, id ORDER BY c2 DESC, c1 DESC;
id	c1	c2
3	3	5
4	2	3
5	1	3
1	5	1
2	4	1
SELECT * FROM t1 GROUP BY c2  ORDER BY c2, c1;
id	c1	c2
2	4	1
5	1	3
3	3	5
SELECT * FROM t1 GROUP BY c2  ORDER BY c2 DESC, c1;
id	c1	c2
3	3	5
5	1	3
2	4	1
SELECT * FROM t1 GROUP BY c2  ORDER BY c2 DESC, c1 DESC;
id	c1	c2
3	3	5
5	1	3
2	4	1
DROP TABLE t1;
#
# Bug#27219: Aggregate functions in ORDER BY.  
#
SET @save_sql_mode=@@sql_mode;
SET @@sql_mode='ONLY_FULL_GROUP_BY';
CREATE TABLE t1 (a INT, b INT, c INT DEFAULT 0);
INSERT INTO t1 (a, b) VALUES (3,3), (2,2), (3,3), (2,2), (3,3), (4,4);
CREATE TABLE t2 SELECT * FROM t1;
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*);
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*) + 1;
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*) + a;
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*), 1;
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*), a;
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY SUM(a);
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY SUM(a + 1);
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY SUM(a) + 1;
COUNT(*)
6
SELECT COUNT(*) FROM t1 ORDER BY SUM(a), b;
COUNT(*)
6
SELECT SUM(a) FROM t1 ORDER BY COUNT(b);
SUM(a)
17
SELECT t1.a FROM t1 ORDER BY (SELECT SUM(t2.a) FROM t2);
a
3
2
3
2
3
4
SELECT t1.a FROM t1 ORDER BY (SELECT SUM(t2.a), t2.a FROM t2);
ERROR 21000: Operand should contain 1 column(s)
SELECT t1.a FROM t1 ORDER BY (SELECT SUM(t2.a) FROM t2 ORDER BY t2.a);
a
3
2
3
2
3
4
SELECT t1.a FROM t1 ORDER BY (SELECT t2.a FROM t2 ORDER BY SUM(t2.b) LIMIT 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT t1.a FROM t1
WHERE t1.a = (SELECT t2.a FROM t2 ORDER BY SUM(t2.b) LIMIT 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT t1.a FROM t1 GROUP BY t1.a
HAVING t1.a = (SELECT t2.a FROM t2 ORDER BY SUM(t2.a) LIMIT 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT t1.a FROM t1 GROUP BY t1.a
HAVING t1.a IN (SELECT t2.a FROM t2 ORDER BY SUM(t1.b));
a
2
3
4
SELECT t1.a FROM t1 GROUP BY t1.a
HAVING t1.a IN (SELECT t2.a FROM t2 ORDER BY t2.a, SUM(t2.b));
ERROR HY000: Expression #2 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT t1.a FROM t1 GROUP BY t1.a
HAVING t1.a > ANY (SELECT t2.a FROM t2 ORDER BY t2.a, SUM(t2.b));
ERROR HY000: Expression #2 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT t1.a FROM t1
WHERE t1.a = (SELECT t2.a FROM t2 ORDER BY SUM(t1.b));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(SUM(t1.b) + 1) FROM t2 ORDER BY SUM(t2.a) LIMIT 1);
1
1
1
1
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(SUM(t1.b) + t2.b) FROM t2 ORDER BY SUM(t2.a) LIMIT 1);
1
1
1
1
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(t1.b + t2.b) FROM t2 ORDER BY SUM(t2.a) LIMIT 1);
ERROR 42000: Expression #1 of HAVING clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(SUM(t1.b) + 1) FROM t2 ORDER BY t2.a LIMIT 1);
1
1
1
1
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(SUM(t1.b) + t2.b) FROM t2 ORDER BY t2.a LIMIT 1);
1
1
1
1
SELECT 1 FROM t1 GROUP BY t1.a
HAVING (SELECT AVG(t1.b + t2.b) FROM t2 ORDER BY t2.a LIMIT 1);
ERROR 42000: Expression #1 of HAVING clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT t1.a FROM t1 
WHERE t1.a = (SELECT t2.a FROM t2 GROUP BY t2.a
ORDER BY SUM(t2.b), SUM(t1.b) LIMIT 1);
a
4
SELECT t1.a, SUM(t1.b) FROM t1 
WHERE t1.a = (SELECT SUM(t2.b) FROM t2 GROUP BY t2.a
ORDER BY SUM(t2.b), SUM(t1.b) LIMIT 1)
GROUP BY t1.a;
a	SUM(t1.b)
4	4
SELECT t1.a, SUM(t1.b) FROM t1 
WHERE t1.a = (SELECT SUM(t2.b) FROM t2
ORDER BY SUM(t2.b) + SUM(t1.b) LIMIT 1)
GROUP BY t1.a;
a	SUM(t1.b)
SELECT t1.a, SUM(t1.b) FROM t1 
WHERE t1.a = (SELECT SUM(t2.b) FROM t2
ORDER BY SUM(t2.b + t1.a) LIMIT 1)
GROUP BY t1.a;
a	SUM(t1.b)
SELECT t1.a FROM t1 GROUP BY t1.a
HAVING (1, 1) = (SELECT SUM(t1.a), t1.a FROM t2 LIMIT 1);
a
select avg (
(select
(select sum(outr.a + innr.a) from t1 as innr limit 1) as tt
from t1 as outr order by outr.a limit 1))
from t1 as most_outer;
avg (
(select
(select sum(outr.a + innr.a) from t1 as innr limit 1) as tt
from t1 as outr order by outr.a limit 1))
29.0000
select avg (
(select (
(select sum(outr.a + innr.a) from t1 as innr limit 1)) as tt
from t1 as outr order by count(outr.a) limit 1)) as tt
from t1 as most_outer;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
select (select sum(outr.a + t1.a) from t1 limit 1) as tt from t1 as outr order by outr.a;
tt
29
29
35
35
35
41
SET sql_mode=@save_sql_mode;
DROP TABLE t1, t2;
# 
# BUG#38072: Wrong result: HAVING not observed in a query with aggregate
# 
CREATE TABLE t1 (
pk int(11) NOT NULL AUTO_INCREMENT,
int_nokey int(11) NOT NULL,
int_key int(11) NOT NULL,
varchar_key varchar(1) NOT NULL,
varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk),
KEY int_key (int_key),
KEY varchar_key (varchar_key)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES 
(1,5,5, 'h','h'),
(2,1,1, '{','{'),
(3,1,1, 'z','z'),
(4,8,8, 'x','x'),
(5,7,7, 'o','o'),
(6,3,3, 'p','p'),
(7,9,9, 'c','c'),
(8,0,0, 'k','k'),
(9,6,6, 't','t'),
(10,0,0,'c','c');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
explain SELECT COUNT(varchar_key) AS x FROM t1 WHERE pk = 8 having 'foo'='bar';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible HAVING
Warnings:
Note	1003	/* select#1 */ select count(`test`.`t1`.`varchar_key`) AS `x` from `test`.`t1` where multiple equal(8, `test`.`t1`.`pk`) having false
SELECT COUNT(varchar_key) AS x FROM t1 WHERE pk = 8 having 'foo'='bar';
x
drop table t1;
End of 5.0 tests
CREATE TABLE t1 (a INT, b INT,
PRIMARY KEY (a),
KEY i2(a,b));
INSERT INTO t1 VALUES (1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
INSERT INTO t1 SELECT a + 8,b FROM t1;
INSERT INTO t1 SELECT a + 16,b FROM t1;
INSERT INTO t1 SELECT a + 32,b FROM t1;
INSERT INTO t1 SELECT a + 64,b FROM t1;
INSERT INTO t1 SELECT a + 128,b FROM t1 limit 16;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT a FROM t1 WHERE a < 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY,i2	PRIMARY	4	NULL	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` < 2)
EXPLAIN SELECT a FROM t1 WHERE a < 2 ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY,i2	PRIMARY	4	NULL	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` < 2) order by `test`.`t1`.`a`
EXPLAIN SELECT a FROM t1 WHERE a < 2 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY,i2	PRIMARY	4	NULL	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` < 2) group by `test`.`t1`.`a`
EXPLAIN SELECT a FROM t1 IGNORE INDEX (PRIMARY,i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX (`i2`) IGNORE INDEX (PRIMARY)
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR JOIN (PRIMARY,i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX FOR JOIN (`i2`) IGNORE INDEX FOR JOIN (PRIMARY)
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR GROUP BY (PRIMARY,i2) GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY,i2	PRIMARY	4	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX FOR GROUP BY (`i2`) IGNORE INDEX FOR GROUP BY (PRIMARY) group by `test`.`t1`.`a`
FLUSH STATUS;
SELECT a FROM t1 IGNORE INDEX FOR GROUP BY (PRIMARY,i2) GROUP BY a;
SHOW SESSION STATUS LIKE 'Sort_scan%';
Variable_name	Value
Sort_scan	0
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY,i2) ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	144	100.00	Using index; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX FOR ORDER BY (`i2`) IGNORE INDEX FOR ORDER BY (PRIMARY) order by `test`.`t1`.`a`
FLUSH STATUS;
SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY,i2) ORDER BY a;
SHOW SESSION STATUS LIKE 'Sort_scan%';
Variable_name	Value
Sort_scan	1
SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY,i2) ORDER BY a;
a
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
EXPLAIN SELECT a FROM t1 IGNORE INDEX FOR ORDER BY (PRIMARY)
IGNORE INDEX FOR GROUP BY (i2) GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY,i2	PRIMARY	4	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX FOR GROUP BY (`i2`) IGNORE INDEX FOR ORDER BY (PRIMARY) group by `test`.`t1`.`a`
EXPLAIN SELECT a FROM t1 IGNORE INDEX (PRIMARY) IGNORE INDEX FOR ORDER BY (i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX FOR ORDER BY (`i2`) IGNORE INDEX (PRIMARY)
EXPLAIN SELECT a FROM t1 FORCE INDEX (i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` FORCE INDEX (`i2`)
EXPLAIN SELECT a FROM t1 USE INDEX ();
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX ()
EXPLAIN SELECT a FROM t1 USE INDEX () USE INDEX (i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX (`i2`) USE INDEX ()
EXPLAIN SELECT a FROM t1 
FORCE INDEX (PRIMARY) 
IGNORE INDEX FOR GROUP BY (i2)
IGNORE INDEX FOR ORDER BY (i2)
USE INDEX (i2);
ERROR HY000: Incorrect usage of USE INDEX and FORCE INDEX
EXPLAIN SELECT a FROM t1 USE INDEX (i2) USE INDEX ();
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX () USE INDEX (`i2`)
EXPLAIN SELECT a FROM t1 FORCE INDEX ();
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ')' at line 1
EXPLAIN SELECT a FROM t1 IGNORE INDEX ();
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ')' at line 1
EXPLAIN SELECT a FROM t1 USE INDEX FOR JOIN (i2) 
USE INDEX FOR GROUP BY (i2) GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i2	i2	9	NULL	#	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX FOR GROUP BY (`i2`) USE INDEX FOR JOIN (`i2`) group by `test`.`t1`.`a`
EXPLAIN SELECT a FROM t1 FORCE INDEX FOR JOIN (i2) 
FORCE INDEX FOR GROUP BY (i2) GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i2	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` FORCE INDEX FOR GROUP BY (`i2`) FORCE INDEX FOR JOIN (`i2`) group by `test`.`t1`.`a`
EXPLAIN SELECT a FROM t1 USE INDEX () IGNORE INDEX (i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX (`i2`) USE INDEX ()
EXPLAIN SELECT a FROM t1 IGNORE INDEX (i2) USE INDEX ();
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX () IGNORE INDEX (`i2`)
EXPLAIN SELECT a FROM t1 
USE INDEX FOR GROUP BY (i2) 
USE INDEX FOR ORDER BY (i2)
USE INDEX FOR JOIN (i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX FOR JOIN (`i2`) USE INDEX FOR ORDER BY (`i2`) USE INDEX FOR GROUP BY (`i2`)
EXPLAIN SELECT a FROM t1 
USE INDEX FOR JOIN (i2) 
USE INDEX FOR JOIN (i2) 
USE INDEX FOR JOIN (i2,i2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	i2	9	NULL	144	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` USE INDEX FOR JOIN (`i2`) USE INDEX FOR JOIN (`i2`) USE INDEX FOR JOIN (`i2`) USE INDEX FOR JOIN (`i2`)
EXPLAIN SELECT 1 FROM t1 WHERE a IN
(SELECT a FROM t1 USE INDEX (i2) IGNORE INDEX (i2));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY,i2	PRIMARY	4	NULL	144	100.00	Using index
1	SIMPLE	<subquery2>	NULL	eq_ref	<auto_distinct_key>	<auto_distinct_key>	4	test.t1.a	1	100.00	NULL
2	MATERIALIZED	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` semi join (`test`.`t1` IGNORE INDEX (`i2`) USE INDEX (`i2`)) where (`<subquery2>`.`a` = `test`.`t1`.`a`)
CREATE TABLE t2 (a INT, b INT, KEY(a));
INSERT INTO t2 VALUES (1, 1), (2, 2), (3,3), (4,4);
EXPLAIN SELECT a, SUM(b) FROM t2 GROUP BY a LIMIT 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	a	a	5	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,sum(`test`.`t2`.`b`) AS `SUM(b)` from `test`.`t2` group by `test`.`t2`.`a` limit 2
EXPLAIN SELECT a, SUM(b) FROM t2 IGNORE INDEX (a) GROUP BY a LIMIT 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,sum(`test`.`t2`.`b`) AS `SUM(b)` from `test`.`t2` IGNORE INDEX (`a`) group by `test`.`t2`.`a` limit 2
ANALYZE TABLE t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
EXPLAIN SELECT 1 FROM t2 WHERE a IN
(SELECT a FROM t1 USE INDEX (i2) IGNORE INDEX (i2));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	a	a	5	NULL	4	100.00	Using where; Using index
1	SIMPLE	<subquery2>	NULL	eq_ref	<auto_distinct_key>	<auto_distinct_key>	4	test.t2.a	1	100.00	NULL
2	MATERIALIZED	t1	NULL	ALL	NULL	NULL	NULL	NULL	144	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t2` semi join (`test`.`t1` IGNORE INDEX (`i2`) USE INDEX (`i2`)) where (`<subquery2>`.`a` = `test`.`t2`.`a`)
SHOW VARIABLES LIKE 'old';
Variable_name	Value
old	OFF
SET @@old = off;
ERROR HY000: Variable 'old' is a read only variable
DROP TABLE t1, t2;
CREATE TABLE t1(
a INT, 
b INT NOT NULL, 
c INT NOT NULL, 
d INT, 
UNIQUE KEY (c,b)
);
INSERT INTO t1 VALUES (1,1,1,50), (1,2,3,40), (2,1,3,4);
CREATE TABLE t2(
a INT,
b INT,
UNIQUE KEY(a,b)
);
INSERT INTO t2 VALUES (NULL, NULL), (NULL, NULL), (NULL, 1), (1, NULL), (1, 1), (1,2);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT c,b,d FROM t1 GROUP BY c,b,d;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`c` AS `c`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`d` AS `d` from `test`.`t1` group by `test`.`t1`.`c`,`test`.`t1`.`b`,`test`.`t1`.`d`
SELECT c,b,d FROM t1 GROUP BY c,b,d;
c	b	d
1	1	50
3	1	4
3	2	40
EXPLAIN SELECT c,b,d FROM t1 GROUP BY c,b,d ORDER BY NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`c` AS `c`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`d` AS `d` from `test`.`t1` group by `test`.`t1`.`c`,`test`.`t1`.`b`,`test`.`t1`.`d` order by NULL
SELECT c,b,d FROM t1 GROUP BY c,b,d ORDER BY NULL;
c	b	d
1	1	50
3	1	4
3	2	40
EXPLAIN SELECT c,b,d FROM t1 ORDER BY c,b,d;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`c` AS `c`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`d` AS `d` from `test`.`t1` order by `test`.`t1`.`c`,`test`.`t1`.`b`,`test`.`t1`.`d`
SELECT c,b,d FROM t1 ORDER BY c,b,d;
c	b	d
1	1	50
3	1	4
3	2	40
EXPLAIN SELECT c,b,d FROM t1 GROUP BY c,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	c	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`c` AS `c`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`d` AS `d` from `test`.`t1` group by `test`.`t1`.`c`,`test`.`t1`.`b`
SELECT c,b,d FROM t1 GROUP BY c,b;
c	b	d
1	1	50
3	1	4
3	2	40
EXPLAIN SELECT c,b   FROM t1 GROUP BY c,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	c	c	8	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`c` AS `c`,`test`.`t1`.`b` AS `b` from `test`.`t1` group by `test`.`t1`.`c`,`test`.`t1`.`b`
SELECT c,b   FROM t1 GROUP BY c,b;
c	b
1	1
3	1
3	2
EXPLAIN SELECT a,b from t2 ORDER BY a,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	NULL	a	10	NULL	6	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` order by `test`.`t2`.`a`,`test`.`t2`.`b`
SELECT a,b from t2 ORDER BY a,b;
a	b
NULL	NULL
NULL	NULL
NULL	1
1	NULL
1	1
1	2
EXPLAIN SELECT a,b from t2 GROUP BY a,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	a	a	10	NULL	6	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` group by `test`.`t2`.`a`,`test`.`t2`.`b`
SELECT a,b from t2 GROUP BY a,b;
a	b
NULL	NULL
NULL	1
1	NULL
1	1
1	2
EXPLAIN SELECT a from t2 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	a	a	5	NULL	3	100.00	Using index for group-by
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2` group by `test`.`t2`.`a`
SELECT a from t2 GROUP BY a;
a
NULL
1
EXPLAIN SELECT b from t2 GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	a	a	10	NULL	6	100.00	Using index; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`b` AS `b` from `test`.`t2` group by `test`.`t2`.`b`
SELECT b from t2 GROUP BY b;
b
NULL
1
2
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1 ( a INT, b INT );
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1;
c	(SELECT a FROM t1 WHERE b = c)
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1 
HAVING b = 10;
c	(SELECT a FROM t1 WHERE b = c)
SELECT MAX(b) c, (SELECT a FROM t1 WHERE b = c)
FROM t1 
HAVING b = 10;
ERROR 42S22: Reference 'c' not supported (reference to group function)
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode='ONLY_FULL_GROUP_BY';
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1;
c	(SELECT a FROM t1 WHERE b = c)
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1 
HAVING b = 10;
c	(SELECT a FROM t1 WHERE b = c)
SELECT MAX(b) c, (SELECT a FROM t1 WHERE b = c)
FROM t1 
HAVING b = 10;
ERROR 42S22: Reference 'c' not supported (reference to group function)
INSERT INTO t1 VALUES (1, 1);
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1;
c	(SELECT a FROM t1 WHERE b = c)
1	1
INSERT INTO t1 VALUES (2, 1);
SELECT b c, (SELECT a FROM t1 WHERE b = c)
FROM t1;
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t1;
SET @@sql_mode = @old_sql_mode;
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode='ONLY_FULL_GROUP_BY';
CREATE TABLE t1(i INT);
INSERT INTO t1 VALUES (1), (10);
SELECT COUNT(i) FROM t1;
COUNT(i)
2
SELECT COUNT(i) FROM t1 WHERE i > 1;
COUNT(i)
1
DROP TABLE t1;
SET @@sql_mode = @old_sql_mode;
#
# Bug #45640: optimizer bug produces wrong results
#
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (4, 40), (1, 10), (2, 20), (2, 20), (3, 30);
# should return 4 ordered records:
SELECT (SELECT t1.a) aa, COUNT(DISTINCT b) FROM t1 GROUP BY aa;
aa	COUNT(DISTINCT b)
1	1
2	1
3	1
4	1
SELECT (SELECT (SELECT t1.a)) aa, COUNT(DISTINCT b) FROM t1 GROUP BY aa;
aa	COUNT(DISTINCT b)
1	1
2	1
3	1
4	1
SELECT (SELECT t1.a) aa, COUNT(DISTINCT b) FROM t1 GROUP BY aa+0;
aa	COUNT(DISTINCT b)
1	1
2	1
3	1
4	1
# should return the same result in a reverse order:
SELECT (SELECT t1.a) aa, COUNT(DISTINCT b) FROM t1 GROUP BY -aa;
aa	COUNT(DISTINCT b)
4	1
3	1
2	1
1	1
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
# execution plan should not use temporary table:
EXPLAIN
SELECT (SELECT t1.a) aa, COUNT(DISTINCT b) FROM t1 GROUP BY aa+0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	Using temporary; Using filesort
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1249	Select 2 was reduced during optimization
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `aa`,count(distinct `test`.`t1`.`b`) AS `COUNT(DISTINCT b)` from `test`.`t1` group by (`a` + 0)
EXPLAIN
SELECT (SELECT t1.a) aa, COUNT(DISTINCT b) FROM t1 GROUP BY -aa;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	Using temporary; Using filesort
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1249	Select 2 was reduced during optimization
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `aa`,count(distinct `test`.`t1`.`b`) AS `COUNT(DISTINCT b)` from `test`.`t1` group by -(`a`)
# should return only one record
SELECT (SELECT tt.a FROM t1 tt LIMIT 1) aa, COUNT(DISTINCT b) FROM t1
GROUP BY aa;
aa	COUNT(DISTINCT b)
4	4
CREATE TABLE t2 SELECT DISTINCT a FROM t1;
# originally reported queries (1st two columns of next two query
# results should be same):
SELECT (SELECT t2.a FROM t2 WHERE t2.a = t1.a) aa, b, COUNT(DISTINCT b)
FROM t1 GROUP BY aa, b;
aa	b	COUNT(DISTINCT b)
1	10	1
2	20	1
3	30	1
4	40	1
SELECT (SELECT t2.a FROM t2 WHERE t2.a = t1.a) aa, b, COUNT(         b)
FROM t1 GROUP BY aa, b;
aa	b	COUNT(         b)
1	10	1
2	20	2
3	30	1
4	40	1
# ORDER BY for sure:
SELECT (SELECT t2.a FROM t2 WHERE t2.a = t1.a) aa, b, COUNT(DISTINCT b)
FROM t1 GROUP BY aa, b ORDER BY -aa, -b;
aa	b	COUNT(DISTINCT b)
4	40	1
3	30	1
2	20	1
1	10	1
SELECT (SELECT t2.a FROM t2 WHERE t2.a = t1.a) aa, b, COUNT(         b)
FROM t1 GROUP BY aa, b ORDER BY -aa, -b;
aa	b	COUNT(         b)
4	40	1
3	30	1
2	20	2
1	10	1
DROP TABLE t1, t2;
#
# Bug#52051: Aggregate functions incorrectly returns NULL from outer
# join query
#
CREATE TABLE t1 (a INT PRIMARY KEY);
CREATE TABLE t2 (a INT PRIMARY KEY);
INSERT INTO t2 VALUES (1), (2);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT MIN(t2.a) FROM t2 LEFT JOIN t1 ON t2.a = t1.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t2`.`a`) AS `MIN(t2.a)` from `test`.`t2` left join `test`.`t1` on(multiple equal(`test`.`t2`.`a`, `test`.`t1`.`a`))
SELECT MIN(t2.a) FROM t2 LEFT JOIN t1 ON t2.a = t1.a;
MIN(t2.a)
1
EXPLAIN SELECT MAX(t2.a) FROM t2 LEFT JOIN t1 ON t2.a = t1.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t2`.`a`) AS `MAX(t2.a)` from `test`.`t2` left join `test`.`t1` on(multiple equal(`test`.`t2`.`a`, `test`.`t1`.`a`))
SELECT MAX(t2.a) FROM t2 LEFT JOIN t1 ON t2.a = t1.a;
MAX(t2.a)
2
DROP TABLE t1, t2;
#
# Bug#55188: GROUP BY, GROUP_CONCAT and TEXT - inconsistent results
#
CREATE TABLE t1 (a text, b varchar(10));
INSERT INTO t1 VALUES (repeat('1', 1300),'one'), (repeat('1', 1300),'two');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN 
SELECT SUBSTRING(a,1,10), LENGTH(a), GROUP_CONCAT(b) FROM t1 GROUP BY a;
id	1
select_type	SIMPLE
table	t1
partitions	NULL
type	ALL
possible_keys	NULL
key	NULL
key_len	NULL
ref	NULL
rows	2
filtered	100.00
Extra	Using filesort
Warnings:
Level	Note
Code	1003
Message	/* select#1 */ select substr(`test`.`t1`.`a`,1,10) AS `SUBSTRING(a,1,10)`,length(`test`.`t1`.`a`) AS `LENGTH(a)`,group_concat(`test`.`t1`.`b` separator ',') AS `GROUP_CONCAT(b)` from `test`.`t1` group by `test`.`t1`.`a`
SELECT SUBSTRING(a,1,10), LENGTH(a), GROUP_CONCAT(b) FROM t1 GROUP BY a;
SUBSTRING(a,1,10)	LENGTH(a)	GROUP_CONCAT(b)
1111111111	1300	one,two
EXPLAIN 
SELECT SUBSTRING(a,1,10), LENGTH(a) FROM t1 GROUP BY a;
id	1
select_type	SIMPLE
table	t1
partitions	NULL
type	ALL
possible_keys	NULL
key	NULL
key_len	NULL
ref	NULL
rows	2
filtered	100.00
Extra	Using temporary
Warnings:
Level	Note
Code	1003
Message	/* select#1 */ select substr(`test`.`t1`.`a`,1,10) AS `SUBSTRING(a,1,10)`,length(`test`.`t1`.`a`) AS `LENGTH(a)` from `test`.`t1` group by `test`.`t1`.`a`
SELECT SUBSTRING(a,1,10), LENGTH(a) FROM t1 GROUP BY a;
SUBSTRING(a,1,10)	LENGTH(a)
1111111111	1300
DROP TABLE t1;
#
# Bug#57688 Assertion `!table || (!table->write_set || bitmap_is_set(table->write_set, field
#
CREATE TABLE t1(f1 INT NOT NULL);
INSERT INTO t1 VALUES (16777214),(0);
SELECT COUNT(*) FROM t1 LEFT JOIN t1 t2
ON 1 WHERE t2.f1 > 1 GROUP BY t2.f1;
COUNT(*)
2
DROP TABLE t1;
#
# Bug#12798270: ASSERTION `!TAB->SORTED' FAILED IN JOIN_READ_KEY2
#
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (pk int PRIMARY KEY);
INSERT INTO t2 VALUES (10);
CREATE VIEW v1 AS SELECT t2.pk FROM t2;
SELECT v1.pk
FROM t1 LEFT JOIN v1 ON t1.i = v1.pk 
GROUP BY v1.pk;
pk
NULL
DROP VIEW v1;
DROP TABLE t1,t2;
# End of Bug#12798270
#
# Bug#59839: Aggregation followed by subquery yields wrong result
#
CREATE TABLE t1 (
a INT,
b INT,
c INT,
KEY (a, b)
);
INSERT INTO t1 VALUES
( 1, 1,  1 ),
( 1, 2,  2 ),
( 1, 3,  3 ),
( 1, 4,  6 ),
( 1, 5,  5 ),
( 1, 9, 13 ),
( 2, 1,  6 ),
( 2, 2,  7 ),
( 2, 3,  8 );
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN
SELECT a, AVG(t1.b),
(SELECT t11.c FROM t1 t11 WHERE t11.a = t1.a AND t11.b = AVG(t1.b)) AS t11c,
(SELECT t12.c FROM t1 t12 WHERE t12.a = t1.a AND t12.b = AVG(t1.b)) AS t12c
FROM t1 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	a	a	10	NULL	9	100.00	Using index
3	DEPENDENT SUBQUERY	t12	NULL	ref	a	a	10	func,func	1	100.00	Using where
2	DEPENDENT SUBQUERY	t11	NULL	ref	a	a	10	func,func	1	100.00	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.b' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,avg(`test`.`t1`.`b`) AS `AVG(t1.b)`,(/* select#2 */ select `test`.`t11`.`c` from `test`.`t1` `t11` where ((`test`.`t11`.`a` = `test`.`t1`.`a`) and (`test`.`t11`.`b` = avg(`test`.`t1`.`b`)))) AS `t11c`,(/* select#3 */ select `test`.`t12`.`c` from `test`.`t1` `t12` where ((`test`.`t12`.`a` = `test`.`t1`.`a`) and (`test`.`t12`.`b` = avg(`test`.`t1`.`b`)))) AS `t12c` from `test`.`t1` group by `test`.`t1`.`a`
SELECT a, AVG(t1.b),
(SELECT t11.c FROM t1 t11 WHERE t11.a = t1.a AND t11.b = AVG(t1.b)) AS t11c,
(SELECT t12.c FROM t1 t12 WHERE t12.a = t1.a AND t12.b = AVG(t1.b)) AS t12c
FROM t1 GROUP BY a;
a	AVG(t1.b)	t11c	t12c
1	4.0000	6	6
2	2.0000	7	7
DROP TABLE t1;
#
# Bug#11765254 (58200): Assertion failed: param.sort_length when grouping
# by functions
#
SET BIG_TABLES=1;
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0),(0);
SELECT 1 FROM t1 GROUP BY IF(`a`,'','');
ERROR 42000: The used storage engine can't index column 'if(t1.a,'','')'
SELECT 1 FROM t1 GROUP BY TRIM(LEADING RAND() FROM '');
1
1
SELECT 1 FROM t1 GROUP BY SUBSTRING('',SLEEP(0),'');
1
1
Warnings:
Warning	1292	Truncated incorrect INTEGER value: ''
Warning	1292	Truncated incorrect INTEGER value: ''
Warning	1292	Truncated incorrect INTEGER value: ''
SELECT 1 FROM t1 GROUP BY SUBSTRING(SYSDATE() FROM 'K' FOR 'jxW<');
1
1
Warnings:
Warning	1292	Truncated incorrect INTEGER value: 'K'
Warning	1292	Truncated incorrect INTEGER value: 'jxW<'
Warning	1292	Truncated incorrect INTEGER value: 'K'
Warning	1292	Truncated incorrect INTEGER value: 'jxW<'
Warning	1292	Truncated incorrect INTEGER value: 'K'
Warning	1292	Truncated incorrect INTEGER value: 'jxW<'
DROP TABLE t1;
SET BIG_TABLES=0;
# End of 5.1 tests
#
# Bug#49771: Incorrect MIN (date) when minimum value is 0000-00-00
#
SET @save_sql_mode=@@sql_mode;
SET @@sql_mode='ONLY_FULL_GROUP_BY';
CREATE TABLE t1 (f1 int, f2 DATE);
INSERT INTO t1 VALUES (1,'2004-04-19'), (1,'0000-00-00'), (1,'2004-04-18'),
(2,'2004-05-19'), (2,'0001-01-01'), (3,'2004-04-10');
SELECT MIN(f2),MAX(f2) FROM t1;
MIN(f2)	MAX(f2)
0000-00-00	2004-05-19
SELECT f1,MIN(f2),MAX(f2) FROM t1 GROUP BY 1;
f1	MIN(f2)	MAX(f2)
1	0000-00-00	2004-04-19
2	0001-01-01	2004-05-19
3	2004-04-10	2004-04-10
DROP TABLE t1;
CREATE TABLE t1 ( f1 int, f2 time);
INSERT INTO t1 VALUES (1,'01:27:35'), (1,'06:11:01'), (2,'19:53:05'),
(2,'21:44:25'), (3,'10:55:12'), (3,'05:45:11'), (4,'00:25:00');
SELECT MIN(f2),MAX(f2) FROM t1;
MIN(f2)	MAX(f2)
00:25:00	21:44:25
SELECT f1,MIN(f2),MAX(f2) FROM t1 GROUP BY 1;
f1	MIN(f2)	MAX(f2)
1	01:27:35	06:11:01
2	19:53:05	21:44:25
3	05:45:11	10:55:12
4	00:25:00	00:25:00
DROP TABLE t1;
SET sql_mode=@save_sql_mode;
#End of test#49771
#
# Bug #58782
# Missing rows with SELECT .. WHERE .. IN subquery 
# with full GROUP BY and no aggr
#
CREATE TABLE t1 (
pk INT NOT NULL,
col_int_nokey INT,
PRIMARY KEY (pk)
);
INSERT INTO t1 VALUES (10,7);
INSERT INTO t1 VALUES (11,1);
INSERT INTO t1 VALUES (12,5);
INSERT INTO t1 VALUES (13,3);
SELECT pk AS field1, col_int_nokey AS field2 
FROM t1 
WHERE col_int_nokey > 0
GROUP BY field1, field2;
field1	field2
10	7
11	1
12	5
13	3
CREATE TABLE where_subselect
SELECT pk AS field1, col_int_nokey AS field2
FROM t1
WHERE col_int_nokey > 0
GROUP BY field1, field2
;
SELECT * 
FROM where_subselect
WHERE (field1, field2) IN (
SELECT pk AS field1, col_int_nokey AS field2
FROM t1
WHERE col_int_nokey > 0
GROUP BY field1, field2
);
field1	field2
10	7
11	1
12	5
13	3
DROP TABLE t1;
DROP TABLE where_subselect;
# End of Bug #58782
#
# Bug #11766429 
# RE-EXECUTE OF PREPARED STATEMENT CRASHES IN ITEM_REF::FIX_FIELDS WITH
#
CREATE TABLE t1(a INT, KEY(a));
INSERT INTO t1 VALUES (0);
CREATE TABLE t2(b INT, KEY(b));
INSERT INTO t2 VALUES (0),(0);
PREPARE stmt FROM '
SELECT 1 FROM t2
LEFT JOIN t1 ON NULL
GROUP BY t2.b, t1.a
HAVING a <> 2';
EXECUTE stmt;
1
EXECUTE stmt;
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
# End of Bug #11766429
#
# Bug#12699645 SELECT SUM() + STRAIGHT_JOIN QUERY MISSES ROWS
#
CREATE TABLE t1 (
pk INT, col_int_key INT,
col_varchar_key VARCHAR(1), col_varchar_nokey VARCHAR(1)
);
INSERT INTO t1 VALUES
(10,7,'v','v'),(11,0,'s','s'),(12,9,'l','l'),(13,3,'y','y'),(14,4,'c','c'),
(15,2,'i','i'),(16,5,'h','h'),(17,3,'q','q'),(18,1,'a','a'),(19,3,'v','v'),
(20,6,'u','u'),(21,7,'s','s'),(22,5,'y','y'),(23,1,'z','z'),(24,204,'h','h'),
(25,224,'p','p'),(26,9,'e','e'),(27,5,'i','i'),(28,0,'y','y'),(29,3,'w','w');
CREATE TABLE t2 (
pk INT, col_int_key INT,
col_varchar_key VARCHAR(1), col_varchar_nokey VARCHAR(1),
PRIMARY KEY (pk)
);
INSERT INTO t2 VALUES
(1,4,'b','b'),(2,8,'y','y'),(3,0,'p','p'),(4,0,'f','f'),(5,0,'p','p'),
(6,7,'d','d'),(7,7,'f','f'),(8,5,'j','j'),(9,3,'e','e'),(10,188,'u','u'),
(11,4,'v','v'),(12,9,'u','u'),(13,6,'i','i'),(14,1,'x','x'),(15,5,'l','l'),
(16,6,'q','q'),(17,2,'n','n'),(18,4,'r','r'),(19,231,'c','c'),(20,4,'h','h'),
(21,3,'k','k'),(22,3,'t','t'),(23,7,'t','t'),(24,6,'k','k'),(25,7,'g','g'),
(26,9,'z','z'),(27,4,'n','n'),(28,4,'j','j'),(29,2,'l','l'),(30,1,'d','d'),
(31,2,'t','t'),(32,194,'y','y'),(33,2,'i','i'),(34,3,'j','j'),(35,8,'r','r'),
(36,4,'b','b'),(37,9,'o','o'),(38,4,'k','k'),(39,5,'a','a'),(40,5,'f','f'),
(41,9,'t','t'),(42,3,'c','c'),(43,8,'c','c'),(44,0,'r','r'),(45,98,'k','k'),
(46,3,'l','l'),(47,1,'o','o'),(48,0,'t','t'),(49,189,'v','v'),(50,8,'x','x'),
(51,3,'j','j'),(52,3,'x','x'),(53,9,'k','k'),(54,6,'o','o'),(55,8,'z','z'),
(56,3,'n','n'),(57,9,'c','c'),(58,5,'d','d'),(59,9,'s','s'),(60,2,'j','j'),
(61,2,'w','w'),(62,5,'f','f'),(63,8,'p','p'),(64,6,'o','o'),(65,9,'f','f'),
(66,0,'x','x'),(67,3,'q','q'),(68,6,'g','g'),(69,5,'x','x'),(70,8,'p','p'),
(71,2,'q','q'),(72,120,'q','q'),(73,25,'v','v'),(74,1,'g','g'),(75,3,'l','l'),
(76,1,'w','w'),(77,3,'h','h'),(78,153,'c','c'),(79,5,'o','o'),(80,9,'o','o'),
(81,1,'v','v'),(82,8,'y','y'),(83,7,'d','d'),(84,6,'p','p'),(85,2,'z','z'),
(86,4,'t','t'),(87,7,'b','b'),(88,3,'y','y'),(89,8,'k','k'),(90,4,'c','c'),
(91,6,'z','z'),(92,1,'t','t'),(93,7,'o','o'),(94,1,'u','u'),(95,0,'t','t'),
(96,2,'k','k'),(97,7,'u','u'),(98,2,'b','b'),(99,1,'m','m'),(100,5,'o','o');
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT SUM(alias2.col_varchar_nokey) , alias2.pk AS field2 FROM t1 AS alias1
STRAIGHT_JOIN t2 AS alias2 ON alias2.pk = alias1.col_int_key WHERE alias1.pk
GROUP BY field2 ORDER BY alias1.col_int_key,alias2.pk ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	90.00	Using where; Using temporary; Using filesort
1	SIMPLE	alias2	NULL	eq_ref	PRIMARY	PRIMARY	4	test.alias1.col_int_key	#	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select sum(`test`.`alias2`.`col_varchar_nokey`) AS `SUM(alias2.col_varchar_nokey)`,`test`.`alias2`.`pk` AS `field2` from `test`.`t1` `alias1` straight_join `test`.`t2` `alias2` where ((`test`.`alias2`.`pk` = `test`.`alias1`.`col_int_key`) and (0 <> `test`.`alias1`.`pk`)) group by `field2` order by `test`.`alias1`.`col_int_key`
SELECT SUM(alias2.col_varchar_nokey) , alias2.pk AS field2 FROM t1 AS alias1
STRAIGHT_JOIN t2 AS alias2 ON alias2.pk = alias1.col_int_key WHERE alias1.pk
GROUP BY field2 ORDER BY alias1.col_int_key,alias2.pk ;
SUM(alias2.col_varchar_nokey)	field2
0	1
0	2
0	3
0	4
0	5
0	6
0	7
0	9
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'f'
Warning	1292	Truncated incorrect DOUBLE value: 'e'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'f'
Warning	1292	Truncated incorrect DOUBLE value: 'y'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'b'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'd'
Warning	1292	Truncated incorrect DOUBLE value: 'f'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'b'
Warning	1292	Truncated incorrect DOUBLE value: 'e'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
Warning	1292	Truncated incorrect DOUBLE value: 'p'
DROP TABLE t1,t2;
#
# Bug#12798270: ASSERTION `!TAB->SORTED' FAILED IN JOIN_READ_KEY2
#
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (pk int PRIMARY KEY);
INSERT INTO t2 VALUES (10);
CREATE VIEW v1 AS SELECT t2.pk FROM t2;
SELECT v1.pk
FROM t1 LEFT JOIN v1 ON t1.i = v1.pk 
GROUP BY v1.pk;
pk
NULL
DROP VIEW v1;
DROP TABLE t1,t2;
# End of Bug#12798270
#
# Bug#12837714: ADDITIONAL NULL IN 5.6 ON GROUPED SELECT
#
CREATE TABLE t1 (vc varchar(1), INDEX vc_idx (vc)) ;
INSERT INTO t1 VALUES (NULL), ('o'), (NULL), ('p'), ('c');
FLUSH TABLE t1;
SELECT vc FROM t1 GROUP BY vc;
vc
NULL
c
o
p
DROP TABLE t1;
# End of Bug#12837714
#
# Bug#12578908: SELECT SQL_BUFFER_RESULT OUTPUTS TOO MANY 
#               ROWS WHEN GROUP IS OPTIMIZED AWAY
#
CREATE TABLE t1 (col1 int, col2 int) ;
INSERT INTO t1 VALUES (10,1),(11,7);
CREATE TABLE t2 (col1 int, col2 int) ;
INSERT INTO t2 VALUES (10,8);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK

EXPLAIN SELECT SQL_BUFFER_RESULT t2.col2 FROM t2 JOIN t1 ON t1.col1 GROUP BY t2.col2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select sql_buffer_result `test`.`t2`.`col2` AS `col2` from `test`.`t2` join `test`.`t1` where (0 <> `test`.`t1`.`col1`) group by `test`.`t2`.`col2`
SELECT SQL_BUFFER_RESULT t2.col2 FROM t2 JOIN t1 ON t1.col1 GROUP BY t2.col2;
col2
8

EXPLAIN SELECT t2.col2 FROM t2 JOIN t1 ON t1.col1 GROUP BY t2.col2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`col2` AS `col2` from `test`.`t2` join `test`.`t1` where (0 <> `test`.`t1`.`col1`) group by `test`.`t2`.`col2`
SELECT t2.col2 FROM t2 JOIN t1 ON t1.col1 GROUP BY t2.col2;
col2
8

DROP TABLE t1,t2;
#
# Bug#11761078: 53534: INCORRECT 'SELECT SQL_BIG_RESULT...' 
#               WITH GROUP BY ON DUPLICATED FIELDS
#
CREATE TABLE t1(
col1 int, 
INDEX idx (col1)
);
INSERT INTO t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
(11),(12),(13),(14),(15),(16),(17),(18),(19),(20);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT SQL_BIG_RESULT col1 AS field1, col1 AS field2
FROM t1 GROUP BY field1, field2;;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	idx	idx	5	NULL	20	100.00	Using index; Using filesort
Warnings:
Note	1003	/* select#1 */ select sql_big_result `test`.`t1`.`col1` AS `field1`,`test`.`t1`.`col1` AS `field2` from `test`.`t1` group by `field1`
FLUSH STATUS;
SELECT SQL_BIG_RESULT col1 AS field1, col1 AS field2
FROM t1 GROUP BY field1, field2;;
field1	field2
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
10	10
11	11
12	12
13	13
14	14
15	15
16	16
17	17
18	18
19	19
20	20
SHOW SESSION STATUS LIKE 'Sort_scan%';
Variable_name	Value
Sort_scan	1
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT SQL_BIG_RESULT col1 AS field1, col1 AS field2
FROM v1 
GROUP BY field1, field2;
field1	field2
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
10	10
11	11
12	12
13	13
14	14
15	15
16	16
17	17
18	18
19	19
20	20
SELECT SQL_BIG_RESULT tbl1.col1 AS field1, tbl2.col1 AS field2
FROM t1 as tbl1, t1 as tbl2 
GROUP BY field1, field2
ORDER BY field1, field2
LIMIT 3;
field1	field2
1	1
1	2
1	3
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#13422961: WRONG RESULTS FROM SELECT WITH AGGREGATES AND
#               IMPLICIT GROUPING + MYISAM OR MEM
#
CREATE TABLE it (
pk INT NOT NULL,
col_int_nokey INT NOT NULL,
PRIMARY KEY (pk)
) ENGINE=INNODB;
CREATE TABLE ot (
pk int(11) NOT NULL,
col_int_nokey int(11) NOT NULL,
PRIMARY KEY (pk)
) ENGINE=INNODB;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO ot VALUES (10,8);

SELECT col_int_nokey, MAX( pk ) 
FROM ot 
WHERE (8, 1) IN ( SELECT pk, COUNT( col_int_nokey ) FROM it );
col_int_nokey	MAX( pk )
NULL	NULL

DROP TABLE it,ot;
#
# Bug#13430588: WRONG RESULT FROM IMPLICITLY GROUPED QUERY WITH
#               CONST TABLE AND NO MATCHING ROWS
#
CREATE TABLE t1 (i INT) ENGINE=INNODB;
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (j INT) ENGINE=INNODB;
INSERT INTO t2 VALUES (1),(2);

SELECT i, j, COUNT(i) FROM t1 JOIN t2 WHERE j=3;
i	j	COUNT(i)
NULL	NULL	0

DROP TABLE t1,t2;
#
# BUG#13541761: WRONG RESULTS ON CORRELATED SUBQUERY + 
#               AGGREGATE FUNCTION + MYISAM OR MEMORY
#
CREATE TABLE t1 (
a varchar(1)
) ENGINE=INNODB;
INSERT INTO t1 VALUES ('a'), ('b');
CREATE TABLE t2 (
a varchar(1),
b int(11)
) ENGINE=INNODB;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES ('a',1);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK

EXPLAIN SELECT (SELECT MAX(b) FROM t2 WHERE t2.a != t1.a) as MAX 
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select max(`test`.`t2`.`b`) from `test`.`t2` where (`test`.`t2`.`a` <> `test`.`t1`.`a`)) AS `MAX` from `test`.`t1`
SELECT (SELECT MAX(b) FROM t2 WHERE t2.a != t1.a) as MAX 
FROM t1;
MAX
NULL
1
DROP TABLE t1,t2;
# Bug 11923239 - ERROR WITH CORRELATED SUBQUERY IN VIEW WITH
# ONLY_FULL_GROUP_BY SQL MODE
SET @old_sql_mode = @@sql_mode;
SET sql_mode='';
CREATE TABLE t1 (
pk INT,
col_int_key INT,
col_int_nokey INT,
col_varchar_key VARCHAR(10),
col_varchar_nokey VARCHAR(10),
KEY col_int_key (col_int_key),
KEY col_varchar_key (col_varchar_key)
);
INSERT INTO t1 VALUES (), ();
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
# In GROUP BY, aliases are printed as aliases.
EXPLAIN SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1
GROUP BY field1, field2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
2	DEPENDENT SUBQUERY	alias2	NULL	index	NULL	col_int_key	5	NULL	2	100.00	Using where; Using index
Warnings:
Note	1276	Field or reference 'test.alias1.col_varchar_key' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.alias1.col_varchar_nokey' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`alias1`.`col_int_nokey` AS `field1`,(/* select#2 */ select `test`.`alias2`.`col_int_key` from `test`.`t1` `alias2` where (`test`.`alias1`.`col_varchar_key` <= `test`.`alias1`.`col_varchar_nokey`)) AS `field2` from `test`.`t1` `alias1` group by `field1`,`field2`
# In GROUP BY, expressions are printed as expressions.
EXPLAIN SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1
GROUP BY field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
3	DEPENDENT SUBQUERY	alias2	NULL	index	NULL	col_int_key	5	NULL	2	100.00	Using where; Using index
2	DEPENDENT SUBQUERY	alias2	NULL	index	NULL	col_int_key	5	NULL	2	100.00	Using where; Using index
Warnings:
Note	1276	Field or reference 'test.alias1.col_varchar_key' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.alias1.col_varchar_nokey' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.alias1.col_varchar_key' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test.alias1.col_varchar_nokey' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`alias1`.`col_int_nokey` AS `field1`,(/* select#2 */ select `test`.`alias2`.`col_int_key` from `test`.`t1` `alias2` where (`test`.`alias1`.`col_varchar_key` <= `test`.`alias1`.`col_varchar_nokey`)) AS `field2` from `test`.`t1` `alias1` group by `field1`,(/* select#3 */ select `test`.`alias2`.`col_int_key` from `test`.`t1` `alias2` where (`test`.`alias1`.`col_varchar_key` <= `test`.`alias1`.`col_varchar_nokey`))
# Aliased expression in GROUP BY in a view.
CREATE VIEW v1 AS SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1
GROUP BY field1, field2;
# In GROUP BY, aliases are printed as aliases.
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `alias1`.`col_int_nokey` AS `field1`,(select `alias2`.`col_int_key` from `t1` `alias2` where (`alias1`.`col_varchar_key` <= `alias1`.`col_varchar_nokey`)) AS `field2` from `t1` `alias1` group by `field1`,`field2`	utf8mb4	utf8mb4_0900_ai_ci
SET @@sql_mode='ONLY_FULL_GROUP_BY';
SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1
GROUP BY field1, field2;
field1	field2
NULL	NULL
# The SELECT above has been accepted, and v1 was created
# using the same SELECT as above, so SELECTing from v1
# should be accepted.
SELECT * FROM v1;
field1	field2
NULL	NULL
# Here is why in GROUP BY we print aliases of subqueries as
# aliases: below, "GROUP BY (subquery)" confuses
# ONLY_FULL_GROUP_BY, it causes an error though the subquery of
# GROUP BY and of SELECT list are the same. Fixing this would
# require implementing Item_subselect::eq(). It's not worth
# the effort because:
# a) GROUP BY (subquery) is non-SQL-standard so is likely of
# very little interest to users of ONLY_FULL_GROUP_BY
# b) as the user uses ONLY_FULL_GROUP_BY, he wants to have the
# same subquery in GROUP BY and SELECT list, so can give the
# subquery an alias in the SELECT list and use this alias in
# GROUP BY, thus avoiding the problem.
SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1
GROUP BY field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
);
ERROR 42000: Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.alias1.col_varchar_key' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
DROP VIEW v1;
SET @@sql_mode = @old_sql_mode;
# Verify that if an alias is used in GROUP BY/ORDER BY it
# is printed as an alias, not as the expression.
CREATE TABLE t2(a INT);
INSERT INTO t2 VALUES(3),(4);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT
pk AS foo, col_int_key AS bar, (SELECT a FROM t2 WHERE a=t1.pk) AS baz
FROM t1
GROUP BY foo, col_int_key, baz ORDER BY pk, bar, (SELECT a FROM t2 WHERE a=t1.pk);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary; Using filesort
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
Warnings:
Note	1276	Field or reference 'test.t1.pk' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.pk' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `foo`,`test`.`t1`.`col_int_key` AS `bar`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`pk`)) AS `baz` from `test`.`t1` group by `foo`,`test`.`t1`.`col_int_key`,`baz` order by `test`.`t1`.`pk`,`bar`,(/* select#3 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`pk`))
EXPLAIN SELECT
pk AS foo, col_int_key AS foo, (SELECT a FROM t2 WHERE a=t1.pk) AS foo
FROM t1
GROUP BY pk, col_int_key, (SELECT a FROM t2 WHERE a=t1.pk)
ORDER BY pk, col_int_key, (SELECT a FROM t2 WHERE a=t1.pk);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary; Using filesort
4	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
Warnings:
Note	1276	Field or reference 'test.t1.pk' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.pk' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.pk' of SELECT #4 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `foo`,`test`.`t1`.`col_int_key` AS `foo`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`pk`)) AS `foo` from `test`.`t1` group by `test`.`t1`.`pk`,`test`.`t1`.`col_int_key`,(/* select#3 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`pk`)) order by `test`.`t1`.`pk`,`test`.`t1`.`col_int_key`,(/* select#4 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`pk`))
DROP TABLE t1,t2;
#
# Bug#13591138 - ASSERTION NAME && !IS_AUTOGENERATED_NAME IN
# ITEM::PRINT_FOR_ORDER ON EXPLAIN EXT
#
CREATE TABLE t1 (  
pk int(11) NOT NULL AUTO_INCREMENT,
col_datetime_key datetime NOT NULL,
col_varchar_key varchar(1) NOT NULL,
PRIMARY KEY (pk),
KEY col_datetime_key (col_datetime_key),
KEY col_varchar_key (col_varchar_key)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (  
pk int(11) NOT NULL AUTO_INCREMENT,
PRIMARY KEY (pk)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t3 (  
pk int(11) NOT NULL AUTO_INCREMENT,
col_varchar_key varchar(1) NOT NULL,
PRIMARY KEY (pk),
KEY col_varchar_key (col_varchar_key)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE VIEW view1 AS SELECT * FROM t1;
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN
SELECT
alias1.col_datetime_key AS field1
FROM (
view1 AS alias1,
t3 AS alias2
)
WHERE (
(SELECT MIN(sq1_alias1.pk)
FROM t2 AS sq1_alias1
)
) OR (alias1.col_varchar_key = alias2.col_varchar_key
AND alias1.col_varchar_key = 'j'
) AND alias1.pk IS NULL
GROUP BY
field1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
2	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No matching min/max row
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`col_datetime_key` AS `field1` from `test`.`t1` join `test`.`t3` `alias2` where false group by `field1`
DROP TABLE t1,t2,t3;
DROP VIEW view1;
CREATE TABLE t1 (
col_int_key int(11) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
col_varchar_nokey varchar(1) DEFAULT NULL,
KEY col_int_key (col_int_key),
KEY col_varchar_key (col_varchar_key,col_int_key)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (
col_int_key int(11) DEFAULT NULL,
col_varchar_key varchar(1) DEFAULT NULL,
col_varchar_nokey varchar(1) DEFAULT NULL,
KEY col_int_key (col_int_key),
KEY col_varchar_key (col_varchar_key,col_int_key)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE ALGORITHM=MERGE VIEW view1 AS
SELECT CONCAT( table1.col_varchar_nokey , table2.col_varchar_key ) AS
field1
FROM
t2 AS table1 JOIN t1 AS table2
ON table2.col_varchar_nokey = table1.col_varchar_key 
AND
table2.col_varchar_key >= table1.col_varchar_nokey 
ORDER BY field1
;
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT * FROM view1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	table1	NULL	ALL	col_varchar_key	NULL	NULL	NULL	1	100.00	Using temporary; Using filesort
1	SIMPLE	table2	NULL	ALL	col_varchar_key	NULL	NULL	NULL	1	100.00	Range checked for each record (index map: 0x2)
Warnings:
Note	1003	/* select#1 */ select concat(`test`.`table1`.`col_varchar_nokey`,`test`.`table2`.`col_varchar_key`) AS `field1` from `test`.`t2` `table1` join `test`.`t1` `table2` where ((`test`.`table2`.`col_varchar_nokey` = `test`.`table1`.`col_varchar_key`) and (`test`.`table2`.`col_varchar_key` >= `test`.`table1`.`col_varchar_nokey`)) order by concat(`test`.`table1`.`col_varchar_nokey`,`test`.`table2`.`col_varchar_key`)
DROP TABLE t1,t2;
DROP VIEW view1;
CREATE TABLE t1 (col_varchar_nokey varchar(1) DEFAULT NULL);
INSERT INTO t1 VALUES ('v'),('c');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT (SELECT 150) AS field5
FROM (SELECT * FROM t1) AS alias1
GROUP BY field5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1249	Select 2 was reduced during optimization
Note	1003	/* select#1 */ select 150 AS `field5` from `test`.`t1` group by `field5`
DROP TABLE t1;
#
# BUG#12626418 "only_full_group_by wrongly allows column in order by"
#
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode='ONLY_FULL_GROUP_BY';
create table t1(a int, b int);
select a from t1 group by b;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
select 1 from t1 group by b;
1
select 1 from t1 group by b order by a;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
select a from t1 group by b order by b;
ERROR 42000: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.t1.a' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
drop table t1;
CREATE TABLE t1 (pk int, i1 int,  v1 varchar(1), primary key (pk));
INSERT INTO t1 VALUES (0,2,'b'),(1,4,'a'),(2,0,'a'),(3,7,'b'),(4,7,'c');
SELECT a1.v1,a2.v1 FROM t1 AS a1 JOIN t1 AS a2 ON a2.pk = a1.i1 group by
a1.v1,a2.v1 ORDER BY a1.i1,a2.pk,a2.v1 ASC;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.a1.i1' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SELECT a1.v1,a2.v1 FROM t1 AS a1 JOIN t1 AS a2 ON a2.pk = a1.i1 group by
a1.v1,a2.v1 ORDER BY             a2.v1 ASC;
v1	v1
b	a
a	b
a	c
DROP TABLE t1;
CREATE TABLE t1 (pk int(11) NOT NULL AUTO_INCREMENT, col_int_key int(11) NOT
NULL, col_varchar_key varchar(1) NOT NULL, col_varchar_nokey varchar(1) NOT
NULL, PRIMARY KEY (pk), KEY col_int_key (col_int_key), KEY col_varchar_key
(col_varchar_key,col_int_key));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (pk int(11) NOT NULL AUTO_INCREMENT, col_int_key int(11) NOT
NULL, col_varchar_key varchar(1) NOT NULL, col_varchar_nokey varchar(1) NOT
NULL, PRIMARY KEY (pk), KEY col_int_key (col_int_key), KEY col_varchar_key
(col_varchar_key,col_int_key));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
SELECT SUM(alias2.col_varchar_nokey) , alias2.pk AS field2 FROM t1 AS alias1
STRAIGHT_JOIN t2 AS alias2 ON alias2.pk = alias1.col_int_key WHERE alias1.pk
group by field2 ORDER BY alias1.col_int_key,alias2.pk ;
SUM(alias2.col_varchar_nokey)	field2
DROP TABLE t1,t2;
CREATE TABLE t1 (pk int(11) NOT NULL AUTO_INCREMENT, col_int_key int(11) NOT
NULL, col_datetime_key datetime NOT NULL, col_varchar_key varchar(1) NOT
NULL, col_varchar_nokey varchar(1) NOT NULL, PRIMARY KEY (pk), KEY
col_int_key (col_int_key), KEY col_datetime_key (col_datetime_key), KEY
col_varchar_key (col_varchar_key,col_int_key));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (pk int(11) NOT NULL AUTO_INCREMENT, col_int_key int(11) NOT
NULL, col_datetime_key datetime NOT NULL, col_varchar_key varchar(1) NOT
NULL, col_varchar_nokey varchar(1) NOT NULL, PRIMARY KEY (pk), KEY
col_int_key (col_int_key), KEY col_datetime_key (col_datetime_key), KEY
col_varchar_key (col_varchar_key,col_int_key));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
SELECT alias2.col_varchar_key AS field1 ,
COUNT(DISTINCT alias1.col_varchar_nokey), alias2.pk AS field4
FROM t1 AS alias1
RIGHT JOIN t2 AS alias2 ON alias2.pk = alias1.col_int_key
GROUP BY field1 , field4
ORDER BY alias1.col_datetime_key ;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.alias1.col_datetime_key' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
DROP TABLE t1,t2;
create table t1 (a int, b int);
select count(*) > 3 from t1 group by a order by b;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
create table t2 (a int, b int);
select a from t2 group by a
order by (select a from t1 order by t2.b limit 1);
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.t2.b' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
SET @@sql_mode = @old_sql_mode;
DROP TABLE t1,t2;
create table t1 (branch varchar(40), id int);
select count(*) from t1 group by branch having
branch<>'mumbai' order by id desc,branch desc limit 100;
count(*)
select branch, count(*)/max(id) from t1 group by branch
having (branch<>'mumbai' OR count(*)<2)
order by id desc,branch desc limit 100;
branch	count(*)/max(id)
SET @@sql_mode='ONLY_FULL_GROUP_BY';
select count(*) from t1 group by branch having
branch<>'mumbai' order by id desc,branch desc limit 100;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
select branch, count(*)/max(id) from t1 group by branch
having (branch<>'mumbai' OR count(*)<2)
order by id desc,branch desc limit 100;
ERROR 42000: Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'test.t1.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
DROP TABLE t1;
create table t1 (a int, b int);
insert into t1 values (1, 2), (1, 3), (null, null);
select sum(a), count(*) from t1 group by a;
sum(a)	count(*)
2	2
NULL	1
select round(sum(a)), count(*) from t1 group by a;
round(sum(a))	count(*)
2	2
NULL	1
select ifnull(a, 'xyz') from t1 group by a;
ifnull(a, 'xyz')
1
xyz
DROP TABLE t1;
SET @@sql_mode = @old_sql_mode;
#
# BUG#12640437: USING SQL_BUFFER_RESULT RESULTS IN A
#               DIFFERENT QUERY OUTPUT
#
CREATE TABLE t1 (
a int,
b varchar(1),
KEY (b,a)
) charset utf8mb4;
INSERT INTO t1 VALUES (1,NULL),(0,'a'),(1,NULL),(0,'a');
INSERT INTO t1 VALUES (1,'a'),(0,'a'),(1,'a'),(0,'a');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK

EXPLAIN SELECT SQL_BUFFER_RESULT MIN(a), b FROM t1 WHERE t1.b = 'a' GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	b	b	12	NULL	1	100.00	Using where; Using index for group-by; Using temporary
Warnings:
Note	1003	/* select#1 */ select sql_buffer_result min(`test`.`t1`.`a`) AS `MIN(a)`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = 'a') group by `test`.`t1`.`b`

SELECT SQL_BUFFER_RESULT MIN(a), b FROM t1 WHERE t1.b = 'a' GROUP BY b;
MIN(a)	b
0	a

EXPLAIN SELECT MIN(a), b FROM t1 WHERE t1.b = 'a' GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	b	b	12	NULL	1	100.00	Using where; Using index for group-by
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`a`) AS `MIN(a)`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = 'a') group by `test`.`t1`.`b`

SELECT MIN(a), b FROM t1 WHERE t1.b = 'a' GROUP BY b;
MIN(a)	b
0	a

DROP TABLE t1;
#
# Bug #12888306 MISSING ROWS FOR SELECT >ALL (SUBQUERY WITHOUT ROWS)
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (0);
SELECT 1 FROM t1 WHERE 1 > ALL(SELECT 1 FROM t1 WHERE a);
1
1
DROP TABLE t1;
# 
# Bug#18035906: TEST_IF_SKIP_SORT_ORDER INCORRECTLY CHOSES NON-COVERING
#               INDEX FOR ORDERING
# 
CREATE TABLE t1 (
i INT PRIMARY KEY AUTO_INCREMENT,
kp1 INT,
kp2 INT,
INDEX idx_noncov(kp1),
INDEX idx_cov(kp1,kp2)
) ENGINE=InnoDB;
INSERT INTO t1 VALUES (NULL, 1, 1);
INSERT INTO t1 SELECT NULL, kp1, kp2+1 from t1;
INSERT INTO t1 SELECT NULL, kp1, kp2+2 from t1;
INSERT INTO t1 SELECT NULL, kp1, kp2+4 from t1;
INSERT INTO t1 SELECT NULL, kp1, kp2 from t1;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT kp1, SUM(kp2) FROM t1 GROUP BY kp1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	idx_noncov,idx_cov	idx_cov	10	NULL	16	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`kp1` AS `kp1`,sum(`test`.`t1`.`kp2`) AS `SUM(kp2)` from `test`.`t1` group by `test`.`t1`.`kp1`
DROP TABLE t1;
# Bug#72512/18694751: Non-aggregated query with set function in
# ORDER BY should be rejected
CREATE TABLE t1(a INTEGER);
INSERT INTO t1 VALUES (1), (2);
# Non-aggregated queries
SELECT a FROM t1 ORDER BY COUNT(*);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT a FROM t1 WHERE a > 0 ORDER BY COUNT(*);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
# Implicitly grouped query
SELECT SUM(a) FROM t1 ORDER BY COUNT(*);
SUM(a)
3
SELECT COUNT(*) FROM t1 ORDER BY COUNT(*);
COUNT(*)
2
SELECT COUNT(*) AS c FROM t1 ORDER BY COUNT(*);
c
2
SELECT COUNT(*) AS c FROM t1 ORDER BY c;
c
2
# Explicitly grouped query
SELECT a, COUNT(*) FROM t1 GROUP BY a ORDER BY COUNT(*);
a	COUNT(*)
1	1
2	1
SELECT a, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY COUNT(*);
a	c
1	1
2	1
SELECT a, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY c;
a	c
1	1
2	1
SELECT a AS c FROM t1 GROUP BY a ORDER BY COUNT(*);
c
1
2
# Query with HAVING,
SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);
1
1
# Subquery, ORDER BY contains outer reference
SELECT (SELECT 1 AS foo ORDER BY a) AS x
FROM t1;
x
1
1
SELECT (SELECT 1 AS foo ORDER BY t1.a) AS x
FROM t1;
x
1
1
# Subquery, ORDER BY contains set function with outer reference
SELECT (SELECT 1 AS foo ORDER BY COUNT(a)) AS x
FROM t1;
x
1
SELECT (SELECT 1 AS foo ORDER BY COUNT(t1.a)) AS x
FROM t1;
x
1
# Subquery, ORDER BY contains set function with local reference
SELECT (SELECT 1 AS foo ORDER BY COUNT(*)) AS x
FROM t1;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
# Subquery in ORDER BY with outer reference
SELECT a FROM t1 ORDER BY (SELECT COUNT(t1.a) FROM t1 AS t2);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT SUM(a) FROM t1 ORDER BY (SELECT COUNT(t1.a) FROM t1 AS t2);
SUM(a)
3
# Query with ORDER BY inside UNION
(SELECT a FROM t1 ORDER BY COUNT(*))
UNION
SELECT a FROM t1;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*))
UNION ALL
SELECT a FROM t1;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1)
UNION
SELECT a FROM t1;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1)
UNION ALL
SELECT a FROM t1;
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT a FROM t1
UNION
(SELECT a FROM t1 ORDER BY COUNT(*));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT a FROM t1
UNION ALL
(SELECT a FROM t1 ORDER BY COUNT(*));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT a FROM t1
UNION
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1 OFFSET 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT a FROM t1
UNION ALL
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1 OFFSET 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*))
UNION
(SELECT a FROM t1 ORDER BY COUNT(*));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*))
UNION ALL
(SELECT a FROM t1 ORDER BY COUNT(*));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1)
UNION
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1 OFFSET 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1)
UNION ALL
(SELECT a FROM t1 ORDER BY COUNT(*) LIMIT 1 OFFSET 1);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
(SELECT COUNT(*) FROM t1 ORDER BY a) ORDER BY COUNT(*);
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
DROP TABLE t1;
# 
# Bug#18487060: ASSERTION FAILED: !TABLE || (!TABLE->READ_SET || 
#               BITMAP_IS_SET(TABLE->READ_SET,
# 
CREATE TABLE r(c BLOB) ENGINE=INNODB;
INSERT INTO r VALUES('');
SELECT 1 FROM r GROUP BY MAKE_SET(1,c) WITH ROLLUP;
1
1
1
DROP TABLE r;
#
# Bug #18921626 	DEBUG CRASH IN PLAN_CHANGE_WATCHDOG::~PLAN_CHANGE_WATCHDOG AT SQL_OPTIMIZER.CC
#
SET @old_sql_mode = @@sql_mode;
set sql_mode='';
CREATE TABLE AA (
col_varchar_1024_latin1 varchar(1024)  CHARACTER SET latin1,
pk integer auto_increment,
col_varchar_1024_utf8_key varchar(1024)  CHARACTER SET utf8,
col_varchar_1024_latin1_key varchar(1024)  CHARACTER SET latin1,
col_varchar_10_utf8_key varchar(10)  CHARACTER SET utf8,
col_varchar_10_latin1_key varchar(10)  CHARACTER SET latin1,
col_int int,
col_varchar_10_latin1 varchar(10)  CHARACTER SET latin1,
col_varchar_10_utf8 varchar(10)  CHARACTER SET utf8,
col_varchar_1024_utf8 varchar(1024)  CHARACTER SET utf8,
col_int_key int,
primary key (pk),
key (col_varchar_1024_utf8_key ),
key (col_varchar_1024_latin1_key ),
key (col_varchar_10_utf8_key ),
key (col_varchar_10_latin1_key ),
key (col_int_key )) ENGINE=innodb ROW_FORMAT=DYNAMIC;
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
CREATE OR REPLACE VIEW view_AA AS SELECT * FROM AA;
CREATE TABLE B (
col_varchar_1024_latin1_key varchar(1024)  CHARACTER SET latin1,
col_varchar_10_latin1 varchar(10)  CHARACTER SET latin1,
col_varchar_10_utf8_key varchar(10)  CHARACTER SET utf8,
col_int_key int,
col_varchar_1024_latin1 varchar(1024)  CHARACTER SET latin1,
col_varchar_1024_utf8_key varchar(1024)  CHARACTER SET utf8,
col_varchar_10_utf8 varchar(10)  CHARACTER SET utf8,
col_int int,
pk integer auto_increment,
col_varchar_10_latin1_key varchar(10)  CHARACTER SET latin1,
col_varchar_1024_utf8 varchar(1024)  CHARACTER SET utf8,
key (col_varchar_1024_latin1_key ),
key (col_varchar_10_utf8_key ),
key (col_int_key ),
key (col_varchar_1024_utf8_key ),
primary key (pk),
key (col_varchar_10_latin1_key )) ENGINE=INNODB;
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
INSERT INTO B VALUES  ('at', repeat('a',1000), 'the',
-1622540288, 'as', repeat('a',1000), 'want', 1810890752, NULL, 'v', 'just');
Warnings:
Warning	1265	Data truncated for column 'col_varchar_10_latin1' at row 1
SELECT
DISTINCT table1 . pk AS field1
FROM  view_AA AS table1  LEFT  JOIN B AS table2
ON  table1 . col_varchar_10_latin1_key =  table2 .
col_varchar_1024_latin1_key
WHERE ( ( table2 . pk > table1 . col_int_key AND table1 . pk NOT
BETWEEN 3 AND ( 3 + 3 ) ) AND table2 . pk <> 6 )
GROUP BY table1 . pk;
field1
DROP TABLE AA,B;
DROP VIEW view_AA;
SET @@sql_mode = @old_sql_mode;
SET sql_mode = default;
#
# Bug#20262196 ASSERTION FAILED: !IMPLICIT_GROUPING || TMP_TABLE_PARAM.SUM_FUNC_COUNT
#
CREATE TABLE t1(a INT, b INT) ENGINE=INNODB;
INSERT INTO t1 VALUES (1,2), (3,4);
SELECT
EXISTS
(
SELECT 1
FROM (SELECT a FROM t1) t_inner
GROUP BY t_inner.a
ORDER BY MIN(t_outer.b)
)
FROM t1 t_outer;
EXISTS
(
SELECT 1
FROM (SELECT a FROM t1) t_inner
GROUP BY t_inner.a
ORDER BY MIN(t_outer.b)
)
1
DROP TABLE t1;
#
# Bug#20210742 GROUP BY ON MERGE VIEW WITH ORDER BY DOES NOT WORK WITH ONLY_FULL_GROUP_BY
#
CREATE TABLE t1(cc CHAR(1), n CHAR(1), d CHAR(1));
CREATE OR REPLACE ALGORITHM = MERGE VIEW v1 AS
SELECT * FROM t1 WHERE cc = 'AUS' ORDER BY n;
SELECT d, COUNT(*) FROM v1 GROUP BY d;
d	COUNT(*)
DROP TABLE t1;
DROP VIEW v1;
#
# Bug#20819199 ASSERTION FAILED IN TEST_IF_SKIP_SORT_ORDER
#
CREATE TABLE t0 ( a INT );
INSERT INTO t0 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
CREATE TABLE t1 (
pk INT NOT NULL AUTO_INCREMENT,
a INT,
b INT,
PRIMARY KEY (pk),
KEY idx1 (a),
KEY idx2 (b, a),
KEY idx3 (a, b)
) ENGINE = InnoDB;
INSERT INTO t1 (a, b) SELECT t01.a, t02.a FROM t0 t01, t0 t02;
ANALYZE TABLE t0,t1;
Table	Op	Msg_type	Msg_text
test.t0	analyze	status	OK
test.t1	analyze	status	OK
EXPLAIN SELECT DISTINCT a, MAX(b) FROM t1 WHERE a >= 0 GROUP BY a,a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	idx1,idx2,idx3	idx1	5	NULL	100	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1` where (`test`.`t1`.`a` >= 0) group by `test`.`t1`.`a`
SELECT DISTINCT a, MAX(b) FROM t1 WHERE a >= 0 GROUP BY a,a;
a	MAX(b)
1	10
2	10
3	10
4	10
5	10
6	10
7	10
8	10
9	10
10	10
DROP TABLE t0, t1;
# Bug#21753180: handle_fatal_signal (sig=11) in my_strtod_int
CREATE TABLE t1(
a INTEGER,
b BLOB(1),
c BLOB(1),
PRIMARY KEY(a,b(1)),
UNIQUE KEY (a,c(1))
);
INSERT INTO t1 VALUES(1,2,1),(2,4,1);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
explain SELECT a, (SELECT SUM(a + c) FROM (SELECT b as c FROM t1) AS v1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	index	NULL	a	8	NULL	2	100.00	Using index
2	DEPENDENT SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,(/* select#2 */ select sum((`test`.`t1`.`a` + `test`.`t1`.`b`)) from `test`.`t1`) AS `(SELECT SUM(a + c) FROM (SELECT b as c FROM t1) AS v1)` from `test`.`t1`
SELECT a, (SELECT SUM(a + c) FROM (SELECT b as c FROM t1) AS v1) FROM t1;
a	(SELECT SUM(a + c) FROM (SELECT b as c FROM t1) AS v1)
1	8
2	10
DROP TABLE t1;
#
# Bug#21761044 CONDITIONAL JUMP AT TEST_IF_ORDER_BY_KEY IN SQL_OPTIMIZER.CC
#
# Used to give ASAN error on the SELECT: addressing beyond allocated memory
#
CREATE TABLE cc (pk int,  i int, c varchar(1),
PRIMARY KEY (pk, i), KEY c_key(c)) ENGINE=InnoDB;
SELECT c, i, pk FROM cc WHERE (cc.pk = 1)  GROUP BY c, i, pk;
c	i	pk
DROP TABLE cc;
#
# Bug#22132822 CRASH IN GROUP_CHECK::IS_FD_ON_SOURCE
#
CREATE TABLE t1
(
a INT GENERATED ALWAYS AS (1) VIRTUAL,
b INT GENERATED ALWAYS AS (a) VIRTUAL,
c INT GENERATED ALWAYS AS (1) VIRTUAL
);
DROP TABLE t1;
#
# Bug #22186926 CONVERT_CONSTANT_ITEM(THD*, ITEM_FIELD*, ITEM**): ASSERTION `!RESULT' FAILED.
#
CREATE TABLE t1
(
f1 INTEGER NOT NULL,
f2 DATETIME NOT NULL,
f3 VARCHAR(1) NOT NULL,
KEY (f3)
);
INSERT INTO t1(f1, f2, f3) VALUES
(5, '2001-07-25 08:40:24.058646', 'j'),
(2, '1900-01-01 00:00:00', 's'),
(4, '2001-01-20 12:47:23.022022', 'x');
CREATE TABLE t2 (f1 VARCHAR(1) NOT NULL);
FLUSH TABLES;
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN SELECT MIN(t1.f3 ) FROM t1
WHERE t1.f3 IN (SELECT t2.f1 FROM t2 WHERE NOT t1.f2 IS NOT NULL) AND t1.f1 IS NULL OR
NOT t1 . f3 < 'q';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1276	Field or reference 'test.t1.f2' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select min(`test`.`t1`.`f3`) AS `MIN(t1.f3 )` from `test`.`t1` where (`test`.`t1`.`f3` >= 'q')
DROP TABLE t1,t2;
#
# Bug#22275357 ORDER BY DOES NOT WORK CORRECTLY WITH GROUPED AVG()
#              VALUES EXTRACTED FROM JSON
#
CREATE TABLE t(txt TEXT, i INT);
INSERT INTO t VALUES ('a', 2), ('b', 8), ('b', 0), ('c', 2);
SELECT txt, AVG(i) a FROM t GROUP BY txt ORDER BY a, txt;
txt	a
a	2.0000
c	2.0000
b	4.0000
SELECT txt, VAR_POP(i) v FROM t GROUP BY txt ORDER BY v, txt;
txt	v
a	0
c	0
b	16
SELECT txt, STDDEV_POP(i) s FROM t GROUP BY txt ORDER BY s, txt;
txt	s
a	0
c	0
b	4
SELECT SQL_BUFFER_RESULT txt, AVG(i) a FROM t GROUP BY txt ORDER BY a, txt;
txt	a
a	2.0000
c	2.0000
b	4.0000
SELECT SQL_BUFFER_RESULT txt, VAR_POP(i) v FROM t GROUP BY txt ORDER BY v, txt;
txt	v
a	0
c	0
b	16
SELECT SQL_BUFFER_RESULT txt, STDDEV_POP(i) s FROM t
GROUP BY txt ORDER BY s, txt;
txt	s
a	0
c	0
b	4
DROP TABLE t;
#
# Bug#26162009: INCORRECT RESULT WITH EXPRESSION IN HAVING CLAUSE
#
CREATE TABLE t1 (col_varchar VARCHAR(10), col_int_key INT);
INSERT INTO t1 VALUES('r',83);
SELECT col_varchar as field1, MAX(col_int_key) AS field3 FROM t1
GROUP BY col_varchar HAVING (field1 >= 'i' OR field3 <= 9);
field1	field3
r	83
SELECT CONCAT(col_varchar) as field1, MAX(col_int_key) AS field3
FROM t1 GROUP BY col_varchar HAVING (field1 >= 'i' OR field3 <= 9);
field1	field3
r	83
DROP TABLE t1;
#
# Bug#21974346: GROUPING ON AGGREGATED RESULTS NOT ALWAYS REJECTED
#
CREATE TABLE t (a INT);
INSERT INTO t VALUES (0), (1), (1), (2);
# These queries did not raise the expected error before the fix.
SELECT COUNT(*) AS c FROM t GROUP BY (SELECT 1 HAVING c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) + 1 AS c FROM t GROUP BY (SELECT 1 HAVING c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT SUM(a) AS s FROM t GROUP BY (SELECT 1 HAVING s);
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT SUM(a) + 1 AS s FROM t GROUP BY (SELECT 1 HAVING s);
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT (SELECT COUNT(*) AS c FROM t GROUP BY (SELECT 1 HAVING c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT (SELECT COUNT(*) AS c FROM t GROUP BY (SELECT 1 HAVING c) LIMIT 1);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT (SELECT COUNT(*) + 1 AS c FROM t GROUP BY (SELECT 1 HAVING c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c1, (SELECT 1 HAVING c1) AS c2
FROM t GROUP BY (SELECT 1 WHERE c2);
ERROR 42S22: Reference 'c2' not supported (reference to group function)
SELECT COUNT(*) + 1 AS c1, (SELECT 1 HAVING c1) + 1 AS c2
FROM t GROUP BY (SELECT 1 WHERE c2);
ERROR 42S22: Reference 'c2' not supported (reference to group function)
# These queries were accepted before the fix, and they still are.
SELECT COUNT(*) AS c FROM t ORDER BY (SELECT 1 HAVING c);
c
4
SELECT COUNT(*) AS c FROM t ORDER BY c;
c
4
SELECT COUNT(*) AS c FROM t ORDER BY c+1;
c
4
SELECT COUNT(*) AS c FROM t ORDER BY c+c;
c
4
SELECT COUNT(*) AS c FROM t HAVING (SELECT 1 HAVING c);
c
4
SELECT COUNT(*) AS c FROM t HAVING c;
c
4
SELECT a, COUNT(*) AS c FROM t GROUP BY a WITH ROLLUP
HAVING (SELECT 1 HAVING c);
a	c
0	1
1	2
2	1
NULL	4
SELECT a, COUNT(*) AS c FROM t GROUP BY a WITH ROLLUP HAVING c;
a	c
0	1
1	2
2	1
NULL	4
SELECT (SELECT COUNT(*) AS c FROM t HAVING c <> 0);
(SELECT COUNT(*) AS c FROM t HAVING c <> 0)
4
SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);
(SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0)
4
SELECT (SELECT COUNT(*) AS c FROM t ORDER BY c);
(SELECT COUNT(*) AS c FROM t ORDER BY c)
4
SELECT (SELECT COUNT(*) FROM t ORDER BY COUNT(*));
(SELECT COUNT(*) FROM t ORDER BY COUNT(*))
4
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2
GROUP BY (SELECT 1 HAVING s > 0)) > 0;
1
1
SELECT (SELECT SUM(a)) FROM t;
(SELECT SUM(a))
4
SELECT SUM(a) AS s, (SELECT SUM(a)) FROM t;
s	(SELECT SUM(a))
4	4
SELECT a, (SELECT SUM(a)) s FROM t GROUP BY a;
a	s
0	0
1	2
2	2
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 HAVING s > 5);
1
SELECT (SELECT SUM(t1.a) s FROM t t2 WHERE t2.a = 0 HAVING s > 3) FROM t t1;
(SELECT SUM(t1.a) s FROM t t2 WHERE t2.a = 0 HAVING s > 3)
4
SELECT 1 FROM t HAVING (SELECT SUM(a)) > 0;
1
1
SELECT (SELECT SUM(a)) FROM t;
(SELECT SUM(a))
4
# Bug #22588319: OUTER REFERENCE TO AGGREGATE INCORRECTLY 0 OR NULL IN SUBQUERY
SELECT SUM(a) AS s, (SELECT 1 HAVING s) FROM t;
s	(SELECT 1 HAVING s)
4	1
SELECT SUM(a) AS s, (SELECT 1 HAVING s IS NULL) FROM t;
s	(SELECT 1 HAVING s IS NULL)
4	NULL
SELECT COUNT(a) AS c, (SELECT 1 HAVING c) FROM t;
c	(SELECT 1 HAVING c)
4	1
SELECT COUNT(a) AS c, (SELECT 1 HAVING c = 0) FROM t;
c	(SELECT 1 HAVING c = 0)
4	NULL
# Shows that #22588319 isn't fixed for ORDER BY.
# Should have ordered ascending on -a, but comes out in random order
# because the ORDER BY clause always evaluates to NULL. Have to use
# the --sorted_result directive to produce stable test results.
SELECT a, COUNT(*) c FROM t GROUP BY a ORDER BY (SELECT -a HAVING c > 0);
a	c
0	1
1	2
2	1
# These queries were accepted in the default sql_mode before the fix,
# and rejected in the ANSI sql_mode. Expect no change after the fix.
SELECT * FROM t t1 WHERE (SELECT SUM(t1.a) s FROM t t2 HAVING s = 0);
a
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s FROM t t2 ORDER BY s);
1
1
1
1
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s FROM t t2 ORDER BY s + 1);
1
1
1
1
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s);
1
1
1
1
SELECT 1 FROM t WHERE (SELECT SUM(a)) > 0;
1
1
1
1
SELECT 1 FROM t GROUP BY (SELECT SUM(a));
1
1
1
1
SET sql_mode = ANSI;
SELECT * FROM t t1 WHERE (SELECT SUM(t1.a) s FROM t t2 HAVING s = 0);
ERROR HY000: Invalid use of group function
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s FROM t t2 ORDER BY s);
ERROR HY000: Invalid use of group function
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s FROM t t2 ORDER BY s + 1);
ERROR HY000: Invalid use of group function
SELECT 1 FROM t t1 GROUP BY (SELECT SUM(t1.a) s);
ERROR HY000: Invalid use of group function
SELECT 1 FROM t WHERE (SELECT SUM(a)) > 0;
ERROR HY000: Invalid use of group function
SELECT 1 FROM t GROUP BY (SELECT SUM(a));
ERROR HY000: Invalid use of group function
SET sql_mode = DEFAULT;
# These queries were rejected before the fix, and they still are.
SELECT COUNT(*) AS c FROM t GROUP BY (SELECT c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) + 1 AS c FROM t GROUP BY (SELECT c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t GROUP BY (SELECT 1 WHERE c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) + 1 AS c FROM t GROUP BY (SELECT 1 WHERE c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t GROUP BY (SELECT c HAVING c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) + 1 AS c FROM t GROUP BY (SELECT c HAVING c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t GROUP BY (SELECT c WHERE c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT c FROM (SELECT COUNT(*) AS c FROM t GROUP BY (SELECT 1 ORDER BY c)) tt;
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t
GROUP BY (SELECT COUNT(*) FROM t HAVING (SELECT c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t
GROUP BY (SELECT COUNT(*) FROM t ORDER BY (SELECT c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT (SELECT COUNT(*) AS c FROM t GROUP BY c);
ERROR 42000: Can't group on 'c'
SELECT (SELECT COUNT(*) FROM t GROUP BY COUNT(*));
ERROR 42000: Can't group on 'COUNT(*)'
SELECT 1 FROM t t1 WHERE (SELECT SUM(t1.a) s FROM t t2 GROUP BY s);
ERROR 42000: Can't group on 's'
SELECT 1 FROM t t1 WHERE (SELECT SUM(t1.a) s FROM t t2 GROUP BY s+1);
ERROR 42000: Can't group on '???'
SELECT 1 FROM t t1 ORDER BY (SELECT SUM(t1.a) s FROM t t2 GROUP BY s) > 0;
ERROR 42000: Can't group on 's'
SELECT 1 FROM t t1 ORDER BY (SELECT SUM(t1.a) s FROM t t2 GROUP BY s+1) > 0;
ERROR 42000: Can't group on '???'
SELECT 1 FROM t t1 ORDER BY (SELECT SUM(t1.a) s FROM t t2
GROUP BY (SELECT s)) > 0;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t t1 ORDER BY (SELECT SUM(t1.a) s FROM t t2
GROUP BY (SELECT s+1)) > 0;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t ORDER BY (SELECT SUM(a));
ERROR HY000: Expression #1 of ORDER BY contains aggregate function and applies to the result of a non-aggregated query
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 WHERE s > 5);
ERROR 42S22: Unknown column 's' in 'where clause'
SELECT a, (SELECT SUM(a)) s FROM t GROUP BY a, s;
ERROR 42000: Can't group on 's'
SELECT EXISTS (SELECT SUM(t1.a) s FROM t t2 GROUP BY s) FROM t t1;
ERROR 42000: Can't group on 's'
SELECT SUM(a) s, s FROM t;
ERROR 42S22: Unknown column 's' in 'field list'
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 GROUP BY s) > 0;
ERROR 42000: Can't group on 's'
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 GROUP BY s+1) > 0;
ERROR 42000: Can't group on '???'
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2
HAVING (SELECT 1 GROUP BY s+1)) > 0;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t ORDER BY (SELECT c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t ORDER BY (SELECT 1 ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t ORDER BY (SELECT c ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t HAVING (SELECT c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t HAVING (SELECT 1 ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t HAVING (SELECT c ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT a, COUNT(*) AS c FROM t GROUP BY a WITH ROLLUP
HAVING (SELECT c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT a, COUNT(*) AS c FROM t GROUP BY a WITH ROLLUP
HAVING (SELECT 1 ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT a, COUNT(*) AS c FROM t GROUP BY a WITH ROLLUP
HAVING (SELECT c ORDER BY c);
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t ORDER BY (SELECT COUNT(*) FROM t HAVING (SELECT c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT c FROM (SELECT COUNT(*) AS c FROM t ORDER BY (SELECT 1 ORDER BY c)) tt;
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t
ORDER BY (SELECT COUNT(*) FROM t GROUP BY (SELECT c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT COUNT(*) AS c FROM t
HAVING (SELECT COUNT(*) FROM t GROUP BY (SELECT c));
ERROR 42S22: Reference 'c' not supported (reference to group function)
SELECT SUM(a) AS s, (SELECT s) FROM t;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT EXISTS (SELECT SUM(t1.a) s FROM t t2 GROUP BY (SELECT s)) FROM t t1;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT (SELECT SUM(t1.a) s FROM t t2 HAVING (SELECT s > 5)) FROM t t1;
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 HAVING (SELECT s) < 0);
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 GROUP BY (SELECT s));
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 HAVING (SELECT -s) > 0);
ERROR 42S22: Reference 's' not supported (reference to group function)
SELECT 1 FROM t t1 HAVING (SELECT SUM(t1.a) s FROM t t2 GROUP BY (SELECT -s));
ERROR 42S22: Reference 's' not supported (reference to group function)
DROP TABLE t;
#
# Bug#25407964 GROUP BY DESC GIVES WRONG RESULT WHEN GROUPS ON DECIMAL AND SEES A NULL
#
CREATE TABLE t(d DATE, i INT);
INSERT INTO t VALUES(NULL,1),('2017-01-14',3);
SELECT WEEK(d)/10, GROUP_CONCAT(i) FROM t GROUP BY WEEK(d)/10;
WEEK(d)/10	GROUP_CONCAT(i)
NULL	1
0.2000	3
SELECT WEEK(d)/10, GROUP_CONCAT(i) FROM t GROUP BY WEEK(d)/10 ORDER BY WEEK(d)/10 DESC;
WEEK(d)/10	GROUP_CONCAT(i)
0.2000	3
NULL	1
DROP TABLE t;
#
# Bug#21974696 WRONG RESULT WHEN GROUPING ON VALUE FROM SUBQUERY
#              AND USING COUNT DISTINCT
#
CREATE TABLE t(a TEXT, b INT);
INSERT INTO t VALUES ('1', 10), ('1', 11), ('2', 20), ('2', 20), ('3', 30);
EXPLAIN FORMAT=tree SELECT (SELECT a) AS col1, COUNT(DISTINCT b) FROM t GROUP BY -col1;
EXPLAIN
-> Group aggregate: count(distinct t.b)
    -> Sort: -(a)
        -> Stream results  (cost=*** rows=***)
            -> Table scan on t  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t.a' of SELECT #2 was resolved in SELECT #1
Note	1249	Select 2 was reduced during optimization
SELECT (SELECT a) AS col1, COUNT(DISTINCT b) FROM t GROUP BY -col1;
col1	COUNT(DISTINCT b)
1	2
2	1
3	1
SELECT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1;
col1	COUNT(b)
1	2
2	2
3	1
SELECT SQL_BIG_RESULT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1;
col1	COUNT(b)
1	2
2	2
3	1
SELECT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1 WITH ROLLUP;
col1	COUNT(b)
1	2
1	5
2	2
3	1
DROP TABLE t;
CREATE TABLE t(a JSON, b INT);
INSERT INTO t VALUES ('1', 10), ('1', 11), ('2', 20), ('2', 20), ('3', 30);
EXPLAIN FORMAT=tree SELECT (SELECT a) AS col1, COUNT(DISTINCT b) FROM t GROUP BY -col1;
EXPLAIN
-> Group aggregate: count(distinct t.b)
    -> Sort: -(a)
        -> Stream results  (cost=*** rows=***)
            -> Table scan on t  (cost=*** rows=***)

Warnings:
Note	1276	Field or reference 'test.t.a' of SELECT #2 was resolved in SELECT #1
Note	1249	Select 2 was reduced during optimization
SELECT (SELECT a) AS col1, COUNT(DISTINCT b) FROM t GROUP BY -col1;
col1	COUNT(DISTINCT b)
1	2
2	1
3	1
SELECT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1;
col1	COUNT(b)
1	2
2	2
3	1
SELECT SQL_BIG_RESULT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1;
col1	COUNT(b)
1	2
2	2
3	1
SELECT (SELECT a) AS col1, COUNT(b) FROM t GROUP BY -col1 WITH ROLLUP;
col1	COUNT(b)
1	2
1	5
2	2
3	1
DROP TABLE t;
#
# WL#8963: REMOVAL OF NON STANDARD GROUP BY ASC/DESC
#
CREATE TABLE t1 (i INTEGER NOT NULL, j INTEGER NOT NULL, key(i,j));
INSERT INTO t1 VALUES (1,2),(1,4),(1,3),(2,5),(5,3),(2,6),(6,2);
SELECT i, SUM(j) FROM t1 GROUP BY i ASC;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ASC' at line 1
SELECT i, SUM(j) FROM t1 GROUP BY i DESC;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'DESC' at line 1
EXPLAIN SELECT i, SUM(j) FROM t1 GROUP BY i;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i	i	8	NULL	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,sum(`test`.`t1`.`j`) AS `SUM(j)` from `test`.`t1` group by `test`.`t1`.`i`
SELECT i, SUM(j) FROM t1 GROUP BY i;
i	SUM(j)
1	9
2	11
5	3
6	2
EXPLAIN SELECT i, SUM(j) FROM t1 GROUP BY i ORDER BY i;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i	i	8	NULL	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,sum(`test`.`t1`.`j`) AS `SUM(j)` from `test`.`t1` group by `test`.`t1`.`i` order by `test`.`t1`.`i`
SELECT i, SUM(j) FROM t1 GROUP BY i ORDER BY i;
i	SUM(j)
1	9
2	11
5	3
6	2
EXPLAIN SELECT i, SUM(j) FROM t1 GROUP BY i ORDER BY SUM(j);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i	i	8	NULL	#	#	Using index; Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i`,sum(`test`.`t1`.`j`) AS `SUM(j)` from `test`.`t1` group by `test`.`t1`.`i` order by sum(`test`.`t1`.`j`)
SELECT i, SUM(j) FROM t1 GROUP BY i ORDER BY SUM(j);
i	SUM(j)
6	2
5	3
1	9
2	11
ALTER TABLE t1 ADD UNIQUE INDEX (i,j);
EXPLAIN SELECT i FROM t1 GROUP BY j,i ORDER BY i,j;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	i_2,i	i_2	8	NULL	7	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`i` AS `i` from `test`.`t1` group by `test`.`t1`.`j`,`test`.`t1`.`i` order by `test`.`t1`.`i`,`test`.`t1`.`j`
SELECT i, SUM(j) FROM t1 GROUP BY j,i ORDER BY i,j;
i	SUM(j)
1	2
1	3
1	4
2	5
2	6
5	3
6	2
DROP TABLE t1;
# End of tests for WL#8693
#
# Bug #29214970: WRONG RESULTS FOR GROUP EXPRESSIONS WITH THE ITERATOR EXECUTOR
#
CREATE TABLE t1 (
f1 INTEGER,
f2 INTEGER,
KEY k1 ( f1 )
);
INSERT INTO t1 VALUES ( 1, 1 );
INSERT INTO t1 VALUES ( 1, 2 );
INSERT INTO t1 VALUES ( 1, 3 );
INSERT INTO t1 VALUES ( 2, 1 );
INSERT INTO t1 VALUES ( 2, 2 );
INSERT INTO t1 VALUES ( 3, 5 );
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=tree SELECT f1, f1 + 1, COUNT(DISTINCT f2) AS x FROM t1 GROUP BY f1 ORDER BY x;
EXPLAIN
-> Sort: x
    -> Stream results  (cost=1.45 rows=2)
        -> Group aggregate: count(distinct t1.f2)  (cost=1.45 rows=2)
            -> Index scan on t1 using k1  (cost=0.85 rows=6)

SELECT f1, f1 + 1, COUNT(DISTINCT f2) AS x FROM t1 GROUP BY f1 ORDER BY x;
f1	f1 + 1	x
3	4	1
2	3	2
1	2	3
DROP TABLE t1;
# Bug#29240516: Count on nullable expression may return wrong result
CREATE TABLE t1 (
vc varchar(255) DEFAULT NULL,
b tinyint DEFAULT NULL
);
INSERT INTO t1 (vc, b) VALUES (1, true), (2, false), (3, true), (4, false);
INSERT INTO t1 (vc) VALUES (5), (6), (7), (8), (9), (10);
SELECT COUNT(b), COUNT(*)
FROM t1;
COUNT(b)	COUNT(*)
4	10
SELECT COUNT(b)
FROM t1
HAVING COUNT(1) > 0;
COUNT(b)
4
DROP TABLE t1;
# Bug#28857990: Different result for COUNT with EXISTS subquery
CREATE TABLE d (pk INT PRIMARY KEY);
INSERT INTO d VALUES (1),(2),(3),(4),(5);
CREATE TABLE c (col_varchar VARCHAR(1));
INSERT INTO c VALUES ('a'),('b'),('c'),('d'),('e');
SELECT COUNT(pk) FROM d WHERE EXISTS (SELECT col_varchar FROM c);
COUNT(pk)
5
DROP TABLE c, d;
#
# Bug #29396628: SIG 6 AT LIST<ITEM>::END | SQL_LIST.H
#
CREATE TABLE t1 (
f1 integer,
f2 integer,
f3 integer
);
SELECT * FROM t1 GROUP BY f3,f2,f1 WITH ROLLUP;
f1	f2	f3
DROP TABLE t1;
# Bug#23599127 Unexpected unknown column error without ONLY_FULL_GROUP_BY
SET SQL_MODE = '';
CREATE TABLE t1 (
id_aams int NOT NULL ,
PRIMARY KEY (id_aams)
);
CREATE TABLE t2 (
id int NOT NULL,
id_game int DEFAULT NULL,
code_id char(11) DEFAULT NULL,
PRIMARY KEY (id),
UNIQUE KEY codeid (code_id,id_game)
);
select count(distinct x.id_aams)
from (select *
from (select t1.id_aams, t2.*
from t1 left join t2
on t2.code_id='G0000000012' and
t1.id_aams=t2.id_game
where t1.id_aams=1715000360
order by t2.id desc
) as g
group by g.id_aams
having g.id is null
) as x;
count(distinct x.id_aams)
0
CREATE FUNCTION f1(vlt_code_id CHAR(11)) RETURNS tinyint DETERMINISTIC
BEGIN
DECLARE not_installed TINYINT DEFAULT 0;
select count(distinct x.id_aams)
into not_installed
from (select *
from (select t1.id_aams, t2.*
from t1 left join t2
on t2.code_id = vlt_code_id and
t1.id_aams = t2.id_game
where t1.id_aams = 1715000360
order by t2.id desc
) as g
group by g.id_aams
having g.id is null
) as x;
RETURN TRUE;
END //
SELECT f1('G0000000012');
f1('G0000000012')
1
SELECT f1('G0000000012');
f1('G0000000012')
1
PREPARE stmt from "
select count(distinct x.id_aams)
from (select g.id_aams, g.id
      from (select t1.id_aams, t2.*
            from t1 left join t2
                 on t2.code_id='G0000000012' and
                    t1.id_aams=t2.id_game
            where t1.id_aams=1715000360
            order by t2.id desc
           ) as g
      group by g.id_aams
      having g.id is null
     ) as x";
EXECUTE stmt;
count(distinct x.id_aams)
0
EXECUTE stmt;
count(distinct x.id_aams)
0
DEALLOCATE PREPARE stmt;
DROP FUNCTION f1;
DROP TABLE t1, t2;
SET SQL_MODE = DEFAULT;
# Bug#31562881: Crash in change_to_use_tmp_fields_except_sums
CREATE TABLE w(a INTEGER);
INSERT INTO w VALUES (1),(2),(3),(4);
SELECT MAX(FROM_UNIXTIME(1536999161)),
GROUP_CONCAT(ST_LATFROMGEOHASH(ST_GEOHASH(POINT(115,155),201)))
FROM w RIGHT JOIN w AS e ON TRUE
GROUP BY w.a
LIMIT 39;
ERROR 22003: latitude value is out of range in 'st_geohash'
DROP TABLE w;
#
# Bug #32179240: ADDING ROLLUP BREAKS GROUP LABELS
#
CREATE TABLE t1 (a DOUBLE);
INSERT INTO t1 ( a ) VALUES ( 0.1 );
SELECT TRUNCATE(a, 1) FROM t1 GROUP BY TRUNCATE(a, 1) WITH ROLLUP;
TRUNCATE(a, 1)
0.1
NULL
DROP TABLE t1;
#
# Bug#32193123: DIFFERENT RESULTSET WITH HYPERGRAPH_OPTIMIZER SWITCH ENABLED
#
CREATE TABLE t1 (a INTEGER, b VARCHAR(1));
INSERT INTO t1 VALUES (1, 'x');
SELECT SUM(t1.a) AS field1, CONCAT(d1.b) AS field2
FROM (SELECT * FROM t1) AS d1, t1
GROUP BY field2 HAVING field2 > '' AND field1 < 4;
field1	field2
1	x
DROP TABLE t1;
#
# Bug #32234709: TEMPTABLEAGGREGATEITERATOR::INIT(): ASSERTION `!THD()->IS_ERROR()' FAILED.
#
CREATE TABLE t1 (
a INTEGER,
e INTEGER
);
INSERT INTO t1 VALUES (1,0);
INSERT INTO t1 VALUES (1,8388607);
SELECT COUNT(*) FROM
t1
LEFT JOIN json_table(
'{}','$[0][1]'
    COLUMNS(a FOR ORDINALITY)
) AS t2 ON TRUE
GROUP BY e*from_unixtime(0);
ERROR 22003: BIGINT value is out of range in '(`test`.`t1`.`e` * from_unixtime(0))'
DROP TABLE t1;
#
# Bug #32244407: ASSERTION FAILURE IN `!THD()->IS_ERROR()' AT AGGREGATEITERATOR::READ()
#
CREATE TABLE t1 (
a INTEGER,
b VARCHAR(1)
);
CREATE INDEX i1 ON t1 (b);
INSERT INTO t1 VALUES (1,'0');
INSERT INTO t1 VALUES (1,'y');
INSERT INTO t1 VALUES (1,'Q');
INSERT INTO t1 VALUES (1,'H');
INSERT INTO t1 VALUES (1,'j');
INSERT INTO t1 VALUES (1,'a');
INSERT INTO t1 VALUES (1,'b');
INSERT INTO t1 VALUES (1,'j');
INSERT INTO t1 VALUES (1,'q');
INSERT INTO t1 VALUES (1,'e');
SELECT AVG(a2.a)
FROM t1 AS a1
LEFT JOIN t1 AS a2 ON a2.b = ( SELECT a1.b FROM t1 );
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t1;
#
# Bug #32335256: COUNT(*) RETURNS NULL IN NESTED QUERY
#
CREATE TABLE t1 (
f1 INTEGER
);
SELECT
(
SELECT COUNT(*) +
(
SELECT COUNT(*)
FROM t1
WHERE f1 = c.f2
)
FROM t1
)
FROM (SELECT 555 AS f2) AS c;
(
SELECT COUNT(*) +
(
SELECT COUNT(*)
FROM t1
WHERE f1 = c.f2
)
FROM t1
)
0
DROP TABLE t1;
#
# Bug#32248291: ENABLE THE HYPERGRAPH OPTIMIZER FOR SQL_BUFFER_RESULT
#
# Verify that expressions in the SELECT list are evaluated only once
# per row.
#
CREATE TABLE t(x INTEGER);
INSERT INTO t VALUES (1), (2), (3);
SELECT RAND(1) r, COUNT(*) FROM t GROUP BY x ORDER BY r;
r	COUNT(*)
0.1418603212962489	1
0.40540353712197724	1
0.8716141803857071	1
DROP TABLE t;
#
# Bug #32598902: WL#14325: ASSERTION `RECEIVER.HASSECONDARYENGINECOSTHOOK()' FAILED|JOIN_OPTIMIZE
#
CREATE TABLE t1 (
a INTEGER,
b INTEGER
);
SELECT t1.b
FROM t1, t1 AS t2
WHERE t1.a = t1.b AND t1.a = t2.b
GROUP BY t1.b
ORDER BY t2.b;
b
DROP TABLE t1;
# Bug#32717969: Wrong result of execute prepare on 'smallint'
CREATE TABLE t1(
c1 smallint NOT NULL
);
INSERT INTO t1 VALUES(32767),(14742),(14743);
SELECT COUNT(*), SUM(c1), AVG(c1), MIN(c1), MAX(c1) FROM t1 WHERE c1 > 32767;
COUNT(*)	SUM(c1)	AVG(c1)	MIN(c1)	MAX(c1)
0	NULL	NULL	NULL	NULL
PREPARE stmt from
'SELECT COUNT(*), SUM(c1), AVG(c1), MIN(c1), MAX(c1) FROM t1 WHERE c1 > ?';
SET @a=14742;
EXECUTE stmt USING @a;
COUNT(*)	SUM(c1)	AVG(c1)	MIN(c1)	MAX(c1)
2	47510	23755.0000	14743	32767
set @a=32767;
EXECUTE stmt USING @a;
COUNT(*)	SUM(c1)	AVG(c1)	MIN(c1)	MAX(c1)
0	NULL	NULL	NULL	NULL
SELECT BIT_AND(c1), BIT_OR(c1), BIT_XOR(c1) FROM t1 WHERE c1 > 32767;
BIT_AND(c1)	BIT_OR(c1)	BIT_XOR(c1)
18446744073709551615	0	0
PREPARE stmt from
'SELECT BIT_AND(c1), BIT_OR(c1), BIT_XOR(c1) FROM t1 WHERE c1 > ?';
SET @a=14742;
EXECUTE stmt USING @a;
BIT_AND(c1)	BIT_OR(c1)	BIT_XOR(c1)
14743	32767	18024
set @a=32767;
EXECUTE stmt USING @a;
BIT_AND(c1)	BIT_OR(c1)	BIT_XOR(c1)
18446744073709551615	0	0
SELECT GROUP_CONCAT(c1), JSON_ARRAYAGG(c1), JSON_OBJECTAGG('key', c1)
FROM t1
WHERE c1 > 32767;
GROUP_CONCAT(c1)	JSON_ARRAYAGG(c1)	JSON_OBJECTAGG('key', c1)
NULL	NULL	NULL
PREPARE stmt from
"SELECT GROUP_CONCAT(c1), JSON_ARRAYAGG(c1), JSON_OBJECTAGG('key', c1)
 FROM t1
 WHERE c1 > ?";
SET @a=14742;
EXECUTE stmt USING @a;
GROUP_CONCAT(c1)	JSON_ARRAYAGG(c1)	JSON_OBJECTAGG('key', c1)
32767,14743	[32767, 14743]	{"key": 14743}
set @a=32767;
EXECUTE stmt USING @a;
GROUP_CONCAT(c1)	JSON_ARRAYAGG(c1)	JSON_OBJECTAGG('key', c1)
NULL	NULL	NULL
SELECT STDDEV_POP(c1), STDDEV_SAMP(c1), VAR_POP(c1), VAR_SAMP(c1)
FROM t1
WHERE c1 > 32767;
STDDEV_POP(c1)	STDDEV_SAMP(c1)	VAR_POP(c1)	VAR_SAMP(c1)
NULL	NULL	NULL	NULL
PREPARE stmt from
'SELECT STDDEV_POP(c1), STDDEV_SAMP(c1), VAR_POP(c1), VAR_SAMP(c1)
 FROM t1
 WHERE c1 > ?';
SET @a=14742;
EXECUTE stmt USING @a;
STDDEV_POP(c1)	STDDEV_SAMP(c1)	VAR_POP(c1)	VAR_SAMP(c1)
9012	12744.892624106333	81216144	162432288
set @a=32767;
EXECUTE stmt USING @a;
STDDEV_POP(c1)	STDDEV_SAMP(c1)	VAR_POP(c1)	VAR_SAMP(c1)
NULL	NULL	NULL	NULL
DROP TABLE t1;
#
# Verify that ROLLUP and DISTINCT on nullable GROUP BY expressions
# work as expected (the sort is not elided).
#
CREATE TABLE t1 (a INTEGER);
INSERT INTO t1 VALUES (NULL), (1), (2);
SELECT DISTINCT a, COUNT(*) FROM t1 GROUP BY a WITH ROLLUP;
a	COUNT(*)
1	1
2	1
NULL	1
NULL	3
DROP TABLE t1;
#
# Bug #33007298: RECENT REGRESSION: CRASH IN QEP_SHARED_OWNER::TABLE
#
select is_uuid(avg(distinct json_storage_free('$b*<*#]E')));
ERROR 22032: Invalid JSON text in argument 1 to function json_storage_free: "Invalid value." at position 0.
#
# Bug#31894023 THE RESULTS OF AGGREGATION ON BIT TYPE ARE INCONSISTENT WHEN JOIN TYPE DIFFERS
#
CREATE TABLE t1(id INT, b1 BIT, b9 BIT(9), b64 BIT(64));
INSERT INTO t1 VALUES
(1, b'0', b'000000000', b'0000000000000000000000000000000000000000000000000000000000000000'),
(2, b'1', b'100000000', b'1000000000000000000000000000000000000000000000000000000000000000');
CREATE INDEX i1 ON t1(id);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
SELECT HEX(CONCAT(MIN(b1))), HEX(CONCAT(MIN(b9))), HEX(CONCAT(MIN(b64))) FROM t1 GROUP BY id;
HEX(CONCAT(MIN(b1)))	HEX(CONCAT(MIN(b9)))	HEX(CONCAT(MIN(b64)))
00	0000	0000000000000000
01	0100	8000000000000000
SELECT HEX(CONCAT(MIN(b1))), HEX(CONCAT(MIN(b9))), HEX(CONCAT(MIN(b64))) FROM t1 IGNORE INDEX(i1) GROUP BY id;
HEX(CONCAT(MIN(b1)))	HEX(CONCAT(MIN(b9)))	HEX(CONCAT(MIN(b64)))
00	0000	0000000000000000
01	0100	8000000000000000
DROP TABLE t1;
#
# Bug#33515752: Data insertion exception in version 8.0.27
#
CREATE TABLE t1(f1 INTEGER);
INSERT INTO t1 VALUES(1);
SELECT SQL_BUFFER_RESULT MAX(f1)+1, 1 AS f2  FROM t1 GROUP BY f2;
MAX(f1)+1	f2
2	1
DROP TABLE t1;
#
# Bug #33603911: Incorrect result with aggregation by temporary table
#
CREATE TABLE t1 ( a INTEGER, b VARCHAR(1) );
INSERT INTO t1 VALUES (3, 'Q'), (4, '5');
CREATE TABLE t2 ( a INTEGER );
INSERT INTO t2 VALUES (3), (4);
SELECT
t2d.a,
SUM(t1.b) AS field2
FROM
t1
JOIN ( SELECT * FROM t2 ) AS t2d ON t1.a = t2d.a
GROUP BY t2d.a
HAVING t2d.a <> 3 OR field2 < 5;
a	field2
3	0
4	5
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'Q'
DROP TABLE t1, t2;
#
# Bug#33738447:
# Assertion `!(used_tabs & (~ read_tables & ~filter_for_table))' failed.
#
CREATE TABLE t (i INTEGER, blobfield LONGTEXT);
INSERT INTO t VALUES (1, '');
PREPARE ps FROM '
SELECT d.i, COUNT(*)
FROM t, LATERAL (SELECT i, blobfield) AS d
GROUP BY d.i
HAVING d.i < 100
ORDER BY d.i
';
EXECUTE ps;
i	COUNT(*)
1	1
EXECUTE ps;
i	COUNT(*)
1	1
DEALLOCATE PREPARE ps;
DROP TABLE t;
#
# Bug#33674441: Wrong result with outer join and streaming aggregation
#
CREATE TABLE t1 (a INTEGER PRIMARY KEY, b INTEGER);
INSERT INTO t1 VALUES (1, 2), (2, 1), (3, 1);
CREATE TABLE t2 (a INTEGER, b INTEGER, KEY (b));
INSERT INTO t2 VALUES (1, 11);
CREATE TABLE t3 (a INTEGER PRIMARY KEY, b INTEGER);
INSERT INTO t3 VALUES (1, 10), (2, 11), (3, 0), (4, 0), (5, 0), (6, 0);
SELECT t1.a, MAX(t2.a)
FROM t1 LEFT JOIN (t2 JOIN t3 ON t2.b = t3.b) ON t1.b = t3.a
GROUP BY t1.a;
a	MAX(t2.a)
1	1
2	NULL
3	NULL
SELECT SQL_BUFFER_RESULT t1.a, MAX(t2.a)
FROM t1 LEFT JOIN (t2 JOIN t3 ON t2.b = t3.b) ON t1.b = t3.a
GROUP BY t1.a;
a	MAX(t2.a)
1	1
2	NULL
3	NULL
DROP TABLE t1, t2, t3;
#
# Bug #33621358: Hypergraph: Assertion `!null_value || is_nullable()'
#                failed
#
CREATE TABLE t1 (f1 INTEGER, PRIMARY KEY(f1));
SELECT SUM(t1.f1)
FROM t1 JOIN t1 AS t2
ON t1.f1 = t2.f1
ORDER BY RANK() OVER(), CAST(t1.f1 AS UNSIGNED);
SUM(t1.f1)
NULL
DROP TABLE t1;
#
# Bug#34051026: mysqld uint Filesort::make_sortorder(ORDER*, bool):
#               Assertion `count > 0' failed
#
CREATE TABLE t1(x INT PRIMARY KEY);
CREATE TABLE t2(x INT PRIMARY KEY);
CREATE TABLE t3(x INT);
INSERT INTO t1 VALUES (1);
SELECT t2.x
FROM
t1
LEFT JOIN t2
LEFT JOIN t3 ON t3.x = t2.x ON t1.x = t3.x
WHERE t3.x IS NULL
GROUP BY t2.x
ORDER BY t2.x;
x
NULL
DROP TABLE t1, t2, t3;
#
# Bug#34341503: TPC-DS Q18 SF1 result diff old optimizer vs. hypergraph
#
CREATE TABLE t1 (
id INT,
x INT,
PRIMARY KEY (id)
);
CREATE TABLE t2 (
id INT
);
INSERT INTO t1 VALUES (1, 1), (2, 2);
INSERT INTO t2 VALUES (1), (2);
SELECT t1.x
FROM t1, t2
WHERE t1.id = t2.id
GROUP BY t1.x WITH ROLLUP;
x
1
2
NULL
DROP TABLE t1, t2;
#
# Bug#34463842: Result diff seen with hypergraph off and on
#
CREATE TABLE t1 (x INT);
INSERT INTO t1 VALUES (1), (2);
CREATE TABLE t2 (pk INT PRIMARY KEY);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (6), (7), (8);
SELECT t1.x FROM t1, t2 WHERE t1.x = t2.pk
GROUP BY t1.x
HAVING (COUNT(*) = 3 AND COUNT(*) > 6) OR t1.x = 2;
x
2
DROP TABLE t1, t2;
#
# Bug#34682586: MySQL server crash, segmentation fault: count_field_types
#
CREATE TABLE t1 (pk INT PRIMARY KEY, x INT);
INSERT INTO t1(pk) VALUES (1), (2), (3), (4), (5);
CREATE TABLE t2 (x INT);
PREPARE ps FROM
'SELECT 1 FROM t1, (SELECT DISTINCT x FROM t2) AS ot2
 WHERE t1.pk = ot2.x GROUP BY ot2.x, t1.x';
EXECUTE ps;
1
EXECUTE ps;
1
DEALLOCATE PREPARE ps;
DROP TABLE t1, t2;
#
# Bug#34727088: Assertion `!OrderItemsReferenceUnavailableTables(path, tables)' failed.
#
CREATE TABLE t1 (pk INT PRIMARY KEY, x INT);
INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3);
CREATE TABLE t2 (pk INT PRIMARY KEY);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5);
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
SELECT DISTINCT t1.x FROM t1, t2 WHERE t1.x = t2.pk GROUP BY t1.pk;
x
1
2
3
DROP TABLE t1, t2;
