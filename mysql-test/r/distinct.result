drop table if exists t1,t2,t3;
CREATE TABLE t1 (id int,facility char(20));
CREATE TABLE t2 (facility char(20));
INSERT INTO t1 VALUES (NULL,NULL);
INSERT INTO t1 VALUES (-1,'');
INSERT INTO t1 VALUES (0,'');
INSERT INTO t1 VALUES (1,'/L');
INSERT INTO t1 VALUES (2,'A01');
INSERT INTO t1 VALUES (3,'ANC');
INSERT INTO t1 VALUES (4,'F01');
INSERT INTO t1 VALUES (5,'FBX');
INSERT INTO t1 VALUES (6,'MT');
INSERT INTO t1 VALUES (7,'P');
INSERT INTO t1 VALUES (8,'RV');
INSERT INTO t1 VALUES (9,'SRV');
INSERT INTO t1 VALUES (10,'VMT');
INSERT INTO t2 SELECT DISTINCT FACILITY FROM t1;
select id from t1 group by id;
id
NULL
-1
0
1
2
3
4
5
6
7
8
9
10
select * from t1 order by id;
id	facility
NULL	NULL
-1	
0	
1	/L
2	A01
3	ANC
4	F01
5	FBX
6	MT
7	P
8	RV
9	SRV
10	VMT
select id-5,facility from t1 order by "id-5";
id-5	facility
NULL	NULL
-6	
-5	
-4	/L
-3	A01
-2	ANC
-1	F01
0	FBX
1	MT
2	P
3	RV
4	SRV
5	VMT
select id,concat(facility) from t1 group by id ;
id	concat(facility)
NULL	NULL
-1	
0	
1	/L
2	A01
3	ANC
4	F01
5	FBX
6	MT
7	P
8	RV
9	SRV
10	VMT
select id+0 as a,max(id),concat(facility) as b from t1 group by a order by b desc,a;
a	max(id)	b
10	10	VMT
9	9	SRV
8	8	RV
7	7	P
6	6	MT
5	5	FBX
4	4	F01
3	3	ANC
2	2	A01
1	1	/L
-1	-1	
0	0	
NULL	NULL	NULL
select id >= 0 and id <= 5 as grp,count(*) from t1 group by grp;
grp	count(*)
NULL	1
0	6
1	6
SELECT DISTINCT FACILITY FROM t1;
FACILITY
NULL

/L
A01
ANC
F01
FBX
MT
P
RV
SRV
VMT
SELECT FACILITY FROM t2;
FACILITY
NULL

/L
A01
ANC
F01
FBX
MT
P
RV
SRV
VMT
SELECT count(*) from t1,t2 where t1.facility=t2.facility;
count(*)
12
select count(facility) from t1;
count(facility)
12
select count(*) from t1;
count(*)
13
select count(*) from t1 where facility IS NULL;
count(*)
1
select count(*) from t1 where facility = NULL;
count(*)
0
select count(*) from t1 where facility IS NOT NULL;
count(*)
12
select count(*) from t1 where id IS NULL;
count(*)
1
select count(*) from t1 where id IS NOT NULL;
count(*)
12
drop table t1,t2;
CREATE TABLE t1 (UserId int(11) DEFAULT '0' NOT NULL);
INSERT INTO t1 VALUES (20);
INSERT INTO t1 VALUES (27);
SELECT UserId FROM t1 WHERE Userid=22;
UserId
SELECT UserId FROM t1 WHERE UserId=22 group by Userid;
UserId
SELECT DISTINCT UserId FROM t1 WHERE UserId=22 group by Userid;
UserId
SELECT DISTINCT UserId FROM t1 WHERE UserId=22;
UserId
drop table t1;
CREATE TABLE t1 (a int(10) unsigned not null primary key,b int(10) unsigned);
INSERT INTO t1 VALUES (1,1),(2,1),(3,1),(4,1);
CREATE TABLE t2 (a int(10) unsigned not null, key (A));
INSERT INTO t2 VALUES (1),(2);
CREATE TABLE t3 (a int(10) unsigned, key(A), b text);
INSERT INTO t3 VALUES (1,'1'),(2,'2');
SELECT DISTINCT t3.b FROM t3,t2,t1 WHERE t3.a=t1.b AND t1.a=t2.a;
b
1
INSERT INTO t2 values (1),(2),(3);
INSERT INTO t3 VALUES (1,'1'),(2,'2'),(1,'1'),(2,'2');
explain SELECT distinct t3.a FROM t3,t2,t1 WHERE t3.a=t1.b AND t1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	a	a	4	NULL	5	100.00	Using index; Using temporary
1	SIMPLE	t1	NULL	eq_ref	PRIMARY	PRIMARY	4	test.t2.a	1	100.00	Using where
1	SIMPLE	t3	NULL	ref	a	a	5	test.t1.b	2	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t3`.`a` AS `a` from `test`.`t3` join `test`.`t2` join `test`.`t1` where ((`test`.`t1`.`a` = `test`.`t2`.`a`) and (`test`.`t3`.`a` = `test`.`t1`.`b`))
SELECT distinct t3.a FROM t3,t2,t1 WHERE t3.a=t1.b AND t1.a=t2.a;
a
1
create temporary table t4 select * from t3;
insert into t3 select * from t4;
insert into t4 select * from t3;
insert into t3 select * from t4;
insert into t4 select * from t3;
insert into t3 select * from t4;
insert into t4 select * from t3;
insert into t3 select * from t4;
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
explain select distinct t1.a from t1,t3 where t1.a=t3.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	4	100.00	Using index; Using temporary
1	SIMPLE	t3	NULL	ref	a	a	5	test.t1.a	102	100.00	Using index; Distinct
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` join `test`.`t3` where (`test`.`t3`.`a` = `test`.`t1`.`a`)
flush status;
select distinct t1.a from t1,t3 where t1.a=t3.a;
a
1
2
show status like 'Handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	4
Handler_read_last	0
Handler_read_next	4
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	3
flush status;
select distinct 1 from t1,t3 where t1.a=t3.a;
1
1
show status like 'Handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	4
Handler_read_last	0
Handler_read_next	208
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	1
explain SELECT distinct t1.a from t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	4	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT distinct t1.a from t1 order by a desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	4	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` order by `test`.`t1`.`a` desc
explain SELECT t1.a from t1 group by a order by a desc;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	4	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` group by `test`.`t1`.`a` order by `test`.`t1`.`a` desc
explain SELECT distinct t1.a from t1 order by a desc limit 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	1	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` order by `test`.`t1`.`a` desc limit 1
explain SELECT distinct a from t3 order by a desc limit 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	index	a	a	5	NULL	204	100.00	Backward index scan; Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t3`.`a` AS `a` from `test`.`t3` order by `test`.`t3`.`a` desc limit 2
explain SELECT distinct a,b from t3 order by a+1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	204	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t3`.`a` AS `a`,`test`.`t3`.`b` AS `b` from `test`.`t3` order by (`test`.`t3`.`a` + 1)
explain SELECT distinct a,b from t3 order by a limit 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	index	NULL	a	5	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t3`.`a` AS `a`,`test`.`t3`.`b` AS `b` from `test`.`t3` order by `test`.`t3`.`a` limit 2
explain SELECT a,b from t3 group by a,b order by a+1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	204	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a`,`test`.`t3`.`b` AS `b` from `test`.`t3` group by `test`.`t3`.`a`,`test`.`t3`.`b` order by (`test`.`t3`.`a` + 1)
 SELECT distinct t1.a from t1;
a
1
2
3
4
 SELECT distinct t1.a from t1 order by a desc;
a
4
3
2
1
 SELECT t1.a from t1 group by a order by a desc;
a
4
3
2
1
 SELECT distinct t1.a from t1 order by a desc limit 1;
a
4
 SELECT distinct a from t3 order by a desc limit 2;
a
2
1
 SELECT distinct a,b from t3 order by a+1;
a	b
1	1
2	2
 SELECT distinct a,b from t3 order by a limit 2;
a	b
1	1
2	2
 SELECT a,b from t3 group by a,b order by a+1;
a	b
1	1
2	2
drop table t1,t2,t3,t4;
CREATE TABLE t1 (name varchar(255));
INSERT INTO t1 VALUES ('aa'),('ab'),('ac'),('ad'),('ae');
SELECT DISTINCT * FROM t1 LIMIT 2;
name
aa
ab
SELECT DISTINCT name FROM t1 LIMIT 2;
name
aa
ab
SELECT DISTINCT 1 FROM t1 LIMIT 2;
1
1
drop table t1;
CREATE TABLE t1 (
ID int(11) NOT NULL auto_increment,
NAME varchar(75) DEFAULT '' NOT NULL,
LINK_ID int(11) DEFAULT '0' NOT NULL,
PRIMARY KEY (ID),
KEY NAME (NAME),
KEY LINK_ID (LINK_ID)
);
INSERT INTO t1 (ID, NAME, LINK_ID) VALUES (1,'Mike',0),(2,'Jack',0),(3,'Bill',0);
CREATE TABLE t2 (
ID int(11) NOT NULL auto_increment,
NAME varchar(150) DEFAULT '' NOT NULL,
PRIMARY KEY (ID),
KEY NAME (NAME)
);
SELECT DISTINCT
t2.id AS key_link_id,
t2.name AS link
FROM t1
LEFT JOIN t2 ON t1.link_id=t2.id
GROUP BY t1.id
ORDER BY link;
key_link_id	link
NULL	NULL
drop table t1,t2;
create table t1 (
id		int not null,
name	tinytext not null,
unique	(id)
);
create table t2 (
id		int not null,
idx		int not null,
unique	(id, idx)
);
create table t3 (
id		int not null,
idx		int not null,
unique	(id, idx)
);
insert into t1 values (1,'yes'), (2,'no');
insert into t2 values (1,1);
insert into t3 values (1,1);
EXPLAIN
SELECT DISTINCT
t1.id
from
t1
straight_join
t2
straight_join
t3
straight_join
t1 as j_lj_t2 left join t2 as t2_lj
on j_lj_t2.id=t2_lj.id
straight_join
t1 as j_lj_t3 left join t3 as t3_lj
on j_lj_t3.id=t3_lj.id
WHERE
((t1.id=j_lj_t2.id AND t2_lj.id IS NULL) OR (t1.id=t2.id AND t2.idx=2))
AND ((t1.id=j_lj_t3.id AND t3_lj.id IS NULL) OR (t1.id=t3.id AND t3.idx=2));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	id	id	4	NULL	2	100.00	Using index; Using temporary
1	SIMPLE	t2	NULL	index	id	id	8	NULL	1	100.00	Using index; Distinct; Using join buffer (Block Nested Loop)
1	SIMPLE	t3	NULL	index	id	id	8	NULL	1	100.00	Using index; Distinct; Using join buffer (Block Nested Loop)
1	SIMPLE	j_lj_t2	NULL	index	id	id	4	NULL	2	100.00	Using where; Using index; Distinct; Using join buffer (Block Nested Loop)
1	SIMPLE	t2_lj	NULL	index	id	id	8	NULL	1	100.00	Using where; Using index; Distinct; Using join buffer (Block Nested Loop)
1	SIMPLE	j_lj_t3	NULL	index	id	id	4	NULL	2	100.00	Using where; Using index; Distinct; Using join buffer (Block Nested Loop)
1	SIMPLE	t3_lj	NULL	index	id	id	8	NULL	1	100.00	Using where; Using index; Distinct; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`id` AS `id` from `test`.`t1` straight_join `test`.`t2` straight_join `test`.`t3` straight_join `test`.`t1` `j_lj_t2` left join `test`.`t2` `t2_lj` on((`test`.`t2_lj`.`id` = `test`.`j_lj_t2`.`id`)) straight_join `test`.`t1` `j_lj_t3` left join `test`.`t3` `t3_lj` on((`test`.`t3_lj`.`id` = `test`.`j_lj_t3`.`id`)) where ((((`test`.`j_lj_t2`.`id` = `test`.`t1`.`id`) and isnull(`test`.`t2_lj`.`id`)) or ((`test`.`t2`.`idx` = 2) and (`test`.`t2`.`id` = `test`.`t1`.`id`))) and (((`test`.`j_lj_t3`.`id` = `test`.`t1`.`id`) and isnull(`test`.`t3_lj`.`id`)) or ((`test`.`t3`.`idx` = 2) and (`test`.`t3`.`id` = `test`.`t1`.`id`))))
SELECT DISTINCT
t1.id
from
t1
straight_join
t2
straight_join
t3
straight_join
t1 as j_lj_t2 left join t2 as t2_lj
on j_lj_t2.id=t2_lj.id
straight_join
t1 as j_lj_t3 left join t3 as t3_lj
on j_lj_t3.id=t3_lj.id
WHERE
((t1.id=j_lj_t2.id AND t2_lj.id IS NULL) OR (t1.id=t2.id AND t2.idx=2))
AND ((t1.id=j_lj_t3.id AND t3_lj.id IS NULL) OR (t1.id=t3.id AND t3.idx=2));
id
2
drop table t1,t2,t3;
create table t1 (a int not null, b int not null, t time);
insert into t1 values (1,1,"00:06:15"),(1,2,"00:06:15"),(1,2,"00:30:15"),(1,3,"00:06:15"),(1,3,"00:30:15");
select a,sec_to_time(sum(time_to_sec(t))) from t1 group by a,b;
a	sec_to_time(sum(time_to_sec(t)))
1	00:06:15
1	00:36:30
1	00:36:30
select distinct a,sec_to_time(sum(time_to_sec(t))) from t1 group by a,b;
a	sec_to_time(sum(time_to_sec(t)))
1	00:06:15
1	00:36:30
create table t2 (a int not null primary key, b int);
insert into t2 values (1,1),(2,2),(3,3);
select t1.a,sec_to_time(sum(time_to_sec(t))) from t1 left join t2 on (t1.b=t2.a) group by t1.a,t2.b;
a	sec_to_time(sum(time_to_sec(t)))
1	00:06:15
1	00:36:30
1	00:36:30
select distinct t1.a,sec_to_time(sum(time_to_sec(t))) from t1 left join t2 on (t1.b=t2.a) group by t1.a,t2.b;
a	sec_to_time(sum(time_to_sec(t)))
1	00:06:15
1	00:36:30
drop table t1,t2;
create table t1 (a int not null,b char(5), c text);
insert into t1 (a) values (1),(2),(3),(4),(1),(2),(3),(4);
select distinct a from t1 group by b,a having a > 2 order by a desc;
a
4
3
select distinct a,c from t1 group by b,c,a having a > 2 order by a desc;
a	c
4	NULL
3	NULL
drop table t1;
create table t1 (a char(1), key(a)) engine=myisam;
insert into t1 values('1'),('1');
select * from t1 where a >= '1';
a
1
1
select distinct a from t1 order by a desc;
a
1
select distinct a from t1 where a >= '1' order by a desc;
a
1
drop table t1;
CREATE TABLE t1 (email varchar(50), infoID BIGINT, dateentered DATETIME);
CREATE TABLE t2 (infoID BIGINT, shipcode varchar(10));
INSERT INTO t1 (email, infoID, dateentered) VALUES
('test1@testdomain.com', 1, '2002-07-30 22:56:38'),
('test1@testdomain.com', 1, '2002-07-27 22:58:16'),
('test2@testdomain.com', 1, '2002-06-19 15:22:19'),
('test2@testdomain.com', 2, '2002-06-18 14:23:47'),
('test3@testdomain.com', 1, '2002-05-19 22:17:32');
INSERT INTO t2(infoID, shipcode) VALUES
(1, 'Z001'),
(2, 'R002');
SELECT DISTINCTROW email, shipcode FROM t1, t2 WHERE t1.infoID=t2.infoID;
email	shipcode
test1@testdomain.com	Z001
test2@testdomain.com	Z001
test2@testdomain.com	R002
test3@testdomain.com	Z001
SELECT DISTINCTROW email FROM t1 ORDER BY dateentered DESC;
email
test1@testdomain.com
test2@testdomain.com
test3@testdomain.com
SELECT DISTINCTROW email, shipcode FROM t1, t2 WHERE t1.infoID=t2.infoID ORDER BY dateentered DESC;
email	shipcode
test1@testdomain.com	Z001
test2@testdomain.com	Z001
test2@testdomain.com	R002
test3@testdomain.com	Z001
drop table t1,t2;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1 (privatemessageid int(10) unsigned NOT NULL auto_increment,  folderid smallint(6) NOT NULL default '0',  userid int(10) unsigned NOT NULL default '0',  touserid int(10) unsigned NOT NULL default '0',  fromuserid int(10) unsigned NOT NULL default '0',  title varchar(250) NOT NULL default '',  message mediumtext NOT NULL,  dateline int(10) unsigned NOT NULL default '0',  showsignature smallint(6) NOT NULL default '0',  iconid smallint(5) unsigned NOT NULL default '0',  messageread smallint(6) NOT NULL default '0',  readtime int(10) unsigned NOT NULL default '0',  receipt smallint(6) unsigned NOT NULL default '0',  deleteprompt smallint(6) unsigned NOT NULL default '0',  multiplerecipients smallint(6) unsigned NOT NULL default '0',  PRIMARY KEY  (privatemessageid),  KEY userid (userid)) ENGINE=MyISAM;
INSERT INTO t1 VALUES (128,0,33,33,8,':D','',996121863,1,0,2,996122850,2,0,0);
CREATE TABLE t2 (userid int(10) unsigned NOT NULL auto_increment,  usergroupid smallint(5) unsigned NOT NULL default '0',  username varchar(50) NOT NULL default '',  password varchar(50) NOT NULL default '',  email varchar(50) NOT NULL default '',  styleid smallint(5) unsigned NOT NULL default '0',  parentemail varchar(50) NOT NULL default '',  coppauser smallint(6) NOT NULL default '0',  homepage varchar(100) NOT NULL default '',  icq varchar(20) NOT NULL default '',  aim varchar(20) NOT NULL default '',  yahoo varchar(20) NOT NULL default '',  signature mediumtext NOT NULL,  adminemail smallint(6) NOT NULL default '0',  showemail smallint(6) NOT NULL default '0',  invisible smallint(6) NOT NULL default '0',  usertitle varchar(250) NOT NULL default '',  customtitle smallint(6) NOT NULL default '0',  joindate int(10) unsigned NOT NULL default '0',  cookieuser smallint(6) NOT NULL default '0',  daysprune smallint(6) NOT NULL default '0',  lastvisit int(10) unsigned NOT NULL default '0',  lastactivity int(10) unsigned NOT NULL default '0',  lastpost int(10) unsigned NOT NULL default '0',  posts smallint(5) unsigned NOT NULL default '0',  timezoneoffset varchar(4) NOT NULL default '',  emailnotification smallint(6) NOT NULL default '0',  buddylist mediumtext NOT NULL,  ignorelist mediumtext NOT NULL,  pmfolders mediumtext NOT NULL,  receivepm smallint(6) NOT NULL default '0',  emailonpm smallint(6) NOT NULL default '0',  pmpopup smallint(6) NOT NULL default '0',  avatarid smallint(6) NOT NULL default '0',  avatarrevision int(6) unsigned NOT NULL default '0',  options smallint(6) NOT NULL default '15',  birthday date NOT NULL default '0000-00-00',  maxposts smallint(6) NOT NULL default '-1',  startofweek smallint(6) NOT NULL default '1',  ipaddress varchar(20) NOT NULL default '',  referrerid int(10) unsigned NOT NULL default '0',  nosessionhash smallint(6) NOT NULL default '0',  autorefresh smallint(6) NOT NULL default '-1',  messagepopup tinyint(2) NOT NULL default '0',  inforum smallint(5) unsigned NOT NULL default '0',  ratenum smallint(5) unsigned NOT NULL default '0',  ratetotal smallint(5) unsigned NOT NULL default '0',  allowrate smallint(5) unsigned NOT NULL default '1',  PRIMARY KEY  (userid),  KEY usergroupid (usergroupid),  KEY username (username),  KEY inforum (inforum)) ENGINE=MyISAM;
INSERT INTO t2 VALUES (33,6,'Kevin','0','kevin@stileproject.com',1,'',0,'http://www.stileproject.com','','','','',1,1,0,'Administrator',0,996120694,1,-1,1030996168,1031027028,1030599436,36,'-6',0,'','','',1,0,1,0,0,15,'0000-00-00',-1,1,'64.0.0.0',0,1,-1,0,0,4,19,1);
SELECT DISTINCT t1.*, t2.* FROM t1 LEFT JOIN t2 ON (t2.userid = t1.touserid);
privatemessageid	folderid	userid	touserid	fromuserid	title	message	dateline	showsignature	iconid	messageread	readtime	receipt	deleteprompt	multiplerecipients	userid	usergroupid	username	password	email	styleid	parentemail	coppauser	homepage	icq	aim	yahoo	signature	adminemail	showemail	invisible	usertitle	customtitle	joindate	cookieuser	daysprune	lastvisit	lastactivity	lastpost	posts	timezoneoffset	emailnotification	buddylist	ignorelist	pmfolders	receivepm	emailonpm	pmpopup	avatarid	avatarrevision	options	birthday	maxposts	startofweek	ipaddress	referrerid	nosessionhash	autorefresh	messagepopup	inforum	ratenum	ratetotal	allowrate
128	0	33	33	8	:D		996121863	1	0	2	996122850	2	0	0	33	6	Kevin	0	kevin@stileproject.com	1		0	http://www.stileproject.com					1	1	0	Administrator	0	996120694	1	-1	1030996168	1031027028	1030599436	36	-6	0				1	0	1	0	0	15	0000-00-00	-1	1	64.0.0.0	0	1	-1	0	0	4	19	1
DROP TABLE t1,t2;
SET sql_mode = default;
CREATE TABLE t1 (a int primary key, b int, c int);
INSERT t1 VALUES (1,2,3);
CREATE TABLE t2 (a int primary key, b int, c int);
INSERT t2 VALUES (3,4,5);
SELECT DISTINCT t1.a, t2.b FROM t1, t2 WHERE t1.a=1 ORDER BY t2.c;
a	b
1	4
DROP TABLE t1,t2;
CREATE table t1 (  `id` int(11) NOT NULL auto_increment,  `name` varchar(50) NOT NULL default '',  PRIMARY KEY  (`id`)) ENGINE=MyISAM AUTO_INCREMENT=3 ;
INSERT INTO t1 VALUES (1, 'aaaaa');
INSERT INTO t1 VALUES (3, 'aaaaa');
INSERT INTO t1 VALUES (2, 'eeeeeee');
select distinct left(name,1) as name from t1;
name
a
e
drop  table t1;
CREATE TABLE t1 (
ID int(11) NOT NULL auto_increment,
NAME varchar(75) DEFAULT '' NOT NULL,
LINK_ID int(11) DEFAULT '0' NOT NULL,
PRIMARY KEY (ID),
KEY NAME (NAME),
KEY LINK_ID (LINK_ID)
);
INSERT INTO t1 (ID, NAME, LINK_ID) VALUES (1,'Mike',0);
INSERT INTO t1 (ID, NAME, LINK_ID) VALUES (2,'Jack',0);
INSERT INTO t1 (ID, NAME, LINK_ID) VALUES (3,'Bill',0);
CREATE TABLE t2 (
ID int(11) NOT NULL auto_increment,
NAME varchar(150) DEFAULT '' NOT NULL,
PRIMARY KEY (ID),
KEY NAME (NAME)
);
SELECT DISTINCT
t2.id AS key_link_id,
t2.name AS link
FROM t1
LEFT JOIN t2 ON t1.link_id=t2.id
GROUP BY t1.id
ORDER BY link;
key_link_id	link
NULL	NULL
drop table t1,t2;
CREATE TABLE t1 (
html varchar(5) default NULL,
rin int(11) default '0',
rout int(11) default '0'
) ENGINE=MyISAM;
INSERT INTO t1 VALUES ('1',1,0);
SELECT DISTINCT html,SUM(rout)/(SUM(rin)+1) as 'prod' FROM t1 GROUP BY rin;
html	prod
1	0.0000
drop table t1;
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1),(2),(3),(4),(5);
SELECT DISTINCT a, 1 FROM t1;
a	1
1	1
2	1
3	1
4	1
5	1
SELECT DISTINCT 1, a FROM t1;
1	a
1	1
1	2
1	3
1	4
1	5
CREATE TABLE t2 (a int, b int);
INSERT INTO t2 VALUES (1,1),(2,2),(2,3),(2,4),(3,5);
SELECT DISTINCT a, b, 2 FROM t2;
a	b	2
1	1	2
2	2	2
2	3	2
2	4	2
3	5	2
SELECT DISTINCT 2, a, b FROM t2;
2	a	b
2	1	1
2	2	2
2	2	3
2	2	4
2	3	5
SELECT DISTINCT a, 2, b FROM t2;
a	2	b
1	2	1
2	2	2
2	2	3
2	2	4
3	2	5
DROP TABLE t1,t2;
CREATE TABLE t1(a INT PRIMARY KEY, b INT);
INSERT INTO t1 VALUES (1,1), (2,1), (3,1);
EXPLAIN SELECT DISTINCT a FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`
EXPLAIN SELECT DISTINCT a,b FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1`
EXPLAIN SELECT DISTINCT t1_1.a, t1_1.b FROM t1 t1_1, t1 t1_2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1_1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using temporary
1	SIMPLE	t1_2	NULL	index	NULL	PRIMARY	4	NULL	3	100.00	Using index; Distinct; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1_1`.`a` AS `a`,`test`.`t1_1`.`b` AS `b` from `test`.`t1` `t1_1` join `test`.`t1` `t1_2`
EXPLAIN SELECT DISTINCT t1_1.a, t1_1.b FROM t1 t1_1, t1 t1_2
WHERE t1_1.a = t1_2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1_1	NULL	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	Using temporary
1	SIMPLE	t1_2	NULL	eq_ref	PRIMARY	PRIMARY	4	test.t1_1.a	1	100.00	Using index; Distinct
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1_1`.`a` AS `a`,`test`.`t1_1`.`b` AS `b` from `test`.`t1` `t1_1` join `test`.`t1` `t1_2` where (`test`.`t1_2`.`a` = `test`.`t1_1`.`a`)
EXPLAIN SELECT a FROM t1 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	4	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` group by `test`.`t1`.`a`
EXPLAIN SELECT a,b FROM t1 GROUP BY a,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` group by `test`.`t1`.`a`,`test`.`t1`.`b`
EXPLAIN SELECT DISTINCT a,b FROM t1 GROUP BY a,b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` group by `test`.`t1`.`a`,`test`.`t1`.`b`
CREATE TABLE t2(a INT, b INT NOT NULL, c INT NOT NULL, d INT, 
PRIMARY KEY (a,b));
INSERT INTO t2 VALUES (1,1,1,50), (1,2,3,40), (2,1,3,4);
EXPLAIN SELECT DISTINCT a FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	PRIMARY	PRIMARY	8	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a` from `test`.`t2`
EXPLAIN SELECT DISTINCT a,a FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	PRIMARY	PRIMARY	8	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`a` AS `a` from `test`.`t2`
EXPLAIN SELECT DISTINCT b,a FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	PRIMARY	PRIMARY	8	NULL	3	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a` from `test`.`t2`
EXPLAIN SELECT DISTINCT a,c FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`c` AS `c` from `test`.`t2`
EXPLAIN SELECT DISTINCT c,a,b FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`c` AS `c`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2`
EXPLAIN SELECT DISTINCT a,b,d FROM t2 GROUP BY c,b,d;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`d` AS `d` from `test`.`t2` group by `test`.`t2`.`c`,`test`.`t2`.`b`,`test`.`t2`.`d`
CREATE UNIQUE INDEX c_b_unq ON t2 (c,b);
EXPLAIN SELECT DISTINCT a,b,d FROM t2 GROUP BY c,b,d;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`d` AS `d` from `test`.`t2` group by `test`.`t2`.`c`,`test`.`t2`.`b`,`test`.`t2`.`d`
DROP TABLE t1,t2;
create table t1 (id int, dsc varchar(50));
insert into t1 values (1, "line number one"), (2, "line number two"), (3, "line number three");
select distinct id, IFNULL(dsc, '-') from t1;
id	IFNULL(dsc, '-')
1	line number one
2	line number two
3	line number three
drop table t1;
CREATE TABLE t1 (a int primary key, b int);
INSERT INTO t1 (a,b) values (1,1), (2,3), (3,2);
explain SELECT DISTINCT a, b FROM t1 ORDER BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` order by `test`.`t1`.`b`
SELECT DISTINCT a, b FROM t1 ORDER BY b;
a	b
1	1
3	2
2	3
DROP TABLE t1;
CREATE TABLE t1 (
ID int(11) NOT NULL auto_increment,
x varchar(20) default NULL,
y decimal(10,0) default NULL,
PRIMARY KEY  (ID),
KEY (y)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t1 VALUES
(1,'ba','-1'),
(2,'ba','1150'),
(306,'ba','-1'),
(307,'ba','1150'),
(611,'ba','-1'),
(612,'ba','1150');
select count(distinct x,y) from t1;
count(distinct x,y)
2
select count(distinct concat(x,y)) from t1;
count(distinct concat(x,y))
2
drop table t1;
CREATE TABLE t1 (a INT, b INT, PRIMARY KEY (a,b));
INSERT INTO t1 VALUES (1, 101);
INSERT INTO t1 SELECT a + 1, a + 101 FROM t1;
INSERT INTO t1 SELECT a + 2, a + 102 FROM t1;
INSERT INTO t1 SELECT a + 4, a + 104 FROM t1;
INSERT INTO t1 SELECT a + 8, a + 108 FROM t1;
EXPLAIN SELECT DISTINCT a,a FROM t1 WHERE b < 12 ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY	PRIMARY	8	NULL	16	33.33	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a`,`test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`b` < 12) order by `test`.`t1`.`a`
SELECT DISTINCT a,a FROM t1 WHERE b < 12 ORDER BY a;
a	a
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (id INT NOT NULL, fruit_id INT NOT NULL, fruit_name varchar(20)
default NULL);
INSERT INTO t1 VALUES (1,1,'ORANGE');
INSERT INTO t1 VALUES (2,2,'APPLE');
INSERT INTO t1 VALUES (3,2,'APPLE');
INSERT INTO t1 VALUES (4,3,'PEAR');
SELECT DISTINCT fruit_id, fruit_name INTO @v1, @v2 FROM t1 WHERE fruit_name = 
'APPLE';
SELECT @v1, @v2;
@v1	@v2
2	APPLE
SELECT DISTINCT fruit_id, fruit_name INTO @v3, @v4 FROM t1 GROUP BY fruit_id, 
fruit_name HAVING fruit_name = 'APPLE';
SELECT @v3, @v4;
@v3	@v4
2	APPLE
SELECT DISTINCT @v5:= fruit_id, @v6:= fruit_name INTO @v7, @v8 FROM t1 WHERE 
fruit_name = 'APPLE';
SELECT @v5, @v6, @v7, @v8;
@v5	@v6	@v7	@v8
2	APPLE	2	APPLE
SELECT DISTINCT @v5 + fruit_id, CONCAT(@v6, fruit_name) INTO @v9, @v10 FROM t1 
WHERE fruit_name = 'APPLE';
SELECT @v5, @v6, @v7, @v8, @v9, @v10;
@v5	@v6	@v7	@v8	@v9	@v10
2	APPLE	2	APPLE	4	APPLEAPPLE
SELECT DISTINCT @v11:= @v5 + fruit_id, @v12:= CONCAT(@v6, fruit_name) INTO 
@v13, @v14 FROM t1 WHERE fruit_name = 'APPLE';
SELECT @v11, @v12, @v13, @v14;
@v11	@v12	@v13	@v14
4	APPLEAPPLE	4	APPLEAPPLE
SELECT DISTINCT @v13, @v14 INTO @v15, @v16 FROM t1 WHERE fruit_name = 'APPLE';
SELECT @v15, @v16;
@v15	@v16
4	APPLEAPPLE
SELECT DISTINCT 2 + 2, 'Bob' INTO @v17, @v18 FROM t1 WHERE fruit_name = 
'APPLE';
SELECT @v17, @v18;
@v17	@v18
4	Bob
DROP TABLE IF EXISTS t2;
CREATE TABLE t2 (fruit_id INT NOT NULL, fruit_name varchar(20)
default NULL);
SELECT DISTINCT fruit_id, fruit_name INTO OUTFILE 
'../../tmp/data1.tmp' FROM t1 WHERE fruit_name = 'APPLE';
LOAD DATA INFILE '../../tmp/data1.tmp' INTO TABLE t2;
SELECT DISTINCT @v19:= fruit_id, @v20:= fruit_name INTO OUTFILE 
'../../tmp/data2.tmp' FROM t1 WHERE fruit_name = 'APPLE';
LOAD DATA INFILE '../../tmp/data2.tmp' INTO TABLE t2;
SELECT @v19, @v20;
@v19	@v20
2	APPLE
SELECT * FROM t2;
fruit_id	fruit_name
2	APPLE
2	APPLE
DROP TABLE t1;
DROP TABLE t2;
CREATE TABLE t1 (a CHAR(1));
INSERT INTO t1 VALUES('A'), (0);
SELECT a FROM t1 WHERE a=0;
a
A
0
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'A'
SELECT DISTINCT a FROM t1 WHERE a=0;
a
A
0
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'A'
DROP TABLE t1;
CREATE TABLE t1 (a DATE);
INSERT INTO t1 VALUES ('1972-07-29'), ('1972-02-06');
EXPLAIN SELECT (SELECT DISTINCT a FROM t1 WHERE a = '2002-08-03');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select distinct `test`.`t1`.`a` from `test`.`t1` where (`test`.`t1`.`a` = '2002-08-03')) AS `(SELECT DISTINCT a FROM t1 WHERE a = '2002-08-03')`
EXPLAIN SELECT (SELECT DISTINCT ADDDATE(a,1) FROM t1
WHERE ADDDATE(a,1) = '2002-08-03');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select distinct (`test`.`t1`.`a` + interval 1 day) from `test`.`t1` where ((`test`.`t1`.`a` + interval 1 day) = '2002-08-03')) AS `(SELECT DISTINCT ADDDATE(a,1) FROM t1
WHERE ADDDATE(a,1) = '2002-08-03')`
CREATE TABLE t2 (a CHAR(5) CHARACTER SET latin1 COLLATE latin1_general_ci);
INSERT INTO t2 VALUES (0xf6);
INSERT INTO t2 VALUES ('oe');
SELECT COUNT(*) FROM (SELECT DISTINCT a FROM t2) dt;
COUNT(*)
2
set names latin1;
SELECT COUNT(*) FROM 
(SELECT DISTINCT a FROM t2 WHERE a='oe' COLLATE latin1_german2_ci) dt;
COUNT(*)
2
set names utf8mb4;
DROP TABLE t1, t2;
CREATE TABLE t1 (a INT, UNIQUE (a));
INSERT INTO t1 VALUES (4),(null),(2),(1),(null),(3);
EXPLAIN SELECT DISTINCT a FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	a	a	5	NULL	6	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`
SELECT DISTINCT a FROM t1;
a
NULL
1
2
3
4
EXPLAIN SELECT a FROM t1 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	a	a	5	NULL	6	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` group by `test`.`t1`.`a`
SELECT a FROM t1 GROUP BY a;
a
NULL
1
2
3
4
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES(1,1),(1,2),(1,3);
SELECT DISTINCT a, b FROM t1;
a	b
1	1
1	2
1	3
SELECT DISTINCT a, a, b FROM t1;
a	a	b
1	1	1
1	1	2
1	1	3
DROP TABLE t1;
End of 5.0 tests
CREATE TABLE t1(a INT, b INT, c INT, d INT, e INT,
PRIMARY KEY(a,b,c,d,e),
KEY(a,b,d,c)
);
INSERT IGNORE INTO t1(a, b, c) VALUES (1, 1, 1),
(1, 1, 2),
(1, 1, 3),
(1, 2, 1),
(1, 2, 2),
(1, 2, 3);
Warnings:
Warning	1364	Field 'd' doesn't have a default value
Warning	1364	Field 'e' doesn't have a default value
EXPLAIN SELECT DISTINCT a, b, d, c FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	PRIMARY,a	a	16	NULL	6	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`d` AS `d`,`test`.`t1`.`c` AS `c` from `test`.`t1`
SELECT DISTINCT a, b, d, c FROM t1;
a	b	d	c
1	1	0	1
1	1	0	2
1	1	0	3
1	2	0	1
1	2	0	2
1	2	0	3
DROP TABLE t1;
#
# Bug #46159: simple query that never returns
#
SET @old_max_heap_table_size = @@max_heap_table_size;
SET @@max_heap_table_size = 16384;
SET @old_sort_buffer_size = @@sort_buffer_size;
SET @@sort_buffer_size = 32804;
CREATE TABLE t1(c1 int, c2 VARCHAR(20));
INSERT INTO t1 VALUES (1, '1'), (1, '1'), (2, '2'), (3, '1'), (3, '1'), (4, '4');
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
INSERT INTO t1 SELECT 5 + 10000 * RAND(), '5' FROM t1;
SELECT c1, c2, COUNT(*) FROM t1 GROUP BY c1 LIMIT 4;
c1	c2	COUNT(*)
1	1	2
2	2	1
3	1	2
4	4	1
SELECT DISTINCT c2 FROM t1 GROUP BY c1 HAVING COUNT(*) > 1;
c2
1
5
DROP TABLE t1;
SET @@sort_buffer_size = @old_sort_buffer_size;
SET @@max_heap_table_size = @old_max_heap_table_size;
End of 5.1 tests
#
# Bug #11744875: 4082: integer lengths cause truncation with distinct concat and innodb
#
CREATE TABLE t1 (a INT(1), b INT(1));
INSERT INTO t1 VALUES (1111, 2222), (3333, 4444);
SELECT DISTINCT CONCAT(a,b) AS c FROM t1 ORDER BY 1;
c
11112222
33334444
DROP TABLE t1;
#
# Bug#16539979 BASIC SELECT COUNT(DISTINCT ID) IS BROKEN.
# Bug#17867117 ERROR RESULT WHEN "COUNT + DISTINCT + CASE WHEN" NEED MERGE_WALK 
#
SET @tmp_table_size_save= @@tmp_table_size;
SET @@tmp_table_size= 1024;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3),(4),(5),(6),(7),(8);
INSERT INTO t1 SELECT a+8 FROM t1;
INSERT INTO t1 SELECT a+16 FROM t1;
INSERT INTO t1 SELECT a+32 FROM t1;
INSERT INTO t1 SELECT a+64 FROM t1;
INSERT INTO t1 VALUE(NULL);
SELECT COUNT(DISTINCT a) FROM t1;
COUNT(DISTINCT a)
128
SELECT COUNT(DISTINCT (a+0)) FROM t1;
COUNT(DISTINCT (a+0))
128
DROP TABLE t1;
create table tb(
id int auto_increment primary key,
v varchar(32))
engine=myisam charset=gbk;
insert into tb(v) values("aaa");
insert into tb(v) (select v from tb);
insert into tb(v) (select v from tb);
insert into tb(v) (select v from tb);
insert into tb(v) (select v from tb);
insert into tb(v) (select v from tb);
insert into tb(v) (select v from tb);
update tb set v=concat(v, id);
select count(distinct case when id<=64 then id end) from tb;
count(distinct case when id<=64 then id end)
64
select count(distinct case when id<=63 then id end) from tb;
count(distinct case when id<=63 then id end)
63
drop table tb;
SET @@tmp_table_size= @tmp_table_size_save;
End of 5.5 tests
#
# Bug#13335170 - ASSERT IN
# PLAN_CHANGE_WATCHDOG::~PLAN_CHANGE_WATCHDOG() ON SELECT DISTINCT 
#
CREATE TABLE t1 (
col_int_key int(11) NOT NULL,
col_time_key time NOT NULL,
col_datetime_key datetime NOT NULL,
KEY col_int_key (col_int_key),
KEY col_time_key (col_time_key),
KEY col_datetime_key (col_datetime_key)
) ENGINE=InnoDB;
INSERT INTO t1 VALUES (7,'06:17:39','2003-08-21 00:00:00');
SELECT DISTINCT col_int_key
FROM t1
WHERE col_int_key IN  ( 18, 6, 84, 4, 0, 2, 8, 3, 7, 9, 1 )  
AND col_datetime_key BETWEEN '2001-08-04' AND '2003-06-13'  
ORDER BY col_time_key
LIMIT 3;
col_int_key
DROP TABLE t1;
#
# BUG#13540692: WRONG NULL HANDLING WITH RIGHT JOIN + 
#               DISTINCT OR ORDER BY
#
CREATE TABLE t1 (
a INT,
b INT NOT NULL
);
INSERT INTO t1 VALUES (1,2), (3,3);
SET @save_optimizer_switch= @@optimizer_switch;
SET @@SESSION.optimizer_switch="derived_merge=off";

EXPLAIN SELECT DISTINCT subselect.b
FROM t1 LEFT JOIN 
(SELECT it_b.* FROM t1 as it_a LEFT JOIN t1 as it_b ON true) AS subselect 
ON t1.a = subselect.b
;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	2	100.00	NULL
2	DERIVED	it_a	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
2	DERIVED	it_b	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select distinct `subselect`.`b` AS `b` from `test`.`t1` left join (/* select#2 */ select `test`.`it_b`.`a` AS `a`,`test`.`it_b`.`b` AS `b` from `test`.`t1` `it_a` left join `test`.`t1` `it_b` on(TRUE) where 1) `subselect` on((`subselect`.`b` = `test`.`t1`.`a`)) where 1
SELECT DISTINCT subselect.b
FROM t1 LEFT JOIN 
(SELECT it_b.* FROM t1 as it_a LEFT JOIN t1 as it_b ON true) AS subselect 
ON t1.a = subselect.b
;
b
NULL
3
SET @@SESSION.optimizer_switch= @save_optimizer_switch;
DROP TABLE t1;
#
# BUG#13538387: WRONG RESULT ON SELECT DISTINCT + LEFT JOIN + 
#               LIMIT + MIX OF MYISAM AND INNODB
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (2),(3);
CREATE TABLE t2 (b INT);
CREATE TABLE t3 (
a INT,
b INT,
PRIMARY KEY (b)
);
INSERT INTO t3 VALUES (2001,1), (2007,2);
EXPLAIN SELECT DISTINCT t3.a AS t3_date
FROM t1
LEFT JOIN t2 ON false
LEFT JOIN t3 ON t2.b = t3.b
LIMIT 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	system	NULL	NULL	NULL	NULL	0	0.00	const row not found
1	SIMPLE	t3	NULL	const	PRIMARY	NULL	NULL	NULL	1	100.00	Impossible ON condition
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary; Distinct
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t3`.`a` AS `t3_date` from `test`.`t1` left join `test`.`t3` on(multiple equal(NULL, `test`.`t3`.`b`)) where 1 limit 1
SELECT DISTINCT t3.a AS t3_date
FROM t1
LEFT JOIN t2 ON false
LEFT JOIN t3 ON t2.b = t3.b
LIMIT 1;
t3_date
NULL
DROP TABLE t1,t2,t3;

# BUG#13581713 ONLY_FULL_GROUP_BY DOES NOT BLOCK "SELECT
# DISTINCT A ORDER BY B"

create table t1(a int, b int, c int) engine=InnoDB;
create table t2(a int, b int, c int) engine=InnoDB;
insert into t2 values();
analyze table t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
# Test when selecting from base table
insert into t1 values(100,1,2),(200,1,1),(300,2,1),(400,2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select distinct b from t1 order by c;
b
2
1
select distinct min(b) from t1 group by a order by min(c);
min(b)
2
1
explain select distinct min(b) from t1 group by a order by min(c);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	#	4	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select distinct min(`test`.`t1`.`b`) AS `min(b)` from `test`.`t1` group by `test`.`t1`.`a` order by min(`test`.`t1`.`c`)
Insert rows in different order:
delete from t1;
insert into t1 values(200,1,1),(100,1,2),(400,2,2),(300,2,1);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
And get a different order. Query is executed like this:
- First, DISTINCT, using a tmp MEMORY table with a unique
index, thus if two rows have the same 'b' but a different 'c',
the second row is rejected, so the first value of 'c' wins
(=> randomness of 'c')
- Second, ORDER BY on the random 'c'.
select distinct b from t1 order by c;
b
1
2
Random order too (same reason):
select distinct min(b) from t1 group by a order by min(c);
min(b)
1
2
This query gives random order:
select distinct b from t1 order by c;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct b from t1 order by b-1,b+1,c;
ERROR HY000: Expression #3 of ORDER BY clause is not in SELECT list, references column 'test.t1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct min(b) from t1 group by a order by min(c);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Not random (though Standard bans aggregates from ORDER BY):
select distinct min(b) from t1 group by a order by min(b);
min(b)
1
2
select distinct min(b) from t1 group by a order by -min(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
All group exprs are in select list => DISTINCT is removed => no error
select distinct a, min(b) from t1 group by a order by max(b-2)-min(c*5);
a	min(b)
100	1
400	2
200	1
300	2
This one is standard:
select distinct min(b) as z from t1 group by a order by z;
z
1
2
Other queries:
select distinct b from t1 where b<0 order by rand();
b
select distinct b from t1 order by 45.0+3;
b
1
2
select (select distinct b from t1 as S2 where b=7 order by S3.a) from t1 as S3;
(select distinct b from t1 as S2 where b=7 order by S3.a)
NULL
NULL
NULL
NULL
select distinct b from t1 order by abs(b);
b
1
2
select distinct b as z from t1 order by abs(z);
z
1
2
select distinct b from t1 order by abs(b+a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.a' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from t1 order by z;
z
1
2
select distinct abs(b) as z from t1 order by abs(b);
z
1
2
select distinct abs(b) from t1 order by abs(b);
abs(b)
1
2
Not ok: ABS(b)+1 is neither a SELECTed expression nor an alias
to one, and mentions a column of FROM tables.
select distinct abs(b) as z from t1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from t1 order by z+1;
z
1
2
select distinct abs(b) from t1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from t1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from t1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.b' which is not in SELECT list; this is incompatible with DISTINCT
Two offending columns; error message needs to report only one
select distinct abs(b) from t1 order by floor(10*b),floor(10*a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from t1 as S2 order by
(select floor(10*S2.b) from t1 as S3 limit 1);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Ok as S2.b in SELECT list
select distinct abs(b),b from t1 as S2 order by
(select floor(10*S2.b) from t1 as S3 limit 1);
abs(b)	b
1	1
2	2
Ok as subq does not use columns of FROM clause of ordered Q.
select distinct abs(b) from t1 as S2 order by
(select floor(10*S3.b) from t1 as S3 limit 1);
abs(b)
1
2
Subq as alias => ok
select distinct abs(b),
(select floor(10*S3.b) from t1 as S3 limit 1) as subq
from t1 as S2 order by subq;
abs(b)	subq
1	10
2	10
Bad field in left or right argument of ALL/ANY(subq):
select distinct abs(b) from t1 as S2 order by
floor(10*S2.b) IN (select floor(10*S3.b) from t1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from t1 as S2 order by
floor(10*S2.b) > ALL(select floor(10*S3.b) from t1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from t1 as S2 order by
floor(10*10) IN (select floor(10*S2.b) from t1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from t1 as S2 order by
floor(10*10) > ALL(select floor(10*S2.b) from t1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Aggregates:
SELECT distinct 1 FROM t1 group by a order by count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
SELECT distinct 1 FROM t1 group by a order by count(*)-count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Test ANY_VALUE
SELECT distinct 1 FROM t1 group by a order by any_value(count(*)-count(b));
1
1
SELECT distinct 1 FROM t1 group by a order by any_value(count(*))-any_value(count(b));
1
1
All group exprs are in select list => DISTINCT is removed => no error
SELECT distinct a, min(b) FROM t1 group by a order by count(*)-count(*);
a	min(b)
100	1
200	1
300	2
400	2
SELECT distinct 1 FROM t1 group by a order by count(*)-count(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
aggregation in outer Q => constant in inner Q
select * from t1 as t2 where t2.a in
(SELECT distinct 1 FROM t1 group by a order by count(t2.a)-max(t2.a));
a	b	c
ORDER BY expressions are in SELECT list => ok
SELECT distinct 1, count(*)-count(b) FROM t1 group by a order by count(*)-count(b);
1	count(*)-count(b)
1	0
Without GROUP BY, aggregates yield a single row, no random order
SELECT distinct sum(a) FROM t1 order by count(*)-count(*);
sum(a)
1000
SELECT distinct sum(a) FROM t1 order by count(*)-count(b);
sum(a)
1000
Verify that DISTINCT is optimized away even if the aggregate
function is hidden in a subquery
EXPLAIN SELECT DISTINCT MAX(b) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1`
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select max(`test`.`t1`.`b`) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
but if the subquery is the aggregation query, DISTINCT must stay:
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select distinct (/* select#2 */ select max((`test`.`t1`.`b` + (0 * `test`.`t2`.`a`))) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
QA's query is properly rejected:
SELECT DISTINCT GP1.a AS g1 FROM t1 AS GP1
WHERE GP1.a >= 0
ORDER BY GP1.b LIMIT 8;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.GP1.b' which is not in SELECT list; this is incompatible with DISTINCT
result order does change depending on chosen plan.
SELECT DISTINCT GP1.a AS g1 FROM t1 AS GP1
WHERE GP1.a >= 0
ORDER BY 2+ANY_VALUE(GP1.b) LIMIT 8;
g1
100
200
300
400
truncate table t1;
# Test when selecting from view
create view v1 as select t1.* from t1 left join t2 on 1;
insert into t1 values(100,1,2),(200,1,1),(300,2,1),(400,2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select distinct b from v1 order by c;
b
2
1
select distinct min(b) from v1 group by a order by min(c);
min(b)
2
1
explain select distinct min(b) from v1 group by a order by min(c);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	#	4	100.00	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	#	1	100.00	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select distinct min(`test`.`t1`.`b`) AS `min(b)` from `test`.`t1` left join `test`.`t2` on(1) where 1 group by `test`.`t1`.`a` order by min(`test`.`t1`.`c`)
Insert rows in different order:
delete from t1;
insert into t1 values(200,1,1),(100,1,2),(400,2,2),(300,2,1);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
And get a different order. Query is executed like this:
- First, DISTINCT, using a tmp MEMORY table with a unique
index, thus if two rows have the same 'b' but a different 'c',
the second row is rejected, so the first value of 'c' wins
(=> randomness of 'c')
- Second, ORDER BY on the random 'c'.
select distinct b from v1 order by c;
b
1
2
Random order too (same reason):
select distinct min(b) from v1 group by a order by min(c);
min(b)
1
2
This query gives random order:
select distinct b from v1 order by c;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct b from v1 order by b-1,b+1,c;
ERROR HY000: Expression #3 of ORDER BY clause is not in SELECT list, references column 'v1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct min(b) from v1 group by a order by min(c);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Not random (though Standard bans aggregates from ORDER BY):
select distinct min(b) from v1 group by a order by min(b);
min(b)
1
2
select distinct min(b) from v1 group by a order by -min(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
All group exprs are in select list => DISTINCT is removed => no error
select distinct a, min(b) from v1 group by a order by max(b-2)-min(c*5);
a	min(b)
100	1
400	2
200	1
300	2
This one is standard:
select distinct min(b) as z from v1 group by a order by z;
z
1
2
Other queries:
select distinct b from v1 where b<0 order by rand();
b
select distinct b from v1 order by 45.0+3;
b
1
2
select (select distinct b from v1 as S2 where b=7 order by S3.a) from v1 as S3;
(select distinct b from v1 as S2 where b=7 order by S3.a)
NULL
NULL
NULL
NULL
select distinct b from v1 order by abs(b);
b
1
2
select distinct b as z from v1 order by abs(z);
z
1
2
select distinct b from v1 order by abs(b+a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.a' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by z;
z
1
2
select distinct abs(b) as z from v1 order by abs(b);
z
1
2
select distinct abs(b) from v1 order by abs(b);
abs(b)
1
2
Not ok: ABS(b)+1 is neither a SELECTed expression nor an alias
to one, and mentions a column of FROM tables.
select distinct abs(b) as z from v1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by z+1;
z
1
2
select distinct abs(b) from v1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
Two offending columns; error message needs to report only one
select distinct abs(b) from v1 order by floor(10*b),floor(10*a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
(select floor(10*S2.b) from v1 as S3 limit 1);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Ok as S2.b in SELECT list
select distinct abs(b),b from v1 as S2 order by
(select floor(10*S2.b) from v1 as S3 limit 1);
abs(b)	b
1	1
2	2
Ok as subq does not use columns of FROM clause of ordered Q.
select distinct abs(b) from v1 as S2 order by
(select floor(10*S3.b) from v1 as S3 limit 1);
abs(b)
1
2
Subq as alias => ok
select distinct abs(b),
(select floor(10*S3.b) from v1 as S3 limit 1) as subq
from v1 as S2 order by subq;
abs(b)	subq
1	10
2	10
Bad field in left or right argument of ALL/ANY(subq):
select distinct abs(b) from v1 as S2 order by
floor(10*S2.b) IN (select floor(10*S3.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*S2.b) > ALL(select floor(10*S3.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*10) IN (select floor(10*S2.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*10) > ALL(select floor(10*S2.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Aggregates:
SELECT distinct 1 FROM t1 group by a order by count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
SELECT distinct 1 FROM t1 group by a order by count(*)-count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Test ANY_VALUE
SELECT distinct 1 FROM t1 group by a order by any_value(count(*)-count(b));
1
1
SELECT distinct 1 FROM t1 group by a order by any_value(count(*))-any_value(count(b));
1
1
All group exprs are in select list => DISTINCT is removed => no error
SELECT distinct a, min(b) FROM t1 group by a order by count(*)-count(*);
a	min(b)
100	1
200	1
300	2
400	2
SELECT distinct 1 FROM t1 group by a order by count(*)-count(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
aggregation in outer Q => constant in inner Q
select * from t1 as t2 where t2.a in
(SELECT distinct 1 FROM t1 group by a order by count(t2.a)-max(t2.a));
a	b	c
ORDER BY expressions are in SELECT list => ok
SELECT distinct 1, count(*)-count(b) FROM t1 group by a order by count(*)-count(b);
1	count(*)-count(b)
1	0
Without GROUP BY, aggregates yield a single row, no random order
SELECT distinct sum(a) FROM t1 order by count(*)-count(*);
sum(a)
1000
SELECT distinct sum(a) FROM t1 order by count(*)-count(b);
sum(a)
1000
Verify that DISTINCT is optimized away even if the aggregate
function is hidden in a subquery
EXPLAIN SELECT DISTINCT MAX(b) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1`
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select max(`test`.`t1`.`b`) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
but if the subquery is the aggregation query, DISTINCT must stay:
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select distinct (/* select#2 */ select max((`test`.`t1`.`b` + (0 * `test`.`t2`.`a`))) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
QA's query is properly rejected:
SELECT DISTINCT GP1.a AS g1 FROM v1 AS GP1
WHERE GP1.a >= 0
ORDER BY GP1.b LIMIT 8;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'GP1.b' which is not in SELECT list; this is incompatible with DISTINCT
result order does change depending on chosen plan.
SELECT DISTINCT GP1.a AS g1 FROM v1 AS GP1
WHERE GP1.a >= 0
ORDER BY 2+ANY_VALUE(GP1.b) LIMIT 8;
g1
100
200
300
400
truncate table t1;
drop view v1;
# Test when selecting from view, again
create view v1 as select t1.a*2 as a, t1.b*2 as b, t1.c*2 as c from t1;
insert into t1 values(100,1,2),(200,1,1),(300,2,1),(400,2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select distinct b from v1 order by c;
b
4
2
select distinct min(b) from v1 group by a order by min(c);
min(b)
4
2
explain select distinct min(b) from v1 group by a order by min(c);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	#	4	100.00	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select distinct min((`test`.`t1`.`b` * 2)) AS `min(b)` from `test`.`t1` group by (`test`.`t1`.`a` * 2) order by min((`test`.`t1`.`c` * 2))
Insert rows in different order:
delete from t1;
insert into t1 values(200,1,1),(100,1,2),(400,2,2),(300,2,1);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
And get a different order. Query is executed like this:
- First, DISTINCT, using a tmp MEMORY table with a unique
index, thus if two rows have the same 'b' but a different 'c',
the second row is rejected, so the first value of 'c' wins
(=> randomness of 'c')
- Second, ORDER BY on the random 'c'.
select distinct b from v1 order by c;
b
2
4
Random order too (same reason):
select distinct min(b) from v1 group by a order by min(c);
min(b)
2
4
This query gives random order:
select distinct b from v1 order by c;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct b from v1 order by b-1,b+1,c;
ERROR HY000: Expression #3 of ORDER BY clause is not in SELECT list, references column 'v1.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct min(b) from v1 group by a order by min(c);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Not random (though Standard bans aggregates from ORDER BY):
select distinct min(b) from v1 group by a order by min(b);
min(b)
2
4
select distinct min(b) from v1 group by a order by -min(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
All group exprs are in select list => DISTINCT is removed => no error
select distinct a, min(b) from v1 group by a order by max(b-2)-min(c*5);
a	min(b)
200	2
800	4
400	2
600	4
This one is standard:
select distinct min(b) as z from v1 group by a order by z;
z
2
4
Other queries:
select distinct b from v1 where b<0 order by rand();
b
select distinct b from v1 order by 45.0+3;
b
2
4
select (select distinct b from v1 as S2 where b=7 order by S3.a) from v1 as S3;
(select distinct b from v1 as S2 where b=7 order by S3.a)
NULL
NULL
NULL
NULL
select distinct b from v1 order by abs(b);
b
2
4
select distinct b as z from v1 order by abs(z);
z
2
4
select distinct b from v1 order by abs(b+a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.a' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by z;
z
2
4
select distinct abs(b) as z from v1 order by abs(b);
z
2
4
select distinct abs(b) from v1 order by abs(b);
abs(b)
2
4
Not ok: ABS(b)+1 is neither a SELECTed expression nor an alias
to one, and mentions a column of FROM tables.
select distinct abs(b) as z from v1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by z+1;
z
2
4
select distinct abs(b) from v1 order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from v1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
Two offending columns; error message needs to report only one
select distinct abs(b) from v1 order by floor(10*b),floor(10*a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'v1.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
(select floor(10*S2.b) from v1 as S3 limit 1);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Ok as S2.b in SELECT list
select distinct abs(b),b from v1 as S2 order by
(select floor(10*S2.b) from v1 as S3 limit 1);
abs(b)	b
2	2
4	4
Ok as subq does not use columns of FROM clause of ordered Q.
select distinct abs(b) from v1 as S2 order by
(select floor(10*S3.b) from v1 as S3 limit 1);
abs(b)
2
4
Subq as alias => ok
select distinct abs(b),
(select floor(10*S3.b) from v1 as S3 limit 1) as subq
from v1 as S2 order by subq;
abs(b)	subq
2	20
4	20
Bad field in left or right argument of ALL/ANY(subq):
select distinct abs(b) from v1 as S2 order by
floor(10*S2.b) IN (select floor(10*S3.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*S2.b) > ALL(select floor(10*S3.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*10) IN (select floor(10*S2.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from v1 as S2 order by
floor(10*10) > ALL(select floor(10*S2.b) from v1 as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Aggregates:
SELECT distinct 1 FROM t1 group by a order by count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
SELECT distinct 1 FROM t1 group by a order by count(*)-count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Test ANY_VALUE
SELECT distinct 1 FROM t1 group by a order by any_value(count(*)-count(b));
1
1
SELECT distinct 1 FROM t1 group by a order by any_value(count(*))-any_value(count(b));
1
1
All group exprs are in select list => DISTINCT is removed => no error
SELECT distinct a, min(b) FROM t1 group by a order by count(*)-count(*);
a	min(b)
100	1
200	1
300	2
400	2
SELECT distinct 1 FROM t1 group by a order by count(*)-count(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
aggregation in outer Q => constant in inner Q
select * from t1 as t2 where t2.a in
(SELECT distinct 1 FROM t1 group by a order by count(t2.a)-max(t2.a));
a	b	c
ORDER BY expressions are in SELECT list => ok
SELECT distinct 1, count(*)-count(b) FROM t1 group by a order by count(*)-count(b);
1	count(*)-count(b)
1	0
Without GROUP BY, aggregates yield a single row, no random order
SELECT distinct sum(a) FROM t1 order by count(*)-count(*);
sum(a)
1000
SELECT distinct sum(a) FROM t1 order by count(*)-count(b);
sum(a)
1000
Verify that DISTINCT is optimized away even if the aggregate
function is hidden in a subquery
EXPLAIN SELECT DISTINCT MAX(b) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1`
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select max(`test`.`t1`.`b`) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
but if the subquery is the aggregation query, DISTINCT must stay:
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select distinct (/* select#2 */ select max((`test`.`t1`.`b` + (0 * `test`.`t2`.`a`))) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
QA's query is properly rejected:
SELECT DISTINCT GP1.a AS g1 FROM v1 AS GP1
WHERE GP1.a >= 0
ORDER BY GP1.b LIMIT 8;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'GP1.b' which is not in SELECT list; this is incompatible with DISTINCT
result order does change depending on chosen plan.
SELECT DISTINCT GP1.a AS g1 FROM v1 AS GP1
WHERE GP1.a >= 0
ORDER BY 2+ANY_VALUE(GP1.b) LIMIT 8;
g1
200
400
600
800
truncate table t1;
drop view v1;
# Test when selecting from derived table
insert into t1 values(100,1,2),(200,1,1),(300,2,1),(400,2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by c;
b
2
1
select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by min(c);
min(b)
2
1
explain select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by min(c);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	#	4	100.00	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	#	1	100.00	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select distinct min(`test`.`t1`.`b`) AS `min(b)` from `test`.`t1` left join `test`.`t2` on(1) where 1 group by `test`.`t1`.`a` order by min(`test`.`t1`.`c`)
Insert rows in different order:
delete from t1;
insert into t1 values(200,1,1),(100,1,2),(400,2,2),(300,2,1);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
And get a different order. Query is executed like this:
- First, DISTINCT, using a tmp MEMORY table with a unique
index, thus if two rows have the same 'b' but a different 'c',
the second row is rejected, so the first value of 'c' wins
(=> randomness of 'c')
- Second, ORDER BY on the random 'c'.
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by c;
b
1
2
Random order too (same reason):
select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by min(c);
min(b)
1
2
This query gives random order:
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by c;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by b-1,b+1,c;
ERROR HY000: Expression #3 of ORDER BY clause is not in SELECT list, references column 'derived.c' which is not in SELECT list; this is incompatible with DISTINCT
and this one too:
select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by min(c);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Not random (though Standard bans aggregates from ORDER BY):
select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by min(b);
min(b)
1
2
select distinct min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by -min(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
All group exprs are in select list => DISTINCT is removed => no error
select distinct a, min(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by max(b-2)-min(c*5);
a	min(b)
100	1
400	2
200	1
300	2
This one is standard:
select distinct min(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived group by a order by z;
z
1
2
Other queries:
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived where b<0 order by rand();
b
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by 45.0+3;
b
1
2
select (select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) as S2 where b=7 order by S3.a) from (SELECT t1.* FROM t1 left join t2 on 1) as S3;
(select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) as S2 where b=7 order by S3.a)
NULL
NULL
NULL
NULL
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b);
b
1
2
select distinct b as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(z);
z
1
2
select distinct b from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b+a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.a' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by z;
z
1
2
select distinct abs(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b);
z
1
2
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b);
abs(b)
1
2
Not ok: ABS(b)+1 is neither a SELECTed expression nor an alias
to one, and mentions a column of FROM tables.
select distinct abs(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by z+1;
z
1
2
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by abs(b)+1;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) as z from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by floor(10*b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.b' which is not in SELECT list; this is incompatible with DISTINCT
Two offending columns; error message needs to report only one
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) AS derived order by floor(10*b),floor(10*a);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'derived.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
(select floor(10*S2.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3 limit 1);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Ok as S2.b in SELECT list
select distinct abs(b),b from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
(select floor(10*S2.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3 limit 1);
abs(b)	b
1	1
2	2
Ok as subq does not use columns of FROM clause of ordered Q.
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
(select floor(10*S3.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3 limit 1);
abs(b)
1
2
Subq as alias => ok
select distinct abs(b),
(select floor(10*S3.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3 limit 1) as subq
from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by subq;
abs(b)	subq
1	10
2	10
Bad field in left or right argument of ALL/ANY(subq):
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
floor(10*S2.b) IN (select floor(10*S3.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
floor(10*S2.b) > ALL(select floor(10*S3.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
floor(10*10) IN (select floor(10*S2.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct abs(b) from (SELECT t1.* FROM t1 left join t2 on 1) as S2 order by
floor(10*10) > ALL(select floor(10*S2.b) from (SELECT t1.* FROM t1 left join t2 on 1) as S3);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'S2.b' which is not in SELECT list; this is incompatible with DISTINCT
Aggregates:
SELECT distinct 1 FROM t1 group by a order by count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
SELECT distinct 1 FROM t1 group by a order by count(*)-count(*);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
Test ANY_VALUE
SELECT distinct 1 FROM t1 group by a order by any_value(count(*)-count(b));
1
1
SELECT distinct 1 FROM t1 group by a order by any_value(count(*))-any_value(count(b));
1
1
All group exprs are in select list => DISTINCT is removed => no error
SELECT distinct a, min(b) FROM t1 group by a order by count(*)-count(*);
a	min(b)
100	1
200	1
300	2
400	2
SELECT distinct 1 FROM t1 group by a order by count(*)-count(b);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, contains aggregate function; this is incompatible with DISTINCT
aggregation in outer Q => constant in inner Q
select * from t1 as t2 where t2.a in
(SELECT distinct 1 FROM t1 group by a order by count(t2.a)-max(t2.a));
a	b	c
ORDER BY expressions are in SELECT list => ok
SELECT distinct 1, count(*)-count(b) FROM t1 group by a order by count(*)-count(b);
1	count(*)-count(b)
1	0
Without GROUP BY, aggregates yield a single row, no random order
SELECT distinct sum(a) FROM t1 order by count(*)-count(*);
sum(a)
1000
SELECT distinct sum(a) FROM t1 order by count(*)-count(b);
sum(a)
1000
Verify that DISTINCT is optimized away even if the aggregate
function is hidden in a subquery
EXPLAIN SELECT DISTINCT MAX(b) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`b`) AS `MAX(b)` from `test`.`t1`
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select max(`test`.`t1`.`b`) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
but if the subquery is the aggregation query, DISTINCT must stay:
EXPLAIN SELECT DISTINCT (SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	NULL
Warnings:
Note	1276	Field or reference 'test.t1.b' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select distinct (/* select#2 */ select max((`test`.`t1`.`b` + (0 * `test`.`t2`.`a`))) from `test`.`t1` `t2` limit 1) AS `(SELECT MAX(t1.b+0*t2.a) FROM t1 AS t2 LIMIT 1)` from `test`.`t1`
QA's query is properly rejected:
SELECT DISTINCT GP1.a AS g1 FROM (SELECT t1.* FROM t1 left join t2 on 1) AS GP1
WHERE GP1.a >= 0
ORDER BY GP1.b LIMIT 8;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'GP1.b' which is not in SELECT list; this is incompatible with DISTINCT
result order does change depending on chosen plan.
SELECT DISTINCT GP1.a AS g1 FROM (SELECT t1.* FROM t1 left join t2 on 1) AS GP1
WHERE GP1.a >= 0
ORDER BY 2+ANY_VALUE(GP1.b) LIMIT 8;
g1
100
200
300
400
truncate table t1;
select distinct t1_outer.a from t1 t1_outer
order by t1_outer.b;
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1_outer.b' which is not in SELECT list; this is incompatible with DISTINCT
select distinct t1_outer.a from t1 t1_outer
order by (select max(t1_outer.b+t1_inner.b) from t1 t1_inner);
ERROR HY000: Expression #1 of ORDER BY clause is not in SELECT list, references column 'test.t1_outer.b' which is not in SELECT list; this is incompatible with DISTINCT
select
(select distinct 1 from t1 t1_inner
group by t1_inner.a order by max(t1_outer.b))
from t1 t1_outer;
(select distinct 1 from t1 t1_inner
group by t1_inner.a order by max(t1_outer.b))
NULL
drop table t1, t2;
#
# Bug#22686994 REGRESSION FOR A GROUPING QUERY WITH DISTINCT
#
CREATE TABLE t1 (a INTEGER, b INTEGER);
INSERT INTO t1 VALUES (1,3), (2,4), (1,5),
(1,3), (2,1), (1,5), (1,7), (3,1),
(3,2), (3,1), (2,4);
SELECT DISTINCT (COUNT(DISTINCT b) + 1) AS c FROM t1 GROUP BY a;
c
4
3
DROP TABLE t1;
# End of test for Bug#22686994
#
# Bug #25740550: DISTINCT OPERATIONS ON TEMP TABLES ALLOCATE TOO LITTLE
#                MEMORY FOR SORT KEYS
#
# A test for remove_dup_with_hash_index() where sort keys are significantly
# longer than the row itself.
#
CREATE TABLE t1(c1 int, c2 VARCHAR(1) COLLATE utf8mb4_0900_as_cs);
INSERT INTO t1 VALUES (1, 'a');
INSERT INTO t1 VALUES (2, 'A');
SELECT DISTINCT c2 FROM t1 GROUP BY c1;
c2
a
A
DROP TABLE t1;
#
# Bug#20692219 INCORRECT RESULT FOR DISTINCT SELECT
#
CREATE TABLE t(a INT, b INT);
INSERT INTO t VALUES(1,2);
INSERT INTO t VALUES(2,4);
SELECT  LEAST(1,COUNT(DISTINCT a)) FROM t GROUP BY a;
LEAST(1,COUNT(DISTINCT a))
1
1
SELECT DISTINCT LEAST(1,COUNT(DISTINCT a)) FROM t GROUP BY a;
LEAST(1,COUNT(DISTINCT a))
1
DROP TABLE t;
