drop table if exists t1, t2, t3;
create table t1 (i int);
reset master;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change i c char(10) default 'Test1';;
set debug_sync='now WAIT_FOR parked';
insert into t1 values ();;
set debug_sync='now SIGNAL go';
select * from t1;
c
Test1
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change c vc varchar(100) default 'Test2';;
set debug_sync='now WAIT_FOR parked';
rename table t1 to t2;;
set debug_sync='now SIGNAL go';
drop table t2;
create table t1 (i int);
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
alter table t1 change i c char(10) default 'Test3', rename to t2;;
set debug_sync='now WAIT_FOR parked';
insert into t2 values();;
set debug_sync='now SIGNAL go';
select * from t2;
c
Test3
alter table t2 change c vc varchar(100) default 'Test2', rename to t1;;
rename table t1 to t3;
drop table t3;
set debug_sync='alter_table_before_main_binlog SIGNAL parked WAIT_FOR go';
set debug_sync='RESET';
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
binlog.000001	#	Query	#	#	use `test`; alter table t1 change i c char(10) default 'Test1'
binlog.000001	#	Query	#	#	BEGIN
binlog.000001	#	Query	#	#	use `test`; insert into t1 values ()
binlog.000001	#	Xid	#	#	COMMIT /* XID */
binlog.000001	#	Query	#	#	use `test`; alter table t1 change c vc varchar(100) default 'Test2'
binlog.000001	#	Query	#	#	use `test`; rename table t1 to t2
binlog.000001	#	Query	#	#	use `test`; DROP TABLE `t2` /* generated by server */
binlog.000001	#	Query	#	#	use `test`; create table t1 (i int)
binlog.000001	#	Query	#	#	use `test`; alter table t1 change i c char(10) default 'Test3', rename to t2
binlog.000001	#	Query	#	#	BEGIN
binlog.000001	#	Query	#	#	use `test`; insert into t2 values()
binlog.000001	#	Xid	#	#	COMMIT /* XID */
binlog.000001	#	Query	#	#	use `test`; alter table t2 change c vc varchar(100) default 'Test2', rename to t1
binlog.000001	#	Query	#	#	use `test`; rename table t1 to t3
binlog.000001	#	Query	#	#	use `test`; DROP TABLE `t3` /* generated by server */
End of 5.1 tests
#
# Additional coverage for WL#7743 "New data dictionary: changes
# to DDL-related parts of SE API".
#
# Killed ALTER TABLE on temporary table sometimes led to assertion
# failure on connection close.
connect  con1, localhost, root,,;
create temporary table t1 (i int) engine=innodb;
set debug= "+d,mysql_lock_tables_kill_query";
alter table t1 add index (i);
ERROR 70100: Query execution was interrupted
set debug= "-d,mysql_lock_tables_kill_query";
# The below disconnect should drop temporary table automagically.
disconnect con1;
connection default;
#
# Test coverage for new (since 8.0) behavior of ALTER TABLE RENAME
# under LOCK TABLES.
#
connect  con1, localhost, root,,;
SET @old_lock_wait_timeout= @@lock_wait_timeout;
connection default;
#
# 1) Simple ALTER TABLE RENAME.
#
# 1.1) Successfull ALTER TABLE RENAME.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 RENAME TO t2;
# Table is available under new name under LOCK TABLES.
SELECT * FROM t2;
i
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM t2;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not for old table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
connection default;
UNLOCK TABLES;
#
# 1.2) ALTER TABLE RENAME in case when several tables are locked.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 RENAME TO t3;
# Table t1 should be still locked, and t2 should be available as t3
# with correct lock type.
SELECT * FROM t1;
i
INSERT INTO t3 values (1);
UNLOCK TABLES;
#
# 1.3) ALTER TABLE RENAME in case when same table locked more than once.
#
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 RENAME TO t4;
# Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
i	i
1	1
INSERT INTO t4 VALUES (2);
DELETE a FROM t4 AS a, t4 AS b;
DELETE b FROM t4 AS a, t4 AS b;
ERROR HY000: Table 'b' was locked with a READ lock and can't be updated
UNLOCK TABLES;
DROP TABLES t1, t4;
# 1.4) ALTER TABLE RENAME to different schema.
#
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 RENAME TO mysqltest.t1;
# Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;
i
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM mysqltest.t1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not to old schema and table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
# Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
ALTER DATABASE mysqltest CHARACTER SET latin1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
connection default;
UNLOCK TABLES;
DROP DATABASE mysqltest;
#
# 2) ALTER TABLE INPLACE with RENAME clause.
#
# 2.1) Successful ALTER TABLE INPLACE with RENAME clause.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN j INT, RENAME TO t2, ALGORITHM=INPLACE;
# Table is available under new name under LOCK TABLES.
SELECT * FROM t2;
i	j
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM t2;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not for old table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
connection default;
UNLOCK TABLES;
#
# 2.2) ALTER TABLE INPLACE with RENAME clause in case when several
#      tables are locked.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 ADD COLUMN k INT, RENAME TO t3, ALGORITHM=INPLACE;
# Table t1 should be still locked, and t2 should be available as t3
# with correct lock type.
SELECT * FROM t1;
i
INSERT INTO t3 values (1, 2, 3);
UNLOCK TABLES;
#
# 2.3) ALTER TABLE INPLACE with RENAME clause in case when same table
#      locked more than once.
#
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 ADD COLUMN l INT, RENAME TO t4, ALGORITHM=INPLACE;
# Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
i	j	k	l	i	j	k	l
1	2	3	NULL	1	2	3	NULL
INSERT INTO t4 VALUES (2, 3, 4, 5);
DELETE a FROM t4 AS a, t4 AS b;
DELETE b FROM t4 AS a, t4 AS b;
ERROR HY000: Table 'b' was locked with a READ lock and can't be updated
UNLOCK TABLES;
DROP TABLES t1, t4;
# 2.4) ALTER TABLE INPLACE with RENAME clause to different schema.
#
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN k INT, RENAME TO mysqltest.t1, ALGORITHM=INPLACE;
# Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;
i	k
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM mysqltest.t1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not to old schema and table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
# Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
ALTER DATABASE mysqltest CHARACTER SET latin1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
connection default;
UNLOCK TABLES;
DROP DATABASE mysqltest;
#
# 3) ALTER TABLE COPY with RENAME clause.
#
# 3.1) Successful ALTER TABLE COPY with RENAME clause.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN j INT, RENAME TO t2, ALGORITHM=COPY;
# Table is available under new name under LOCK TABLES.
SELECT * FROM t2;
i	j
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM t2;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not for old table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
connection default;
UNLOCK TABLES;
#
# 3.2) ALTER TABLE COPY with RENAME clause in case when several
#      tables are locked.
#
CREATE TABLE t1 (i INT);
LOCK TABLES t1 READ, t2 WRITE;
ALTER TABLE t2 ADD COLUMN k INT, RENAME TO t3, ALGORITHM=COPY;
# Table t1 should be still locked, and t2 should be available as t3
# with correct lock type.
SELECT * FROM t1;
i
INSERT INTO t3 values (1, 2, 3);
UNLOCK TABLES;
#
# 3.3) ALTER TABLE COPY with RENAME clause in case when same table
#      locked more than once.
#
LOCK TABLES t1 READ, t3 WRITE, t3 AS a WRITE, t3 AS b READ;
ALTER TABLE t3 ADD COLUMN l INT, RENAME TO t4, ALGORITHM=COPY;
# Check that tables are locked under correct aliases and with modes.
SELECT * FROM t4 AS a, t4 AS b;
i	j	k	l	i	j	k	l
1	2	3	NULL	1	2	3	NULL
INSERT INTO t4 VALUES (2, 3, 4, 5);
DELETE a FROM t4 AS a, t4 AS b;
DELETE b FROM t4 AS a, t4 AS b;
ERROR HY000: Table 'b' was locked with a READ lock and can't be updated
UNLOCK TABLES;
DROP TABLES t1, t4;
# 3.4) ALTER TABLE COPY with RENAME clause to different schema.
#
CREATE TABLE t1 (i INT);
CREATE DATABASE mysqltest;
LOCK TABLES t1 WRITE;
ALTER TABLE t1 ADD COLUMN k INT, RENAME TO mysqltest.t1, ALGORITHM=COPY;
# Table is available in new schema under LOCK TABLES.
SELECT * FROM mysqltest.t1;
i	k
connection con1;
# Access by new name from other connections should be blocked.
SET @@lock_wait_timeout= 1;
SELECT * FROM mysqltest.t1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
# But not to old schema and table name.
SELECT * FROM t1;
ERROR 42S02: Table 'test.t1' doesn't exist
# Also IX lock on new schema should be kept.
SET @@lock_wait_timeout= 1;
ALTER DATABASE mysqltest CHARACTER SET latin1;
ERROR HY000: Lock wait timeout exceeded; try restarting transaction
SET @@lock_wait_timeout= @old_lock_wait_timeout;
connection default;
UNLOCK TABLES;
DROP DATABASE mysqltest;
