drop table if exists t1, t2, t3, t10, t100;
CREATE TABLE t1 (
event_date date DEFAULT '0000-00-00' NOT NULL,
type int(11) DEFAULT '0' NOT NULL,
event_id int(11) DEFAULT '0' NOT NULL,
PRIMARY KEY (event_date,type,event_id)
);
INSERT INTO t1 VALUES ('1999-07-10',100100,24), ('1999-07-11',100100,25),
('1999-07-13',100600,0), ('1999-07-13',100600,4), ('1999-07-13',100600,26),
('1999-07-14',100600,10), ('1999-07-15',100600,16), ('1999-07-15',100800,45),
('1999-07-15',101000,47), ('1999-07-16',100800,46), ('1999-07-20',100600,5),
('1999-07-20',100600,27), ('1999-07-21',100600,11), ('1999-07-22',100600,17),
('1999-07-23',100100,39), ('1999-07-24',100100,39), ('1999-07-24',100500,40),
('1999-07-25',100100,39), ('1999-07-27',100600,1), ('1999-07-27',100600,6),
('1999-07-27',100600,28), ('1999-07-28',100600,12), ('1999-07-29',100500,41),
('1999-07-29',100600,18), ('1999-07-30',100500,41), ('1999-07-31',100500,41),
('1999-08-01',100700,34), ('1999-08-03',100600,7), ('1999-08-03',100600,29),
('1999-08-04',100600,13), ('1999-08-05',100500,42), ('1999-08-05',100600,19),
('1999-08-06',100500,42), ('1999-08-07',100500,42), ('1999-08-08',100500,42),
('1999-08-10',100600,2), ('1999-08-10',100600,9), ('1999-08-10',100600,30),
('1999-08-11',100600,14), ('1999-08-12',100600,20), ('1999-08-17',100500,8),
('1999-08-17',100600,31), ('1999-08-18',100600,15), ('1999-08-19',100600,22),
('1999-08-24',100600,3), ('1999-08-24',100600,32), ('1999-08-27',100500,43),
('1999-08-31',100600,33), ('1999-09-17',100100,37), ('1999-09-18',100100,37),
('1999-09-19',100100,37), ('2000-12-18',100700,38);
select event_date,type,event_id from t1 WHERE event_date >= "1999-07-01" AND event_date < "1999-07-15" AND (type=100600 OR type=100100) ORDER BY event_date;
event_date	type	event_id
1999-07-10	100100	24
1999-07-11	100100	25
1999-07-13	100600	0
1999-07-13	100600	4
1999-07-13	100600	26
1999-07-14	100600	10
explain select event_date,type,event_id from t1 WHERE type = 100601 and event_date >= "1999-07-01" AND event_date < "1999-07-15" AND (type=100600 OR type=100100) ORDER BY event_date;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
select event_date,type,event_id from t1 WHERE event_date >= "1999-07-01" AND event_date <= "1999-07-15" AND (type=100600 OR type=100100) or event_date >= "1999-07-01" AND event_date <= "1999-07-15" AND type=100099;
event_date	type	event_id
1999-07-10	100100	24
1999-07-11	100100	25
1999-07-13	100600	0
1999-07-13	100600	4
1999-07-13	100600	26
1999-07-14	100600	10
1999-07-15	100600	16
drop table t1;
CREATE TABLE t1 (
PAPER_ID smallint(6) DEFAULT '0' NOT NULL,
YEAR smallint(6) DEFAULT '0' NOT NULL,
ISSUE smallint(6) DEFAULT '0' NOT NULL,
CLOSED tinyint(4) DEFAULT '0' NOT NULL,
ISS_DATE date DEFAULT '0000-00-00' NOT NULL,
PRIMARY KEY (PAPER_ID,YEAR,ISSUE)
);
INSERT INTO t1 VALUES (3,1999,34,0,'1999-07-12'), (1,1999,111,0,'1999-03-23'),
(1,1999,222,0,'1999-03-23'), (3,1999,33,0,'1999-07-12'),
(3,1999,32,0,'1999-07-12'), (3,1999,31,0,'1999-07-12'),
(3,1999,30,0,'1999-07-12'), (3,1999,29,0,'1999-07-12'),
(3,1999,28,0,'1999-07-12'), (1,1999,40,1,'1999-05-01'),
(1,1999,41,1,'1999-05-01'), (1,1999,42,1,'1999-05-01'),
(1,1999,46,1,'1999-05-01'), (1,1999,47,1,'1999-05-01'),
(1,1999,48,1,'1999-05-01'), (1,1999,49,1,'1999-05-01'),
(1,1999,50,0,'1999-05-01'), (1,1999,51,0,'1999-05-01'),
(1,1999,200,0,'1999-06-28'), (1,1999,52,0,'1999-06-28'),
(1,1999,53,0,'1999-06-28'), (1,1999,54,0,'1999-06-28'),
(1,1999,55,0,'1999-06-28'), (1,1999,56,0,'1999-07-01'),
(1,1999,57,0,'1999-07-01'), (1,1999,58,0,'1999-07-01'),
(1,1999,59,0,'1999-07-01'), (1,1999,60,0,'1999-07-01'),
(3,1999,35,0,'1999-07-12');
select YEAR,ISSUE from t1 where PAPER_ID=3 and (YEAR>1999 or (YEAR=1999 and ISSUE>28))  order by YEAR,ISSUE;
YEAR	ISSUE
1999	29
1999	30
1999	31
1999	32
1999	33
1999	34
1999	35
check table t1;
Table	Op	Msg_type	Msg_text
test.t1	check	status	OK
repair table t1;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
drop table t1;
CREATE TABLE t1 (
id int(11) NOT NULL auto_increment,
parent_id int(11) DEFAULT '0' NOT NULL,
level tinyint(4) DEFAULT '0' NOT NULL,
PRIMARY KEY (id),
KEY parent_id (parent_id),
KEY level (level)
);
INSERT INTO t1 VALUES (1,0,0), (3,1,1), (4,1,1), (8,2,2), (9,2,2), (17,3,2),
(22,4,2), (24,4,2), (28,5,2), (29,5,2), (30,5,2), (31,6,2), (32,6,2), (33,6,2),
(203,7,2), (202,7,2), (20,3,2), (157,0,0), (193,5,2), (40,7,2), (2,1,1),
(15,2,2), (6,1,1), (34,6,2), (35,6,2), (16,3,2), (7,1,1), (36,7,2), (18,3,2),
(26,5,2), (27,5,2), (183,4,2), (38,7,2), (25,5,2), (37,7,2), (21,4,2),
(19,3,2), (5,1,1), (179,5,2);
SELECT * FROM t1 WHERE level = 1 AND parent_id = 1;
id	parent_id	level
3	1	1
4	1	1
2	1	1
6	1	1
7	1	1
5	1	1
SELECT * FROM t1 WHERE level = 1 AND parent_id = 1 order by id;
id	parent_id	level
2	1	1
3	1	1
4	1	1
5	1	1
6	1	1
7	1	1
drop table t1;
create table t1(
Satellite		varchar(25)	not null,
SensorMode		varchar(25)	not null,
FullImageCornersUpperLeftLongitude	double	not null,
FullImageCornersUpperRightLongitude	double	not null,
FullImageCornersUpperRightLatitude	double	not null,
FullImageCornersLowerRightLatitude	double	not null,
index two (Satellite, SensorMode, FullImageCornersUpperLeftLongitude, FullImageCornersUpperRightLongitude, FullImageCornersUpperRightLatitude, FullImageCornersLowerRightLatitude));
insert into t1 values("OV-3","PAN1",91,-92,40,50);
insert into t1 values("OV-4","PAN1",91,-92,40,50);
select * from t1 where t1.Satellite = "OV-3" and t1.SensorMode = "PAN1" and t1.FullImageCornersUpperLeftLongitude > -90.000000 and t1.FullImageCornersUpperRightLongitude < -82.000000;
Satellite	SensorMode	FullImageCornersUpperLeftLongitude	FullImageCornersUpperRightLongitude	FullImageCornersUpperRightLatitude	FullImageCornersLowerRightLatitude
OV-3	PAN1	91	-92	40	50
drop table t1;
create table t1 ( aString char(100) not null default "", key aString (aString(10)) );
insert t1 (aString) values ( "believe in myself" ), ( "believe" ), ("baaa" ), ( "believe in love");
select * from t1 where aString < "believe in myself" order by aString;
aString
baaa
believe
believe in love
select * from t1 where aString > "believe in love" order by aString;
aString
believe in myself
alter table t1 drop key aString;
select * from t1 where aString < "believe in myself" order by aString;
aString
baaa
believe
believe in love
select * from t1 where aString > "believe in love" order by aString;
aString
believe in myself
drop table t1;
CREATE TABLE t1 (
t1ID int(10) unsigned NOT NULL auto_increment,
art binary(1) NOT NULL default '',
KNR char(5) NOT NULL default '',
RECHNR char(6) NOT NULL default '',
POSNR char(2) NOT NULL default '',
ARTNR char(10) NOT NULL default '',
TEX char(70) NOT NULL default '',
PRIMARY KEY  (t1ID),
KEY IdxArt (art),
KEY IdxKnr (KNR),
KEY IdxArtnr (ARTNR)
) ENGINE=MyISAM;
INSERT INTO t1 (art) VALUES ('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j');
select count(*) from t1 where upper(art) = 'J';
count(*)
213
select count(*) from t1 where art = 'J' or art = 'j';
count(*)
602
select count(*) from t1 where art = 'j' or art = 'J';
count(*)
602
select count(*) from t1 where art = 'j';
count(*)
389
select count(*) from t1 where art = 'J';
count(*)
213
drop table t1;
create table t1 (x int, y int, index(x), index(y));
insert into t1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9);
update t1 set y=x;
explain select * from t1, t1 t2 where t1.y = 8 and t2.x between 7 and t1.y+0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	2	Using index condition; Using join buffer (flat, BNL join)
explain select * from t1, t1 t2 where t1.y = 8 and t2.x >= 7 and t2.x <= t1.y+0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	2	Using index condition; Using join buffer (flat, BNL join)
explain select * from t1, t1 t2 where t1.y = 2 and t2.x between t1.y-1 and t1.y+1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	3	Using index condition; Using join buffer (flat, BNL join)
explain select * from t1, t1 t2 where t1.y = 2 and t2.x >= t1.y-1 and t2.x <= t1.y+1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	3	Using index condition; Using join buffer (flat, BNL join)
explain select * from t1, t1 t2 where t1.y = 2 and t2.x between 0 and t1.y;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	2	Using index condition; Using join buffer (flat, BNL join)
explain select * from t1, t1 t2 where t1.y = 2 and t2.x >= 0 and t2.x <= t1.y;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	y	y	5	const	1	
1	SIMPLE	t2	range	x	x	5	NULL	2	Using index condition; Using join buffer (flat, BNL join)
explain select count(*) from t1 where x in (1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	x	x	5	const	1	Using index
explain select count(*) from t1 where x in (1,2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	x	x	5	NULL	9	Using where; Using index
drop table t1;
CREATE TABLE t1 (key1 int(11) NOT NULL default '0', KEY i1 (key1));
INSERT INTO t1 VALUES (0),(0),(0),(0),(0),(1),(1);
CREATE TABLE t2 (keya int(11) NOT NULL default '0', KEY j1 (keya));
INSERT INTO t2 VALUES (0),(0),(1),(1),(2),(2);
explain select * from t1, t2 where (t1.key1 <t2.keya + 1) and t2.keya=3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ref	j1	j1	4	const	1	Using index
1	SIMPLE	t1	index	i1	i1	4	NULL	7	Using where; Using index; Using join buffer (flat, BNL join)
explain select * from t1 force index(i1), t2 force index(j1) where 
(t1.key1 <t2.keya + 1) and t2.keya=3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ref	j1	j1	4	const	1	Using index
1	SIMPLE	t1	index	i1	i1	4	NULL	7	Using where; Using index; Using join buffer (flat, BNL join)
DROP TABLE t1,t2;
CREATE TABLE t1 (
a int(11) default NULL,
b int(11) default NULL,
KEY a (a),
KEY b (b)
) ENGINE=MyISAM;
INSERT INTO t1 VALUES
(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,2),(10,2),
(13,2),(14,2),(15,2),(16,2),(17,3),(17,3),(16,3),(17,3),(19,3),(20,3),
(21,4),(22,5),(23,5),(24,5),(25,5),(26,5),(30,5),(31,5),(32,5),(33,5),
(33,5),(33,5),(33,5),(33,5),(34,5),(35,5);
EXPLAIN SELECT * FROM t1 WHERE a IN(1,2) AND b=5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a,b	a	5	NULL	2	Using index condition; Using where
SELECT * FROM t1 WHERE a IN(1,2) AND b=5;
a	b
DROP TABLE t1;
CREATE TABLE t1 (a int, b int, c int, INDEX (c,a,b));
INSERT INTO t1 VALUES (1,0,0),(1,0,0),(1,0,0);
INSERT INTO t1 VALUES (0,1,0),(0,1,0),(0,1,0);
SELECT COUNT(*) FROM t1 WHERE (c=0 and a=1) or (c=0 and b=1);
COUNT(*)
6
SELECT COUNT(*) FROM t1 WHERE (c=0 and b=1) or (c=0 and a=1);
COUNT(*)
6
DROP TABLE t1;
CREATE TABLE t1 ( a int not null, b int not null, INDEX ab(a,b) );
INSERT INTO t1 VALUES (47,1), (70,1), (15,1), (15, 4);
SELECT * FROM t1
WHERE
(
( b =1 AND a BETWEEN 14 AND 21 ) OR
( b =2 AND a BETWEEN 16 AND 18 ) OR
( b =3 AND a BETWEEN 15 AND 19 ) OR
(a BETWEEN 19 AND 47)
);
a	b
15	1
47	1
DROP TABLE t1;
CREATE TABLE t1 (
id int( 11 ) unsigned NOT NULL AUTO_INCREMENT ,
line int( 5 ) unsigned NOT NULL default '0',
columnid int( 3 ) unsigned NOT NULL default '0',
owner int( 3 ) unsigned NOT NULL default '0',
ordinal int( 3 ) unsigned NOT NULL default '0',
showid smallint( 6 ) unsigned NOT NULL default '1',
tableid int( 1 ) unsigned NOT NULL default '1',
content int( 5 ) unsigned NOT NULL default '188',
PRIMARY KEY ( owner, id ) ,
KEY menu( owner, showid, columnid ) ,
KEY `COLUMN` ( owner, columnid, line ) ,
KEY `LINES` ( owner, tableid, content, id ) ,
KEY recount( owner, line ) 
) ENGINE = MYISAM;
INSERT into t1 (owner,id,columnid,line) values (11,15,15,1),(11,13,13,5);
SELECT id, columnid, tableid, content, showid, line, ordinal FROM t1 WHERE owner=11 AND ((columnid IN ( 15, 13, 14 ) AND line IN ( 1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 31 )) OR (columnid IN ( 13, 14 ) AND line IN ( 15 ))) LIMIT 0 , 30;
id	columnid	tableid	content	showid	line	ordinal
13	13	1	188	1	5	0
15	15	1	188	1	1	0
drop table t1;
create  table t1 (id int(10) primary key);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9);
select id from t1 where id in (2,5,9) ;
id
2
5
9
select id from t1 where id=2 or id=5 or id=9 ;
id
2
5
9
drop table t1;
create table t1 ( id1 int not null, id2 int not null, idnull int null, c char(20), primary key (id1,id2));
insert into t1 values (0,1,NULL,"aaa"), (1,1,NULL,"aaa"), (2,1,NULL,"aaa"),
(3,1,NULL,"aaa"), (4,1,NULL,"aaa"), (5,1,NULL,"aaa"),
(6,1,NULL,"aaa"), (7,1,NULL,"aaa"), (8,1,NULL,"aaa"),
(9,1,NULL,"aaa"), (10,1,NULL,"aaa"), (11,1,NULL,"aaa"),
(12,1,NULL,"aaa"), (13,1,NULL,"aaa"), (14,1,NULL,"aaa"),
(15,1,NULL,"aaa"), (16,1,NULL,"aaa"), (17,1,NULL,"aaa"),
(18,1,NULL,"aaa"), (19,1,NULL,"aaa"), (20,1,NULL,"aaa");
select a.id1, b.idnull from t1 as a, t1 as b where a.id2=1 and a.id1=1 and b.id1=a.idnull order by b.id2 desc limit 1;
id1	idnull
drop table t1;
create table t1 (
id int not null auto_increment,
name char(1) not null,
uid int not null,
primary key (id),
index uid_index (uid));
create table t2 (
id int not null auto_increment,
name char(1) not null,
uid int not null,
primary key (id),
index uid_index (uid));
insert into t1(id, uid, name) values(1, 0, ' ');
insert into t1(uid, name) values(0, ' ');
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
delete from t2;
insert into t2(uid, name) values 
(1, CHAR(64+1)),
(2, CHAR(64+2)),
(3, CHAR(64+3)),
(4, CHAR(64+4)),
(5, CHAR(64+5)),
(6, CHAR(64+6)),
(7, CHAR(64+7)),
(8, CHAR(64+8)),
(9, CHAR(64+9)),
(10, CHAR(64+10)),
(11, CHAR(64+11)),
(12, CHAR(64+12)),
(13, CHAR(64+13)),
(14, CHAR(64+14)),
(15, CHAR(64+15)),
(16, CHAR(64+16)),
(17, CHAR(64+17)),
(18, CHAR(64+18)),
(19, CHAR(64+19)),
(20, CHAR(64+20)),
(21, CHAR(64+21)),
(22, CHAR(64+22)),
(23, CHAR(64+23)),
(24, CHAR(64+24)),
(25, CHAR(64+25)),
(26, CHAR(64+26));
insert into t1(uid, name) select uid, name from t2 order by uid;
delete from t2;
insert into t2(id, uid, name) select id, uid, name from t1;
select count(*) from t1;
count(*)
1026
select count(*) from t2;
count(*)
1026
analyze table t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	Table is already up to date
explain select * from t1, t2  where t1.uid=t2.uid AND t1.uid > 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	uid_index	uid_index	4	NULL	112	Using index condition
1	SIMPLE	t2	ref	uid_index	uid_index	4	test.t1.uid	38	
explain select * from t1, t2  where t1.uid=t2.uid AND t2.uid > 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	uid_index	uid_index	4	NULL	112	Using index condition
1	SIMPLE	t2	ref	uid_index	uid_index	4	test.t1.uid	38	
explain select * from t1, t2  where t1.uid=t2.uid AND t1.uid != 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	uid_index	uid_index	4	NULL	113	Using index condition
1	SIMPLE	t2	ref	uid_index	uid_index	4	test.t1.uid	38	
explain select * from t1, t2  where t1.uid=t2.uid AND t2.uid != 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	uid_index	uid_index	4	NULL	113	Using index condition
1	SIMPLE	t2	ref	uid_index	uid_index	4	test.t1.uid	38	
select * from t1, t2  where t1.uid=t2.uid AND t1.uid > 0;
id	name	uid	id	name	uid
1001	A	1	1001	A	1
1002	B	2	1002	B	2
1003	C	3	1003	C	3
1004	D	4	1004	D	4
1005	E	5	1005	E	5
1006	F	6	1006	F	6
1007	G	7	1007	G	7
1008	H	8	1008	H	8
1009	I	9	1009	I	9
1010	J	10	1010	J	10
1011	K	11	1011	K	11
1012	L	12	1012	L	12
1013	M	13	1013	M	13
1014	N	14	1014	N	14
1015	O	15	1015	O	15
1016	P	16	1016	P	16
1017	Q	17	1017	Q	17
1018	R	18	1018	R	18
1019	S	19	1019	S	19
1020	T	20	1020	T	20
1021	U	21	1021	U	21
1022	V	22	1022	V	22
1023	W	23	1023	W	23
1024	X	24	1024	X	24
1025	Y	25	1025	Y	25
1026	Z	26	1026	Z	26
select * from t1, t2  where t1.uid=t2.uid AND t1.uid != 0;
id	name	uid	id	name	uid
1001	A	1	1001	A	1
1002	B	2	1002	B	2
1003	C	3	1003	C	3
1004	D	4	1004	D	4
1005	E	5	1005	E	5
1006	F	6	1006	F	6
1007	G	7	1007	G	7
1008	H	8	1008	H	8
1009	I	9	1009	I	9
1010	J	10	1010	J	10
1011	K	11	1011	K	11
1012	L	12	1012	L	12
1013	M	13	1013	M	13
1014	N	14	1014	N	14
1015	O	15	1015	O	15
1016	P	16	1016	P	16
1017	Q	17	1017	Q	17
1018	R	18	1018	R	18
1019	S	19	1019	S	19
1020	T	20	1020	T	20
1021	U	21	1021	U	21
1022	V	22	1022	V	22
1023	W	23	1023	W	23
1024	X	24	1024	X	24
1025	Y	25	1025	Y	25
1026	Z	26	1026	Z	26
drop table t1,t2;
create table t1 (x bigint unsigned not null);
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
x
18446744073709551600
18446744073709551601
select count(*) from t1 where x>0;
count(*)
2
select count(*) from t1 where x=0;
count(*)
0
select count(*) from t1 where x<0;
count(*)
0
select count(*) from t1 where x < -16;
count(*)
0
select count(*) from t1 where x = -16;
count(*)
0
select count(*) from t1 where x > -16;
count(*)
2
select count(*) from t1 where x = 18446744073709551601;
count(*)
1
create table t2 (x bigint not null);
insert into t2(x) values (-16);
insert into t2(x) values (-15);
select * from t2;
x
-16
-15
select count(*) from t2 where x>0;
count(*)
0
select count(*) from t2 where x=0;
count(*)
0
select count(*) from t2 where x<0;
count(*)
2
select count(*) from t2 where x < -16;
count(*)
0
select count(*) from t2 where x = -16;
count(*)
1
select count(*) from t2 where x > -16;
count(*)
1
select count(*) from t2 where x = 18446744073709551601;
count(*)
0
drop table t1,t2;
create table t1 (x bigint unsigned not null primary key) engine=innodb;
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
x
18446744073709551600
18446744073709551601
select count(*) from t1 where x>0;
count(*)
2
select count(*) from t1 where x=0;
count(*)
0
select count(*) from t1 where x<0;
count(*)
0
select count(*) from t1 where x < -16;
count(*)
0
select count(*) from t1 where x = -16;
count(*)
0
select count(*) from t1 where x > -16;
count(*)
2
select count(*) from t1 where x = 18446744073709551601;
count(*)
1
drop table t1;
create table t1 (a bigint unsigned);
create index t1i on t1(a);
insert into t1 select 18446744073709551615;
insert into t1 select 18446744073709551614;
explain select * from t1 where a <> -1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	t1i	t1i	9	NULL	2	Using where; Using index
select * from t1 where a <> -1;
a
18446744073709551614
18446744073709551615
explain select * from t1 where a > -1 or a < -1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	t1i	t1i	9	NULL	2	Using where; Using index
select * from t1 where a > -1 or a < -1;
a
18446744073709551614
18446744073709551615
explain select * from t1 where a > -1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	t1i	t1i	9	NULL	2	Using where; Using index
select * from t1 where a > -1;
a
18446744073709551614
18446744073709551615
explain select * from t1 where a < -1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
select * from t1 where a < -1;
a
drop table t1;
set names latin1;
create table t1 (a char(10), b text, key (a)) character set latin1;
INSERT INTO t1 (a) VALUES
('111'),('222'),('222'),('222'),('222'),('444'),('aaa'),('AAA'),('bbb');
explain select * from t1 where a='aaa';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	a	a	11	const	2	Using index condition
explain select * from t1 where a=binary 'aaa';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	11	NULL	2	Using index condition
explain select * from t1 where a='aaa' collate latin1_bin;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	11	NULL	2	Using index condition
explain select * from t1 where a='aaa' collate latin1_german1_ci;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	a	NULL	NULL	NULL	9	Using where
drop table t1;
CREATE TABLE t1 (
`CLIENT` char(3) character set latin1 collate latin1_bin NOT NULL default '000',
`ARG1` char(3) character set latin1 collate latin1_bin NOT NULL default '',
`ARG2` char(3) character set latin1 collate latin1_bin NOT NULL default '',
`FUNCTION` varchar(10) character set latin1 collate latin1_bin NOT NULL default '',
`FUNCTINT` int(11) NOT NULL default '0',
KEY `VERI_CLNT~2` (`ARG1`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
INSERT INTO t1 VALUES ('000',' 0',' 0','Text 001',0), ('000',' 0',' 1','Text 002',0),
('000',' 1',' 2','Text 003',0), ('000',' 2',' 3','Text 004',0),
('001',' 3',' 0','Text 017',0);
SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 1' OR ARG1 != ' 2');
count(*)
4
SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 2' OR ARG1 != ' 1');
count(*)
4
drop table t1;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t2 (
pk1 int(11) NOT NULL,
pk2 int(11) NOT NULL,
pk3 int(11) NOT NULL,
pk4 int(11) NOT NULL,
filler char(82),
PRIMARY KEY (pk1,pk2,pk3,pk4)
) DEFAULT CHARSET=latin1;
insert into t2 select 1, A.a+10*B.a, 432, 44, 'fillerZ' from t1 A, t1 B;
INSERT INTO t2 VALUES (2621, 2635, 0, 0,'filler'), (2621, 2635, 1, 0,'filler'),
(2621, 2635, 10, 0,'filler'), (2621, 2635, 11, 0,'filler'),
(2621, 2635, 14, 0,'filler'), (2621, 2635, 1000015, 0,'filler');
SELECT * FROM t2
WHERE ((((pk4 =0) AND (pk1 =2621) AND (pk2 =2635)))
OR ((pk4 =1) AND (((pk1 IN ( 7, 2, 1 ))) OR (pk1 =522)) AND ((pk2 IN ( 0, 2635))))
) AND (pk3 >=1000000);
pk1	pk2	pk3	pk4	filler
2621	2635	1000015	0	filler
drop table t1, t2;
create table t1(a char(2), key(a(1)));
insert into t1 values ('x'), ('xx');
explain select a from t1 where a > 'x';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	2	NULL	2	Using where
select a from t1 where a > 'x';
a
xx
drop table t1;
CREATE TABLE t1 (
OXID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
OXPARENTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT 'oxrootid',
OXLEFT int NOT NULL DEFAULT '0',
OXRIGHT int NOT NULL DEFAULT '0',
OXROOTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
PRIMARY KEY  (OXID),
KEY OXNID (OXID),
KEY OXLEFT (OXLEFT),
KEY OXRIGHT (OXRIGHT),
KEY OXROOTID (OXROOTID)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_german2_ci;
INSERT INTO t1 VALUES
('d8c4177d09f8b11f5.52725521','oxrootid',1,40,'d8c4177d09f8b11f5.52725521'),
('d8c4177d151affab2.81582770','d8c4177d09f8b11f5.52725521',2,3,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d206a333d2.74422679','d8c4177d09f8b11f5.52725521',4,5,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d225791924.30714720','d8c4177d09f8b11f5.52725521',6,7,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d2380fc201.39666693','d8c4177d09f8b11f5.52725521',8,9,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d24ccef970.14957924','d8c4177d09f8b11f5.52725521',10,11,
'd8c4177d09f8b11f5.52725521');
INSERT INTO t1 VALUES
('d8c4177d09f8b11f5.52725522','oxrootid',1,40,'d8c4177d09f8b11f5.52725522'),
('d8c4177d151affab2.81582771','d8c4177d09f8b11f5.52725521',2,3,
'd8c4177d09f8b11f5.52725522'),
('d8c4177d206a333d2.74422678','d8c4177d09f8b11f5.52725521',4,5,
'd8c4177d09f8b11f5.52725522'),
('d8c4177d225791924.30714721','d8c4177d09f8b11f5.52725521',6,7,
'd8c4177d09f8b11f5.52725522'),
('d8c4177d2380fc201.39666694','d8c4177d09f8b11f5.52725521',8,9,
'd8c4177d09f8b11f5.52725522'),
('d8c4177d24ccef970.14957925','d8c4177d09f8b11f5.52725521',10,11,
'd8c4177d09f8b11f5.52725522');
EXPLAIN
SELECT s.oxid FROM t1 v, t1 s 
WHERE 
v.oxrootid ='d8c4177d09f8b11f5.52725521' AND
s.oxleft > v.oxleft AND s.oxleft < v.oxright;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	v	ref	OXLEFT,OXRIGHT,OXROOTID	OXROOTID	34	const	5	Using index condition
1	SIMPLE	s	ALL	OXLEFT	NULL	NULL	NULL	12	Range checked for each record (index map: 0x4)
SELECT s.oxid FROM t1 v, t1 s 
WHERE
v.oxrootid ='d8c4177d09f8b11f5.52725521' AND
s.oxleft > v.oxleft AND s.oxleft < v.oxright;
oxid
d8c4177d151affab2.81582770
d8c4177d206a333d2.74422679
d8c4177d225791924.30714720
d8c4177d2380fc201.39666693
d8c4177d24ccef970.14957924
d8c4177d151affab2.81582771
d8c4177d206a333d2.74422678
d8c4177d225791924.30714721
d8c4177d2380fc201.39666694
d8c4177d24ccef970.14957925
DROP TABLE t1;
create table t1 (
c1  char(10), c2  char(10), c3  char(10), c4  char(10),
c5  char(10), c6  char(10), c7  char(10), c8  char(10),
c9  char(10), c10 char(10), c11 char(10), c12 char(10),
c13 char(10), c14 char(10), c15 char(10), c16 char(10),
index(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,c13,c14,c15,c16)
);
insert into t1 (c1) values ('1'),('1'),('1'),('1');
select * from t1 where
c1 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c2 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c3 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c4 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5", 
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c5 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c6 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c7 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c8 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c9 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c10 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC");
c1	c2	c3	c4	c5	c6	c7	c8	c9	c10	c11	c12	c13	c14	c15	c16
drop table t1;
End of 4.1 tests
CREATE TABLE t1 (
id int(11) NOT NULL auto_increment,
status varchar(20),
PRIMARY KEY  (id),
KEY (status)
);
INSERT INTO t1 VALUES
(1,'B'), (2,'B'), (3,'B'), (4,'B'), (5,'B'), (6,'B'),
(7,'B'), (8,'B'), (9,'B'), (10,'B'), (11,'B'), (12,'B'),
(13,'B'), (14,'B'), (15,'B'), (16,'B'), (17,'B'), (18,'B'),
(19,'B'), (20,'B'), (21,'B'), (22,'B'), (23,'B'), (24,'B'), 
(25,'A'), (26,'A'), (27,'A'), (28,'A'), (29,'A'), (30,'A'),
(31,'A'), (32,'A'), (33,'A'), (34,'A'), (35,'A'), (36,'A'),
(37,'A'), (38,'A'), (39,'A'), (40,'A'), (41,'A'), (42,'A'),
(43,'A'), (44,'A'), (45,'A'), (46,'A'), (47,'A'), (48,'A'),
(49,'A'), (50,'A'), (51,'A'), (52,'A'), (53,'C'), (54,'C'),
(55,'C'), (56,'C'), (57,'C'), (58,'C'), (59,'C'), (60,'C');
EXPLAIN SELECT * FROM t1 WHERE status <> 'A' AND status <> 'B';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	11	Using index condition
EXPLAIN SELECT * FROM t1 WHERE status NOT IN ('A','B');
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	11	Using index condition
SELECT * FROM t1 WHERE status <> 'A' AND status <> 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
SELECT * FROM t1 WHERE status NOT IN ('A','B');
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
EXPLAIN SELECT status FROM t1 WHERE status <> 'A' AND status <> 'B';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	11	Using where; Using index
EXPLAIN SELECT status FROM t1 WHERE status NOT IN ('A','B');
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	11	Using where; Using index
EXPLAIN SELECT * FROM t1 WHERE status NOT BETWEEN 'A' AND 'B';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	10	Using index condition
EXPLAIN SELECT * FROM t1 WHERE status < 'A' OR status > 'B';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	status	status	23	NULL	10	Using index condition; Using where
SELECT * FROM t1 WHERE status NOT BETWEEN 'A' AND 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
SELECT * FROM t1 WHERE status < 'A' OR status > 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
DROP TABLE t1;
CREATE TABLE  t1 (a int, b int, primary key(a,b));
INSERT INTO  t1 VALUES
(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3);
CREATE VIEW v1 as SELECT a,b FROM t1 WHERE b=3;
EXPLAIN SELECT a,b FROM t1 WHERE a < 2 and b=3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	4	NULL	4	Using where; Using index
EXPLAIN SELECT a,b FROM v1 WHERE a < 2 and b=3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	4	NULL	4	Using where; Using index
EXPLAIN SELECT a,b FROM t1 WHERE a < 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	4	NULL	4	Using where; Using index
EXPLAIN SELECT a,b FROM v1 WHERE a < 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	4	NULL	4	Using where; Using index
SELECT a,b FROM t1 WHERE a < 2 and b=3;
a	b
1	3
SELECT a,b FROM v1 WHERE a < 2 and b=3;
a	b
1	3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (name varchar(15) NOT NULL, KEY idx(name));
INSERT INTO t1 VALUES ('Betty'), ('Anna');
SELECT * FROM t1;
name
Anna
Betty
DELETE FROM t1 WHERE name NOT LIKE 'A%a';
SELECT * FROM t1;
name
Anna
DROP TABLE t1;
CREATE TABLE t1 (a int, KEY idx(a));
INSERT INTO t1 VALUES (NULL), (1), (2), (3);
SELECT * FROM t1;
a
NULL
1
2
3
DELETE FROM t1 WHERE NOT(a <=> 2);
SELECT * FROM t1;
a
2
DROP TABLE t1;
create table t1 (a int, b int, primary key(a,b));
create view v1 as select a, b from t1;
INSERT INTO `t1` VALUES
(0,0),(1,0),(2,0),(3,0),(4,0),(5,1),(6,1),(7,1),(8,1),(9,1),(10,2),(11,2),(12,2)
,(13,2),(14,2),(15,3),(16,3),(17,3),(18,3),(19,3);
explain select * from t1 where a in (3,4)  and b in (1,2,3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	8	NULL	#	Using where; Using index
explain select * from v1 where a in (3,4)  and b in (1,2,3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	8	NULL	#	Using where; Using index
explain select * from t1 where a between 3 and 4 and b between 1 and 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	8	NULL	#	Using where; Using index
explain select * from v1 where a between 3 and 4 and b between 1 and 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY	PRIMARY	8	NULL	#	Using where; Using index
drop view v1;
drop table t1;
create table t3 (a int);
insert into t3 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a varchar(10), filler char(200), key(a)) charset=binary;
insert into t1 values ('a','');
insert into t1 values ('a ','');
insert into t1 values ('a  ', '');
insert into t1 select concat('a', 1000 + A.a + 10 * (B.a + 10 * C.a)), ''
  from t3 A, t3 B, t3 C;
create table t2 (a varchar(10), filler char(200), key(a));
insert into t2 select * from t1;
explain select * from t1 where a between 'a' and 'a ';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	13	NULL	#	Using index condition
explain select * from t1 where a = 'a' or a='a ';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	13	NULL	#	Using index condition; Using where
explain select * from t2 where a between 'a' and 'a ';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ref	a	a	13	const	#	Using index condition
explain select * from t2 where a = 'a' or a='a ';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ref	a	a	13	const	#	Using index condition; Using where
update t1 set a='b' where a<>'a';
explain select * from t1 where a not between 'b' and 'b';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	13	NULL	#	Using index condition
select a, hex(filler) from t1 where a not between 'b' and 'b';
a	hex(filler)
a	0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
drop table t1,t2,t3;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, key(a));
insert into t2 select 2*(A.a + 10*(B.a + 10*C.a)) from t1 A, t1 B, t1 C;
set @a="select * from t2 force index (a) where a NOT IN(0";
select count(*) from (select @a:=concat(@a, ',', a) from t2 ) Z;
count(*)
1000
set @a=concat(@a, ')');
insert into t2 values (11),(13),(15);
set @b= concat("explain ", @a);
prepare stmt1 from @b;
execute stmt1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	index	a	a	5	NULL	1003	Using where; Using index
prepare stmt1 from @a;
execute stmt1;
a
11
13
15
drop table t1, t2;
CREATE TABLE t1 (
id int NOT NULL DEFAULT '0',
b int NOT NULL DEFAULT '0',
c int NOT NULL DEFAULT '0', 
INDEX idx1(b,c), INDEX idx2(c));
INSERT INTO t1(id) VALUES (1), (2), (3), (4), (5), (6), (7), (8);
INSERT INTO t1(b,c) VALUES (3,4), (3,4);
SELECT * FROM t1 WHERE b<=3 AND 3<=c;
id	b	c
0	3	4
0	3	4
SELECT * FROM t1 WHERE 3 BETWEEN b AND c;
id	b	c
0	3	4
0	3	4
EXPLAIN  SELECT * FROM t1 WHERE b<=3 AND 3<=c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx1,idx2	idx2	4	NULL	3	Using index condition; Using where
EXPLAIN  SELECT * FROM t1 WHERE 3 BETWEEN b AND c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx1,idx2	idx2	4	NULL	3	Using where
SELECT * FROM t1 WHERE 0 < b OR 0 > c;
id	b	c
0	3	4
0	3	4
SELECT * FROM t1 WHERE 0 NOT BETWEEN b AND c;
id	b	c
0	3	4
0	3	4
EXPLAIN SELECT * FROM t1 WHERE 0 < b OR 0 > c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index_merge	idx1,idx2	idx1,idx2	4,4	NULL	4	Using sort_union(idx1,idx2); Using where
EXPLAIN SELECT * FROM t1 WHERE 0 NOT BETWEEN b AND c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index_merge	idx1,idx2	idx1,idx2	4,4	NULL	4	Using sort_union(idx1,idx2); Using where
DROP TABLE t1;
CREATE TABLE t1 (                                      
item char(20) NOT NULL default '',                          
started datetime NOT NULL default '0000-00-00 00:00:00', 
price decimal(16,3) NOT NULL default '0.000',                 
PRIMARY KEY (item,started)                     
) ENGINE=MyISAM;
INSERT INTO t1 VALUES
('A1','2005-11-01 08:00:00',1000),
('A1','2005-11-15 00:00:00',2000),
('A1','2005-12-12 08:00:00',3000),
('A2','2005-12-01 08:00:00',1000);
EXPLAIN SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	PRIMARY	PRIMARY	20	const	2	Using index condition
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
item	started	price
Warnings:
Warning	1292	Incorrect datetime value: '2005-12-01 24:00:00'
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-02 00:00:00';
item	started	price
A1	2005-11-01 08:00:00	1000.000
A1	2005-11-15 00:00:00	2000.000
DROP INDEX `PRIMARY` ON t1;
EXPLAIN SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
item	started	price
Warnings:
Warning	1292	Incorrect datetime value: '2005-12-01 24:00:00'
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-02 00:00:00';
item	started	price
A1	2005-11-01 08:00:00	1000.000
A1	2005-11-15 00:00:00	2000.000
DROP TABLE t1;

BUG#32198 "Comparison of DATE with DATETIME still not using indexes correctly"

CREATE TABLE t1 (
id int(11) NOT NULL auto_increment,
dateval date default NULL,
PRIMARY KEY  (id),
KEY dateval (dateval)
) AUTO_INCREMENT=173;
INSERT INTO t1 VALUES
(1,'2007-01-01'),(2,'2007-01-02'),(3,'2007-01-03'),(4,'2007-01-04'),
(5,'2007-01-05'),(6,'2007-01-06'),(7,'2007-01-07'),(8,'2007-01-08'),
(9,'2007-01-09'),(10,'2007-01-10'),(11,'2007-01-11');
This must use range access:
explain select * from t1 where dateval >= '2007-01-01 00:00:00' and dateval <= '2007-01-02 23:59:59';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	dateval	dateval	4	NULL	2	Using index condition
drop table t1;
CREATE TABLE t1 (
a varchar(32), index (a)
) DEFAULT CHARSET=latin1 COLLATE=latin1_bin;
INSERT INTO t1 VALUES
('B'), ('A'), ('A'), ('C'), ('B'), ('A'), ('A');
SELECT a FROM t1 WHERE a='b' OR a='B';
a
B
B
EXPLAIN SELECT a FROM t1 WHERE a='b' OR a='B';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	35	NULL	3	Using where; Using index
DROP TABLE t1;
CREATE TABLE t1 (f1 TINYINT(11) UNSIGNED NOT NULL, PRIMARY KEY (f1));
INSERT INTO t1 VALUES (127),(254),(0),(1),(255);
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 255;
COUNT(*)
4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < -1;
COUNT(*)
0
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -1;
COUNT(*)
5
DROP TABLE t1;
CREATE TABLE t1 ( f1 TINYINT(11) NOT NULL, PRIMARY KEY (f1));
INSERT INTO t1 VALUES (127),(126),(0),(-128),(-127);
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 127;
COUNT(*)
4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -128;
COUNT(*)
4
DROP TABLE t1;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, b int, filler char(100));
insert into t2 select A.a + 10 * (B.a + 10 * C.a), 10, 'filler' from t1 A,
t1 B, t1 C where A.a < 5;
insert into t2 select 1000, b, 'filler' from t2;
alter table t2 add index (a,b);
select 'In following EXPLAIN the access method should be ref, #rows~=500 (and not 2)' Z;
Z
In following EXPLAIN the access method should be ref, #rows~=500 (and not 2)
explain select * from t2 where a=1000 and b<11;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ref	a	a	5	const	502	Using index condition
drop table t1, t2;
CREATE TABLE t1( a INT, b INT, KEY( a, b ) );
CREATE TABLE t2( a INT, b INT, KEY( a, b ) );
CREATE TABLE t3( a INT, b INT, KEY( a, b ) );
INSERT INTO t1( a, b ) 
VALUES (0, 1), (1, 2), (1, 4), (2, 3), (5, 0), (9, 7);
INSERT INTO t2( a, b ) 
VALUES ( 1, 1), ( 2, 1), ( 3, 1), ( 4, 1), ( 5, 1),
( 6, 1), ( 7, 1), ( 8, 1), ( 9, 1), (10, 1), 
(11, 1), (12, 1), (13, 1), (14, 1), (15, 1),
(16, 1), (17, 1), (18, 1), (19, 1), (20, 1);
INSERT INTO t2 SELECT a, 2 FROM t2 WHERE b = 1;
INSERT INTO t2 SELECT a, 3 FROM t2 WHERE b = 1;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t3
VALUES (1, 0), (2, 0), (3, 0), (4, 0), (5, 0),
(6, 0), (7, 0), (8, 0), (9, 0), (10, 0);
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 < a AND b = 3 OR
3 <= a;
a	b
5	0
9	7
EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 < a AND b = 3 OR
3 <= a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	5	NULL	3	Using where; Using index
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 <= a AND b = 3 OR
3 <= a;
a	b
5	0
9	7
EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 <= a AND b = 3 OR
3 <= a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	5	NULL	4	Using where; Using index
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
5 <= a AND b = 3 OR
3 <= a;
a	b
5	0
9	7
EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
5 <= a AND b = 3 OR
3 <= a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	5	NULL	3	Using where; Using index
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
3 <= a;
a	b
5	0
9	7
EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
3 <= a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	5	NULL	3	Using where; Using index
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 1 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
a	b
1	1
2	1
3	1
4	1
5	1
6	1
7	1
8	1
9	1
10	1
11	1
12	1
13	1
14	1
15	1
15	3
16	1
16	3
17	1
17	3
18	1
18	3
19	1
19	3
20	1
EXPLAIN
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 1 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	a	a	10	NULL	50	Using where; Using index
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 2 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
a	b
1	1
2	1
3	1
4	1
5	1
5	2
6	1
6	2
7	1
7	2
8	1
8	2
9	1
9	2
10	1
11	1
12	1
13	1
14	1
15	1
15	3
16	1
16	3
17	1
17	3
18	1
18	3
19	1
19	3
20	1
EXPLAIN
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 2 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	a	a	10	NULL	50	Using where; Using index
SELECT * FROM t3 WHERE
5 <= a AND a < 10 AND b = 3 OR 
a < 5 OR
a < 10;
a	b
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0
EXPLAIN
SELECT * FROM t3 WHERE
5 <= a AND a < 10 AND b = 3 OR 
a < 5 OR
a < 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	range	a	a	5	NULL	8	Using where; Using index
DROP TABLE t1, t2, t3;
#
# Bug #47123: Endless 100% CPU loop with STRAIGHT_JOIN
#
CREATE TABLE t1(a INT, KEY(a));
INSERT INTO t1 VALUES (1), (NULL);
SELECT * FROM t1 WHERE a <> NULL and (a <> NULL or a <= NULL);
a
DROP TABLE t1;
#
# Bug#47925: regression of range optimizer and date comparison in 5.1.39!
#
CREATE TABLE t1 ( a DATE,     KEY ( a ) );
CREATE TABLE t2 ( a DATETIME, KEY ( a ) );
# Make optimizer choose range scan
INSERT INTO t1 VALUES ('2009-09-22'), ('2009-09-22'), ('2009-09-22');
INSERT INTO t1 VALUES ('2009-09-23'), ('2009-09-23'), ('2009-09-23');
INSERT INTO t2 VALUES ('2009-09-22 12:00:00'), ('2009-09-22 12:00:00'),
('2009-09-22 12:00:00');
INSERT INTO t2 VALUES ('2009-09-23 12:00:00'), ('2009-09-23 12:00:00'),
('2009-09-23 12:00:00');
# DATE vs DATE
EXPLAIN
SELECT * FROM t1 WHERE a >= '2009/09/23';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
X	X	X	range	a	a	X	X	X	X
SELECT * FROM t1 WHERE a >= '2009/09/23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '20090923';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >=  20090923;
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009-9-23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009.09.23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009:09:23';
a
2009-09-23
2009-09-23
2009-09-23
# DATE vs DATETIME
EXPLAIN
SELECT * FROM t2 WHERE a >= '2009/09/23';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
X	X	X	range	a	a	X	X	X	X
SELECT * FROM t2 WHERE a >= '2009/09/23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009/09/23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '20090923';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >=  20090923;
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009-9-23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009.09.23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009:09:23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
# DATETIME vs DATETIME
EXPLAIN
SELECT * FROM t2 WHERE a >= '2009/09/23 12:00:00';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
X	X	X	range	a	a	X	X	X	X
SELECT * FROM t2 WHERE a >= '2009/09/23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '20090923120000';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >=  20090923120000;
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009-9-23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009.09.23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009:09:23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
# DATETIME vs DATE
EXPLAIN
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
X	X	X	range	a	a	X	X	X	X
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '20090923000000';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >=  20090923000000;
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009-9-23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009.09.23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009:09:23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
# Test of the new get_date_from_str implementation
# Behavior differs slightly between the trunk and mysql-pe.
# The former may give errors for the truncated values, while the latter
# gives warnings. The purpose of this test is not to interfere, and only
# preserve existing behavior.
SELECT str_to_date('2007-10-00', '%Y-%m-%d') >= '' AND 
str_to_date('2007-10-00', '%Y-%m-%d') <= '2007/10/20';
str_to_date('2007-10-00', '%Y-%m-%d') >= '' AND 
str_to_date('2007-10-00', '%Y-%m-%d') <= '2007/10/20'
1
Warnings:
Warning	1292	Incorrect datetime value: ''
SELECT str_to_date('2007-20-00', '%Y-%m-%d') >= '2007/10/20' AND 
str_to_date('2007-20-00', '%Y-%m-%d') <= '';
str_to_date('2007-20-00', '%Y-%m-%d') >= '2007/10/20' AND 
str_to_date('2007-20-00', '%Y-%m-%d') <= ''
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
SELECT str_to_date('2007-10-00', '%Y-%m-%d') BETWEEN '' AND '2007/10/20';
str_to_date('2007-10-00', '%Y-%m-%d') BETWEEN '' AND '2007/10/20'
1
Warnings:
Warning	1292	Incorrect datetime value: ''
SELECT str_to_date('2007-20-00', '%Y-%m-%d') BETWEEN '2007/10/20' AND '';
str_to_date('2007-20-00', '%Y-%m-%d') BETWEEN '2007/10/20' AND ''
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
SELECT str_to_date('', '%Y-%m-%d');
str_to_date('', '%Y-%m-%d')
0000-00-00
DROP TABLE t1, t2;
#
# Bug#48459: valgrind errors with query using 'Range checked for each 
# record'
#
CREATE TABLE t1 (
a INT,
b CHAR(2),
c INT,
d INT,
KEY ( c ),
KEY ( d, a, b ( 2 ) ),
KEY ( b ( 1 ) )
);
INSERT INTO t1 VALUES ( NULL, 'a', 1, 2 ), ( NULL, 'a', 1, 2 ),
( 1,    'a', 1, 2 ), ( 1,    'a', 1, 2 );
CREATE TABLE t2 (
a INT,
c INT,
e INT,
KEY ( e )
);
INSERT INTO t2 VALUES ( 1, 1, NULL ), ( 1, 1, NULL );
# Should not give Valgrind warnings
SELECT 1
FROM t1, t2
WHERE t1.d <> '1' AND t1.b > '1'
AND t1.a = t2.a AND t1.c = t2.c;
1
1
1
1
1
DROP TABLE t1, t2;
#
# Bug #48665: sql-bench's insert test fails due to wrong result
#
CREATE TABLE t1 (a INT, b INT, PRIMARY KEY (a));
INSERT INTO t1 VALUES (0,0), (1,1);
EXPLAIN 
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
@	@	@	range	@	@	@	@	@	@
# Should return 2 rows
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);
a	b
0	0
1	1
DROP TABLE t1;
#
# Bug #54802: 'NOT BETWEEN' evaluation is incorrect
#
CREATE TABLE t1 (c_key INT, c_notkey INT, KEY(c_key));
INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3);
EXPLAIN SELECT * FROM t1 WHERE 2 NOT BETWEEN c_notkey AND c_key;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	c_key	NULL	NULL	NULL	3	Using where
SELECT * FROM t1 WHERE 2 NOT BETWEEN c_notkey AND c_key;
c_key	c_notkey
1	1
3	3
DROP TABLE t1;
#
# Bug #57030: 'BETWEEN' evaluation is incorrect
#
CREATE TABLE t1(pk INT PRIMARY KEY, i4 INT);
CREATE UNIQUE INDEX i4_uq ON t1(i4);
INSERT INTO t1 VALUES (1,10), (2,20), (3,30);
EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	const	i4_uq	i4_uq	5	const	1	
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 10;
pk	i4
1	10
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND i4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	const	i4_uq	i4_uq	5	const	1	
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND i4;
pk	i4
1	10
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND i4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	i4_uq	i4_uq	5	NULL	3	Using index condition
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND i4;
pk	i4
1	10
2	20
3	30
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	i4_uq	i4_uq	5	NULL	1	Using index condition
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND 10;
pk	i4
1	10
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	3	
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND 10;
pk	i4
1	10
2	20
3	30
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 11 AND 11;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
SELECT * FROM t1 WHERE 10 BETWEEN 11 AND 11;
pk	i4
EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 100 AND 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
SELECT * FROM t1 WHERE 10 BETWEEN 100 AND 0;
pk	i4
EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 100 AND 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
SELECT * FROM t1 WHERE i4 BETWEEN 100 AND 0;
pk	i4
EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 99999999999999999;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	i4_uq	i4_uq	5	NULL	2	Using index condition
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 99999999999999999;
pk	i4
1	10
2	20
3	30
EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 999999999999999 AND 30;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
SELECT * FROM t1 WHERE i4 BETWEEN 999999999999999 AND 30;
pk	i4
EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND '20';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	i4_uq	i4_uq	5	NULL	1	Using index condition
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND '20';
pk	i4
1	10
2	20
EXPLAIN
SELECT * FROM t1, t1 as t2 WHERE t2.pk BETWEEN t1.i4 AND t1.i4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	i4_uq	NULL	NULL	NULL	3	
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t1.i4	1	Using index condition
SELECT * FROM t1, t1 as t2 WHERE t2.pk BETWEEN t1.i4 AND t1.i4;
pk	i4	pk	i4
EXPLAIN
SELECT * FROM t1, t1 as t2 WHERE t1.i4 BETWEEN t2.pk AND t2.pk;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	i4_uq	NULL	NULL	NULL	3	
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t1.i4	1	Using index condition
SELECT * FROM t1, t1 as t2 WHERE t1.i4 BETWEEN t2.pk AND t2.pk;
pk	i4	pk	i4
DROP TABLE t1;
#
# BUG#13519696 - 62940: SELECT RESULTS VARY WITH VERSION AND
# WITH/WITHOUT INDEX RANGE SCAN
#
create table t1 (id int unsigned not null auto_increment primary key);
insert into t1 values (null);
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
insert into t1 select null from t1;
create table t2 (
id int unsigned not null auto_increment,
val decimal(5,3) not null,
primary key (id,val),
unique key (val,id),
unique key (id));
insert into t2 select null,id*0.0009 from t1;
select count(val) from t2 ignore index (val) where val > 0.1155;
count(val)
128
select count(val) from t2 force index (val)  where val > 0.1155;
count(val)
128
drop table t2, t1;
#
# BUG#13453382 - REGRESSION SINCE 5.1.39, RANGE OPTIMIZER WRONG
# RESULTS WITH DECIMAL CONVERSION
#
create table t1 (a int,b int,c int,primary key (a,c));
insert into t1 values (1,1,2),(1,1,3),(1,1,4);
select convert(3, signed integer) > 2.9;
convert(3, signed integer) > 2.9
1
select * from t1 force  index (primary) where a=1 and c>= 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 ignore index (primary) where a=1 and c>= 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 force  index (primary) where a=1 and c> 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 ignore index (primary) where a=1 and c> 2.9;
a	b	c
1	1	3
1	1	4
drop table t1;
#
# BUG#13463488 - 63437: CHAR & BETWEEN WITH INDEX RETURNS WRONG
# RESULT AFTER MYSQL 5.1.
#
CREATE TABLE t1(
F1 CHAR(5) NOT NULL,
F2 CHAR(5) NOT NULL,
F3 CHAR(5) NOT NULL,
PRIMARY KEY(F1),
INDEX IDX_F2(F2)
);
INSERT INTO t1 VALUES
('A','A','A'),('AA','AA','AA'),('AAA','AAA','AAA'),
('AAAA','AAAA','AAAA'),('AAAAA','AAAAA','AAAAA');
SELECT * FROM t1 WHERE F1 = 'A    ';
F1	F2	F3
A	A	A
SELECT * FROM t1 IGNORE INDEX(PRIMARY) WHERE F1 = 'A    ';
F1	F2	F3
A	A	A
SELECT * FROM t1 WHERE F1 >= 'A    ';
F1	F2	F3
A	A	A
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
SELECT * FROM t1 WHERE F1 > 'A    ';
F1	F2	F3
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
SELECT * FROM t1 WHERE F1 BETWEEN 'A    ' AND 'AAAAA';
F1	F2	F3
A	A	A
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
SELECT * FROM t1 WHERE F2 BETWEEN 'A    ' AND 'AAAAA';
F1	F2	F3
A	A	A
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
SELECT * FROM t1 WHERE F3 BETWEEN 'A    ' AND 'AAAAA';
F1	F2	F3
A	A	A
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
SELECT * FROM t1 IGNORE INDEX(PRIMARY) WHERE F1 BETWEEN 'A    ' AND
'AAAAA';
F1	F2	F3
A	A	A
AA	AA	AA
AAA	AAA	AAA
AAAA	AAAA	AAAA
AAAAA	AAAAA	AAAAA
DROP TABLE t1;
#
# mdev-4894:  Poor performance with unnecessary 
# (bug#70021) 'Range checked for each record'
#
create table t1( key1 int not null, INDEX i1(key1) );
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8);
insert into t1 select key1+8 from t1;
insert into t1 select key1+16 from t1;
insert into t1 select key1+32 from t1;
insert into t1 select key1+64 from t1;
insert into t1 select key1+128 from t1;
insert into t1 select key1+256 from t1;
insert into t1 select key1+512 from t1;
alter table t1 add key2 int not null, add index i2(key2);
update t1 set key2=key1;
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create table t2 (a int);
insert into t2 values (1),(2),(3),(4),(5),(6),(7),(8);
insert into t2 select a+16 from t2;
insert into t2 select a+32 from t2;
insert into t2 select a+64 from t2;
explain
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < 1000;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	64	
1	SIMPLE	t1	range	i1,i2	i1	4	NULL	78	Using where; Using join buffer (flat, BNL join)
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < 1000;
count(*)
128
explain
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < t2.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	64	
1	SIMPLE	t1	range	i1,i2	i1	4	NULL	78	Using where; Using join buffer (flat, BNL join)
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < t2.a;
count(*)
126
drop table t1,t2;
End of 5.1 tests
#
# LP Bug #533117: Wrong use_count in SEL_ARG trees
#   (Bug #58731)
#
create table t1 (a int, b int, c int, key idx (a,b,c));
insert into t1 values (0,0,0), (2,2,0), (1,1,1), (2,2,1);
explain
select * from t1 force index (idx) where a >=1 and c <= 1 and a=b and b > 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx	idx	5	NULL	3	Using where; Using index
select * from t1 force index (idx) where a >=1 and c <= 1 and a=b and b > 1;
a	b	c
2	2	0
2	2	1
drop table t1;
create table t1 (f1 datetime, key (f1));
insert into t1 values ('2000-03-09 15:56:59'),('2000-05-05 23:24:28'),('2000-06-13 13:12:06');
select  min(f1)  from t1 where f1 >= '2006-05-25 07:00:20' and f1 between '2003-11-23 10:00:09' and '2010-01-01 01:01:01' and f1 > '2001-01-01 01:01:01';
min(f1)
NULL
drop table t1;
#
# BUG#11765831: 'RANGE ACCESS' MAY INCORRECTLY FILTER 
#               AWAY QUALIFYING ROWS
#
CREATE TABLE t10(
K INT NOT NULL AUTO_INCREMENT,
I INT, J INT,
PRIMARY KEY(K),
KEY(I,J)
);
INSERT INTO t10(I,J) VALUES (6,1),(6,2),(6,3),(6,4),(6,5),
(6,6),(6,7),(6,8),(6,9),(6,0);
CREATE TABLE t100 LIKE t10;
INSERT INTO t100(I,J) SELECT X.I, X.K+(10*Y.K) FROM t10 AS X,t10 AS Y;
INSERT INTO t100(I,J) VALUES(8,26);

EXPLAIN SELECT * FROM t100 WHERE I <> 6 OR (I <> 8 AND J = 5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t100	range	I	I	10	NULL	4	Using index condition; Using where

SELECT * FROM t100 WHERE I <> 6 OR (I <> 8 AND J = 5);
K	I	J
101	8	26
DROP TABLE t10,t100;
#
# lp:817363: Wrong result with sort_union and multipart key in maria-5.3
# 
CREATE TABLE t1 (a int NOT NULL , b int, c int, d varchar(32), KEY (d,b), PRIMARY KEY (a)) ;
INSERT INTO t1 VALUES (7,7,NULL,'e'),(8,1,0,'p'),(9,7,1,'s'),(10,1,1,'j'),(12,2,0,'c'),(13,0,0,'a'),(14,1,1,'q');
SELECT c FROM t1                  WHERE d='q' OR d>='q' OR a > 97 OR (d IN ('j','s','i') AND b = 102);
c
1
1
SELECT c FROM t1 ignore index (d) WHERE d='q' OR d>='q' OR a > 97 OR (d IN ('j','s','i') AND b = 102);
c
1
1
SELECT * FROM t1 ignore index(d) WHERE d = 'q' OR d >= 'q' OR (d IN ( 'j' , 's' , 'i' ) AND ( b = 102 ));
a	b	c	d
9	7	1	s
14	1	1	q
SELECT * FROM t1 force index(d)  WHERE d = 'q' OR d >= 'q' OR (d IN ( 'j' , 's' , 'i' ) AND ( b = 102 ));
a	b	c	d
14	1	1	q
9	7	1	s
DROP TABLE t1;
#
# BUG#13256446 - ASSERTION QUICK->HEAD->READ_SET ==
# SAVE_READ_SET' FAILED IN OPT_RANGE.CC:1606 
#
CREATE TABLE t1 (
f1 INT AUTO_INCREMENT,
f2 INT,
f3 INT,
f4 INT,
PRIMARY KEY (f1),KEY(f2)
) ENGINE=INNODB;
CREATE ALGORITHM=MERGE VIEW v2 AS SELECT f1,f2,f3,f4 FROM t1 WHERE f2=103;
INSERT INTO t1 VALUES (154,0,NULL,0),(0,NULL,9,0),
(NULL,102,NULL,3),(0,3,NULL,0), (9,0,NULL,0),(0,9,NULL,157);
SELECT * FROM v2;
f1	f2	f3	f4
UPDATE v2 SET f4=0, f2=NULL, f1=NULL WHERE f1 > 16 ORDER BY f1;
SELECT * FROM v2;
f1	f2	f3	f4
DROP TABLE t1;
DROP VIEW v2;
CREATE TABLE t1 (
f1 INT AUTO_INCREMENT,
f2 INT,
f3 INT,
f4 INT,
PRIMARY KEY (f1),KEY(f2)
) ENGINE=INNODB;
INSERT INTO t1 VALUES(1,NULL,NULL,0), (2,2,0,3), (9,0,107,18),
(10,0,0,0), (231,0,0,0), (232,0,8,0), (234,0,0,NULL), (235,8,0,3);
CREATE ALGORITHM=MERGE VIEW v3 AS SELECT f1,f2,f3,f4 FROM t1 WHERE f1<=85 ;
SELECT * FROM v3;
f1	f2	f3	f4
1	NULL	NULL	0
2	2	0	3
9	0	107	18
10	0	0	0
UPDATE v3 SET f3=0, f4=4 WHERE f2=68 ORDER BY f1;
SELECT * FROM v3;
f1	f2	f3	f4
1	NULL	NULL	0
2	2	0	3
9	0	107	18
10	0	0	0
DROP TABLE t1;
DROP VIEW v3;
#
# MDEV-6105: Emoji unicode character string search query makes mariadb performance down
#
SET NAMES utf8;
DROP TABLE IF EXISTS t1;
Warnings:
Note	1051	Unknown table 't1'
CREATE TABLE t1(
id int AUTO_INCREMENT,
fd varchar(20),
primary key(id),
index ix_fd(fd)
)engine=innodb default charset=UTF8;
INSERT INTO t1(id, fd) VALUES (null, ''),(null, 'matt'),(null, 'pitt'),(null, 'lee'),(null, 'kim');
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
# The following should show "Impossible WHERE" :
explain
SELECT * FROM t1 WHERE fd='😁';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
Warnings:
Warning	1366	Incorrect string value: '\xF0\x9F\x98\x81' for column 'fd' at row 1
SELECT * FROM t1 WHERE fd='😁';
id	fd
Warnings:
Warning	1366	Incorrect string value: '\xF0\x9F\x98\x81' for column 'fd' at row 1
# The following must not use range access:
explain select count(*) from t1 where fd <'😁';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	ix_fd	ix_fd	63	NULL	#	Using where; Using index
Warnings:
Warning	1366	Incorrect string value: '\xF0\x9F\x98\x81' for column 'fd' at row 1
select count(*) from t1 where fd <'😁';
count(*)
40960
Warnings:
Warning	1366	Incorrect string value: '\xF0\x9F\x98\x81' for column 'fd' at row 1
select count(*) from t1 ignore index (ix_fd) where fd <'😁';
count(*)
40960
drop table t1;
set names default;
create table t2 (a int, b int, c int, d int, key x(a, b));
insert into t2 values (2, 2, 2, 2), (3, 3, 3, 3), (4, 4, 4, 4), (5, 5, 5, 5),
(6, 6, 6, 6), (7, 7, 7, 7), (8, 8, 8, 8), (9, 9, 9, 9);
insert into t2 select * from t2;
insert into t2 values (0, 0, 0, 0), (1, 1, 1, 1);
analyze table t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
select a, b from t2 where (a, b) in ((0, 0), (1, 1));
a	b
0	0
1	1
drop table t2;
#
# MDEV-10228: Delete missing rows with OR conditions
#  (The example uses UPDATE, because UPDATE allows to use index hints
#   and so it's possible to make an example that works with any storage
#   engine)
#
CREATE TABLE t1 (
key1varchar varchar(14) NOT NULL,
key2int int(11) NOT NULL DEFAULT '0',
col1 int,
PRIMARY KEY (key1varchar,key2int),
KEY key1varchar (key1varchar),
KEY key2int (key2int)
) DEFAULT CHARSET=utf8;
insert into t1 values 
('value1',0, 0),
('value1',1, 0),
('value1',1000685, 0),
('value1',1003560, 0),
('value1',1004807, 0);
update t1 force index (PRIMARY) set col1=12345
where (key1varchar='value1' AND (key2int <=1 OR  key2int > 1));
# The following must show col1=12345 for all rows:
select * from t1;
key1varchar	key2int	col1
value1	0	12345
value1	1	12345
value1	1000685	12345
value1	1003560	12345
value1	1004807	12345
drop table t1;
