set @save_optimizer_switch_jcl6=@@optimizer_switch;
set @@optimizer_switch='optimize_join_buffer_size=on';
set @@optimizer_switch='semijoin_with_cache=on';
set @@optimizer_switch='outer_join_with_cache=on';
set optimizer_switch='mrr=on,mrr_sort_keys=on,index_condition_pushdown=on';
set join_cache_level=6;
show variables like 'join_cache_level';
Variable_name	Value
join_cache_level	6
set @optimizer_switch_for_subselect_sj2_test=@@optimizer_switch;
set @join_cache_level_for_subselect_sj2_test=@@join_cache_level;
set @subselect_sj2_tmp= @@optimizer_switch;
set optimizer_switch='semijoin=on,firstmatch=on,loosescan=on';
set optimizer_switch='mrr=on,mrr_sort_keys=on,index_condition_pushdown=on';
SET optimizer_switch=ifnull(@optimizer_switch_for_subselect_sj2_test,'outer_join_with_cache=off');
SET optimizer_switch=ifnull(@optimizer_switch_for_subselect_sj2_test,'semijoin_with_cache=off');
set join_cache_level=@join_cache_level_for_subselect_sj2_test;
drop table if exists t0, t1, t2, t3, t4, t5;
drop view if exists v1;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (
a int, 
b int
);
insert into t1 values (1,1),(1,1),(2,2);
create table t2 (
a int,
b int,
key(b)
);
insert into t2 select a, a/2 from t0;
insert into t2 select a+10, a+10/2 from t0;
select * from t1;
a	b
1	1
1	1
2	2
select * from t2;
a	b
0	0
1	1
2	1
3	2
4	2
5	3
6	3
7	4
8	4
9	5
10	5
11	6
12	7
13	8
14	9
15	10
16	11
17	12
18	13
19	14
explain select * from t2 where b in (select a from t1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	b	NULL	NULL	NULL	20	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t1	ALL	NULL	NULL	NULL	NULL	3	
select * from t2 where b in (select a from t1);
a	b
1	1
2	1
3	2
4	2
create table t3 (
a int, 
b int,
key(b),
pk1 char(200), pk2 char(200), pk3 char(200),
primary key(pk1, pk2, pk3)
) engine=innodb;
insert into t3 select a,a, a,a,a from t0;
insert into t3 select a,a, a+100,a+100,a+100 from t0;
explain select * from t3 where b in (select a from t1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t3	ALL	b	NULL	NULL	NULL	20	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t1	ALL	NULL	NULL	NULL	NULL	3	
select * from t3 where b in (select a from t1);
a	b	pk1	pk2	pk3
1	1	1	1	1
1	1	101	101	101
2	2	102	102	102
2	2	2	2	2
set @save_max_heap_table_size= @@max_heap_table_size;
set max_heap_table_size=16384;
set @save_join_buffer_size = @@join_buffer_size;
set join_buffer_size= 8192;
drop table t3;
create table t3 (
a int, 
b int,
key(b),
pk1 char(200), pk2 char(200),
primary key(pk1, pk2)
) engine=innodb;
insert into t3 select 
A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a, A.a + 10*B.a 
from t0 A, t0 B where B.a <5;
explain select * from t3 where b in (select a from t0);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t3	ALL	b	NULL	NULL	NULL	#	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	#	
2	MATERIALIZED	t0	ALL	NULL	NULL	NULL	NULL	#	
select * from t3 where b in (select A.a+B.a from t0 A, t0 B where B.a<5);
a	b	pk1	pk2
0	0	0	0
1	1	1	1
10	10	10	10
11	11	11	11
12	12	12	12
13	13	13	13
2	2	2	2
3	3	3	3
4	4	4	4
5	5	5	5
6	6	6	6
7	7	7	7
8	8	8	8
9	9	9	9
set join_buffer_size= @save_join_buffer_size;
set max_heap_table_size= @save_max_heap_table_size;
explain select * from t1 where a in (select b from t2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t2	index	b	b	5	NULL	20	Using index
select * from t1;
a	b
1	1
1	1
2	2
select * from t1 where a in (select b from t2);
a	b
1	1
1	1
2	2
drop table t1, t2, t3;
set @save_join_buffer_size = @@join_buffer_size;
set join_buffer_size= 8192;
create table t1 (a int, filler1 binary(200), filler2 binary(200));
insert into t1 select a, 'filler123456', 'filler123456' from t0;
insert into t1 select a+10, 'filler123456', 'filler123456' from t0;
create table t2 as select * from t1;
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;
insert into t1 values (2, 'duplicate ok', 'duplicate ok');
insert into t1 values (18, 'duplicate ok', 'duplicate ok');
insert into t2 values (3, 'duplicate ok', 'duplicate ok');
insert into t2 values (19, 'duplicate ok', 'duplicate ok');
explain select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<subquery2>	ALL	distinct_key	NULL	NULL	NULL	22	
1	PRIMARY	ot	hash_ALL	NULL	#hash#$hj	5	test.it.a	32	Using where; Using join buffer (flat, BNLH join)
2	MATERIALIZED	it	ALL	NULL	NULL	NULL	NULL	22	Using where
select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
a	mid(filler1, 1,10)	Z
0	filler1234	1
1	filler1234	1
2	filler1234	1
3	filler1234	1
4	filler1234	1
5	filler1234	1
6	filler1234	1
7	filler1234	1
8	filler1234	1
9	filler1234	1
10	filler1234	1
11	filler1234	1
12	filler1234	1
13	filler1234	1
14	filler1234	1
15	filler1234	1
16	filler1234	1
17	filler1234	1
18	filler1234	1
19	filler1234	1
2	duplicate 	1
18	duplicate 	1
explain select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	ot	ALL	NULL	NULL	NULL	NULL	22	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	it	ALL	NULL	NULL	NULL	NULL	32	
select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
a	mid(filler1, 1,10)	length(filler1)=length(filler2)
0	filler1234	1
1	filler1234	1
2	filler1234	1
3	filler1234	1
4	filler1234	1
5	filler1234	1
6	filler1234	1
7	filler1234	1
8	filler1234	1
9	filler1234	1
10	filler1234	1
11	filler1234	1
12	filler1234	1
13	filler1234	1
14	filler1234	1
15	filler1234	1
16	filler1234	1
17	filler1234	1
18	filler1234	1
19	filler1234	1
3	duplicate 	1
19	duplicate 	1
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;
insert into t1 select a+20, 'filler123456', 'filler123456' from t0;
explain select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<subquery2>	ALL	distinct_key	NULL	NULL	NULL	22	
1	PRIMARY	ot	hash_ALL	NULL	#hash#$hj	5	test.it.a	52	Using where; Using join buffer (flat, BNLH join)
2	MATERIALIZED	it	ALL	NULL	NULL	NULL	NULL	22	Using where
select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) as Z 
from t1 ot where a in (select a from t2 it);
a	mid(filler1, 1,10)	Z
0	filler1234	1
1	filler1234	1
2	filler1234	1
3	filler1234	1
4	filler1234	1
5	filler1234	1
6	filler1234	1
7	filler1234	1
8	filler1234	1
9	filler1234	1
10	filler1234	1
11	filler1234	1
12	filler1234	1
13	filler1234	1
14	filler1234	1
15	filler1234	1
16	filler1234	1
17	filler1234	1
18	filler1234	1
19	filler1234	1
2	duplicate 	1
18	duplicate 	1
explain select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	ot	ALL	NULL	NULL	NULL	NULL	22	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	it	ALL	NULL	NULL	NULL	NULL	52	
select 
a, mid(filler1, 1,10), length(filler1)=length(filler2) 
from t2 ot where a in (select a from t1 it);
a	mid(filler1, 1,10)	length(filler1)=length(filler2)
0	filler1234	1
1	filler1234	1
2	filler1234	1
3	filler1234	1
4	filler1234	1
5	filler1234	1
6	filler1234	1
7	filler1234	1
8	filler1234	1
9	filler1234	1
10	filler1234	1
11	filler1234	1
12	filler1234	1
13	filler1234	1
14	filler1234	1
15	filler1234	1
16	filler1234	1
17	filler1234	1
18	filler1234	1
19	filler1234	1
3	duplicate 	1
19	duplicate 	1
drop table t1, t2;
create table t1 (a int, b int, key(a));
create table t2 (a int, b int, key(a));
create table t3 (a int, b int, key(a));
insert into t1 select a,a from t0;
insert into t2 select a,a from t0;
insert into t3 select a,a from t0;
t2 and t3 must be use 'ref', not 'ALL':
explain select * 
from t0 where a in
(select t2.a+t3.a from t1 left join (t2 join t3) on t2.a=t1.a and t3.a=t1.a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t0	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func	1	Using where
2	MATERIALIZED	t1	index	a	a	5	NULL	10	Using where; Using index
2	MATERIALIZED	t2	ref	a	a	5	test.t1.a	1	Using index
2	MATERIALIZED	t3	ref	a	a	5	test.t1.a	1	Using index
drop table t0, t1,t2,t3;
CREATE TABLE t1 (
ID int(11) NOT NULL auto_increment,
Name char(35) NOT NULL default '',
Country char(3) NOT NULL default '',
Population int(11) NOT NULL default '0',
PRIMARY KEY  (ID),
INDEX (Population),
INDEX (Country) 
);
CREATE TABLE t2 (
Code char(3) NOT NULL default '',
Name char(52) NOT NULL default '',
SurfaceArea float(10,2) NOT NULL default '0.00',
Population int(11) NOT NULL default '0',
Capital int(11) default NULL,
PRIMARY KEY  (Code),
UNIQUE INDEX (Name),
INDEX (Population)
);
CREATE TABLE t3 (
Country char(3) NOT NULL default '',
Language char(30) NOT NULL default '',
Percentage float(3,1) NOT NULL default '0.0',
PRIMARY KEY  (Country, Language),
INDEX (Percentage)
);
set @bug35674_save_optimizer_switch=@@optimizer_switch;
set optimizer_switch='materialization=off';
EXPLAIN
SELECT Name FROM t2 
WHERE t2.Code IN (SELECT Country FROM t1 WHERE Population > 5000000)
AND
t2.Code IN (SELECT Country FROM t3 
WHERE Language='English' AND Percentage > 10 AND
t2.Population > 100000);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	range	Population,Country	Population	4	NULL	1	Using index condition; Rowid-ordered scan; Start temporary
1	PRIMARY	t2	eq_ref	PRIMARY,Population	PRIMARY	3	test.t1.Country	1	Using where; End temporary; Using join buffer (flat, BKA join); Key-ordered Rowid-ordered scan
1	PRIMARY	t3	eq_ref	PRIMARY,Percentage	PRIMARY	33	test.t1.Country,const	1	Using index condition; Using where; Using join buffer (incremental, BKA join); Key-ordered Rowid-ordered scan
set optimizer_switch=@bug35674_save_optimizer_switch;
DROP TABLE t1,t2,t3;
CREATE TABLE t1 (
Code char(3) NOT NULL DEFAULT '',
Name char(52) NOT NULL DEFAULT '',
Continent enum('Asia','Europe','North America','Africa','Oceania','Antarctica','South America') NOT NULL DEFAULT 'Asia',
Region char(26) NOT NULL DEFAULT '',
SurfaceArea float(10,2) NOT NULL DEFAULT '0.00',
IndepYear smallint(6) DEFAULT NULL,
Population int(11) NOT NULL DEFAULT '0',
LifeExpectancy float(3,1) DEFAULT NULL,
GNP float(10,2) DEFAULT NULL,
GNPOld float(10,2) DEFAULT NULL,
LocalName char(45) NOT NULL DEFAULT '',
GovernmentForm char(45) NOT NULL DEFAULT '',
HeadOfState char(60) DEFAULT NULL,
Capital int(11) DEFAULT NULL,
Code2 char(2) NOT NULL DEFAULT '',
PRIMARY KEY (Code)
);
CREATE TABLE t2 (
ID int(11) NOT NULL AUTO_INCREMENT,
Name char(35) NOT NULL DEFAULT '',
CountryCode char(3) NOT NULL DEFAULT '',
District char(20) NOT NULL DEFAULT '',
Population int(11) NOT NULL DEFAULT '0',
PRIMARY KEY (ID),
KEY CountryCode (CountryCode)
);
Fill the table with test data
This must not use LooseScan:
EXPLAIN SELECT Name FROM t1 
WHERE t1.Code IN (
SELECT t2.CountryCode FROM t2 WHERE Population > 5000000);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	PRIMARY	NULL	NULL	NULL	31	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	3	func	1	
2	MATERIALIZED	t2	ALL	CountryCode	NULL	NULL	NULL	545	Using where
SELECT Name FROM t1 
WHERE t1.Code IN (
SELECT t2.CountryCode FROM t2 WHERE Population > 5000000);
Name
Austria
Canada
China
Czech Republic
drop table t1, t2;
drop procedure if exists p1;
drop procedure if exists p2;
drop procedure if exists p3;
drop procedure if exists p4;
CREATE TABLE t1(a INT);
CREATE TABLE t2(c INT);
CREATE PROCEDURE p1(v1 int)
BEGIN
SELECT 1 FROM t1 WHERE a = v1 AND a IN (SELECT c FROM t2);
END
//
CREATE PROCEDURE p2(v1 int)
BEGIN
SELECT 1 FROM t1 WHERE a IN (SELECT c FROM t2);
END
//
CREATE PROCEDURE p3(v1 int)
BEGIN
SELECT 1 
FROM 
t1 t01,t1 t02,t1 t03,t1 t04,t1 t05,t1 t06,t1 t07,t1 t08,
t1 t09,t1 t10,t1 t11,t1 t12,t1 t13,t1 t14,t1 t15,t1 t16,
t1 t17,t1 t18,t1 t19,t1 t20,t1 t21,t1 t22,t1 t23,t1 t24,
t1 t25,t1 t26,t1 t27,t1 t28,t1 t29,t1 t30,t1 t31,t1 t32,
t1 t33,t1 t34,t1 t35,t1 t36,t1 t37,t1 t38,t1 t39,t1 t40,
t1 t41,t1 t42,t1 t43,t1 t44,t1 t45,t1 t46,t1 t47,t1 t48,
t1 t49,t1 t50,t1 t51,t1 t52,t1 t53,t1 t54,t1 t55,t1 t56,
t1 t57,t1 t58,t1 t59,t1 t60
WHERE t01.a IN (SELECT c FROM t2);
END
//
CREATE PROCEDURE p4(v1 int)
BEGIN
SELECT 1 
FROM 
t1 t01,t1 t02,t1 t03,t1 t04,t1 t05,t1 t06,t1 t07,t1 t08,
t1 t09,t1 t10,t1 t11,t1 t12,t1 t13,t1 t14,t1 t15,t1 t16,
t1 t17,t1 t18,t1 t19,t1 t20,t1 t21,t1 t22,t1 t23,t1 t24,
t1 t25,t1 t26,t1 t27,t1 t28,t1 t29,t1 t30,t1 t31,t1 t32,
t1 t33,t1 t34,t1 t35,t1 t36,t1 t37,t1 t38,t1 t39,t1 t40,
t1 t41,t1 t42,t1 t43,t1 t44,t1 t45,t1 t46,t1 t47,t1 t48,
t1 t49,t1 t50,t1 t51,t1 t52,t1 t53,t1 t54,t1 t55,t1 t56,
t1 t57,t1 t58,t1 t59,t1 t60
WHERE t01.a = v1 AND t01.a IN (SELECT c FROM t2);
END
//
CALL p1(1);
1
CALL p2(1);
1
CALL p3(1);
1
CALL p4(1);
1
DROP TABLE t1, t2;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP PROCEDURE p3;
DROP PROCEDURE p4;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4);
create table t1 (a int, b int, key(a));
insert into t1 select a,a from t0;
insert into t1 select a+5,a from t0;
create table t2 (a int, b int, primary key(a));
insert into t2 select * from t1;
Table t2, unlike table t1, should be displayed as pulled out
explain extended select * from t0
where t0.a in ( select t1.a from t1,t2 where t2.a=t0.a and
t1.b=t2.b);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t0	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where
1	PRIMARY	t2	eq_ref	PRIMARY	PRIMARY	4	test.t0.a	1	100.00	Using join buffer (flat, BKA join); Key-ordered Rowid-ordered scan
1	PRIMARY	t1	ref	a	a	5	test.t0.a	1	100.00	Using where; FirstMatch(t2); Using join buffer (incremental, BKA join); Key-ordered Rowid-ordered scan
Warnings:
Note	1276	Field or reference 'test.t0.a' of SELECT #2 was resolved in SELECT #1
Note	1003	select `test`.`t0`.`a` AS `a` from `test`.`t2` semi join (`test`.`t1`) join `test`.`t0` where ((`test`.`t2`.`a` = `test`.`t0`.`a`) and (`test`.`t1`.`a` = `test`.`t0`.`a`) and (`test`.`t1`.`b` = `test`.`t2`.`b`))
update t1 set a=3, b=11 where a=4;
update t2 set b=11 where a=3;
# Not anymore:
# The following query gives wrong result due to Bug#49129
select * from t0 where t0.a in 
(select t1.a from t1, t2 where t2.a=t0.a and t1.b=t2.b);
a
0
1
2
3
drop table t0, t1, t2;
CREATE TABLE t1 (
id int(11) NOT NULL,
PRIMARY KEY (id));
CREATE TABLE t2 (
id int(11) NOT NULL,
fid int(11) NOT NULL,
PRIMARY KEY (id));
insert into t1 values(1);
insert into t2 values(1,7503),(2,1);
explain select count(*) 
from t1 
where fid IN (select fid from t2 where (id between 7502 and 8420) order by fid );
ERROR 42S22: Unknown column 'fid' in 'IN/ALL/ANY subquery'
drop table t1, t2;
create table t1 (a int, b int, key (a), key (b));
insert into t1 values (2,4),(2,4),(2,4);
select t1.a from t1 
where 
t1.a in (select 1 from t1 where t1.a in (select 1 from t1) group by  t1.a);
a
drop table t1;
create table t1(a int,b int,key(a),key(b));
insert into t1 values (1,1),(2,2),(3,3);
select 1 from t1 
where t1.a not in (select 1 from t1 
where t1.a in (select 1 from t1) 
group by  t1.b);
1
1
1
drop table t1;
CREATE TABLE t1
(EMPNUM   CHAR(3) NOT NULL,
EMPNAME  CHAR(20),
GRADE    DECIMAL(4),
CITY     CHAR(15));
CREATE TABLE t2
(PNUM     CHAR(3) NOT NULL,
PNAME    CHAR(20),
PTYPE    CHAR(6),
BUDGET   DECIMAL(9),
CITY     CHAR(15));
CREATE TABLE t3
(EMPNUM   CHAR(3) NOT NULL,
PNUM     CHAR(3) NOT NULL,
HOURS    DECIMAL(5));
INSERT INTO t1 VALUES ('E1','Alice',12,'Deale');
INSERT INTO t1 VALUES ('E2','Betty',10,'Vienna');
INSERT INTO t1 VALUES ('E3','Carmen',13,'Vienna');
INSERT INTO t1 VALUES ('E4','Don',12,'Deale');
INSERT INTO t1 VALUES ('E5','Ed',13,'Akron');
INSERT INTO t2 VALUES ('P1','MXSS','Design',10000,'Deale');
INSERT INTO t2 VALUES ('P2','CALM','Code',30000,'Vienna');
INSERT INTO t2 VALUES ('P3','SDP','Test',30000,'Tampa');
INSERT INTO t2 VALUES ('P4','SDP','Design',20000,'Deale');
INSERT INTO t2 VALUES ('P5','IRM','Test',10000,'Vienna');
INSERT INTO t2 VALUES ('P6','PAYR','Design',50000,'Deale');
INSERT INTO t3 VALUES  ('E1','P1',40);
INSERT INTO t3 VALUES  ('E1','P2',20);
INSERT INTO t3 VALUES  ('E1','P3',80);
INSERT INTO t3 VALUES  ('E1','P4',20);
INSERT INTO t3 VALUES  ('E1','P5',12);
INSERT INTO t3 VALUES  ('E1','P6',12);
INSERT INTO t3 VALUES  ('E2','P1',40);
INSERT INTO t3 VALUES  ('E2','P2',80);
INSERT INTO t3 VALUES  ('E3','P2',20);
INSERT INTO t3 VALUES  ('E4','P2',20);
INSERT INTO t3 VALUES  ('E4','P4',40);
INSERT INTO t3 VALUES  ('E4','P5',80);
SELECT * FROM t1;
EMPNUM	EMPNAME	GRADE	CITY
E1	Alice	12	Deale
E2	Betty	10	Vienna
E3	Carmen	13	Vienna
E4	Don	12	Deale
E5	Ed	13	Akron
CREATE UNIQUE INDEX t1_IDX ON t1(EMPNUM);
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP INDEX t1_IDX ON t1;
CREATE INDEX t1_IDX ON t1(EMPNUM);
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP INDEX t1_IDX ON t1;
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP TABLE t1, t2, t3;
CREATE TABLE t1 (f1 INT NOT NULL);
CREATE VIEW v1 (a) AS SELECT f1 IN (SELECT f1 FROM t1) FROM t1;
SELECT * FROM v1;
a
drop view v1;
drop table t1;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1(a int, b int);
insert into t1 values (0,0),(1,1),(2,2);
create table t2 as select * from t1;
create table t3 (pk int, a int, primary key(pk));
insert into t3 select a,a from t0;
explain 
select * from t1 left join t2 on (t2.a= t1.a and t2.a in (select pk from t3));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	
1	PRIMARY	t2	hash_ALL	NULL	#hash#$hj	5	test.t1.a	3	Using where; Using join buffer (flat, BNLH join)
2	MATERIALIZED	t3	index	PRIMARY	PRIMARY	4	NULL	10	Using index
drop table t0, t1, t2, t3;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a char(200), b char(200), c char(200), primary key (a,b,c)) engine=innodb;
insert into t2 select concat(a, repeat('X',198)),repeat('B',200),repeat('B',200) from t1;
insert into t2 select concat(a, repeat('Y',198)),repeat('B',200),repeat('B',200) from t1;
alter table t2 add filler1 int;
insert into t1 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;
set @save_join_buffer_size=@@join_buffer_size;
set join_buffer_size=1;
select * from t2 where filler1 in ( select a from t1);
a	b	c	filler1
set join_buffer_size=default;
drop table t1, t2;
create table t1 (a int not null);
drop procedure if exists p1;
CREATE PROCEDURE p1()
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION select a from t1;
prepare s1 from '
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( 
  select a from t1 where a in ( select a from t1) 
  )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))';
execute s1;
END;
|
call p1();
a
drop procedure p1;
drop table t1;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int) as select A.a + 10 *(B.a + 10*C.a) as a  from t0 A, t0 B, t0 C;
create table t2 (id int, a int, primary key(id), key(a)) as select a as id, a as a  from t1;
show create table t2;
Table	Create Table
t2	CREATE TABLE `t2` (
  `id` int(11) NOT NULL DEFAULT '0',
  `a` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1
set @a=0;
create table t3 as select * from t2 limit 0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
alter table t3 add primary key(id), add key(a);
The following must use loose index scan over t3, key a:
explain select count(a) from t2 where a in ( SELECT  a FROM t3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	index	a	a	5	NULL	1000	Using index
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t3	index	a	a	5	NULL	30000	Using index
select count(a) from t2 where a in ( SELECT  a FROM t3);
count(a)
1000
drop table t0,t1,t2,t3;

BUG#42740: crash in optimize_semijoin_nests

create table t1 (c6 timestamp,key (c6)) engine=innodb;
create table t2 (c2 double) engine=innodb;
explain select 1 from t2 where c2 = any (select log10(null) from t1 where c6 <null)  ;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
drop table t1, t2;
# 
# BUG#42742: crash in setup_sj_materialization, Copy_field::set
# 
create table t3 ( c1 year) engine=innodb;
insert into t3 values (2135),(2142);
create table t2 (c1 tinytext,c2 text,c6 timestamp) engine=innodb;
# The following must not crash, EXPLAIN should show one SJ strategy, not a mix:
explain select 1 from t2 where 
c2 in (select 1 from t3, t2) and
c1 in (select convert(c6,char(1)) from t2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	1	Using where
1	PRIMARY	<subquery3>	eq_ref	distinct_key	distinct_key	4	func	1	Using where
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	1	Using join buffer (flat, BNL join)
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	2	FirstMatch((sj-nest)); Using join buffer (incremental, BNL join)
3	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	1	
drop table t2, t3;
#
# BUG#761598: InnoDB: Error: row_search_for_mysql() is called without ha_innobase::external_lock() in maria-5.3
#
CREATE TABLE t1 ( f1 int NOT NULL , f10 int) ;
INSERT IGNORE INTO t1 VALUES (25,0),(29,0);
CREATE TABLE t2 ( f10 int) ENGINE=InnoDB;
CREATE TABLE t3 ( f11 int) ;
INSERT IGNORE INTO t3 VALUES (0);
SELECT alias1.f10 AS field2
FROM t2 AS alias1
JOIN (
t3 AS alias2
JOIN t1 AS alias3
ON alias3.f10
) ON alias3.f1
WHERE alias2.f11 IN (
SELECT SQ4_alias1.f10
FROM t1 AS SQ4_alias1
LEFT JOIN t2 AS SQ4_alias3 ON SQ4_alias3.f10
)
GROUP BY field2;
field2
drop table t1, t2, t3;
#
# BUG#849763: Wrong result with second execution of prepared statement with semijoin + view
#
CREATE TABLE t1 ( c varchar(1)) engine=innodb;
INSERT INTO t1 VALUES ('r');
CREATE TABLE t2 ( a integer, b varchar(1), c varchar(1)) engine=innodb;
INSERT INTO t2 VALUES (1,'r','r');
CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1;
PREPARE st1 FROM 'SELECT * FROM t2 WHERE a = SOME (SELECT a FROM v1 WHERE v1.c = t2.c)';
EXECUTE st1;
a	b	c
1	r	r
EXECUTE st1;
a	b	c
1	r	r
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#858732: Wrong result with semijoin + loosescan + comma join
#
CREATE TABLE t1 (f13 int(11) NOT NULL , PRIMARY KEY (f13)) ENGINE=InnoDB;
INSERT INTO t1 VALUES (16),(24);
CREATE TABLE t2 (f14 int(11) NOT NULL, f12 varchar(1) NOT NULL, KEY (f12,f14)) ENGINE=InnoDB;
INSERT INTO t2 VALUES (6,'y');
CREATE TABLE t3 (f12 varchar(1) NOT NULL) ENGINE=InnoDB;
INSERT INTO t3 VALUES ('r'),('s'),('t'),('v'),('w'),('x'),('y');
# The following must use LooseScan but not join buffering
explain
SELECT * FROM t3 
WHERE f12 IN (SELECT alias2.f12 FROM t1 AS alias1, t2 AS alias2, t1 WHERE alias1.f13 = 24);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	alias1	const	PRIMARY	PRIMARY	4	const	1	Using index
1	PRIMARY	alias2	index	f12	f12	7	NULL	1	Using index; LooseScan
1	PRIMARY	t1	index	NULL	PRIMARY	4	NULL	2	Using index; FirstMatch(alias2)
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	7	Using where; Using join buffer (flat, BNL join)
SELECT * FROM t3 
WHERE f12 IN (SELECT alias2.f12 FROM t1 AS alias1, t2 AS alias2, t1 WHERE alias1.f13 = 24);
f12
y
DROP TABLE t1,t2,t3;
#
# BUG#869012: Wrong result with semijoin + materialization + AND in WHERE
#
CREATE TABLE t1 (f3 varchar(1) , f4 varchar(1) ) engine=InnoDB;
INSERT IGNORE INTO t1 VALUES ('x','x'),('x','x');
CREATE TABLE t2 ( f4 varchar(1) ) ;
INSERT IGNORE INTO t2 VALUES ('g');
CREATE TABLE t3 (f4 varchar(1) ) Engine=InnoDB;
INSERT IGNORE INTO t3 VALUES ('x');
set @tmp_869012=@@optimizer_switch;
SET optimizer_switch='semijoin=on,materialization=on';
SELECT *
FROM t1 , t2
WHERE ( t1.f4 ) IN ( SELECT f4 FROM t3 )
AND t2.f4 != t1.f3 ;
f3	f4	f4
x	x	g
x	x	g
set optimizer_switch= @tmp_869012;
DROP TABLE t1,t2,t3;
#
# BUG#869001: Wrong result with semijoin + materialization + firstmatch + multipart key
#
set @tmp869001_jcl= @@join_cache_level;
set @tmp869001_os= @@optimizer_switch;
SET join_cache_level=0;
SET optimizer_switch='materialization=on,semijoin=on,firstmatch=on,loosescan=off';
CREATE TABLE t1 ( f2 int, f3 varchar(1), KEY (f3,f2)) engine=innodb;
INSERT INTO t1 VALUES (8,'x'),(NULL,'x'),(8,'c');
CREATE TABLE t2 ( f4 varchar(1)) engine=innodb;
INSERT INTO t2 VALUES ('x');
CREATE TABLE t3 ( f1 int) engine=innodb;
INSERT INTO t3 VALUES (8),(6),(2),(9),(6);
CREATE TABLE t4 ( f3 varchar(1)) engine=innodb;
INSERT INTO t4 VALUES ('p'),('j'),('c');
SELECT *
FROM t1 JOIN t2 ON (t2.f4 = t1.f3 )
WHERE ( 8 ) IN (
SELECT t3.f1 FROM t3 , t4
);
f2	f3	f4
NULL	x	x
8	x	x
DROP TABLE t1, t2, t3, t4;
set join_cache_level= @tmp869001_jcl;
set optimizer_switch= @tmp869001_os;
# 
# Bug #881318: join cache + duplicate elimination + left join
#              with empty materialized derived inner table
#
CREATE TABLE t1 (b varchar(1)) ENGINE=InnoDB;
CREATE TABLE t2 (a varchar(1)) ENGINE=InnoDB;
INSERT INTO t2 VALUES ('a');
CREATE TABLE t3 (a varchar(1), b varchar(1)) ENGINE=InnoDB;
INSERT INTO t3 VALUES ('c','c');
CREATE TABLE t4 (b varchar(1)) ENGINE=InnoDB;
INSERT INTO t4 VALUES ('c'), ('b');
CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t1;
EXPLAIN
SELECT * FROM t3 LEFT JOIN (v1,t2) ON t3.a = t2.a
WHERE t3.b IN (SELECT b FROM t4);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	1	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
1	PRIMARY	t2	hash_ALL	NULL	#hash#$hj	5	test.t3.a	1	Using where; Using join buffer (flat, BNLH join)
1	PRIMARY	<derived3>	ALL	NULL	NULL	NULL	NULL	2	Using join buffer (incremental, BNL join)
2	MATERIALIZED	t4	ALL	NULL	NULL	NULL	NULL	2	
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM t3 LEFT JOIN (v1,t2) ON t3.a = t2.a
WHERE t3.b IN (SELECT b FROM t4);
a	b	b	a
c	c	NULL	NULL
DROP VIEW v1;
DROP TABLE t1,t2,t3,t4;
#
# BUG#912538: Wrong result (missing rows) with semijoin=on, firstmatch=on, ...
#
CREATE TABLE t1 ( a INT NOT NULL, UNIQUE KEY(a) );
INSERT INTO t1 VALUES (1),(2),(3),(4);
CREATE TABLE t2 ( b INT, c INT ) ENGINE=InnoDB;
INSERT INTO t2 VALUES (1,1);
SELECT * FROM t1, t2 WHERE c IN (SELECT c FROM t1, t2 WHERE a = b);
a	b	c
1	1	1
2	1	1
3	1	1
4	1	1
DROP TABLE t1,t2;
# 
# BUG#962667: Assertion `0' failed in QUICK_INDEX_SORT_SELECT::need_sorted_output() 
#   with index_merge+index_merge_sort_union+loosescan+semijoin
#
CREATE TABLE t1 (
a INT, b VARCHAR(1), c INT,
KEY(a), KEY(b)
) ENGINE=InnoDB;
INSERT INTO t1 VALUES
(1,'v',9),(2,'v',8),(3,'c',7),(4,'m',6),(5,'x',5),
(6,'i',4),(7,'e',3),(8,'p',2),(9,'s',1),(10,'j',9),
(11,'z',8),(12,'c',7),(13,'a',6),(14,'q',5),(15,'y',4),
(16,'n',3),(17,'r',2),(18,'v',1),(19,'p',0);
CREATE TABLE t2 (
pk INT, d VARCHAR(1), e INT,
PRIMARY KEY(pk), KEY(d,e)
) ENGINE=InnoDB;
INSERT INTO t2 VALUES
(1,'x',1),(2,'d',2),(3,'r',3),(4,'f',4),(5,'y',5),
(6,'u',6),(7,'m',7),(8,'k',8),(9,'o',9),(10,'w',1),
(11,'m',2),(12,'q',3),(13,'m',4),(14,'d',5),
(15,'g',6),(16,'x',7),(17,'f',8);
explain
SELECT * FROM t1 WHERE b IN (
SELECT d FROM t2, t1
WHERE a = d AND ( pk < 2 OR d = 'z' )
);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	b	NULL	NULL	NULL	19	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t2	index	PRIMARY,d	d	9	NULL	17	Using where; Using index
2	MATERIALIZED	t1	ref	a	a	5	test.t2.d	1	Using where; Using index
SELECT * FROM t1 WHERE b IN (
SELECT d FROM t2, t1
WHERE a = d AND ( pk < 2 OR d = 'z' )
);
a	b	c
DROP TABLE t1, t2;
#
# BUG#951937: Wrong result (missing rows) with semijoin+materialization, IN subquery, InnoDB, TEMPTABLE view
#
CREATE TABLE t1 (
a VARCHAR(1),
b VARCHAR(1) NOT NULL,
KEY(a)
) ENGINE=InnoDB;
INSERT INTO t1 VALUES
('j','j'),('v','v'),('c','c'),('m','m'),('d','d'),
('y','y'),('t','t'),('d','d'),('s','s'),('r','r'),
('m','m'),('b','b'),('x','x'),('g','g'),('p','p'),
('q','q'),('w','w'),('d','d'),('e','e');
CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t1;
# This query returned 6 rows instead of 19
SELECT * FROM v1
WHERE ( a, a ) IN (
SELECT alias2.b, alias2.a
FROM t1 AS alias1, t1 AS alias2
WHERE alias2.b = alias1.a
AND ( alias1.b >= alias1.a OR alias2.b = 'z' )
);
a	b
b	b
c	c
d	d
d	d
d	d
e	e
g	g
j	j
m	m
m	m
p	p
q	q
r	r
s	s
t	t
v	v
w	w
x	x
y	y
# Another testcase, without the VIEW:
CREATE TABLE t2 (a VARCHAR(1), b VARCHAR(1) NOT NULL, KEY(a)) ENGINE=InnoDB;
INSERT INTO t2 SELECT * FROM t1;
INSERT INTO t2 SELECT * FROM t1;
EXPLAIN 
SELECT * FROM t2 
WHERE (a, a) IN (SELECT alias2.b, alias2.a FROM t1 AS alias1, t1 AS alias2 
WHERE 
alias2.b = alias1.a AND 
(alias1.b >= alias1.a OR alias2.b = 'z'));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	a	NULL	NULL	NULL	38	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	
2	MATERIALIZED	alias1	ALL	a	NULL	NULL	NULL	19	Using where
2	MATERIALIZED	alias2	ref	a	a	4	test.alias1.a	1	Using where; Using join buffer (flat, BKA join); Key-ordered Rowid-ordered scan
SELECT * FROM t2 
WHERE (a, a) IN (SELECT alias2.b, alias2.a FROM t1 AS alias1, t1 AS alias2 
WHERE 
alias2.b = alias1.a AND 
(alias1.b >= alias1.a OR alias2.b = 'z'));
a	b
b	b
b	b
c	c
c	c
d	d
d	d
d	d
d	d
d	d
d	d
e	e
e	e
g	g
g	g
j	j
j	j
m	m
m	m
m	m
m	m
p	p
p	p
q	q
q	q
r	r
r	r
s	s
s	s
t	t
t	t
v	v
v	v
w	w
w	w
x	x
x	x
y	y
y	y
DROP VIEW v1;
DROP TABLE t1, t2;
# 
# BUG#965872: Server crashes in embedding_sjm on a simple 1-table select with AND and OR  
#  (this is a regression caused by the fix for BUG#951937)
CREATE TABLE t1 ( a INT, b INT, c INT, d INT );
INSERT INTO t1 VALUES (4,2,8,9),(4,2,7,8);
SELECT * FROM t1
WHERE a = d AND ( b = 50 AND b = d OR a = c );
a	b	c	d
DROP TABLE t1;
#
# BUG#951283: Wrong result (missing rows) with semijoin+firstmatch, IN/ANY subquery
#
set @tmp_951283=@@optimizer_prune_level;
SET optimizer_prune_level=0;
CREATE TABLE t1 ( a INT ) ENGINE=InnoDB;
INSERT INTO t1 VALUES
(10),(11),(12),(13),(14),(15),(16),
(17),(18),(19),(20),(21),(22),(23);
CREATE TABLE t2 (
b INT PRIMARY KEY,
c VARCHAR(1),
d VARCHAR(1),
KEY(c)
) ENGINE=InnoDB;
INSERT INTO t2 VALUES
(1,'j','j'),(2,'v','v'),(3,'c','c'),(4,'m','m'),
(5,'d','d'),(6,'d','d'),(7,'y','y'),(8,'t','t'),
(9,'d','d'),(10,'s','s'),(11,'r','r'),(12,'m','m'),
(13,'b','b'),(14,'x','x'),(15,'g','g'),(16,'p','p'),
(17,'q','q'),(18,'w','w'),(19,'d','d');
EXPLAIN
SELECT COUNT(*) FROM t1 AS alias1, t1 AS alias2, t2 AS alias3
WHERE alias3.d IN (
SELECT alias4.c FROM t2 AS alias4, t2 AS alias5
WHERE alias5.b = alias4.b
AND ( alias5.b >= alias3.b OR alias5.c != alias3.c )
);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	alias3	ALL	PRIMARY	NULL	NULL	NULL	19	Using where
1	PRIMARY	alias4	ref	PRIMARY,c	c	4	test.alias3.d	1	Using index
1	PRIMARY	alias5	eq_ref	PRIMARY	PRIMARY	4	test.alias4.b	1	Using where; FirstMatch(alias3)
1	PRIMARY	alias2	ALL	NULL	NULL	NULL	NULL	14	Using join buffer (flat, BNL join)
1	PRIMARY	alias1	ALL	NULL	NULL	NULL	NULL	14	Using join buffer (incremental, BNL join)
SELECT COUNT(*) FROM t1 AS alias1, t1 AS alias2, t2 AS alias3
WHERE alias3.d IN (
SELECT alias4.c FROM t2 AS alias4, t2 AS alias5
WHERE alias5.b = alias4.b
AND ( alias5.b >= alias3.b OR alias5.c != alias3.c )
);
COUNT(*)
3724
set optimizer_prune_level=@tmp_951283;
DROP TABLE t1,t2;
#
# Bug mdev-5135: crash on semijoin with nested outer joins
#
CREATE TABLE t1 (i1 int) ENGINE=MyISAM;
INSERT INTO t1 VALUES (1),(2);
CREATE TABLE t2 (i2 int, INDEX(i2)) ENGINE=MyISAM;
CREATE TABLE t3 (i3 int, c varchar(1), INDEX(i3), INDEX(c)) ENGINE=MyISAM;
INSERT INTO t3 VALUES (3,'x'),(4,'y');
SELECT * FROM t1 WHERE ( 1, 1 ) IN ( 
SELECT i2, i2 FROM t2 LEFT OUTER JOIN ( 
t3 AS t3a INNER JOIN t3 AS t3b ON ( t3a.i3 = t3b.i3 ) 
) ON ( t3a.c = t3b.c ) 
);
i1
DROP TABLE t1,t2,t3;
#
# MDEV-5582: Plugin 'MEMORY' has ref_count=1 after shutdown with materialization+semijoin
#
CREATE TABLE t1 (a INT) engine=innodb;
INSERT INTO t1 VALUES (8),(9);
CREATE TABLE t2 (b INT) engine=innodb;
INSERT INTO t2 VALUES (2),(3);
CREATE TABLE t3 (c INT, INDEX(c)) engine=innodb;
INSERT INTO t2 VALUES (4),(5);
explain
SELECT * FROM t1 WHERE 9 IN ( SELECT b FROM t2 WHERE 1 IN ( SELECT MIN(c) FROM t3 ) );
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
3	MATERIALIZED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No matching min/max row
SELECT * FROM t1 WHERE 9 IN ( SELECT b FROM t2 WHERE 1 IN ( SELECT MIN(c) FROM t3 ) );
a
DROP TABLE t1,t2,t3;
DROP TABLE IF EXISTS t1,t2,t3,t4;
#
# MDEV-4782: Valgrind warnings (Conditional jump or move depends on uninitialised value) with InnoDB, semijoin
#
CREATE TABLE t1 ( t1_pk1 varchar(3), t1_pk2 varchar(52), PRIMARY KEY (t1_pk1,t1_pk2)) ENGINE=InnoDB;
INSERT INTO t1 VALUES ('CHN','Chinese'),('USA','English');
CREATE TABLE t2 ( t2_i int(11), t2_c varchar(52)) ENGINE=InnoDB;
INSERT INTO t2 VALUES (86,'English');
CREATE TABLE t3 ( t3_i int(11), t3_c varchar(35)) ENGINE=InnoDB;
INSERT INTO t3 VALUES (3989,'Abilene'),(3873,'Akron');
create table t4 like t1;
insert into t4 select * from t1;
SELECT * FROM t1, t3 WHERE t3_c IN ( SELECT t1_pk2 FROM t4, t2 WHERE t2_c = t1_pk2 AND t2_i >= t3_i ) AND ( t1_pk1 = 'POL' );
t1_pk1	t1_pk2	t3_i	t3_c
explain
SELECT * FROM t1, t3 WHERE t3_c IN ( SELECT t1_pk2 FROM t4, t2 WHERE t2_c = t1_pk2 AND t2_i >= t3_i ) AND ( t1_pk1 = 'POL' );
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ref	PRIMARY	PRIMARY	5	const	1	Using where; Using index
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	1	Start temporary; Using join buffer (flat, BNL join)
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (incremental, BNL join)
1	PRIMARY	t4	hash_index	NULL	#hash#$hj:PRIMARY	55:59	test.t3.t3_c	2	Using where; End temporary; Using join buffer (incremental, BNLH join)
DROP TABLE t1,t2,t3,t4;
# This must be the last in the file:
set optimizer_switch=@subselect_sj2_tmp;
#
# Bug #898073: potential incremental join cache for semijoin
#
CREATE TABLE t1 (a int, b varchar(1), KEY (b,a));
INSERT INTO t1 VALUES (0,'x'), (5,'r');
CREATE TABLE t2 (a int) ENGINE=InnoDB;
INSERT INTO t2 VALUES (8);
CREATE TABLE t3 (b varchar(1), c varchar(1)) ENGINE=InnoDB;
INSERT INTO t3 VALUES ('x','x');
CREATE TABLE t4 (a int NOT NULL, b varchar(1)) ENGINE=InnoDB;
INSERT INTO t4 VALUES (20,'r'), (10,'x');
set @tmp_optimizer_switch=@@optimizer_switch;
SET SESSION optimizer_switch='semijoin_with_cache=on';
SET SESSION join_cache_level=2;
EXPLAIN
SELECT t3.* FROM t1 JOIN t3 ON t3.b = t1.b
WHERE c IN (SELECT t4.b FROM t4 JOIN t2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	1	Using where
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	1	Using join buffer (flat, BNL join)
1	PRIMARY	t4	ALL	NULL	NULL	NULL	NULL	2	Using where; FirstMatch(t3); Using join buffer (incremental, BNL join)
1	PRIMARY	t1	ref	b	b	4	test.t3.b	1	Using index
SELECT t3.* FROM t1 JOIN t3 ON t3.b = t1.b
WHERE c IN (SELECT t4.b FROM t4 JOIN t2);
b	c
x	x
set optimizer_switch=@tmp_optimizer_switch;
set join_cache_level=default;
DROP TABLE t1,t2,t3,t4;
#
# Bug #899696: potential incremental join cache for semijoin
#
CREATE TABLE t1 (pk int PRIMARY KEY, a int);
INSERT INTO t1 VALUES (1, 6), (2, 8);
CREATE TABLE t2 (b int) ENGINE=InnoDB;
INSERT INTO t2 VALUES (8);
CREATE TABLE t3 (pk int PRIMARY KEY, a int);
INSERT INTO t3 VALUES (1, 6), (2, 8);
CREATE TABLE t4 (b int) ENGINE=InnoDB;
INSERT INTO t4 VALUES (2);
set @tmp_optimizer_switch=@@optimizer_switch;
SET optimizer_switch = 'semijoin_with_cache=on';
SET join_cache_level = 2;
EXPLAIN
SELECT * FROM t1, t2 WHERE b IN (SELECT a FROM t3, t4 WHERE b = pk);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	1	
1	PRIMARY	t4	ALL	NULL	NULL	NULL	NULL	1	Using where
1	PRIMARY	t3	eq_ref	PRIMARY	PRIMARY	4	test.t4.b	1	Using where; FirstMatch(t2)
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	2	Using join buffer (flat, BNL join)
SELECT * FROM t1, t2 WHERE b IN (SELECT a FROM t3, t4 WHERE b = pk);
pk	a	b
1	6	8
2	8	8
set optimizer_switch=@tmp_optimizer_switch;
set join_cache_level=default;
DROP TABLE t1,t2,t3,t4;
#
# Bug #899962: materialized subquery with join_cache_level=3 
#
CREATE TABLE t1 (a varchar(1), b varchar(1)) ENGINE=InnoDB;
INSERT INTO t1 VALUES ('v','v');
CREATE TABLE t2 (a varchar(1), b varchar(1)) ENGINE=InnoDB;
INSERT INTO t2 VALUES ('v','v');
set @tmp_optimizer_switch=@@optimizer_switch;
SET optimizer_switch = 'semijoin_with_cache=on';
SET join_cache_level = 3;
EXPLAIN
SELECT * FROM t1 WHERE b IN (SELECT a FROM t2 GROUP BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	1	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	4	func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM t1 WHERE b IN (SELECT a FROM t2 GROUP BY a);
a	b
v	v
EXPLAIN
SELECT * FROM t1 WHERE b IN (SELECT max(a) FROM t2 GROUP BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	1	Using where
1	PRIMARY	<subquery2>	hash_ALL	distinct_key	#hash#distinct_key	4	test.t1.b	1	Using join buffer (flat, BNLH join)
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	1	Using temporary
SELECT * FROM t1 WHERE b IN (SELECT max(a) FROM t2 GROUP BY a);
a	b
v	v
set optimizer_switch=@tmp_optimizer_switch;
set join_cache_level=default;
DROP TABLE t1,t2;
set join_cache_level=default;
show variables like 'join_cache_level';
Variable_name	Value
join_cache_level	2
set @@optimizer_switch=@save_optimizer_switch_jcl6;
set @optimizer_switch_for_subselect_sj2_test=NULL;
set @join_cache_level_subselect_sj2_test=NULL;
