CREATE TABLE t0 (
i0 INTEGER
);
INSERT INTO t0 VALUES (0),(1),(2),(3),(4);
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER, f3 INTEGER,
KEY(f1), KEY(f1,f2), KEY(f3));
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1 VALUES (NULL, 1, 2);
INSERT INTO t1 VALUES (NULL, 1, 3);
SET optimizer_switch="derived_merge=off,derived_condition_pushdown=on";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt WHERE f1 > 2;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > 2)  (cost=*** rows=***)
            -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt WHERE f1 > 2;
f1	f2
3	33
3	33
4	44
4	44
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt
WHERE f1 < 3 and f2 > 11;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 < 3) and (t1.f2 > 11))  (cost=*** rows=***)
            -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt
WHERE f1 < 3 and f2 > 11;
f1	f2
2	22
2	22
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 2 and f2 < 25 and f3 > 200;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f2 < 25) and (t1.f3 > 200))  (cost=*** rows=***)
            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 2 and f2 < 25 and f3 > 200;
f1	f2	f3
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 3 and f2 < 50 or f3 > 200;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((t1.f1 > 3) and (t1.f2 < 50)) or (t1.f3 > 200))  (cost=*** rows=***)
            -> Table scan on t1  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE f1 > 3 and f2 < 50 or f3 > 200;
f1	f2	f3
2	22	222
3	33	333
4	44	444
2	22	222
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT t1.f2 as f2, dt.f1 as f1, dt.f3 as f3 FROM t1,
(SELECT f1, f2, f3 FROM t1) as dt
WHERE (dt.f1 = 6) or( t1.f2 = 50 and dt.f3 = 200);
EXPLAIN
-> Filter: ((dt.f1 = 6) or ((dt.f3 = 200) and (t1.f2 = 50)))  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Index scan on t1 using f1_2  (cost=*** rows=***)
        -> Hash
            -> Filter: ((dt.f1 = 6) or (dt.f3 = 200))  (cost=*** rows=***)
                -> Table scan on dt  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

SELECT t1.f2 as f2, dt.f1 as f1, dt.f3 as f3 FROM t1,
(SELECT f1, f2, f3 FROM t1) as dt
WHERE (dt.f1 = 6) or( t1.f2 = 50 and dt.f3 = 200);
f2	f1	f3
EXPLAIN FORMAT=tree SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f2 < 50)  (cost=*** rows=***)
                -> Index range scan on t1 using f1, with index condition: (t1.f1 > 3)  (cost=*** rows=***)
    -> Hash
        -> Filter: (t0.i0 > 3)  (cost=*** rows=***)
            -> Table scan on t0  (cost=*** rows=***)

SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
f1	f2	f3	i0
4	44	444	4
4	44	444	4
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT * FROM t1) as dt1) as dt2
WHERE f1 > 3 and f2 < 50 and f3 > 200;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f2 < 50) and (t1.f3 > 200))  (cost=*** rows=***)
                    -> Index range scan on t1 using f1, with index condition: (t1.f1 > 3)  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT * FROM t1) as dt1) as dt2
WHERE f1 > 3 and f2 < 50 and f3 > 200;
f1	f2	f3
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f2 < 35) and ((t1.f1 + t1.f3) > 300))  (cost=*** rows=***)
            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300;
f1	f2	f3
3	33	333
3	33	333
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) or (f1+f3) > 300 or (f1 < 2);
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((t1.f1 > 2) and (t1.f2 < 35)) or ((t1.f1 + t1.f3) > 300) or (t1.f1 < 2))  (cost=*** rows=***)
            -> Table scan on t1  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2, f3 FROM t1) as dt
WHERE (f1 > 2 and f2 < 35) or (f1+f3) > 300 or (f1 < 2);
f1	f2	f3
0	0	0
1	11	111
3	33	333
4	44	444
0	0	0
1	11	111
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300
and (f3 < 400);
EXPLAIN
-> Filter: ((dt1.f1 + dt2.f3) > 300)  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Table scan on dt2  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f3 < 400)  (cost=*** rows=***)
                    -> Index range scan on t1 using f3  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: ((t1.f1 > 2) and (t1.f2 < 35))  (cost=*** rows=***)
                        -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 300
and (f3 < 400);
f1	f2	f3
3	33	333
3	33	333
3	33	333
3	33	333
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2) as dt3
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 200 and (f3 < 300);
EXPLAIN
-> Table scan on dt3  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((dt1.f1 + dt2.f3) > 200)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on dt2  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Filter: (t1.f3 < 300)  (cost=*** rows=***)
                            -> Index range scan on t1 using f3  (cost=*** rows=***)
                -> Hash
                    -> Table scan on dt1  (cost=*** rows=***)
                        -> Materialize  (cost=*** rows=***)
                            -> Filter: ((t1.f1 > 2) and (t1.f2 < 35))  (cost=*** rows=***)
                                -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT f1, f2 FROM t1) as dt1,
(SELECT f3 FROM t1) as dt2) as dt3
WHERE (f1 > 2 and f2 < 35) and (f1+f3) > 200 and (f3 < 300);
f1	f2	f3
3	33	222
3	33	222
3	33	222
3	33	222
EXPLAIN FORMAT=tree SELECT i, j, k FROM (SELECT f1 as i, f2 as j, f2 as k FROM t1) as dt
WHERE i > 1 and i+j > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 > 1) and ((t1.f1 + t1.f2) > 40))  (cost=*** rows=***)
            -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT i, j, k FROM (SELECT f1 as i, f2 as j, f2 as k FROM t1) as dt
WHERE i > 1 and i+j > 40;
i	j	k
4	44	44
4	44	44
EXPLAIN FORMAT=tree SELECT i, j, k
FROM (SELECT l as i, m as j, n as k
FROM (SELECT f1 as l, f2 as m, f3 as n
FROM t1) as dt1 ) as dt2
WHERE i > 1 and i+j > 40;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f1 + t1.f2) > 40)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1, with index condition: (t1.f1 > 1)  (cost=*** rows=***)

SELECT i, j, k
FROM (SELECT l as i, m as j, n as k
FROM (SELECT f1 as l, f2 as m, f3 as n
FROM t1) as dt1 ) as dt2
WHERE i > 1 and i+j > 40;
i	j	k
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT i, j, l, m, n
FROM (SELECT f1 as i, f2 as j FROM t1 ) as dt1 ,
(SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt2
WHERE i > 1 and i+j > 40 and m < 20 and m+i > 20;
EXPLAIN
-> Filter: ((dt2.m + dt1.i) > 20)  (cost=*** rows=***)
    -> Inner hash join (no condition)  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((t1.f1 > 1) and ((t1.f1 + t1.f2) > 40))  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt2  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: (t1.f2 < 20)  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

SELECT i, j, l, m, n
FROM (SELECT f1 as i, f2 as j FROM t1 ) as dt1 ,
(SELECT f1 as l, f2 as m, f3 as n FROM t1) as dt2
WHERE i > 1 and i+j > 40 and m < 20 and m+i > 20;
i	j	l	m	n
EXPLAIN FORMAT=tree SELECT * FROM
(SELECT (i+j) AS g, f1 FROM
(SELECT (f1+f2) AS i, (f1-f2) AS j FROM
(SELECT f1+10 AS f1, f2+10 AS f2 FROM t1) AS dt0)
AS dt1,
(SELECT f1, f2 FROM t1) AS dt2) AS dt3 WHERE g > 26 and g+f1 > 31;
EXPLAIN
-> Table scan on dt3  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((dt1.i + dt1.j) + dt2.f1) > 31)  (cost=*** rows=***)
            -> Inner hash join (no condition)  (cost=*** rows=***)
                -> Table scan on dt2  (cost=*** rows=***)
                    -> Materialize  (cost=*** rows=***)
                        -> Index scan on t1 using f1_2  (cost=*** rows=***)
                -> Hash
                    -> Table scan on dt1  (cost=*** rows=***)
                        -> Materialize  (cost=*** rows=***)
                            -> Table scan on dt0  (cost=*** rows=***)
                                -> Materialize  (cost=*** rows=***)
                                    -> Filter: ((((t1.f1 + 10) + (t1.f2 + 10)) + ((t1.f1 + 10) - (t1.f2 + 10))) > 26)  (cost=*** rows=***)
                                        -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM
(SELECT (i+j) AS g, f1 FROM
(SELECT (f1+f2) AS i, (f1-f2) AS j FROM
(SELECT f1+10 AS f1, f2+10 AS f2 FROM t1) AS dt0)
AS dt1,
(SELECT f1, f2 FROM t1) AS dt2) AS dt3 WHERE g > 26 and g+f1 > 31;
g	f1
28	4
28	4
28	4
28	4
EXPLAIN FORMAT=tree SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+10) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: ((((t1.f1 + t1.f2) + 3) > 20) and ((((t1.f1 + t1.f2) + 3) + ((t1.f3 + 10) + 4)) > 10))  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+10) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ;
l	m
27	236
39	347
51	458
27	236
39	347
51	458
EXPLAIN FORMAT=tree SELECT i FROM (SELECT f1 FROM t1) as dt(i) WHERE i > 10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
            -> Index range scan on t1 using f1  (cost=*** rows=***)

SELECT i FROM (SELECT f1 FROM t1) as dt(i) WHERE i > 10;
i
EXPLAIN FORMAT=tree SELECT m FROM (SELECT k+2 as l
FROM (SELECT f1+f2 as j
FROM t1) as dt1(k)) as dt(m)
WHERE m > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on dt1  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (((t1.f1 + t1.f2) + 2) > 30)  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT m FROM (SELECT k+2 as l
FROM (SELECT f1+f2 as j
FROM t1) as dt1(k)) as dt(m)
WHERE m > 30;
m
38
38
50
50
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Group aggregate: sum(t1.f2)
            -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3;
f1
4
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2, SUM(f3) FROM t1 GROUP BY f1,f2) as dt
WHERE f1+f2 > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Group aggregate: sum(t1.f3)
            -> Filter: ((t1.f1 + t1.f2) > 30)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2, SUM(f3) FROM t1 GROUP BY f1,f2) as dt
WHERE f1+f2 > 30;
f1
3
4
EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1 WITH ROLLUP) as dt
WHERE f1 IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Filter: (t1.f1 is null)
            -> Group aggregate with rollup: sum(t1.f2)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1
FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1 WITH ROLLUP) as dt
WHERE f1 IS NULL;
f1
NULL
NULL
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE j+sum > 50 OR
j IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Filter: (((t1.f1 + sum(t1.f2)) > 50) or (t1.f1 is null))
            -> Group aggregate with rollup: sum(t1.f2)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP) as dt WHERE j+sum > 50 OR
j IS NULL;
j	sum
NULL	2
3	66
4	88
NULL	222
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP
HAVING AVG(f2) > 1) AS dt WHERE j+sum > 50 OR
j IS NULL;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Filter: ((avg(t1.f2) > 1) and (((t1.f1 + sum(t1.f2)) > 50) or (t1.f1 is null)))
            -> Group aggregate with rollup: avg(t1.f2), sum(t1.f2)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1 as j, SUM(f2) as sum
FROM t1 GROUP BY f1 WITH ROLLUP
HAVING AVG(f2) > 1) AS dt WHERE j+sum > 50 OR
j IS NULL;
j	sum
3	66
4	88
NULL	222
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2) as dt
WHERE f1 > 3;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Sort: t1.f2  (cost=*** rows=***)
            -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2) as dt
WHERE f1 > 3;
f1
4
4
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2 LIMIT 4) as dt
WHERE f1 > 0 ;
EXPLAIN
-> Filter: (dt.f1 > 0)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Limit: 4 row(s)  (cost=*** rows=***)
                -> Sort: t1.f2, limit input to 4 row(s) per chunk  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2

SELECT f1 FROM (SELECT f1, f2 FROM t1 ORDER BY f2 LIMIT 4) as dt
WHERE f1 > 0 ;
f1
EXPLAIN FORMAT=tree SELECT f1 FROM (SELECT f1, f2 FROM t1 LIMIT 4) as dt WHERE f1 > 0;
EXPLAIN
-> Filter: (dt.f1 > 0)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Limit: 4 row(s)  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1 FROM (SELECT f1, f2 FROM t1 LIMIT 4) as dt WHERE f1 > 0;
f1
set sql_mode="";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
EXPLAIN
-> Filter: (dt.f1 > 2)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize
            -> Group (computed in earlier step, no aggregates)
                -> Window aggregate with buffering: sum(t1.f2) OVER () 
                    -> Table scan on <temporary>
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Index range scan on t1 using index_for_group_by(f1_2)  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
f1	SUM(f2) OVER()
3	111
4	111
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt WHERE f1 > 2;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1 ) 
            -> Sort: t1.f1
                -> Table scan on <temporary>
                    -> Temporary table with deduplication  (cost=*** rows=***)
                        -> Filter: (t1.f1 > 2)  (cost=*** rows=***)
                            -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt WHERE f1 > 2;
f1	SUM(f2) OVER(PARTITION BY f1)
3	33
4	44
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f2)
FROM t1 GROUP BY f1) as dt WHERE f2 > 30;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f2 ) 
            -> Filter: (t1.f2 > 30)
                -> Sort: t1.f2
                    -> Table scan on <temporary>
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Table scan on t1  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f2)
FROM t1 GROUP BY f1) as dt WHERE f2 > 30;
f1	f2	SUM(f3) OVER(PARTITION BY f2)
3	33	333
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Filter: ((dt.f2 > 30) and ((dt.f1 + dt.f2) > 40))
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize
            -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1)
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1,t1.f2 ) 
            -> Filter: ((t1.f2 > 30) and ((t1.f1 + t1.f2) > 40))
                -> Sort: t1.f1, t1.f2
                    -> Table scan on <temporary>
                        -> Temporary table with deduplication  (cost=*** rows=***)
                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1,f2)
4	44	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2),
AVG(f3) OVER (PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
EXPLAIN
-> Filter: ((dt.f2 > 30) and ((dt.f1 + dt.f2) > 40))
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize
            -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>
                        -> Temporary table
                            -> Window aggregate with buffering: sum(t1.f3) OVER (PARTITION BY t1.f1,t1.f2 ) 
                                -> Sort: t1.f1, t1.f2
                                    -> Table scan on <temporary>
                                        -> Temporary table with deduplication  (cost=*** rows=***)
                                            -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, f2, SUM(f3) OVER(PARTITION BY f1,f2),
AVG(f3) OVER (PARTITION BY f1)
FROM t1 GROUP BY f1) as dt
WHERE f1 > 2 and f2 > 30 and (f1+f2) > 40;
f1	f2	SUM(f3) OVER(PARTITION BY f1,f2)	AVG(f3) OVER (PARTITION BY f1)
4	44	444	444.0000
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) as SUM, AVG(f3) OVER (PARTITION BY SUM(f2))
FROM t1 GROUP BY f1) as dt
WHERE SUM > 40;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY sum(t1.f2) ) 
            -> Filter: (sum(t1.f2) > 40)
                -> Sort: SUM
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Table scan on t1  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) as SUM, AVG(f3) OVER (PARTITION BY SUM(f2))
FROM t1 GROUP BY f1) as dt
WHERE SUM > 40;
f1	SUM	AVG(f3) OVER (PARTITION BY SUM(f2))
2	44	222.0000
3	66	333.0000
4	88	444.0000
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f2) OVER (PARTITION by f1,f2),
AVG(f3) OVER (PARTITION BY f2,f1),
FIRST_VALUE(f3) OVER (PARTITION by f1)
FROM t1) as dt
WHERE f1 > 2 ;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Window aggregate with buffering: first_value(t1.f3) OVER (PARTITION BY t1.f1 ) 
            -> Sort: t1.f1
                -> Table scan on <temporary>
                    -> Temporary table
                        -> Window aggregate with buffering: avg(t1.f3) OVER (PARTITION BY t1.f2,t1.f1 ) 
                            -> Sort: t1.f2, t1.f1
                                -> Table scan on <temporary>
                                    -> Temporary table
                                        -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1,t1.f2 ) 
                                            -> Sort: t1.f1, t1.f2  (cost=*** rows=***)
                                                -> Index range scan on t1 using f1, with index condition: (t1.f1 > 2)  (cost=*** rows=***)

SELECT *
FROM (SELECT f1, SUM(f2) OVER (PARTITION by f1,f2),
AVG(f3) OVER (PARTITION BY f2,f1),
FIRST_VALUE(f3) OVER (PARTITION by f1)
FROM t1) as dt
WHERE f1 > 2 ;
f1	SUM(f2) OVER (PARTITION by f1,f2)	AVG(f3) OVER (PARTITION BY f2,f1)	FIRST_VALUE(f3) OVER (PARTITION by f1)
3	66	333.0000	333
3	66	333.0000	333
4	88	444.0000	444
4	88	444.0000	444
EXPLAIN FORMAT=tree SELECT *
FROM (SELECT f1, SUM(f1) OVER (PARTITION by f2),
AVG(f2) OVER (PARTITION BY f1)
FROM t1) as dt
WHERE f1 > 2 ;
EXPLAIN
-> Filter: (dt.f1 > 2)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize
            -> Window aggregate with buffering: avg(t1.f2) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1
                    -> Table scan on <temporary>
                        -> Temporary table
                            -> Window aggregate with buffering: sum(t1.f1) OVER (PARTITION BY t1.f2 ) 
                                -> Sort: t1.f2  (cost=*** rows=***)
                                    -> Index scan on t1 using f1_2

SELECT *
FROM (SELECT f1, SUM(f1) OVER (PARTITION by f2),
AVG(f2) OVER (PARTITION BY f1)
FROM t1) as dt
WHERE f1 > 2 ;
f1	SUM(f1) OVER (PARTITION by f2)	AVG(f2) OVER (PARTITION BY f1)
3	6	33.0000
3	6	33.0000
4	8	44.0000
4	8	44.0000
set sql_mode=default;
SET @p1 = 3;
PREPARE p FROM "SELECT f1
FROM (SELECT f1 FROM t1) as dt WHERE f1 > ?";
EXECUTE p USING @p1;
f1
4
4
PREPARE p FROM "EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1 FROM t1) as dt WHERE f1 > ?";
EXECUTE p USING @p1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (t1.f1 > <cache>(3))  (cost=*** rows=***)
            -> Index range scan on t1 using f1  (cost=*** rows=***)

DROP PREPARE p;
SET @p1 = 10;
PREPARE p FROM "SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+?) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ";
EXECUTE p USING @p1;
l	m
27	236
39	347
51	458
27	236
39	347
51	458
PREPARE p FROM "EXPLAIN FORMAT=tree SELECT l, m  FROM (SELECT (i+3) as l, (j+4) as m FROM
(SELECT (f1+f2) as i, (f3+?) as j FROM t1) as
dt1) as dt2 WHERE l > 20 and l+m > 10 ";
EXECUTE p USING @p1;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (((dt1.i + 3) + (dt1.j + 4)) > 10)  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Filter: (((t1.f1 + t1.f2) + 3) > 20)  (cost=*** rows=***)
                        -> Table scan on t1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM (SELECT RAND() as a FROM t1) as dt
WHERE a > 0.5;
EXPLAIN
-> Filter: (dt.a > 0.5)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Index scan on t1 using f1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE f1 > 3*RAND() AND f1 < 10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Filter: (t1.f1 > (3 * rand()))
            -> Group aggregate: sum(t1.f2)
                -> Filter: (t1.f1 < 10)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM
(SELECT f1, SUM(f2) OVER(PARTITION BY f1) FROM t1) as dt
WHERE f1 > 3*RAND() AND f1 < 10;
EXPLAIN
-> Filter: (dt.f1 > (3 * rand()))
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize
            -> Window aggregate with buffering: sum(t1.f2) OVER (PARTITION BY t1.f1 ) 
                -> Sort: t1.f1  (cost=*** rows=***)
                    -> Filter: (t1.f1 < 10)  (cost=*** rows=***)
                        -> Index range scan on t1 using f1_2  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT * FROM
(SELECT f1 FROM t1) as dt
WHERE f1 > 3*RAND() AND f1<10;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: ((t1.f1 > (3 * rand())) and (t1.f1 < 10))  (cost=*** rows=***)
            -> Index range scan on t1 using f1  (cost=*** rows=***)

EXPLAIN FORMAT=tree SELECT f1
FROM (SELECT f1 FROM t1 UNION SELECT f2 FROM t1) as dt
WHERE f1 > 2;
EXPLAIN
-> Filter: (dt.f1 > 2)
    -> Table scan on dt  (cost=*** rows=***)
        -> Union materialize with deduplication
            -> Index scan on t1 using f1  (cost=*** rows=***)
            -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT f1
FROM (SELECT f1 FROM t1 UNION SELECT f2 FROM t1) as dt
WHERE f1 > 2;
f1
3
4
11
22
33
44
EXPLAIN FORMAT=tree SELECT f1 FROM
(SELECT (SELECT 1 FROM t1 LIMIT 1) as f1 FROM t1) as dt WHERE f1 = 1;
EXPLAIN
-> Index lookup on dt using <auto_key0> (f1=1)
    -> Materialize  (cost=*** rows=***)
        -> Index scan on t1 using f1  (cost=*** rows=***)
        -> Select #3 (subquery in projection; run only once)
            -> Limit: 1 row(s)  (cost=*** rows=***)
                -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT f1 FROM
(SELECT (SELECT 1 FROM t1 LIMIT 1) as f1 FROM t1) as dt WHERE f1 = 1;
f1
1
1
1
1
1
1
1
1
1
1
1
1
CREATE FUNCTION p() RETURNS INTEGER
BEGIN
DECLARE retn INTEGER;
SELECT count(f1) FROM t1 INTO retn;
RETURN retn;
END|
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Filter: (p() = 1)
            -> Group aggregate: sum(t1.f2)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
f1	SUM(f2)
DROP FUNCTION p;
CREATE FUNCTION p() RETURNS INTEGER DETERMINISTIC
BEGIN
DECLARE retn INTEGER;
SELECT count(f1) FROM t1 INTO retn;
RETURN retn;
END|
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize
        -> Group aggregate: sum(t1.f2)
            -> Filter: <cache>((p() = 1))  (cost=*** rows=***)
                -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) FROM t1 GROUP BY f1) as dt
WHERE p() = 1;
f1	SUM(f2)
DROP FUNCTION p;
CREATE PROCEDURE p()
BEGIN
DECLARE val INTEGER;
SET val = 2;
EXPLAIN FORMAT=tree SELECT AVG(f1) FROM (SELECT * FROM t1) as dt
WHERE f2 > val;
SELECT AVG(f1) FROM (SELECT * FROM t1) as dt WHERE f2 > val;
END|
CALL p();
EXPLAIN
-> Aggregate: avg(dt.f1)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f2 > <cache>(val@0))  (cost=*** rows=***)
                -> Table scan on t1  (cost=*** rows=***)

AVG(f1)
2.5000
DROP PROCEDURE p;
EXPLAIN FORMAT=tree SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn2)) as dt WHERE f2 > 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Table scan on qn2  (cost=*** rows=***)
            -> Materialize CTE qn2  (cost=*** rows=***)
                -> Table scan on qn  (cost=*** rows=***)
                    -> Materialize CTE qn  (cost=*** rows=***)
                        -> Filter: ((3 * (10 * t1.f1)) > 1)  (cost=*** rows=***)
                            -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn2)) as dt WHERE f2 > 1;
f2
30
30
60
60
90
90
120
120
EXPLAIN FORMAT=tree SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn,qn2)) as dt WHERE f1 < 10 and f2 > 1;
EXPLAIN
-> Table scan on dt  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Inner hash join (no condition)  (cost=*** rows=***)
            -> Table scan on qn2  (cost=*** rows=***)
                -> Materialize CTE qn2  (cost=*** rows=***)
                    -> Filter: ((3 * qn.f1) > 1)  (cost=*** rows=***)
                        -> Table scan on qn  (cost=*** rows=***)
                            -> Materialize CTE qn if needed (query plan printed elsewhere)  (cost=*** rows=***)
            -> Hash
                -> Filter: (qn.f1 < 10)  (cost=*** rows=***)
                    -> Table scan on qn  (cost=*** rows=***)
                        -> Materialize CTE qn if needed  (cost=*** rows=***)
                            -> Index scan on t1 using f1  (cost=*** rows=***)

SELECT * FROM ((WITH qn AS (SELECT 10*f1 as f1 FROM t1),
qn2 AS (SELECT 3*f1 AS f2 FROM qn)
SELECT * from qn,qn2)) as dt WHERE f1 < 10 and f2 > 1;
f1	f2
0	30
0	30
0	30
0	30
0	60
0	60
0	60
0	60
0	90
0	90
0	90
0	90
0	120
0	120
0	120
0	120
EXPLAIN FORMAT=tree SELECT * FROM t1 JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 31 and t1.f2  > 40;
EXPLAIN
-> Nested loop inner join  (cost=*** rows=***)
    -> Filter: ((t1.f2 > 40) and (t1.f2 is not null))  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
    -> Index lookup on dt using <auto_key0> (f2=t1.f2)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t1.f1 > 31)  (cost=*** rows=***)
                -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 31 and t1.f2  > 40;
f2	f1	f3	f1
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 is null;
EXPLAIN
-> Filter: (dt.f1 is null)  (cost=*** rows=***)
    -> Left hash join (dt.f2 = t1.f2)  (cost=*** rows=***)
        -> Table scan on t1  (cost=*** rows=***)
        -> Hash
            -> Table scan on dt  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Index scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 is null;
f2	f1	f3	f1
1	NULL	2	NULL
1	NULL	2	NULL
1	NULL	3	NULL
1	NULL	3	NULL
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 3;
EXPLAIN
-> Inner hash join (t1.f2 = dt.f2)  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Hash
        -> Table scan on dt  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 LEFT JOIN (SELECT f1, f2 FROM t1) as dt USING (f2)
WHERE dt.f1 > 3;
f2	f1	f3	f1
44	4	444	4
44	4	444	4
44	4	444	4
44	4	444	4
EXPLAIN FORMAT=tree SELECT * FROM t1 INNER JOIN (SELECT f1, f2 FROM t1) as dt ON dt.f1 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on t1  (cost=*** rows=***)
    -> Hash
        -> Table scan on dt  (cost=*** rows=***)
            -> Materialize  (cost=*** rows=***)
                -> Filter: (t1.f1 > 3)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM t1 INNER JOIN (SELECT f1, f2 FROM t1) as dt ON dt.f1 > 3;
f1	f2	f3	f1	f2
0	0	0	4	44
0	0	0	4	44
1	11	111	4	44
1	11	111	4	44
2	22	222	4	44
2	22	222	4	44
3	33	333	4	44
3	33	333	4	44
4	44	444	4	44
4	44	444	4	44
0	0	0	4	44
0	0	0	4	44
1	11	111	4	44
1	11	111	4	44
2	22	222	4	44
2	22	222	4	44
3	33	333	4	44
3	33	333	4	44
4	44	444	4	44
4	44	444	4	44
NULL	1	2	4	44
NULL	1	2	4	44
NULL	1	3	4	44
NULL	1	3	4	44
EXPLAIN FORMAT = tree SELECT * FROM t1 INNER JOIN(SELECT t2.f1, t2.f2 FROM t1
LEFT JOIN t1 AS t2 ON TRUE) AS dt ON dt.f1 > 3;
EXPLAIN
-> Inner hash join (no condition)  (cost=*** rows=***)
    -> Table scan on dt  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Filter: (t2.f1 > 3)  (cost=*** rows=***)
                -> Left hash join (no condition)  (cost=*** rows=***)
                    -> Index scan on t1 using f1  (cost=*** rows=***)
                    -> Hash
                        -> Index scan on t2 using f1_2  (cost=*** rows=***)
    -> Hash
        -> Table scan on t1  (cost=*** rows=***)

set optimizer_switch="derived_merge=on";
EXPLAIN FORMAT=tree SELECT * FROM (SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM t1 GROUP BY f1) as dt1
WHERE f1 > 10) dt2 WHERE sum > 10;
EXPLAIN
-> Table scan on dt1  (cost=*** rows=***)
    -> Materialize
        -> Filter: (sum(t1.f2) > 10)
            -> Group aggregate: sum(t1.f2)
                -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM t1 GROUP BY f1) as dt1
WHERE f1 > 10) dt2 WHERE sum > 10;
f1	sum
EXPLAIN FORMAT=tree SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM (SELECT f1, f2 FROM t1 WHERE f1 > 10) as dt1
GROUP BY f1) dt2 WHERE sum > 10;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize
        -> Filter: (sum(t1.f2) > 10)
            -> Group aggregate: sum(t1.f2)
                -> Filter: (t1.f1 > 10)  (cost=*** rows=***)
                    -> Index range scan on t1 using f1_2  (cost=*** rows=***)

SELECT * FROM (SELECT f1, SUM(f2) AS sum
FROM (SELECT f1, f2 FROM t1 WHERE f1 > 10) as dt1
GROUP BY f1) dt2 WHERE sum > 10;
f1	sum
SELECT * FROM
(SELECT f1 FROM (SELECT f1 FROM t1) AS dt1 GROUP BY f1) AS dt2
WHERE f1 > 3;
f1
4
SELECT * FROM
(SELECT dt1.f1 FROM (SELECT f1 FROM t1) AS dt1, t1 AS t0
GROUP BY dt1.f1) AS dt2
WHERE dt2.f1 > 3;
f1
4
EXPLAIN SELECT /*+ no_merge(dt,dt1) */ * FROM
((SELECT f1, f2 FROM t1) as dt, (SELECT f1, f2 FROM t1) as dt1) WHERE FALSE;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	NULL	Impossible WHERE
3	DERIVED	t1	NULL	index	NULL	f1_2	10	NULL	#	100.00	Using index
2	DERIVED	t1	NULL	index	NULL	f1_2	10	NULL	#	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select /*+ NO_MERGE(`dt`@`select#1`) NO_MERGE(`dt1`@`select#1`) */ `dt`.`f1` AS `f1`,`dt`.`f2` AS `f2`,`dt1`.`f1` AS `f1`,`dt1`.`f2` AS `f2` from (/* select#2 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1`) `dt` join (/* select#3 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1`) `dt1` where false
SELECT /*+ no_merge(dt,dt1) */ * FROM
((SELECT f1, f2 FROM t1) as dt, (SELECT f1, f2 FROM t1) as dt1) WHERE FALSE;
f1	f2	f1	f2
set optimizer_switch="derived_merge=off";
EXPLAIN FORMAT=tree SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Filter: (dt2.f1 > 3)  (cost=*** rows=***)
    -> Table scan on dt2  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
EXPLAIN FORMAT=tree SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN() */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Filter: (dt2.f1 > 3)  (cost=*** rows=***)
    -> Table scan on dt2  (cost=*** rows=***)
        -> Materialize  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN() */ * FROM
(SELECT * FROM (SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
set optimizer_switch="derived_condition_pushdown=off";
EXPLAIN FORMAT=tree SELECT /*+ DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt1) */ * FROM
(SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
EXPLAIN
-> Table scan on dt2  (cost=*** rows=***)
    -> Materialize  (cost=*** rows=***)
        -> Filter: (dt1.f1 > 3)  (cost=*** rows=***)
            -> Table scan on dt1  (cost=*** rows=***)
                -> Materialize  (cost=*** rows=***)
                    -> Table scan on t1  (cost=*** rows=***)

SELECT /*+ DERIVED_CONDITION_PUSHDOWN(dt2) */ * FROM
(SELECT /*+ NO_DERIVED_CONDITION_PUSHDOWN(dt1) */ * FROM
(SELECT * FROM t1) as dt1) as dt2 WHERE f1 > 3;
f1	f2	f3
4	44	444
4	44	444
set optimizer_switch=default;
# Bug#31491972: WL8084: SERVER CRASH FROM JOIN::UPDATE_SARGABLE_FROM_CONST()
SELECT f1 FROM (SELECT DISTINCT * FROM t1 WHERE f2 = 4) AS alias1
WHERE ( alias1 . f1 = 24 AND alias1 . f3 = 101 );
f1
SELECT f1 FROM (SELECT DISTINCT * FROM t1 WHERE f2 = 4) AS alias1
WHERE ( alias1 . f1 BETWEEN 24 AND 30 AND alias1 . f3 BETWEEN 101 and 103);
f1
DROP TABLE t0, t1;
#
# Bug#31603289:CRASH IN TABLE_LIST::GET_CLONE_FOR_DERIVED_EXPR,
#              ASSERTION `FALSE' IN TABLE_LIST::GET_DERIVED_EXPR
#
CREATE TABLE t(f0 INTEGER PRIMARY KEY, f1 INTEGER,f2 INTEGER);
SELECT NULL IN(SELECT (f1 between 0 and 1)
FROM (SELECT f1 FROM t WHERE  (@b:=NULL) - f2)as dt
);
NULL IN(SELECT (f1 between 0 and 1)
FROM (SELECT f1 FROM t WHERE  (@b:=NULL) - f2)as dt
)
0
Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
DROP TABLE t;
