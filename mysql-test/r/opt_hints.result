SET explain_format = TREE;
# WL#8017 Infrastructure for Optimizer Hints
CREATE TABLE t1(f1 INT, f2 INT);
INSERT INTO t1 VALUES
(1,1),(2,2),(3,3);
CREATE TABLE t2(f1 INT NOT NULL, f2 INT NOT NULL, f3 CHAR(200), KEY(f1, f2));
INSERT INTO t2 VALUES
(1,1, 'qwerty'),(1,2, 'qwerty'),(1,3, 'qwerty'),
(2,1, 'qwerty'),(2,2, 'qwerty'),(2,3, 'qwerty'), (2,4, 'qwerty'),(2,5, 'qwerty'),
(3,1, 'qwerty'),(3,4, 'qwerty'),
(4,1, 'qwerty'),(4,2, 'qwerty'),(4,3, 'qwerty'), (4,4, 'qwerty'),
(1,1, 'qwerty'),(1,2, 'qwerty'),(1,3, 'qwerty'),
(2,1, 'qwerty'),(2,2, 'qwerty'),(2,3, 'qwerty'), (2,4, 'qwerty'),(2,5, 'qwerty'),
(3,1, 'qwerty'),(3,4, 'qwerty'),
(4,1, 'qwerty'),(4,2, 'qwerty'),(4,3, 'qwerty'), (4,4, 'qwerty');
CREATE TABLE t3 (f1 INT NOT NULL, f2 INT, f3 VARCHAR(32),
PRIMARY KEY(f1), KEY f2_idx(f1), KEY f3_idx(f3));
INSERT INTO t3 VALUES
(1, 1, 'qwerty'), (2, 1, 'ytrewq'),
(3, 2, 'uiop'), (4, 2, 'poiu'), (5, 2, 'lkjh'),
(6, 2, 'uiop'), (7, 2, 'poiu'), (8, 2, 'lkjh'),
(9, 2, 'uiop'), (10, 2, 'poiu'), (11, 2, 'lkjh'),
(12, 2, 'uiop'), (13, 2, 'poiu'), (14, 2, 'lkjh');
INSERT INTO t3 SELECT f1 + 20, f2, f3 FROM t3;
INSERT INTO t3 SELECT f1 + 40, f2, f3 FROM t3;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
ANALYZE TABLE t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
ANALYZE TABLE t3;
Table	Op	Msg_type	Msg_text
test.t3	analyze	status	OK
# NO_RANGE_OPTIMIZATION hint testing
set optimizer_switch=default;
# Check statistics with no hint
FLUSH STATUS;
SELECT f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
f1
31
32
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	0
Handler_read_key	1
Handler_read_last	0
Handler_read_next	2
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	0
# Check statistics with hint
FLUSH STATUS;
SELECT /*+ NO_RANGE_OPTIMIZATION(t3) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
f1
31
32
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	1
Handler_read_last	0
Handler_read_next	56
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	0
EXPLAIN SELECT f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
EXPLAIN
-> Filter: ((t3.f1 > 30) and (t3.f1 < 33))  (rows=2)
    -> Covering index range scan on t3 using f2_idx over (30 < f1 < 33)  (rows=2)

# Turn off range access for PRIMARY key
# Should use range access by f2_idx key
EXPLAIN SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
EXPLAIN
-> Filter: ((t3.f1 > 30) and (t3.f1 < 33))  (rows=2)
    -> Covering index range scan on t3 using f2_idx over (30 < f1 < 33)  (rows=2)

# Turn off range access for PRIMARY & f2_idx keys
# Should use skip scan for f3_idx index
EXPLAIN SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
EXPLAIN
-> Filter: ((t3.f1 > 30) and (t3.f1 < 33))  (rows=6)
    -> Covering index skip scan on t3 using f3_idx over 30 < f1 < 33  (rows=6)

# Turn off range access for all keys
# Should use index access
EXPLAIN SELECT /*+ NO_RANGE_OPTIMIZATION(t3) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
EXPLAIN
-> Filter: ((t3.f1 > 30) and (t3.f1 < 33))  (rows=6.22)
    -> Covering index scan on t3 using f2_idx  (rows=56)

# Turn off range access for PRIMARY & f2_idx keys
# Should use index access
EXPLAIN SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY) NO_RANGE_OPTIMIZATION(t3 f2_idx) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
EXPLAIN
-> Filter: ((t3.f1 > 30) and (t3.f1 < 33))  (rows=6)
    -> Covering index skip scan on t3 using f3_idx over 30 < f1 < 33  (rows=6)

# NO_ICP hint testing
set optimizer_switch='index_condition_pushdown=on';
EXPLAIN SELECT  f2 FROM
(SELECT f2, f3, f1 FROM t3 WHERE f1 > 27 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 27 AND TD.f3 = 'poiu';
EXPLAIN
-> Index range scan on t3 using f3_idx over (f3 = 'poiu' AND 27 < f1), with index condition: ((t3.f3 = 'poiu') and (t3.f1 > 27) and (t3.f1 > 27))  (rows=10)

EXPLAIN SELECT /*+ NO_ICP(t3@qb1 f3_idx) */ f2 FROM
(SELECT /*+ QB_NAME(QB1) */ f2, f3, f1 FROM t3 WHERE f1 > 27 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 27 AND TD.f3 = 'poiu';
EXPLAIN
-> Filter: ((t3.f3 = 'poiu') and (t3.f1 > 27) and (t3.f1 > 27))  (rows=10)
    -> Index range scan on t3 using f3_idx over (f3 = 'poiu' AND 27 < f1)  (rows=10)

EXPLAIN SELECT /*+ NO_ICP(t3@qb1) */ f2 FROM
(SELECT /*+ QB_NAME(QB1) */ f2, f3, f1 FROM t3 WHERE f1 > 27 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 27 AND TD.f3 = 'poiu';
EXPLAIN
-> Filter: ((t3.f3 = 'poiu') and (t3.f1 > 27) and (t3.f1 > 27))  (rows=10)
    -> Index range scan on t3 using f3_idx over (f3 = 'poiu' AND 27 < f1)  (rows=10)

# Expected warning for f1_idx key, unresolved name.
EXPLAIN SELECT f2 FROM
(SELECT /*+ NO_ICP(t3 f3_idx, f1_idx, f2_idx) */ f2, f3, f1 FROM t3 WHERE f1 > 27 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 27 AND TD.f3 = 'poiu';
EXPLAIN
-> Filter: ((t3.f3 = 'poiu') and (t3.f1 > 27) and (t3.f1 > 27))  (rows=10)
    -> Index range scan on t3 using f3_idx over (f3 = 'poiu' AND 27 < f1)  (rows=10)

Warnings:
Warning	3128	Unresolved name `t3`@`select#2` `f1_idx` for NO_ICP hint
# ICP should still be used.
EXPLAIN SELECT f2 FROM
(SELECT /*+ NO_ICP(t3 f1_idx, f2_idx) */ f2, f3, f1 FROM t3 WHERE f1 > 27 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 27 AND TD.f3 = 'poiu';
EXPLAIN
-> Index range scan on t3 using f3_idx over (f3 = 'poiu' AND 27 < f1), with index condition: ((t3.f3 = 'poiu') and (t3.f1 > 27) and (t3.f1 > 27))  (rows=10)

Warnings:
Warning	3128	Unresolved name `t3`@`select#2` `f1_idx` for NO_ICP hint
# BKA & NO_BKA hint testing
set optimizer_switch=default;
set optimizer_switch='batched_key_access=off,mrr_cost_based=off';
# Check statistics without hint
FLUSH STATUS;
SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
f1	f2	f3
1	1	qwerty
1	1	qwerty
2	2	qwerty
2	2	qwerty
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	4
Handler_read_last	0
Handler_read_next	4
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	4
# Check statistics with hint
FLUSH STATUS;
SELECT /*+ BKA() */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
f1	f2	f3
1	1	qwerty
1	1	qwerty
2	2	qwerty
2	2	qwerty
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	24
Handler_read_last	0
Handler_read_next	20
Handler_read_prev	0
Handler_read_rnd	20
Handler_read_rnd_next	4
EXPLAIN SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ BKA() */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ BKA(t1, t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ BKA(t1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ QB_NAME(QB1) BKA(t2@QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

set optimizer_switch='batched_key_access=off,mrr_cost_based=on';
EXPLAIN SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ BKA() */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ BKA(t1, t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN SELECT /*+ QB_NAME(QB1) BKA(t2@QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

set optimizer_switch='batched_key_access=on,mrr_cost_based=off';
EXPLAIN SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

set optimizer_switch='mrr=off';
EXPLAIN SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

# MRR switch should not affect BKA.
# BKA should be used for table t2.
EXPLAIN SELECT /*+ BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

set optimizer_switch='mrr=on';
EXPLAIN SELECT /*+ NO_BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ NO_BKA() */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ NO_BKA(t1, t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

EXPLAIN SELECT /*+ QB_NAME(QB1) NO_BKA(t2@QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

# UPDATE|DELETE|INSERT|REPLACE hint testing
set optimizer_switch='batched_key_access=off,mrr_cost_based=off,semijoin=off,materialization=off';
EXPLAIN UPDATE t3
SET f3 = 'mnbv' WHERE f1 > 30 AND f1 < 33 AND (t3.f1, t3.f2, t3.f3) IN
(SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> <not executable by iterator executor>

# Turn off range access for PRIMARY key.
# Range access should be used for f2_idx key.
EXPLAIN UPDATE /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY) */ t3
SET f3 = 'mnbv' WHERE f1 > 30 AND f1 < 33 AND (t3.f1, t3.f2, t3.f3) IN
(SELECT /*+ BKA(t2) NO_BNL(t1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> <not executable by iterator executor>

EXPLAIN DELETE FROM t3
WHERE f1 > 30 AND f1 < 33 AND (t3.f1, t3.f2, t3.f3) IN
(SELECT /*+ QB_NAME(qb1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> <not executable by iterator executor>

# Turn off range access. Range access should not be used.
# Turn off BNL. BNL should not be used.
EXPLAIN DELETE /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) NO_BNL(t1@QB1) */ FROM t3
WHERE f1 > 30 AND f1 < 33 AND (t3.f1, t3.f2, t3.f3) IN
(SELECT /*+ QB_NAME(qb1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> <not executable by iterator executor>

EXPLAIN INSERT INTO t3(f1, f2, f3)
(SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> Insert into t3
    -> Nested loop inner join  (rows=21)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

# Turn off ICP. ICP should not be used.
EXPLAIN INSERT INTO t3(f1, f2, f3)
(SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> Insert into t3
    -> Nested loop inner join  (rows=2.33)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
            -> Index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

# Turn off ICP. ICP should not be used.
EXPLAIN INSERT /*+ NO_ICP(t2@QB1 f1) */ INTO t3(f1, f2, f3)
(SELECT /*+ QB_NAME(qb1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> Insert into t3
    -> Nested loop inner join  (rows=2.33)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
            -> Index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

EXPLAIN REPLACE INTO t3(f1, f2, f3)
(SELECT t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> Replace into t3
    -> Nested loop inner join  (rows=21)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

# Turn off ICP. ICP should not be used.
EXPLAIN REPLACE INTO t3(f1, f2, f3)
(SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
EXPLAIN
-> Replace into t3
    -> Nested loop inner join  (rows=2.33)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
            -> Index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

# Turn off ICP for nonexistent table. ICP should be used.
EXPLAIN REPLACE /*+ NO_ICP(t2@qb1) */ INTO t3(f1, f2, f3)
SELECT /*+ QB_NAME(qb2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Replace into t3
    -> Nested loop inner join  (rows=21)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

Warnings:
Warning	3127	Query block name `qb1` is not found for NO_ICP hint
# Turn off ICP. ICP should not be used.
EXPLAIN REPLACE /*+ NO_ICP(t2@qb1) */ INTO t3(f1, f2, f3)
SELECT /*+ QB_NAME(qb1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Replace into t3
    -> Nested loop inner join  (rows=2.33)
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
        -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
            -> Index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

# Misc tests
# Should issue warning
EXPLAIN SELECT /*+ QB_NAME(qb1) QB_NAME(qb1 ) */ * FROM t2;
EXPLAIN
-> Table scan on t2  (rows=28)

Warnings:
Warning	3126	Hint QB_NAME(`qb1`) is ignored as conflicting/duplicated
# Should issue warning
EXPLAIN SELECT /*+ BKA(@qb1) QB_NAME(qb1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (t1.f1 is not null)  (rows=3)
        -> Table scan on t1  (rows=3)
    -> Index lookup on t2 using f1 (f1 = t1.f1), with index condition: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=7)

Warnings:
Warning	3127	Query block name `qb1` is not found for BKA hint
# Should not crash
PREPARE stmt1 FROM "SELECT /*+ BKA(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1";
EXECUTE stmt1;
f1	f2	f3
1	1	qwerty
2	2	qwerty
1	1	qwerty
2	2	qwerty
EXECUTE stmt1;
f1	f2	f3
1	1	qwerty
2	2	qwerty
1	1	qwerty
2	2	qwerty
DEALLOCATE PREPARE stmt1;
# Check use of alias
EXPLAIN SELECT tbl2.f1, tbl2.f2, tbl2.f3 FROM t1 tbl1,t2 tbl2
WHERE tbl1.f1=tbl2.f1 AND tbl2.f2 BETWEEN tbl1.f1 and tbl1.f2 and tbl2.f2 + 1 >= tbl1.f1 + 1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (tbl1.f1 is not null)  (rows=3)
        -> Table scan on tbl1  (rows=3)
    -> Index lookup on tbl2 using f1 (f1 = tbl1.f1), with index condition: ((tbl2.f2 between tbl1.f1 and tbl1.f2) and ((tbl2.f2 + 1) >= (tbl1.f1 + 1)))  (rows=7)

# Turn on BKA for multiple tables. BKA should be used for tbl2.
EXPLAIN SELECT /*+ BKA(tbl1, tbl2) */ tbl2.f1, tbl2.f2, tbl2.f3 FROM t1 tbl1,t2 tbl2
WHERE tbl1.f1=tbl2.f1 AND tbl2.f2 BETWEEN tbl1.f1 and tbl1.f2 and tbl2.f2 + 1 >= tbl1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (tbl1.f1 is not null)  (rows=3)
            -> Table scan on tbl1  (rows=3)
    -> Filter: ((tbl2.f2 between tbl1.f1 and tbl1.f2) and ((tbl2.f2 + 1) >= (tbl1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on tbl2 using f1 (f1 = tbl1.f1)  (rows=7)

# Print warnings for nonexistent names
EXPLAIN
SELECT /*+ BKA(t2) NO_BNL(t1) BKA(t3) NO_RANGE_OPTIMIZATION(t3 idx1) NO_RANGE_OPTIMIZATION(t3) */
t2.f1, t2.f2, t2.f3 FROM t1,t2 WHERE t1.f1=t2.f1 AND
t2.f2 BETWEEN t1.f1 AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

Warnings:
Warning	3128	Unresolved name `t3`@`select#1` for BKA hint
Warning	3128	Unresolved name `t3`@`select#1` for NO_RANGE_OPTIMIZATION hint
Warning	3128	Unresolved name `t3`@`select#1` `idx1` for NO_RANGE_OPTIMIZATION hint
# Check illegal syntax
EXPLAIN SELECT /*+ BKA(qb1 t3@qb1) */ f2 FROM
(SELECT /*+ QB_NAME(qb1) */ f2, f3, f1 FROM t3 WHERE f1 > 2 AND f3 = 'poiu') AS TD
WHERE TD.f1 > 2 AND TD.f3 = 'poiu';
EXPLAIN
-> Index range scan (Multi-Range Read) on t3 using f3_idx over (f3 = 'poiu' AND 2 < f1), with index condition: ((t3.f3 = 'poiu') and (t3.f1 > 2) and (t3.f1 > 2))  (rows=16)

Warnings:
Warning	1064	Optimizer hint syntax error near 't3@qb1) */ f2 FROM
(SELECT /*+ QB_NAME(qb1) */ f2, f3, f1 FROM t3 WHERE f1 > 2 A' at line 1
# Check illegal syntax
EXPLAIN SELECT * FROM
(SELECT /*+ QB_NAME(qb1) BKA(@qb1 t1@qb1, t2@qb1, t3) */ t2.f1, t2.f2, t2.f3 FROM t1,t2,t3) tt;
EXPLAIN
-> Inner hash join (no condition)  (rows=4704)
    -> Covering index scan on t3 using f2_idx  (rows=56)
    -> Hash
        -> Inner hash join (no condition)  (rows=84)
            -> Table scan on t2  (rows=28)
            -> Hash
                -> Table scan on t1  (rows=3)

Warnings:
Warning	1064	Optimizer hint syntax error near 'qb1, t2@qb1, t3) */ t2.f1, t2.f2, t2.f3 FROM t1,t2,t3) tt' at line 2
# Check '@qb_name table_name' syntax. BKA should be used for t2.
EXPLAIN SELECT /*+ BKA(@qb1 t2) */ * FROM (SELECT /*+ QB_NAME(QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1) AS s1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (t1.f1 is not null)  (rows=3)
            -> Table scan on t1  (rows=3)
    -> Filter: ((t2.f2 between t1.f1 and t1.f2) and ((t2.f2 + 1) >= (t1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on t2 using f1 (f1 = t1.f1)  (rows=7)

# Check that original table name is not recognized if alias is used.
EXPLAIN SELECT * FROM (SELECT /*+ BKA(t2) */ tb2.f1, tb2.f2, tb2.f3 FROM t1 tb1,t2 tb2
WHERE tb1.f1=tb2.f1 AND tb2.f2 BETWEEN tb1.f1 and tb1.f2 and tb2.f2 + 1 >= tb1.f1 + 1) AS s1;
EXPLAIN
-> Nested loop inner join  (rows=21)
    -> Filter: (tb1.f1 is not null)  (rows=3)
        -> Table scan on tb1  (rows=3)
    -> Index lookup on tb2 using f1 (f1 = tb1.f1), with index condition: ((tb2.f2 between tb1.f1 and tb1.f2) and ((tb2.f2 + 1) >= (tb1.f1 + 1)))  (rows=7)

Warnings:
Warning	3128	Unresolved name `t2`@`select#2` for BKA hint
# Table t2 should use BKA.
EXPLAIN SELECT * FROM (SELECT /*+ BKA(tb2) */ tb2.f1, tb2.f2, tb2.f3 FROM t1 tb1,t2 tb2
WHERE tb1.f1=tb2.f1 AND tb2.f2 BETWEEN tb1.f1 and tb1.f2 and tb2.f2 + 1 >= tb1.f1 + 1) AS s1;
EXPLAIN
-> Batched key access inner join
    -> Batch input rows
        -> Filter: (tb1.f1 is not null)  (rows=3)
            -> Table scan on tb1  (rows=3)
    -> Filter: ((tb2.f2 between tb1.f1 and tb1.f2) and ((tb2.f2 + 1) >= (tb1.f1 + 1)))  (rows=0.778)
        -> Multi-range index lookup on tb2 using f1 (f1 = tb1.f1)  (rows=7)

# Check that PS and conventional statements give the same result.
FLUSH STATUS;
SELECT /*+ BKA(@qb1 t2) */ * FROM (SELECT /*+ QB_NAME(QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1) AS s1;
f1	f2	f3
1	1	qwerty
2	2	qwerty
1	1	qwerty
2	2	qwerty
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	24
Handler_read_last	0
Handler_read_next	20
Handler_read_prev	0
Handler_read_rnd	20
Handler_read_rnd_next	4
PREPARE stmt1 FROM "SELECT /*+ BKA(@qb1 t2) */ * FROM (SELECT /*+ QB_NAME(QB1) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 and t1.f2 and t2.f2 + 1 >= t1.f1 + 1) AS s1";
FLUSH STATUS;
EXECUTE stmt1;
f1	f2	f3
1	1	qwerty
2	2	qwerty
1	1	qwerty
2	2	qwerty
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	24
Handler_read_last	0
Handler_read_next	20
Handler_read_prev	0
Handler_read_rnd	20
Handler_read_rnd_next	4
FLUSH STATUS;
EXECUTE stmt1;
f1	f2	f3
1	1	qwerty
2	2	qwerty
1	1	qwerty
2	2	qwerty
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	1
Handler_read_key	24
Handler_read_last	0
Handler_read_next	20
Handler_read_prev	0
Handler_read_rnd	20
Handler_read_rnd_next	4
DEALLOCATE PREPARE stmt1;
DROP TABLE t1, t2, t3;
# BNL & NO_BNL hint testing
set optimizer_switch=default;
set optimizer_switch='block_nested_loop=on';
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,1),(2,2);
CREATE TABLE t2 (a INT, b INT);
INSERT INTO t2 VALUES (1,1),(2,2);
CREATE TABLE t3 (a INT, b INT);
INSERT INTO t3 VALUES (1,1),(2,2);
# Check statistics without hint
FLUSH STATUS;
SELECT t1.* FROM t1,t2,t3;
a	b
1	1
1	1
1	1
1	1
2	2
2	2
2	2
2	2
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	3
Handler_read_key	3
Handler_read_last	0
Handler_read_next	0
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	9
# Check statistics with hint
FLUSH STATUS;
SELECT /*+ NO_BNL() */t1.* FROM t1,t2,t3;
a	b
1	1
1	1
1	1
1	1
2	2
2	2
2	2
2	2
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	7
Handler_read_key	7
Handler_read_last	0
Handler_read_next	0
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	21
EXPLAIN SELECT t1.* FROM t1,t2,t3;
EXPLAIN
-> Inner hash join (no condition)  (rows=8)
    -> Table scan on t3  (rows=2)
    -> Hash
        -> Inner hash join (no condition)  (rows=4)
            -> Table scan on t2  (rows=2)
            -> Hash
                -> Table scan on t1  (rows=2)

EXPLAIN SELECT /*+ NO_BNL() */t1.* FROM t1,t2,t3;
EXPLAIN
-> Nested loop inner join  (rows=8)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t1  (rows=2)
        -> Table scan on t2  (rows=2)
    -> Table scan on t3  (rows=2)

EXPLAIN SELECT /*+ NO_BNL(t2, t3) */t1.* FROM t1,t2,t3;
EXPLAIN
-> Nested loop inner join  (rows=8)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t1  (rows=2)
        -> Table scan on t2  (rows=2)
    -> Table scan on t3  (rows=2)

EXPLAIN SELECT /*+ NO_BNL(t1, t3) */t1.* FROM t1,t2,t3;
EXPLAIN
-> Nested loop inner join  (rows=8)
    -> Inner hash join (no condition)  (rows=4)
        -> Table scan on t2  (rows=2)
        -> Hash
            -> Table scan on t1  (rows=2)
    -> Table scan on t3  (rows=2)

set optimizer_switch='block_nested_loop=off';
EXPLAIN SELECT t1.* FROM t1,t2,t3;
EXPLAIN
-> Nested loop inner join  (rows=8)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t1  (rows=2)
        -> Table scan on t2  (rows=2)
    -> Table scan on t3  (rows=2)

EXPLAIN SELECT /*+ BNL() */t1.* FROM t1,t2,t3;
EXPLAIN
-> Inner hash join (no condition)  (rows=8)
    -> Table scan on t3  (rows=2)
    -> Hash
        -> Inner hash join (no condition)  (rows=4)
            -> Table scan on t2  (rows=2)
            -> Hash
                -> Table scan on t1  (rows=2)

EXPLAIN SELECT /*+ BNL(t2, t3) */t1.* FROM t1,t2,t3;
EXPLAIN
-> Inner hash join (no condition)  (rows=8)
    -> Table scan on t3  (rows=2)
    -> Hash
        -> Inner hash join (no condition)  (rows=4)
            -> Table scan on t2  (rows=2)
            -> Hash
                -> Table scan on t1  (rows=2)

EXPLAIN SELECT /*+ BNL(t1, t3) */t1.* FROM t1,t2,t3;
EXPLAIN
-> Inner hash join (no condition)  (rows=8)
    -> Table scan on t3  (rows=2)
    -> Hash
        -> Nested loop inner join  (rows=4)
            -> Table scan on t1  (rows=2)
            -> Table scan on t2  (rows=2)

EXPLAIN SELECT /*+ BNL(t2) BNL(t3) */t1.* FROM t1,t2,t3;
EXPLAIN
-> Inner hash join (no condition)  (rows=8)
    -> Table scan on t3  (rows=2)
    -> Hash
        -> Inner hash join (no condition)  (rows=4)
            -> Table scan on t2  (rows=2)
            -> Hash
                -> Table scan on t1  (rows=2)

DROP TABLE t1, t2, t3;
# BNL in subquery
set optimizer_switch = DEFAULT;
CREATE TABLE t1 (a INT, b INT, PRIMARY KEY (a));
CREATE TABLE t2 (a INT, INDEX a (a));
CREATE TABLE t3 (a INT, b INT, INDEX a (a,b));
INSERT INTO t1 VALUES (1,10), (2,20), (3,30),  (4,40);
INSERT INTO t2 VALUES (2), (3), (4), (5);
INSERT INTO t3 VALUES (10,3), (20,4), (30,5);
ANALYZE TABLE t1, t2, t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
SET optimizer_prune_level = 0;
EXPLAIN SELECT /*+ QB_NAME(q) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=3)
                    -> Materialize with deduplication  (rows=3)
                        -> Filter: (t3.b is not null)  (rows=3)
                            -> Inner hash join (t4.b = t3.b)  (rows=3)
                                -> Table scan on t4  (rows=4)
                                -> Hash
                                    -> Covering index scan on t3 using a  (rows=3)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL() */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Nested loop inner join  (rows=3)
    -> Nested loop inner join  (rows=3)
        -> Filter: (`<subquery2>`.b is not null)  (rows=3)
            -> Table scan on <subquery2>  (rows=3)
                -> Materialize with deduplication  (rows=3)
                    -> Filter: (t3.b is not null)  (rows=3)
                        -> Inner hash join (t4.b = t3.b)  (rows=3)
                            -> Table scan on t4  (rows=4)
                            -> Hash
                                -> Covering index scan on t3 using a  (rows=3)
        -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)
    -> Filter: (t1.b = `<subquery2>`.b)  (rows=1)
        -> Table scan on t1  (rows=4)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL(t1, t2) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Nested loop inner join  (rows=3)
    -> Nested loop inner join  (rows=3)
        -> Filter: (`<subquery2>`.b is not null)  (rows=3)
            -> Table scan on <subquery2>  (rows=3)
                -> Materialize with deduplication  (rows=3)
                    -> Filter: (t3.b is not null)  (rows=3)
                        -> Inner hash join (t4.b = t3.b)  (rows=3)
                            -> Table scan on t4  (rows=4)
                            -> Hash
                                -> Covering index scan on t3 using a  (rows=3)
        -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)
    -> Filter: (t1.b = `<subquery2>`.b)  (rows=1)
        -> Table scan on t1  (rows=4)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL(@subq1) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=3)
                    -> Materialize with deduplication  (rows=3)
                        -> Filter: (t3.b is not null)  (rows=3)
                            -> Nested loop inner join  (rows=3)
                                -> Covering index scan on t3 using a  (rows=3)
                                -> Filter: (t4.b = t3.b)  (rows=1)
                                    -> Table scan on t4  (rows=4)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL(t4@subq1) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=4)
                    -> Materialize with deduplication  (rows=4)
                        -> Filter: (t3.b is not null)  (rows=4)
                            -> Inner hash join (t3.b = t4.b)  (rows=4)
                                -> Covering index scan on t3 using a  (rows=3)
                                -> Hash
                                    -> Table scan on t4  (rows=4)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL(t3@subq1,t4@subq1) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=3)
                    -> Materialize with deduplication  (rows=3)
                        -> Filter: (t3.b is not null)  (rows=3)
                            -> Nested loop inner join  (rows=3)
                                -> Covering index scan on t3 using a  (rows=3)
                                -> Filter: (t4.b = t3.b)  (rows=1)
                                    -> Table scan on t4  (rows=4)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(q) NO_BNL(@subq1 t3, t4) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=3)
                    -> Materialize with deduplication  (rows=3)
                        -> Filter: (t3.b is not null)  (rows=3)
                            -> Nested loop inner join  (rows=3)
                                -> Covering index scan on t3 using a  (rows=3)
                                -> Filter: (t4.b = t3.b)  (rows=1)
                                    -> Table scan on t4  (rows=4)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(q) */ * FROM t1 JOIN t2 ON t1.b = t2.a WHERE
t2.a IN (SELECT /*+ QB_NAME(subq1)  NO_BNL(t3, t4) */ t3.b FROM t3 JOIN t1 t4 ON t3.b = t4.b);
EXPLAIN
-> Inner hash join (t1.b = `<subquery2>`.b)  (rows=3)
    -> Table scan on t1  (rows=4)
    -> Hash
        -> Nested loop inner join  (rows=3)
            -> Filter: (`<subquery2>`.b is not null)  (rows=3)
                -> Table scan on <subquery2>  (rows=3)
                    -> Materialize with deduplication  (rows=3)
                        -> Filter: (t3.b is not null)  (rows=3)
                            -> Nested loop inner join  (rows=3)
                                -> Covering index scan on t3 using a  (rows=3)
                                -> Filter: (t4.b = t3.b)  (rows=1)
                                    -> Table scan on t4  (rows=4)
            -> Covering index lookup on t2 using a (a = `<subquery2>`.b)  (rows=1)

SET optimizer_prune_level = DEFAULT;
DROP TABLE t1, t2, t3;
# MRR & NO_MRR hint testing
set optimizer_switch=default;
SET @saved_explain_format = @@explain_format;
SET explain_format = TRADITIONAL;
CREATE TABLE t1
(
f1 int NOT NULL DEFAULT '0',
f2 int NOT NULL DEFAULT '0',
f3 int NOT NULL DEFAULT '0',
INDEX idx1(f2, f3), INDEX idx2(f3)
);
INSERT INTO t1(f1) VALUES (1), (2), (3), (4), (5), (6), (7), (8);
INSERT INTO t1(f2, f3) VALUES (3,4), (3,4);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
set optimizer_switch='mrr=on,mrr_cost_based=off';
# Check statistics without hint
FLUSH STATUS;
SELECT * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
f1	f2	f3
0	3	4
0	3	4
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	0
Handler_read_key	3
Handler_read_last	0
Handler_read_next	2
Handler_read_prev	0
Handler_read_rnd	2
Handler_read_rnd_next	0
# Check statistics with hint
FLUSH STATUS;
SELECT /*+ NO_MRR(t1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
f1	f2	f3
0	3	4
0	3	4
SHOW STATUS LIKE 'handler_read%';
Variable_name	Value
Handler_read_first	0
Handler_read_key	1
Handler_read_last	0
Handler_read_next	2
Handler_read_prev	0
Handler_read_rnd	0
Handler_read_rnd_next	0
EXPLAIN SELECT * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn off MRR. MRR should not be used.
EXPLAIN SELECT /*+ NO_MRR(t1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select /*+ NO_MRR(`t1`@`select#1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn off MRR. MRR should not be used.
EXPLAIN SELECT /*+ NO_MRR(t1 idx2) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select /*+ NO_MRR(`t1`@`select#1` `idx2`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn off MRR for unused key. MRR should be used.
EXPLAIN SELECT /*+ NO_MRR(t1 idx1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select /*+ NO_MRR(`t1`@`select#1` `idx1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
set optimizer_switch='mrr=off,mrr_cost_based=off';
EXPLAIN SELECT * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR. MRR should be used.
EXPLAIN SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR. MRR should be used.
EXPLAIN SELECT /*+ MRR(t1 IDX2) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1` `IDX2`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR for unused key. MRR should not be used.
EXPLAIN SELECT /*+ MRR(t1 idx1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1` `idx1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
set optimizer_switch='mrr=off,mrr_cost_based=on';
EXPLAIN SELECT * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR. MRR should be used.
EXPLAIN SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR. MRR should be used.
EXPLAIN SELECT /*+ MRR(t1 idx2) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1` `idx2`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
# Turn on MRR for unused key. MRR should not be used.
EXPLAIN SELECT /*+ MRR(t1 IDX1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	idx1,idx2	idx2	4	NULL	2	100.00	Using index condition; Using where
Warnings:
Note	1003	/* select#1 */ select /*+ MRR(`t1`@`select#1` `IDX1`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3` from `test`.`t1` where ((`test`.`t1`.`f2` <= 3) and (3 <= `test`.`t1`.`f3`))
DROP TABLE t1;
SET explain_format = @saved_explain_format;
#
# Bug#21205282 CRASH/ASSERTION IN JOIN_CACHE::SET_MATCH_FLAG_IF_NONE WITH NO_BNL HINT
#
CREATE TABLE t(a INT);
INSERT INTO t VALUES (1);
SET optimizer_switch='block_nested_loop=on';
EXPLAIN SELECT 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Left hash join (no condition)  (rows=1)
    -> Left hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Table scan on t2  (rows=1)
    -> Hash
        -> Left hash join (no condition)  (rows=1)
            -> Table scan on t3  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t1) */ 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Left hash join (no condition)  (rows=1)
    -> Left hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Table scan on t2  (rows=1)
    -> Hash
        -> Left hash join (no condition)  (rows=1)
            -> Table scan on t3  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t2) */ 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Left hash join (no condition)  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Table scan on t2  (rows=1)
    -> Hash
        -> Left hash join (no condition)  (rows=1)
            -> Table scan on t3  (rows=1)
            -> Hash
                -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t3) */ 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Left hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Table scan on t2  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t4) */ 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Left hash join (no condition)  (rows=1)
        -> Table scan on t1  (rows=1)
        -> Hash
            -> Table scan on t2  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t3) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 LEFT JOIN t t4 ON 1) ON 1 WHERE 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

SELECT /*+ NO_BNL(t4) */ 1 FROM t t1 LEFT JOIN t t2 ON 1 LEFT JOIN (t t3 LEFT JOIN t t4 ON 1) ON 1;
1
1
SELECT /*+ NO_BNL(t3) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 LEFT JOIN t t4 ON 1) ON 1 WHERE 1;
1
1
SET optimizer_switch='block_nested_loop=off';
EXPLAIN SELECT 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t1) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t2) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t3) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t4) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t2, t3) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t3, t4) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Table scan on t2  (rows=1)
            -> Table scan on t3  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ BNL(t2, t3, t4) */ 1 FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON 1 INNER JOIN t t4 ON 1) ON 1;
EXPLAIN
-> Left hash join (no condition)  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Hash
        -> Inner hash join (no condition)  (rows=1)
            -> Table scan on t4  (rows=1)
            -> Hash
                -> Left hash join (no condition)  (rows=1)
                    -> Table scan on t2  (rows=1)
                    -> Hash
                        -> Table scan on t3  (rows=1)

DROP TABLE t;
CREATE TABLE t(a INT, b INT, KEY k(a));
INSERT INTO t VALUES (1,1);
EXPLAIN SELECT * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t1) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t2) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t2, t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t2, t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop left join  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
            -> Index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Index lookup on t4 using k (a = t1.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t2, t3, t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 USING(a) LEFT JOIN t t4 USING(a)) USING(a);
EXPLAIN
-> Nested loop left join
    -> Table scan on t1  (rows=1)
    -> Batched key access left join
        -> Batch input rows
            -> Batched key access left join
                -> Batch input rows
                    -> Index lookup on t2 using k (a = t1.a)  (rows=1)
                -> Multi-range index lookup on t3 using k (a = t1.a)  (rows=1)
        -> Multi-range index lookup on t4 using k (a = t1.a)  (rows=1)

SET optimizer_switch='block_nested_loop=on,batched_key_access=on,mrr_cost_based=off';
EXPLAIN SELECT * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Left hash join (t3.b = t2.b)  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BKA(t1) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Left hash join (t3.b = t2.b)  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BKA(t2) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Left hash join (t3.b = t2.b)  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t3) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Filter: (t3.b = t2.b)  (rows=1)
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t4) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Left hash join (t3.b = t2.b)  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Hash
            -> Table scan on t3  (rows=1)
    -> Filter: (t4.b = t3.b)  (rows=1)
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BKA(t2) NO_BNL(t3) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Filter: (t3.b = t2.b)  (rows=1)
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t3) NO_BKA(t4) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Filter: (t3.b = t2.b)  (rows=1)
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

EXPLAIN SELECT /*+ NO_BKA(t2) NO_BNL(t3) NO_BKA(t4) */ * FROM t t1 INNER JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b LEFT JOIN t t4 ON t3.b=t4.b) ON t1.a=t2.a;
EXPLAIN
-> Left hash join (t4.b = t3.b)  (rows=1)
    -> Nested loop left join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t1.a is not null)  (rows=1)
                -> Table scan on t1  (rows=1)
            -> Index lookup on t2 using k (a = t1.a)  (rows=1)
        -> Filter: (t3.b = t2.b)  (rows=1)
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Table scan on t4  (rows=1)

SET optimizer_switch='batched_key_access=off';
EXPLAIN SELECT * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t1) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ NO_BNL(t2) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Left hash join (t2.b = t1.b), (t3.b = t1.b)
    -> Table scan on t1  (rows=1)
    -> Hash
        -> Batched key access inner join
            -> Batch input rows
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on t3  (rows=1)
                    -> Hash
                        -> Table scan on t2  (rows=1)
            -> Multi-range index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t2, t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t3, t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Left hash join (t2.b = t1.b), (t3.b = t1.b)
    -> Table scan on t1  (rows=1)
    -> Hash
        -> Batched key access inner join
            -> Batch input rows
                -> Inner hash join (no condition)  (rows=1)
                    -> Table scan on t3  (rows=1)
                    -> Hash
                        -> Table scan on t2  (rows=1)
            -> Multi-range index lookup on t4 using k (a = t3.a)  (rows=1)

SET optimizer_switch='block_nested_loop=off';
EXPLAIN SELECT * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t1) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t2) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t2, t3) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BKA(t3, t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

EXPLAIN SELECT /*+ BNL(t2, t3, t4) */ * FROM t t1 LEFT JOIN (t t2 LEFT JOIN t t3 ON t2.b=t3.b INNER JOIN t t4 ON t3.a=t4.a) ON t1.b=t2.b;
EXPLAIN
-> Nested loop left join  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Nested loop inner join  (rows=1)
            -> Filter: (t2.b = t1.b)  (rows=1)
                -> Table scan on t2  (rows=1)
            -> Filter: (t3.b = t1.b)  (rows=1)
                -> Table scan on t3  (rows=1)
        -> Index lookup on t4 using k (a = t3.a)  (rows=1)

DROP TABLE t;
set optimizer_switch=default;
#
# Duplicate hints
#
CREATE TABLE t1 (i INT PRIMARY KEY);
SELECT /*+ BKA() BKA() */ 1;
1
1
Warnings:
Warning	3126	Hint BKA( ) is ignored as conflicting/duplicated
SELECT /*+ BKA(t1) BKA(t1) */ * FROM t1;
i
Warnings:
Warning	3126	Hint BKA(`t1` ) is ignored as conflicting/duplicated
SELECT /*+ QB_NAME(q1) BKA(t1@q1) BKA(t1@q1) */ * FROM t1;
i
Warnings:
Warning	3126	Hint BKA(`t1`@`q1` ) is ignored as conflicting/duplicated
SELECT /*+ QB_NAME(q1) NO_ICP(@q1 t1 PRIMARY) NO_ICP(@q1 t1 PRIMARY) */ * FROM t1;
i
Warnings:
Warning	3126	Hint NO_ICP(`t1`@`q1` `PRIMARY` ) is ignored as conflicting/duplicated
DROP TABLE t1;
#
# Bug#21192857 ASSERTION FAILED: KEYINFO_ARRAY.SIZE() == 0, FILE OPT_HINTS.CC:280
#
CREATE TABLE t1(a INT, KEY(a));
INSERT INTO t1(a) SELECT /*+ NO_RANGE_OPTIMIZATION(t1 a)*/ 1 FROM t1;
DROP TABLE t1;
# WL#8016 Parser for optimizer hints
CREATE TABLE t1 (i INT, j INT);
CREATE INDEX i1 ON t1(i);
CREATE INDEX i2 ON t1(j);

# empty hint comment is ok:

SELECT /*+*/ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '*/' at line 1
SELECT /*+ */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '*/' at line 1
SELECT /*+ * ** / // /* */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '* ** / // /* */ 1' at line 1
SELECT /*+ @ */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '@ */ 1' at line 1
SELECT /*+ @foo */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '@foo */ 1' at line 1
SELECT /*+ foo@bar */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'foo@bar */ 1' at line 1
SELECT /*+ foo @bar */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'foo @bar */ 1' at line 1
SELECT /*+ `@` */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '`@` */ 1' at line 1
SELECT /*+ `@foo` */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '`@foo` */ 1' at line 1
SELECT /*+ `foo@bar` */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '`foo@bar` */ 1' at line 1
SELECT /*+ `foo @bar` */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '`foo @bar` */ 1' at line 1
SELECT /*+ BKA( @) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT /*+ BKA( @) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT /*+ BKA(t1 @) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '@) */ 1' at line 1

# We don't support "*/" inside quoted identifiers (syntax error):

SELECT /*+ BKA(`test*/`) */ 1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '`) */ 1' at line 1

# valid hint sequences:

SELECT  /*+ NO_ICP() */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT  /*+NO_ICP()*/ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ')*/ 1' at line 1
SELECT  /*+ NO_ICP () */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT  /*+ NO_ICP (  ) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT  /*+ NO_ICP() */ 1 UNION SELECT 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1 UNION SELECT 1' at line 1
(SELECT /*+ NO_ICP() */ 1) UNION (SELECT 1);
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1) UNION (SELECT 1)' at line 1
((SELECT  /* + NO_ICP() */ 1));
1
1
EXPLAIN SELECT /*+ QB_NAME(qb1) */ 1 UNION SELECT /*+ QB_NAME(qb2) */ 1;
EXPLAIN
-> Table scan on <union temporary>  (rows=2)
    -> Union materialize with deduplication  (rows=2)
        -> Rows fetched before execution  (rows=1)
        -> Rows fetched before execution  (rows=1)

EXPLAIN (SELECT /*+ QB_NAME(qb1) */ 1) UNION (SELECT /*+ QB_NAME(qb2) */ 1);
EXPLAIN
-> Table scan on <union temporary>  (rows=2)
    -> Union materialize with deduplication  (rows=2)
        -> Rows fetched before execution  (rows=1)
        -> Rows fetched before execution  (rows=1)

UPDATE  /*+ NO_ICP() */ t1 SET i = 10;
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ t1 SET i = 10' at line 1
INSERT  /*+ NO_ICP() */ INTO t1 VALUES ();
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ INTO t1 VALUES ()' at line 1
REPLACE /*+ NO_ICP() */ INTO t1 VALUES ();
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ INTO t1 VALUES ()' at line 1
DELETE  /*+ NO_ICP() */ FROM t1 WHERE 1;
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ FROM t1 WHERE 1' at line 1
SELECT /*+ BKA(t1) */    1 FROM t1;
1
SELECT /*+ BKA(a b) */   1 FROM t1 a, t1 b;
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'b) */   1 FROM t1 a, t1 b' at line 1
SELECT /*+ NO_ICP(i1) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name `i1`@`select#1` for NO_ICP hint
SELECT /*+ NO_ICP(i1 i2) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name `i1`@`select#1` `i2` for NO_ICP hint
SELECT /*+ NO_ICP(@qb ident) */ 1 FROM t1;
1
Warnings:
Warning	3127	Query block name `qb` is not found for NO_ICP hint
#
# test explainable statements for hint support:
# they should warn with a hint syntax error near "test */"
#
EXPLAIN SELECT /*+ test */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

Warnings:
Warning	1064	Optimizer hint syntax error near 'test */ 1' at line 1
EXPLAIN INSERT /*+ test */ INTO t1 VALUES (10, 10);
EXPLAIN
-> Insert into t1
    -> Rows fetched before execution

Warnings:
Warning	1064	Optimizer hint syntax error near 'test */ INTO t1 VALUES (10, 10)' at line 1
EXPLAIN REPLACE /*+ test */ INTO t1 VALUES (10, 10);
EXPLAIN
-> Replace into t1
    -> Rows fetched before execution

Warnings:
Warning	1064	Optimizer hint syntax error near 'test */ INTO t1 VALUES (10, 10)' at line 1
EXPLAIN UPDATE /*+ test */ t1 SET i = 10 WHERE j = 10;
EXPLAIN
-> <not executable by iterator executor>

Warnings:
Warning	1064	Optimizer hint syntax error near 'test */ t1 SET i = 10 WHERE j = 10' at line 1
EXPLAIN DELETE /*+ test */ FROM t1 WHERE i = 10;
EXPLAIN
-> <not executable by iterator executor>

Warnings:
Warning	1064	Optimizer hint syntax error near 'test */ FROM t1 WHERE i = 10' at line 1

# non-alphabetic and non-ASCII identifiers:

CREATE INDEX 3rd_index ON t1(i, j);
SELECT /*+ NO_ICP(3rd_index) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name `3rd_index`@`select#1` for NO_ICP hint
CREATE INDEX `$index` ON t1(j, i);
SELECT /*+ NO_ICP($index) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name `$index`@`select#1` for NO_ICP hint
CREATE TABLE ` quoted name ` (i INT);
SELECT /*+ BKA(` quoted name `) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name ` quoted name `@`select#1` for BKA hint
SELECT /*+ BKA(` quoted name `@`select#1`) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name ` quoted name `@`select#1` for BKA hint
DROP TABLE ` quoted name `;
SET SQL_MODE = 'ANSI_QUOTES';
CREATE TABLE " quoted name " (i INT);
SELECT /*+ BKA(" quoted name ") */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name " quoted name "@"select#1" for BKA hint
SELECT /*+ BKA(" quoted name "@"select#1") */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name " quoted name "@"select#1" for BKA hint
CREATE TABLE `test1``test2``` (i INT);
SELECT /*+ BKA(`test1``test2```) */ 1;
1
1
Warnings:
Warning	3128	Unresolved name "test1`test2`"@"select#1" for BKA hint
SELECT /*+ BKA("test1""test2""") */ 1;
1
1
Warnings:
Warning	3128	Unresolved name "test1""test2"""@"select#1" for BKA hint
SET SQL_MODE = '';
# should warn:
SELECT /*+ BKA(" quoted name ") */ 1 FROM t1;
1
Warnings:
Warning	1064	Optimizer hint syntax error near '" quoted name ") */ 1 FROM t1' at line 1
DROP TABLE ` quoted name `;
DROP TABLE `test1``test2```;
EXPLAIN SELECT /*+ QB_NAME(`*`) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(`a*`) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(`*b`) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

EXPLAIN SELECT /*+ QB_NAME(`a
b`) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

# hint syntax error: empty quoted identifier
EXPLAIN SELECT /*+ QB_NAME(``) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

Warnings:
Warning	1064	Optimizer hint syntax error near '``) */ 1' at line 1
SET NAMES utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
EXPLAIN SELECT /*+ QB_NAME(````) */ 1;
EXPLAIN
-> Rows fetched before execution  (rows=1)

CREATE TABLE table (i INT);
SELECT /*+ BKA(table) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name `table`@`select#1` for BKA hint
SELECT /*+ BKA(test@table) */ 1 FROM t1;
1
Warnings:
Warning	3127	Query block name `table` is not found for BKA hint
DROP TABLE table;
CREATE TABLE  (i INT);
SELECT /*+ BKA(``) */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name ``@`select#1` for BKA hint
SELECT /*+ BKA() */ 1 FROM t1;
1
Warnings:
Warning	3128	Unresolved name ``@`select#1` for BKA hint
SELECT /*+ BKA(test@) */ 1 FROM t1;
1
Warnings:
Warning	3127	Query block name `` is not found for BKA hint
# broken multibyte char, should warn:
SELECT /*+ NO_ICP(``) */ 1 FROM t1;
1
Warnings:
Warning	1064	Optimizer hint syntax error near '`?`) */ 1 FROM t1' at line 1
DROP TABLE ;
SET NAMES DEFAULT;

# derived tables and other subqueries:

SELECT * FROM (SELECT /*+ DEBUG_HINT3 */ 1) a;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'DEBUG_HINT3 */ 1) a' at line 1
SELECT (SELECT /*+ DEBUG_HINT3 */ 1);
(SELECT /*+ DEBUG_HINT3 */ 1)
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'DEBUG_HINT3 */ 1)' at line 1
SELECT 1 FROM DUAL WHERE 1 IN (SELECT /*+ DEBUG_HINT3 */ 1);
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'DEBUG_HINT3 */ 1)' at line 1

# invalid hint sequences (should warn):

SELECT /*+ 10 */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '10 */ 1' at line 1
SELECT /*+ NO_ICP() */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT /*+ NO_ICP(10) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '10) */ 1' at line 1
SELECT /*+ NO_ICP( */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '*/' at line 1
SELECT /*+ NO_ICP) */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1' at line 1
SELECT /*+ NO_ICP(t1 */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '*/' at line 1
SELECT /*+ NO_ICP(t1 ( */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '( */ 1' at line 1
(SELECT 1) UNION (SELECT /*+ NO_ICP() */ 1);
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1)' at line 1
INSERT INTO t1 VALUES (1, 1), (2, 2);

# wrong place for hint, so recognize that stuff as a regular commentary:

SELECT 1 FROM /*+ regular commentary, not a hint! */ t1;
1
1
1
SELECT 1 FROM /*+ #1 */ t1 WHERE /*+ #2 */ 1 /*+ #3 */;
1
1
1
SELECT /*+ NO_ICP() */ 1
FROM /*+ regular commentary, not a hint! */ t1;
1
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near ') */ 1
FROM /*+ regular commentary, not a hint! */ t1' at line 1
SELECT /*+ NO_ICP(t1) bad_hint */ 1 FROM t1;
1
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near 'bad_hint */ 1 FROM t1' at line 1
SELECT /*+
NO_ICP(@qb ident)
*/ 1 FROM t1;
1
1
1
Warnings:
Warning	3127	Query block name `qb` is not found for NO_ICP hint
SELECT /*+
? bad syntax
*/ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '? bad syntax
*/ 1' at line 2
SELECT
/*+ ? bad syntax */ 1;
1
1
Warnings:
Warning	1064	Optimizer hint syntax error near '? bad syntax */ 1' at line 2
DROP TABLE t1;
#
# Bug #21095608: OPTIMIZER HINT PARSER DOESN'T ACCEPT NUMBER-PREFIXED
#                QUERY BLOCK NAMES AFTER @
#
CREATE TABLE t1 (i INT);
EXPLAIN SELECT /*+ QB_NAME(1a) BKA(t1@1a) */ 1 FROM t1;
EXPLAIN
-> Table scan on t1  (rows=1)

DROP TABLE t1;
#
# Bug #21148405: OPTIMIZER HINTS: READ OF FREE MEMORY FOR INVALID HINTS
#
CREATE PROCEDURE p1()
BEGIN
DECLARE cur1 CURSOR FOR  SELECT /*+ NO_MRR(q w)*/1;
OPEN cur1;
END|
CALL p1();
Warnings:
Warning	3128	Unresolved name `q`@`select#1` `w` for NO_MRR hint
CALL p1();
DROP PROCEDURE p1;
#
# WL#9307 MERGE/NO_MERGE hint for derived table, view
#
create table t1(a int);
explain select * from (select * from t1) as dt;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ merge(dt) */ * from (select * from t1) as dt;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ no_merge(dt) */ * from (select * from t1) as dt;
EXPLAIN
-> Table scan on dt  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

# Also testing that case of letters is irrelevant.
explain select /*+ no_mERge(dt) */ * from (select * from t1) as dt;
EXPLAIN
-> Table scan on dt  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

create view v1 as (select * from t1);
explain select * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ merge(v1) */ * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ no_merge(v1) */ * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

drop view v1;
# hint is OVERRIDDEN by algorithm=
create algorithm=merge view v1 as (select * from t1);
explain select * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ merge(v1) */ * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ no_merge(v1) */ * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

drop view v1;
create algorithm=temptable view v1 as (select * from t1);
explain select * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

explain select /*+ merge(v1) */ * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

explain select /*+ no_merge(v1) */ * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

drop view v1;
# hint OVERRIDES optimizer_switch
set optimizer_switch="derived_merge=off";
explain select * from (select * from t1) as dt;
EXPLAIN
-> Table scan on dt  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

explain select /*+ merge(dt) */ * from (select * from t1) as dt;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ no_merge(dt) */ * from (select * from t1) as dt;
EXPLAIN
-> Table scan on dt  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

create view v1 as (select * from t1);
explain select * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

explain select /*+ merge(v1) */ * from v1;
EXPLAIN
-> Table scan on t1  (rows=1)

explain select /*+ no_merge(v1) */ * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t1  (rows=1)

drop view v1;
set optimizer_switch=default;
# Can apply to certain derived tables
create table t2(a int, b int);
create table t3 like t2;
explain select /*+ no_merge(dt) merge(dt2) */ *
from (select * from t1) as dt, (select * from t2) as dt2;
EXPLAIN
-> Inner hash join (no condition)  (rows=1)
    -> Table scan on dt  (rows=1)
        -> Materialize  (rows=1)
            -> Table scan on t1  (rows=1)
    -> Hash
        -> Table scan on t2  (rows=1)

# Or to all:
explain select /*+ no_merge() */ *
from (select * from t1) as dt, (select * from t2) as dt2;
EXPLAIN
-> Inner hash join (no condition)  (rows=1)
    -> Table scan on dt2  (rows=1)
        -> Materialize  (rows=1)
            -> Table scan on t2  (rows=1)
    -> Hash
        -> Table scan on dt  (rows=1)
            -> Materialize  (rows=1)
                -> Table scan on t1  (rows=1)

# And be specified in outer blocks, with naming:
explain select /*+ no_merge(dt@qb1) merge(dt2@qb1) */ * from t1 where a =
(select /*+ qb_name(qb1) */ 3
from (select * from t1) as dt, (select * from t2) as dt2);
EXPLAIN
-> Filter: (t1.a = (select #2))  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Select #2 (subquery in condition; run only once)
        -> Inner hash join (no condition)  (rows=1)
            -> Table scan on dt  (rows=1)
                -> Materialize  (rows=1)
                    -> Table scan on t1  (rows=1)
            -> Hash
                -> Table scan on t2  (rows=1)

# with another syntax:
explain select /*+ no_merge(@qb1 dt) merge(@qb1 dt2) */ * from t1 where a =
(select /*+ qb_name(qb1) */ 3
from (select * from t1) as dt, (select * from t2) as dt2);
EXPLAIN
-> Filter: (t1.a = (select #2))  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Select #2 (subquery in condition; run only once)
        -> Inner hash join (no condition)  (rows=1)
            -> Table scan on dt  (rows=1)
                -> Materialize  (rows=1)
                    -> Table scan on t1  (rows=1)
            -> Hash
                -> Table scan on t2  (rows=1)

# A hint can list more than one table
explain select /*+ merge(dt2) no_merge(dt,dt3) */ *
from (select * from t1) as dt, (select * from t2) as dt2,
(select * from t3) as dt3;
EXPLAIN
-> Inner hash join (no condition)  (rows=1)
    -> Table scan on dt3  (rows=1)
        -> Materialize  (rows=1)
            -> Table scan on t3  (rows=1)
    -> Hash
        -> Inner hash join (no condition)  (rows=1)
            -> Table scan on dt  (rows=1)
                -> Materialize  (rows=1)
                    -> Table scan on t1  (rows=1)
            -> Hash
                -> Table scan on t2  (rows=1)

# Merge hint OVERRIDES heuristics, for example the one which
# materializes when user variables are set.
explain select * from
(
select * from t1
where (1,a,2) =  (
select @n:=@n+1, t2.a, sum(t2.b)
from (select @n:=1) as dt, t2
group by t2.a
)
) as dt2
;
EXPLAIN
-> Table scan on dt2  (rows=1)
    -> Materialize  (rows=1)
        -> Filter: ((1,t1.a,2) = (select #3))  (rows=1)
            -> Table scan on t1  (rows=1)
            -> Select #3 (subquery in condition; uncacheable)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t2  (rows=1)

Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
explain select /*+ merge(dt2) */ * from
(
select * from t1
where (1,a,2) =  (
select @n:=@n+1, t2.a, sum(t2.b)
from (select @n:=1) as dt, t2
group by t2.a
)
) as dt2
;
EXPLAIN
-> Filter: ((1,t1.a,2) = (select #3))  (rows=1)
    -> Table scan on t1  (rows=1)
    -> Select #3 (subquery in condition; uncacheable)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Table scan on t2  (rows=1)

Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
# ALGORITHM clause overrides heuristics too
create view v1 as select (select t1.a from t1 where t1.a=t2.a) from t2;
explain select * from v1;
EXPLAIN
-> Table scan on v1  (rows=1)
    -> Materialize  (rows=1)
        -> Table scan on t2  (rows=1)
        -> Select #3 (subquery in projection; dependent)
            -> Filter: (t1.a = t2.a)  (rows=1)
                -> Table scan on t1  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t2.a' of SELECT #3 was resolved in SELECT #2
drop view v1;
create algorithm=merge view v1 as select (select t1.a from t1 where t1.a=t2.a) from t2;
explain select * from v1;
EXPLAIN
-> Table scan on t2  (rows=1)
-> Select #3 (subquery in projection; dependent)
    -> Filter: (t1.a = t2.a)  (rows=1)
        -> Table scan on t1  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t2.a' of SELECT #3 was resolved in SELECT #2
drop view v1;
# Hint for index is useless and should be ignored
select /*+ no_mrr(dt idx1) */ * from (select 1 from t1 limit 1) dt;
1
Warnings:
Warning	3128	Unresolved name `dt`@`select#1` `idx1` for NO_MRR hint
select /*+ no_mrr(dt idx1) */ * from (select 1 from t1) dt;
1
Warnings:
Warning	3128	Unresolved name `dt`@`select#1` `idx1` for NO_MRR hint
# Hint for UPDATE
insert into t1 values(1),(2);
create view v1 as
select  * from t1 where a <> 0;
delete from t3;
insert into t3 values(1,1),(2,2);
explain update t3, v1 set t3.a=v1.a+10 where t3.a-v1.a=0;
EXPLAIN
-> Update t3 (buffered)
    -> Nested loop inner join  (rows=2)
        -> Filter: (t1.a <> 0)  (rows=1)
            -> Table scan on t1  (rows=2)
        -> Filter: ((t3.a - t1.a) = 0)  (rows=2)
            -> Table scan on t3  (rows=2)

update t3, v1 set t3.a=v1.a+10 where t3.a-v1.a=0;
select * from t3;
a	b
11	1
12	2
delete from t3;
insert into t3 values(1,1),(2,2);
explain update /*+ no_merge(v1) */ t3, v1 set t3.a=v1.a+10 where t3.a-v1.a=0;
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t3  (rows=2)
        -> Filter: ((t3.a - v1.a) = 0)  (rows=2)
            -> Table scan on v1  (rows=1)
                -> Materialize  (rows=1)
                    -> Filter: (t1.a <> 0)  (rows=1)
                        -> Table scan on t1  (rows=2)

update /*+ no_merge(v1) */ t3, v1 set t3.a=v1.a+10 where t3.a-v1.a=0;
select * from t3;
a	b
11	1
12	2
# Update v1
delete from t3;
insert into t3 values(1,1),(2,2);
delete from t1;
insert into t1 values(1),(2);
explain update t3, v1 set v1.a=t3.a+10 where t3.a-v1.a=0;
EXPLAIN
-> Update t1 (immediate)
    -> Nested loop inner join  (rows=2)
        -> Filter: (t1.a <> 0)  (rows=1)
            -> Table scan on t1  (rows=2)
        -> Filter: ((t3.a - t1.a) = 0)  (rows=2)
            -> Table scan on t3  (rows=2)

update t3, v1 set v1.a=t3.a+10 where t3.a-v1.a=0;
select * from t1;
a
11
12
delete from t1;
insert into t1 values(1),(2);
update /*+ no_merge(v1) */ t3, v1 set v1.a=t3.a+10 where t3.a-v1.a=0;
ERROR HY000: The target table v1 of the UPDATE is not updatable
select * from t1;
a
1
2
# A derived table in UPDATE
delete from t1;
insert into t1 values(1),(2);
delete from t3;
insert into t3 values(1,1),(2,2);
explain update t3, (select * from t1) dt set t3.a=dt.a+10 where t3.a-dt.a=0;
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t3  (rows=2)
        -> Filter: ((t3.a - t1.a) = 0)  (rows=2)
            -> Table scan on t1  (rows=2)

update t3, (select * from t1) dt set t3.a=dt.a+10 where t3.a-dt.a=0;
select * from t3;
a	b
11	1
12	2
delete from t3;
insert into t3 values(1,1),(2,2);
explain update /*+ no_merge(dt) */ t3, (select * from t1) dt set t3.a=dt.a+10 where t3.a-dt.a=0;
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t3  (rows=2)
        -> Filter: ((t3.a - dt.a) = 0)  (rows=2)
            -> Table scan on dt  (rows=2)
                -> Materialize  (rows=2)
                    -> Table scan on t1  (rows=2)

update /*+ no_merge(dt) */ t3, (select * from t1) dt set t3.a=dt.a+10 where t3.a-dt.a=0;
select * from t3;
a	b
11	1
12	2
# A derived table in first-level subquery of UPDATE, the update
# target not being in the derived table. Before the WL, the
# derived table would always be materialized; now it's only
# heuristic and can be overridden.
delete from t1;
insert into t1 values(1),(2);
delete from t3;
insert into t3 values(1,1),(2,2);
explain update t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t1 where a>1) dt);
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop semijoin (FirstMatch)  (rows=2)
        -> Filter: (t3.a is not null)  (rows=2)
            -> Table scan on t3  (rows=2)
        -> Covering index lookup on dt using <auto_key0> (a = t3.a)  (rows=2)
            -> Materialize  (rows=1)
                -> Filter: (t1.a > 1)  (rows=1)
                    -> Table scan on t1  (rows=2)

update t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t1 where a>1) dt);
select * from t3;
a	b
1	1
2	NULL
delete from t3;
insert into t3 values(1,1),(2,2);
explain update /*+ merge(dt@sub) */ t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t1 where a>1) dt);
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop semijoin (FirstMatch)  (rows=2)
        -> Filter: (t3.a > 1)  (rows=2)
            -> Table scan on t3  (rows=2)
        -> Filter: (t1.a = t3.a)  (rows=1)
            -> Table scan on t1  (rows=2)

update /*+ merge(dt@sub) */ t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t1 where a>1) dt);
select * from t3;
a	b
1	1
2	NULL
# A derived table in UPDATE, the update target being in the
# derived table.
delete from t3;
insert into t3 values(1,1),(2,2);
explain update t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t3 where b>1) dt);
EXPLAIN
-> Update t3 (immediate)
    -> Nested loop semijoin (FirstMatch)  (rows=2)
        -> Filter: (t3.a is not null)  (rows=2)
            -> Table scan on t3  (rows=2)
        -> Index lookup on dt using <auto_key0> (a = t3.a)  (rows=2)
            -> Materialize  (rows=1)
                -> Filter: (t3.b > 1)  (rows=1)
                    -> Table scan on t3  (rows=2)

update t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t3 where b>1) dt);
select * from t3;
a	b
1	1
2	NULL
delete from t3;
insert into t3 values(1,1),(2,2);
# The heuristic which materializes, intends to allow the query;
# if you disable it, the query cannot run:
update /*+ merge(dt@sub) */ t3 set b=NULL
where a in (select /*+ qb_name(sub) */ a
from (select * from t3 where b>1) dt);
ERROR HY000: You can't specify target table 't3' for update in FROM clause
select * from t3;
a	b
1	1
2	2
# DELETE.
delete from t3;
insert into t3 values(1,1),(2,2);
explain delete t3.* from t3, v1 where t3.a-v1.a=0;
EXPLAIN
-> Delete from t3 (buffered)  (rows=2)
    -> Nested loop inner join  (rows=2)
        -> Filter: (t1.a <> 0)  (rows=1)
            -> Table scan on t1  (rows=2)
        -> Filter: ((t3.a - t1.a) = 0)  (rows=2)
            -> Table scan on t3  (rows=2)

delete t3.* from t3, v1 where t3.a-v1.a=0;
select * from t3;
a	b
delete from t3;
insert into t3 values(1,1),(2,2);
explain delete /*+ no_merge(v1) */ t3.* from t3, v1 where t3.a-v1.a=0;
EXPLAIN
-> Delete from t3 (immediate)  (rows=4)
    -> Nested loop inner join  (rows=4)
        -> Table scan on t3  (rows=2)
        -> Filter: ((t3.a - v1.a) = 0)  (rows=2)
            -> Table scan on v1  (rows=1)
                -> Materialize  (rows=1)
                    -> Filter: (t1.a <> 0)  (rows=1)
                        -> Table scan on t1  (rows=2)

delete /*+ no_merge(v1) */ t3.* from t3, v1 where t3.a-v1.a=0;
select * from t3;
a	b
drop view v1;
drop table t1,t2,t3;
#
# Non-terminated comment test
#
PREPARE stmt FROM 'SELECT /*+ 10';
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '/*+ 10' at line 1
#
# Bug#34976138 records_in_range does too many disk reads
#
CREATE TABLE t (id int AUTO_INCREMENT, cid int NOT NULL, price float NOT NULL,
PRIMARY KEY (id), KEY key1 (price, cid));
INSERT INTO t(cid, price) values(1, 10), (2, 100), (3, 55), (4, 20), (5, 30),
(6, 27), (7, 217), (8, 927), (9, 207);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
SET SESSION OPTIMIZER_TRACE="enabled=on";
# Case without FORCE INDEX, this should do an index dive during query
# optimization.
EXPLAIN SELECT price, cid FROM t WHERE (price >= 10)
ORDER BY price, cid LIMIT 3;
EXPLAIN
-> Limit: 3 row(s)  (rows=3)
    -> Filter: (t.price >= 10)  (rows=3)
        -> Covering index scan on t using key1  (rows=3)

SELECT price, cid FROM t WHERE (price >= 10) ORDER BY price, cid LIMIT 3;
price	cid
10	1
20	4
27	6
SELECT REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n') FROM
INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n')
index_dives_for_eq_ranges": true
# Case with ORDER BY and FORCE INDEX, this should skip the index dive
# during query optimization.
EXPLAIN SELECT price, cid FROM t FORCE INDEX (key1) WHERE (price >= 10)
ORDER BY price, cid LIMIT 3;
EXPLAIN
-> Limit: 3 row(s)  (rows=1)
    -> Filter: (t.price >= 10)  (rows=1)
        -> Covering index range scan on t using key1 over (10 <= price)  (rows=1)

SELECT price, cid FROM t FORCE INDEX (key1) WHERE (price >= 10)
ORDER BY price, cid LIMIT 3;
price	cid
10	1
20	4
27	6
SELECT REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n') FROM
INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n')
index_dives_for_range_access": "skipped_due_to_force_index"
# Case with DESC ORDER BY and FORCE INDEX, this should skip index dive
# during query optimization.
EXPLAIN SELECT price, cid FROM t FORCE INDEX (key1) WHERE (price >= 10)
ORDER BY price DESC, cid DESC LIMIT 3;
EXPLAIN
-> Limit: 3 row(s)  (rows=1)
    -> Filter: (t.price >= 10)  (rows=1)
        -> Covering index range scan on t using key1 over (10 <= price) (reverse)  (rows=1)

SELECT price, cid FROM t FORCE INDEX (key1) WHERE (price >= 200)
ORDER BY price DESC, cid DESC LIMIT 3;
price	cid
927	8
217	7
207	9
SELECT REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n') FROM
INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n')
index_dives_for_range_access": "skipped_due_to_force_index"
# Case where FORCE INDEX can't provide order. This should not skip
# Index dives.
SELECT price, cid FROM t FORCE INDEX(key1) WHERE price >= 20 ORDER BY cid;
price	cid
100	2
55	3
20	4
30	5
27	6
217	7
927	8
207	9
SELECT REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n') FROM
INFORMATION_SCHEMA.OPTIMIZER_TRACE;
REGEXP_SUBSTR(trace, 'index_dive[^,]*',1,1,'n')
index_dives_for_eq_ranges": true
SET SESSION OPTIMIZER_TRACE="enabled=off";
DROP TABLE t;
# Statement modifiers for SELECT which affect temporary table creation
CREATE TABLE t1 (
f1 int unsigned NOT NULL auto_increment primary key,
f2 varchar(100) NOT NULL default ''
);
CREATE TABLE t2 (
f1 varchar(10) NOT NULL default '',
f2 char(3) NOT NULL default '',
PRIMARY KEY  (`f1`),
KEY `k1` (`f2`,`f1`)
);
INSERT INTO t1 values(NULL, '');
INSERT INTO t2 VALUES ('486878','WDT'),('486910','WDT');
EXPLAIN FORMAT=TREE SELECT avg(t2.f1) FROM t1, t2 where t2.f2 = 'SIR' GROUP BY t1.f1;
EXPLAIN
-> Group aggregate: avg(t2.f1)  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Covering index scan on t1 using PRIMARY  (rows=1)
        -> Filter: (t2.f2 = 'SIR')  (rows=1)
            -> Covering index lookup on t2 using k1 (f2 = 'SIR')  (rows=1)

# SELECT SQL_BUFFER_RESULT should use temporary table
EXPLAIN FORMAT=TREE SELECT SQL_BUFFER_RESULT avg(t2.f1) FROM t1, t2 where t2.f2 = 'SIR' GROUP BY t1.f1;
EXPLAIN
-> Table scan on <temporary>  (rows=1)
    -> Temporary table  (rows=1)
        -> Group aggregate: avg(t2.f1)  (rows=1)
            -> Nested loop inner join  (rows=1)
                -> Covering index scan on t1 using PRIMARY  (rows=1)
                -> Filter: (t2.f2 = 'SIR')  (rows=1)
                    -> Covering index lookup on t2 using k1 (f2 = 'SIR')  (rows=1)

# SELECT SQL_BIG_RESULT should not use temporary table
EXPLAIN FORMAT=TREE SELECT SQL_BIG_RESULT avg(t2.f1) FROM t1, t2 where t2.f2 = 'SIR' GROUP BY t1.f1;
EXPLAIN
-> Group aggregate: avg(t2.f1)  (rows=1)
    -> Nested loop inner join  (rows=1)
        -> Sort: t1.f1  (rows=1)
            -> Covering index scan on t1 using PRIMARY  (rows=1)
        -> Filter: (t2.f2 = 'SIR')  (rows=1)
            -> Covering index lookup on t2 using k1 (f2 = 'SIR')  (rows=1)

DROP TABLE t1, t2;
