#
# Table scan, subquery, aggregates
CREATE TABLE t1 ( f1 INT PRIMARY KEY );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE f1 = ( SELECT MIN(f1) FROM t1 AS i WHERE i.f1 > t1.f1 );
EXPLAIN
-> Filter: (t1.f1 = (select #2))  (cost=2.5..2.5 rows=1)
    -> Table scan on t1  (cost=0.0833..0.25 rows=3)
    -> Select #2 (subquery in condition; dependent)
        -> Aggregate: min(i.f1)  (cost=0.65..0.65 rows=1)
            -> Filter: (i.f1 > t1.f1)  (cost=0.55..0.55 rows=1)
                -> Table scan on i  (cost=0.0833..0.25 rows=3)

Warnings:
Note	1276	Field or reference 'test.t1.f1' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=JSON SELECT * FROM t1 WHERE f1 = ( SELECT MIN(f1) FROM t1 AS i WHERE i.f1 > t1.f1 );
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`f1` AS `f1` from `test`.`t1` where (`test`.`t1`.`f1` = (/* select#2 */ select min(`i`.`f1`) from `test`.`t1` `i` where (`i`.`f1` > `test`.`t1`.`f1`)))",
  "inputs": [
    {
      "operation": "Table scan on t1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "f1"
      ],
      "estimated_rows": 3.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.08333333333333333
    },
    {
      "inputs": [
        {
          "inputs": [
            {
              "alias": "i",
              "operation": "Table scan on i",
              "table_name": "t1",
              "access_type": "table",
              "schema_name": "test",
              "used_columns": [
                "f1"
              ],
              "estimated_rows": 3.0,
              "estimated_total_cost": 0.25,
              "estimated_first_row_cost": 0.08333333333333333
            }
          ],
          "condition": "(i.f1 > t1.f1)",
          "operation": "Filter: (i.f1 > t1.f1)",
          "access_type": "filter",
          "estimated_rows": 0.9998999834060669,
          "estimated_total_cost": 0.55,
          "estimated_first_row_cost": 0.55
        }
      ],
      "heading": "Select #2 (subquery in condition; dependent)",
      "subquery": true,
      "dependent": true,
      "functions": [
        "min(i.f1)"
      ],
      "operation": "Aggregate: min(i.f1)",
      "access_type": "aggregate",
      "estimated_rows": 1.0,
      "subquery_location": "condition",
      "estimated_total_cost": 0.6499899983406068,
      "estimated_first_row_cost": 0.6499899983406068
    }
  ],
  "condition": "(t1.f1 = (select #2))",
  "operation": "Filter: (t1.f1 = (select #2))",
  "query_type": "select",
  "access_type": "filter",
  "estimated_rows": 1.0,
  "estimated_total_cost": 2.4999699950218206,
  "estimated_first_row_cost": 2.4999699950218206
}
Warnings:
Note	1276	Field or reference 'test.t1.f1' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=TREE SELECT * FROM t1 WHERE f1 > ( SELECT f1 FROM t1 LIMIT 1 );
EXPLAIN
-> Filter: (t1.f1 > (select #2))  (cost=0.633..0.633 rows=1)
    -> Table scan on t1  (cost=0.0833..0.25 rows=3)
    -> Select #2 (subquery in condition; run only once)
        -> Limit: 1 row(s)  (cost=0.0833..0.0833 rows=1)
            -> Table scan on t1  (cost=0.0833..0.25 rows=3)

EXPLAIN FORMAT=JSON SELECT * FROM t1 WHERE f1 > ( SELECT f1 FROM t1 LIMIT 1 );
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`f1` AS `f1` from `test`.`t1` where (`test`.`t1`.`f1` > (/* select#2 */ select `test`.`t1`.`f1` from `test`.`t1` limit 1))",
  "inputs": [
    {
      "operation": "Table scan on t1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "f1"
      ],
      "estimated_rows": 3.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.08333333333333333
    },
    {
      "limit": 1,
      "inputs": [
        {
          "operation": "Table scan on t1",
          "table_name": "t1",
          "access_type": "table",
          "schema_name": "test",
          "used_columns": [
            "f1"
          ],
          "estimated_rows": 3.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.08333333333333333
        }
      ],
      "heading": "Select #2 (subquery in condition; run only once)",
      "subquery": true,
      "cacheable": true,
      "operation": "Limit: 1 row(s)",
      "access_type": "limit",
      "limit_offset": 0,
      "estimated_rows": 1.0,
      "subquery_location": "condition",
      "estimated_total_cost": 0.08333333333333333,
      "estimated_first_row_cost": 0.08333333333333333
    }
  ],
  "condition": "(t1.f1 > (select #2))",
  "operation": "Filter: (t1.f1 > (select #2))",
  "query_type": "select",
  "access_type": "filter",
  "estimated_rows": 0.9998999834060669,
  "estimated_total_cost": 0.6333333333333333,
  "estimated_first_row_cost": 0.6333333333333333
}
drop table t1;
#
# Index range scan
create table t1 ( a int, b int, c int, d int, primary key(a,b));
insert into t1 values
(1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4),
(1,2,5,1), (1,3,1,2), (1,4,2,3),
(2,1,3,4), (2,3,4,5), (2,4,5,1),
(3,1,1,2), (3,2,2,3), (3,4,3,4),
(4,1,4,5), (4,2,5,1), (4,3,1,2);
explain format=TREE select * from t1 where a > 2;
EXPLAIN
-> Index range scan on t1 using PRIMARY over (2 < a)  (cost=0.133..1.06 rows=8)

explain format=JSON select * from t1 where a > 2;
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`c` AS `c`,`test`.`t1`.`d` AS `d` from `test`.`t1` where (`test`.`t1`.`a` > 2)",
  "ranges": [
    "(2 < a)"
  ],
  "covering": false,
  "operation": "Index range scan on t1 using PRIMARY over (2 < a)",
  "index_name": "PRIMARY",
  "query_type": "select",
  "table_name": "t1",
  "access_type": "index",
  "schema_name": "test",
  "used_columns": [
    "a",
    "b",
    "c",
    "d"
  ],
  "estimated_rows": 8.0,
  "index_access_type": "index_range_scan",
  "estimated_total_cost": 1.0621367521367522,
  "estimated_first_row_cost": 0.13276709401709402
}
drop table t1;
# Index lookup. Nested loop join
set @old_opt_switch=@@optimizer_switch;
set optimizer_switch='firstmatch=off,materialization=off,duplicateweedout=off,loosescan=on';
CREATE TABLE t1 ( i INTEGER, PRIMARY KEY (i) );
CREATE TABLE t2 ( i INTEGER, INDEX i1 (i) );
INSERT INTO t1 VALUES (2), (3), (4), (5);
INSERT INTO t2 VALUES (1), (2), (3), (4);
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN format=TREE SELECT * FROM t1 WHERE t1.i IN (SELECT t2.i FROM t2);
EXPLAIN
-> Nested loop inner join  (cost=0.576..1.15 rows=2)
    -> Remove duplicates from input grouped on t2.i  (cost=0.326..0.651 rows=2)
        -> Covering index scan on t2 using i1  (cost=0.0628..0.251 rows=4)
    -> Single-row covering index lookup on t1 using PRIMARY (i=t2.i)  (cost=0.25..0.25 rows=1)

EXPLAIN format=JSON SELECT * FROM t1 WHERE t1.i IN (SELECT t2.i FROM t2);
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`i` AS `i` from `test`.`t1` semi join (`test`.`t2`) where multiple equal(`test`.`t1`.`i`, `test`.`t2`.`i`)",
  "inputs": [
    {
      "inputs": [
        {
          "covering": true,
          "operation": "Covering index scan on t2 using i1",
          "index_name": "i1",
          "table_name": "t2",
          "access_type": "index",
          "schema_name": "test",
          "used_columns": [
            "i"
          ],
          "estimated_rows": 4.0,
          "index_access_type": "index_scan",
          "estimated_total_cost": 0.25100671140939596,
          "estimated_first_row_cost": 0.06275167785234899
        }
      ],
      "operation": "Remove duplicates from input grouped on t2.i",
      "access_type": "remove_duplicates_from_groups",
      "group_items": [
        "t2.i"
      ],
      "estimated_rows": 2.0,
      "estimated_total_cost": 0.651006711409396,
      "estimated_first_row_cost": 0.325503355704698
    },
    {
      "covering": true,
      "operation": "Single-row covering index lookup on t1 using PRIMARY (i=t2.i)",
      "index_name": "PRIMARY",
      "table_name": "t1",
      "access_type": "index",
      "schema_name": "test",
      "used_columns": [
        "i"
      ],
      "estimated_rows": 1.0,
      "lookup_condition": "i=t2.i",
      "index_access_type": "index_lookup",
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    }
  ],
  "join_type": "inner join",
  "operation": "Nested loop inner join",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 2.0,
  "join_algorithm": "nested_loop",
  "estimated_total_cost": 1.151006711409396,
  "estimated_first_row_cost": 0.575503355704698
}
DROP TABLE t1,t2;
set optimizer_switch=@old_opt_switch;
# Index lookup. Nested loop join. Filter.
CREATE TABLE t1 (col_int INT, pk INT) ENGINE=InnoDB STATS_PERSISTENT=0;
INSERT INTO t1 VALUES (-100,1),(1,6);
CREATE TABLE t2 (
col_int_key INT,
col_varchar VARCHAR(100) NOT NULL DEFAULT "DEFAULT",
pk INT NOT NULL,
PRIMARY KEY (pk),
KEY (col_int_key)
) ENGINE=InnoDB STATS_PERSISTENT=0;
INSERT INTO t2 VALUES
(1,"GOOD",1),(100,"",2),(200,"",3),(300,"",4),(400,"",5),(500,"",8);
EXPLAIN FORMAT=TREE SELECT t1.*,t2.* FROM t1 straight_join t2
ON t2.col_int_key = t1.col_int WHERE t2.pk < t1.pk;
EXPLAIN
-> Nested loop inner join  (cost=0.95..0.95 rows=0.667)
    -> Table scan on t1  (cost=0.125..0.25 rows=2)
    -> Filter: (t2.pk < t1.pk)  (cost=0.35..0.35 rows=0.333)
        -> Index lookup on t2 using col_int_key (col_int_key=t1.col_int)  (cost=0.25..0.25 rows=1)

EXPLAIN FORMAT=JSON SELECT t1.*,t2.* FROM t1 straight_join t2
ON t2.col_int_key = t1.col_int WHERE t2.pk < t1.pk;
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`col_int` AS `col_int`,`test`.`t1`.`pk` AS `pk`,`test`.`t2`.`col_int_key` AS `col_int_key`,`test`.`t2`.`col_varchar` AS `col_varchar`,`test`.`t2`.`pk` AS `pk` from `test`.`t1` straight_join `test`.`t2` where ((`test`.`t2`.`pk` < `test`.`t1`.`pk`) and (`test`.`t2`.`col_int_key` = `test`.`t1`.`col_int`))",
  "inputs": [
    {
      "operation": "Table scan on t1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "col_int",
        "pk"
      ],
      "estimated_rows": 2.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.125
    },
    {
      "inputs": [
        {
          "covering": false,
          "operation": "Index lookup on t2 using col_int_key (col_int_key=t1.col_int)",
          "index_name": "col_int_key",
          "table_name": "t2",
          "access_type": "index",
          "schema_name": "test",
          "used_columns": [
            "col_int_key",
            "col_varchar",
            "pk"
          ],
          "estimated_rows": 1.0,
          "lookup_condition": "col_int_key=t1.col_int",
          "index_access_type": "index_lookup",
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.25
        }
      ],
      "condition": "(t2.pk < t1.pk)",
      "operation": "Filter: (t2.pk < t1.pk)",
      "access_type": "filter",
      "estimated_rows": 0.33329999446868896,
      "estimated_total_cost": 0.35,
      "estimated_first_row_cost": 0.35
    }
  ],
  "join_type": "inner join",
  "operation": "Nested loop inner join",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 0.6665999889373779,
  "join_algorithm": "nested_loop",
  "estimated_total_cost": 0.95,
  "estimated_first_row_cost": 0.95
}
DROP TABLE t1,t2;
# Group aggregates, hash join, sort.
CREATE TABLE t1 (
pk int NOT NULL AUTO_INCREMENT,
col_varchar varchar(1),
col_varchar_key varchar(1),
PRIMARY KEY (pk),
KEY idx_CC_col_varchar_key (col_varchar_key)
);
INSERT INTO t1 VALUES (1,'n','X'),(2,'Y','8'),(3,'R','l');
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT
t1.col_varchar_key AS field1 FROM (t1, t1 as alias1)
WHERE NOT EXISTS( SELECT alias2.col_varchar_key FROM t1 AS alias2
WHERE alias2.col_varchar_key >= t1.col_varchar)
GROUP BY field1;
EXPLAIN
-> Group (no aggregates)  (cost=1.93..2.27 rows=1.95)
    -> Nested loop inner join  (cost=1.65..1.89 rows=3.8)
        -> Sort: t1.col_varchar_key  (cost=1.57..1.57 rows=1.27)
            -> Hash antijoin (no condition), extra conditions: (alias2.col_varchar_key >= t1.col_varchar)  (cost=1.15..1.32 rows=1.27)
                -> Table scan on t1  (cost=0.0833..0.25 rows=3)
                -> Hash
                    -> Table scan on alias2  (cost=0.0833..0.25 rows=3)
        -> Table scan on alias1  (cost=0.0833..0.25 rows=3)

Warnings:
Note	1276	Field or reference 'test.t1.col_varchar' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=JSON SELECT
t1.col_varchar_key AS field1 FROM (t1, t1 as alias1)
WHERE NOT EXISTS( SELECT alias2.col_varchar_key FROM t1 AS alias2
WHERE alias2.col_varchar_key >= t1.col_varchar)
GROUP BY field1;
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`col_varchar_key` AS `field1` from `test`.`t1` join `test`.`t1` `alias1` anti join (`test`.`t1` `alias2`) on(((`alias2`.`col_varchar_key` >= `test`.`t1`.`col_varchar`))) where true group by `field1`",
  "inputs": [
    {
      "inputs": [
        {
          "inputs": [
            {
              "inputs": [
                {
                  "operation": "Table scan on t1",
                  "table_name": "t1",
                  "access_type": "table",
                  "schema_name": "test",
                  "used_columns": [
                    "col_varchar",
                    "col_varchar_key"
                  ],
                  "estimated_rows": 3.0,
                  "estimated_total_cost": 0.25,
                  "estimated_first_row_cost": 0.08333333333333333
                },
                {
                  "alias": "alias2",
                  "heading": "Hash",
                  "operation": "Table scan on alias2",
                  "table_name": "t1",
                  "access_type": "table",
                  "schema_name": "test",
                  "used_columns": [
                    "col_varchar_key"
                  ],
                  "estimated_rows": 3.0,
                  "estimated_total_cost": 0.25,
                  "estimated_first_row_cost": 0.08333333333333333
                }
              ],
              "join_type": "antijoin",
              "operation": "Hash antijoin (no condition), extra conditions: (alias2.col_varchar_key >= t1.col_varchar)",
              "access_type": "join",
              "estimated_rows": 1.2681224262534148,
              "hash_condition": [],
              "join_algorithm": "hash",
              "extra_condition": [
                "(alias2.col_varchar_key >= t1.col_varchar)"
              ],
              "estimated_total_cost": 1.3155808124630806,
              "estimated_first_row_cost": 1.1537120680255923
            }
          ],
          "operation": "Sort: t1.col_varchar_key",
          "access_type": "sort",
          "sort_fields": [
            "t1.col_varchar_key"
          ],
          "estimated_rows": 1.2681224262534148,
          "estimated_total_cost": 1.5692052977137636,
          "estimated_first_row_cost": 1.5692052977137636
        },
        {
          "alias": "alias1",
          "operation": "Table scan on alias1",
          "table_name": "t1",
          "access_type": "table",
          "schema_name": "test",
          "estimated_rows": 3.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.08333333333333333
        }
      ],
      "join_type": "inner join",
      "operation": "Nested loop inner join",
      "access_type": "join",
      "estimated_rows": 3.8043672787602443,
      "join_algorithm": "nested_loop",
      "estimated_total_cost": 1.8862359042771173,
      "estimated_first_row_cost": 1.6525386310470969
    }
  ],
  "group_by": true,
  "functions": [],
  "operation": "Group (no aggregates)",
  "query_type": "select",
  "access_type": "aggregate",
  "estimated_rows": 1.9504787306608202,
  "estimated_total_cost": 2.2666726321531416,
  "estimated_first_row_cost": 1.9267930650015805
}
Warnings:
Note	1276	Field or reference 'test.t1.col_varchar' of SELECT #2 was resolved in SELECT #1
drop table t1;
# Information Schema
explain format=TREE select * from information_schema.engines e WHERE e.ENGINE="MyISAM";
EXPLAIN
-> Filter: (e.`ENGINE` = 'MyISAM')  (cost=16..115 rows=100)
    -> Table scan on e  (cost=0.015..15 rows=1000)
        -> Fill information schema table e  (cost=0.015..15 rows=1000)

explain format=JSON select * from information_schema.engines e WHERE e.ENGINE="MyISAM";
EXPLAIN
{
  "query": "/* select#1 */ select `e`.`ENGINE` AS `ENGINE`,`e`.`SUPPORT` AS `SUPPORT`,`e`.`COMMENT` AS `COMMENT`,`e`.`TRANSACTIONS` AS `TRANSACTIONS`,`e`.`XA` AS `XA`,`e`.`SAVEPOINTS` AS `SAVEPOINTS` from `information_schema`.`ENGINES` `e` where (`e`.`ENGINE` = 'MyISAM')",
  "inputs": [
    {
      "inputs": [
        {
          "operation": "Fill information schema table e",
          "table_name": "e",
          "access_type": "materialize_information_schema",
          "used_columns": [
            "ENGINE",
            "SUPPORT",
            "COMMENT",
            "TRANSACTIONS",
            "XA",
            "SAVEPOINTS"
          ],
          "estimated_rows": 1000.0,
          "estimated_total_cost": 15.0,
          "estimated_first_row_cost": 0.015
        }
      ],
      "operation": "Table scan on e",
      "table_name": "e",
      "access_type": "table",
      "used_columns": [
        "ENGINE",
        "SUPPORT",
        "COMMENT",
        "TRANSACTIONS",
        "XA",
        "SAVEPOINTS"
      ],
      "estimated_rows": 1000.0,
      "estimated_total_cost": 15.0,
      "estimated_first_row_cost": 0.015
    }
  ],
  "condition": "(e.`ENGINE` = 'MyISAM')",
  "operation": "Filter: (e.`ENGINE` = 'MyISAM')",
  "query_type": "select",
  "access_type": "filter",
  "estimated_rows": 100.00000149011612,
  "estimated_total_cost": 115.0,
  "estimated_first_row_cost": 15.999999985098839
}
# Materialize, window aggregates, Stream
CREATE TABLE t0 (i0 INTEGER);
INSERT INTO t0 VALUES (0),(1),(2),(3),(4);
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER, f3 INTEGER,
KEY(f1), KEY(f1,f2), KEY(f3));
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1
SELECT i0, i0 + 10*i0,
i0 + 10*i0 + 100*i0
FROM t0 AS a0;
INSERT INTO t1 VALUES (NULL, 1, 2);
INSERT INTO t1 VALUES (NULL, 1, 3);
ANALYZE TABLE t0, t1;
Table	Op	Msg_type	Msg_text
test.t0	analyze	status	OK
test.t1	analyze	status	OK
set sql_mode="";
EXPLAIN FORMAT=TREE SELECT * FROM
(SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
EXPLAIN
-> Filter: (dt.f1 > 2)  (cost=4.56..4.56 rows=0.816)
    -> Table scan on dt  (cost=2.68..4.31 rows=2.45)
        -> Materialize  (cost=1.79..1.79 rows=2.45)
            -> Window aggregate with buffering: sum(t1.f2) OVER ()   (cost=0.631..1.54 rows=2.45)
                -> Stream results  (cost=0.531..1.3 rows=2.45)
                    -> Covering index skip scan for deduplication on t1 using f1_2  (cost=0.531..1.3 rows=2.45)

EXPLAIN FORMAT=JSON SELECT * FROM
(SELECT f1, SUM(f2) OVER() FROM t1 GROUP BY f1) as dt
WHERE f1 > 2;
EXPLAIN
{
  "query": "/* select#1 */ select `dt`.`f1` AS `f1`,`dt`.`SUM(f2) OVER()` AS `SUM(f2) OVER()` from (/* select#2 */ select `test`.`t1`.`f1` AS `f1`,sum(`test`.`t1`.`f2`) OVER ()  AS `SUM(f2) OVER()` from `test`.`t1` group by `test`.`t1`.`f1`) `dt` where (`dt`.`f1` > 2)",
  "inputs": [
    {
      "inputs": [
        {
          "inputs": [
            {
              "inputs": [
                {
                  "inputs": [
                    {
                      "ranges": [],
                      "covering": true,
                      "operation": "Covering index skip scan for deduplication on t1 using f1_2",
                      "index_name": "f1_2",
                      "table_name": "t1",
                      "access_type": "index",
                      "schema_name": "test",
                      "used_columns": [
                        "f1",
                        "f2"
                      ],
                      "estimated_rows": 2.449489742783178,
                      "index_access_type": "group_index_skip_scan",
                      "estimated_total_cost": 1.3000000000000003,
                      "estimated_first_row_cost": 0.5307227776030221
                    }
                  ],
                  "operation": "Stream results",
                  "access_type": "stream",
                  "estimated_rows": 2.449489742783178,
                  "estimated_total_cost": 1.3000000000000003,
                  "estimated_first_row_cost": 0.5307227776030221
                }
              ],
              "buffering": true,
              "functions": [
                "sum(t1.f2) OVER () "
              ],
              "operation": "Window aggregate with buffering: sum(t1.f2) OVER () ",
              "access_type": "window",
              "estimated_rows": 2.449489742783178,
              "estimated_total_cost": 1.544948974278318,
              "estimated_first_row_cost": 0.6307227776030221
            }
          ],
          "operation": "Materialize",
          "access_type": "materialize",
          "estimated_rows": 2.449489742783178,
          "estimated_total_cost": 1.7898979485566358,
          "estimated_first_row_cost": 1.7898979485566358
        }
      ],
      "operation": "Table scan on dt",
      "table_name": "dt",
      "access_type": "table",
      "used_columns": [
        "f1",
        "SUM(f2) OVER()"
      ],
      "estimated_rows": 2.449489742783178,
      "estimated_total_cost": 4.314897948556635,
      "estimated_first_row_cost": 2.675775907699572
    }
  ],
  "condition": "(dt.f1 > 2)",
  "operation": "Filter: (dt.f1 > 2)",
  "query_type": "select",
  "access_type": "filter",
  "estimated_rows": 0.8164149177207436,
  "estimated_total_cost": 4.559846922834953,
  "estimated_first_row_cost": 4.559846922834953
}
# Filter, nested loop
EXPLAIN FORMAT=TREE SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
EXPLAIN
-> Nested loop inner join  (cost=1.72..1.91 rows=1.11)
    -> Filter: (t1.f2 < 50)  (cost=1.16..1.16 rows=0.667)
        -> Index range scan on t1 using f1 over (3 < f1)  (cost=0.48..0.96 rows=2)
    -> Filter: (t0.i0 > 3)  (cost=0.45..0.75 rows=1.67)
        -> Table scan on t0  (cost=0.05..0.25 rows=5)

EXPLAIN FORMAT=JSON SELECT /*+ JOIN_ORDER(t0, dt) */ * FROM
(SELECT f1, f2, f3 FROM t1) as dt, t0
WHERE f1 > 3 and f2 < 50 and i0 > 3;
EXPLAIN
{
  "query": "/* select#1 */ select /*+ JOIN_ORDER(@`select#1` `t0`,`dt`) */ `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2`,`test`.`t1`.`f3` AS `f3`,`test`.`t0`.`i0` AS `i0` from `test`.`t1` join `test`.`t0` where ((`test`.`t1`.`f1` > 3) and (`test`.`t1`.`f2` < 50) and (`test`.`t0`.`i0` > 3))",
  "inputs": [
    {
      "inputs": [
        {
          "ranges": [
            "(3 < f1)"
          ],
          "covering": false,
          "operation": "Index range scan on t1 using f1 over (3 < f1)",
          "index_name": "f1",
          "table_name": "t1",
          "access_type": "index",
          "schema_name": "test",
          "used_columns": [
            "f1",
            "f2",
            "f3"
          ],
          "estimated_rows": 2.0,
          "index_access_type": "index_range_scan",
          "estimated_total_cost": 0.96,
          "estimated_first_row_cost": 0.48
        }
      ],
      "condition": "(t1.f2 < 50)",
      "operation": "Filter: (t1.f2 < 50)",
      "access_type": "filter",
      "estimated_rows": 0.6665999889373779,
      "estimated_total_cost": 1.16,
      "estimated_first_row_cost": 1.16
    },
    {
      "inputs": [
        {
          "operation": "Table scan on t0",
          "table_name": "t0",
          "access_type": "table",
          "schema_name": "test",
          "used_columns": [
            "i0"
          ],
          "estimated_rows": 5.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.05
        }
      ],
      "condition": "(t0.i0 > 3)",
      "operation": "Filter: (t0.i0 > 3)",
      "access_type": "filter",
      "estimated_rows": 1.6664999723434448,
      "estimated_total_cost": 0.75,
      "estimated_first_row_cost": 0.45004501196921376
    }
  ],
  "join_type": "inner join",
  "operation": "Nested loop inner join",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 1.110888863128281,
  "join_algorithm": "nested_loop",
  "estimated_total_cost": 1.91,
  "estimated_first_row_cost": 1.7193439086439386
}
drop table t0, t1;
# Explain analyze; Temporary table.
CREATE TABLE t1 (a INT NOT NULL, b CHAR(3) NOT NULL, PRIMARY KEY (a));
INSERT INTO t1 VALUES (1,'ABC'), (2,'EFG'), (3,'HIJ');
CREATE TABLE t2 (a INT NOT NULL,b CHAR(3) NOT NULL,PRIMARY KEY (a, b));
INSERT INTO t2 VALUES (1,'a'),(1,'b'),(3,'F');
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN analyze FORMAT=TREE SELECT t1.a, GROUP_CONCAT(t2.b) AS b FROM t1 LEFT JOIN t2 ON t1.a=t2.a GROUP BY t1.a ORDER BY t1.b;
EXPLAIN
-> Sort: t1.b  (cost=2.32..2.32 rows=1.73) (actual rows=3 loops=1)
    -> Table scan on <temporary>  (cost=2.92..3.99 rows=1.73) (actual rows=3 loops=1)
        -> Temporary table  (cost=1.47..1.47 rows=1.73) (actual rows=3 loops=1)
            -> Group aggregate: group_concat(t2.b separator ',')  (cost=0.751..1.3 rows=1.73) (actual rows=3 loops=1)
                -> Nested loop left join  (cost=0.333..1 rows=3) (actual rows=4 loops=1)
                    -> Index scan on t1 using PRIMARY  (cost=0.0834..0.25 rows=3) (actual rows=3 loops=1)
                    -> Covering index lookup on t2 using PRIMARY (a=t1.a)  (cost=0.25..0.25 rows=1) (actual rows=1 loops=3)

EXPLAIN FORMAT=JSON SELECT t1.a, GROUP_CONCAT(t2.b) AS b FROM t1 LEFT JOIN t2 ON t1.a=t2.a GROUP BY t1.a ORDER BY t1.b;
EXPLAIN
{
  "query": "/* select#1 */ select `test`.`t1`.`a` AS `a`,group_concat(`test`.`t2`.`b` separator ',') AS `b` from `test`.`t1` left join `test`.`t2` on(multiple equal(`test`.`t1`.`a`, `test`.`t2`.`a`)) group by `test`.`t1`.`a` order by `test`.`t1`.`b`",
  "inputs": [
    {
      "inputs": [
        {
          "inputs": [
            {
              "inputs": [
                {
                  "inputs": [
                    {
                      "covering": false,
                      "operation": "Index scan on t1 using PRIMARY",
                      "index_name": "PRIMARY",
                      "table_name": "t1",
                      "access_type": "index",
                      "schema_name": "test",
                      "used_columns": [
                        "a",
                        "b"
                      ],
                      "estimated_rows": 3.0,
                      "index_access_type": "index_scan",
                      "estimated_total_cost": 0.25025,
                      "estimated_first_row_cost": 0.08341666666666665
                    },
                    {
                      "covering": true,
                      "operation": "Covering index lookup on t2 using PRIMARY (a=t1.a)",
                      "index_name": "PRIMARY",
                      "table_name": "t2",
                      "access_type": "index",
                      "schema_name": "test",
                      "used_columns": [
                        "a",
                        "b"
                      ],
                      "estimated_rows": 1.0,
                      "lookup_condition": "a=t1.a",
                      "index_access_type": "index_lookup",
                      "estimated_total_cost": 0.25,
                      "estimated_first_row_cost": 0.25
                    }
                  ],
                  "join_type": "left join",
                  "operation": "Nested loop left join",
                  "access_type": "join",
                  "estimated_rows": 3.0,
                  "join_algorithm": "nested_loop",
                  "estimated_total_cost": 1.0002499999999999,
                  "estimated_first_row_cost": 0.33341666666666664
                }
              ],
              "group_by": true,
              "functions": [
                "group_concat(t2.b separator ',')"
              ],
              "operation": "Group aggregate: group_concat(t2.b separator ',')",
              "access_type": "aggregate",
              "estimated_rows": 1.7320508075688772,
              "estimated_total_cost": 1.30025,
              "estimated_first_row_cost": 0.7506996875138109
            }
          ],
          "operation": "Temporary table",
          "temp_table": true,
          "access_type": "materialize",
          "estimated_rows": 1.7320508075688772,
          "estimated_total_cost": 1.4734550807568876,
          "estimated_first_row_cost": 1.4734550807568876
        }
      ],
      "operation": "Table scan on <temporary>",
      "table_name": "<temporary>",
      "access_type": "table",
      "estimated_rows": 1.7320508075688772,
      "estimated_total_cost": 3.985955080756888,
      "estimated_first_row_cost": 2.9240476320958226
    }
  ],
  "operation": "Sort: t1.b",
  "query_type": "select",
  "access_type": "sort",
  "sort_fields": [
    "t1.b"
  ],
  "estimated_rows": 1.7320508075688772,
  "estimated_total_cost": 2.319865242270663,
  "estimated_first_row_cost": 2.319865242270663
}
drop table t1;
drop table t2;
# Zero rows.
CREATE TABLE t1 (a INTEGER NOT NULL);
INSERT INTO t1 VALUES (1),(2),(3),(4);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT * FROM t1 AS a LEFT JOIN t1 AS b ON FALSE
LEFT JOIN t1 AS c ON b.a=c.a;
EXPLAIN
-> Nested loop left join  (cost=0.0625..0.25 rows=4)
    -> Table scan on a  (cost=0.0625..0.25 rows=4)
    -> Zero rows (Join condition rejects all rows)  (cost=0..0 rows=0)

EXPLAIN FORMAT=JSON SELECT * FROM t1 AS a LEFT JOIN t1 AS b ON FALSE
LEFT JOIN t1 AS c ON b.a=c.a;
EXPLAIN
{
  "query": "/* select#1 */ select `a`.`a` AS `a`,`b`.`a` AS `a`,`c`.`a` AS `a` from `test`.`t1` `a` left join `test`.`t1` `b` on(false) left join `test`.`t1` `c` on(multiple equal(`b`.`a`, `c`.`a`))",
  "inputs": [
    {
      "alias": "a",
      "operation": "Table scan on a",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "a"
      ],
      "estimated_rows": 4.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.0625
    },
    {
      "operation": "Zero rows (Join condition rejects all rows)",
      "access_type": "zero_rows",
      "estimated_rows": 0.0,
      "zero_rows_cause": "Join condition rejects all rows",
      "estimated_total_cost": 0.0,
      "estimated_first_row_cost": 0.0
    }
  ],
  "join_type": "left join",
  "operation": "Nested loop left join",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 4.0,
  "join_algorithm": "nested_loop",
  "estimated_total_cost": 0.25,
  "estimated_first_row_cost": 0.0625
}
DROP TABLE t1;
#
# Bug#35382014: Mysqld crash: Assertion `item_name.is_set()' failed
#               in sql/item.cc
#
CREATE TABLE t (a INT);
# Used to hit assertion in debug builds.
EXPLAIN FORMAT=JSON INTO @var
SELECT 1 + 1 AS x FROM t GROUP BY x WITH ROLLUP HAVING x = 1;
# Used to show the GROUP BY clause as "group by ``".
SELECT JSON_UNQUOTE(JSON_EXTRACT(@var, '$.query')) AS query;
query
/* select#1 */ select rollup_group_item(<cache>((1 + 1)),0) AS `x` from `test`.`t` group by `x` with rollup having (rollup_group_item(`x`,0) = 1)
DROP TABLE t;
#
# Bug#35537921 Contribution by Tencent:
# explain format=tree lost the subquery in the hash join
#
CREATE TABLE t1 (a INT NOT NULL, b INT NOT NULL);
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1 JOIN t1 x2 ON x2.a=
(SELECT MIN(x3.a) FROM t1 x3 WHERE x1.a=x3.a);
EXPLAIN
-> Inner hash join (x2.a = (select #2))  (rows=1)
    -> Table scan on x1  (rows=1)
    -> Hash
        -> Table scan on x2  (rows=1)
    -> Select #2 (subquery in condition; dependent)
        -> Aggregate: min(x3.a)  (rows=1)
            -> Filter: (x1.a = x3.a)  (rows=0.1)
                -> Table scan on x3  (rows=1)

Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=JSON SELECT * FROM t1 x1 JOIN t1 x2 ON x2.a=
(SELECT MIN(x3.a) FROM t1 x3 WHERE x1.a=x3.a);
EXPLAIN
{
  "query": "/* select#1 */ select `x1`.`a` AS `a`,`x1`.`b` AS `b`,`x2`.`a` AS `a`,`x2`.`b` AS `b` from `test`.`t1` `x1` join `test`.`t1` `x2` where (`x2`.`a` = (/* select#2 */ select min(`x3`.`a`) from `test`.`t1` `x3` where (`x1`.`a` = `x3`.`a`)))",
  "inputs": [
    {
      "alias": "x1",
      "operation": "Table scan on x1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "a",
        "b"
      ],
      "estimated_rows": 1.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    },
    {
      "alias": "x2",
      "heading": "Hash",
      "operation": "Table scan on x2",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "a",
        "b"
      ],
      "estimated_rows": 1.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    },
    {
      "inputs": [
        {
          "inputs": [
            {
              "alias": "x3",
              "operation": "Table scan on x3",
              "table_name": "t1",
              "access_type": "table",
              "schema_name": "test",
              "used_columns": [
                "a"
              ],
              "estimated_rows": 1.0,
              "estimated_total_cost": 0.25,
              "estimated_first_row_cost": 0.25
            }
          ],
          "condition": "(x1.a = x3.a)",
          "operation": "Filter: (x1.a = x3.a)",
          "access_type": "filter",
          "estimated_rows": 0.10000000149011612,
          "estimated_total_cost": 0.35,
          "estimated_first_row_cost": 0.35
        }
      ],
      "heading": "Select #2 (subquery in condition; dependent)",
      "subquery": true,
      "dependent": true,
      "functions": [
        "min(x3.a)"
      ],
      "operation": "Aggregate: min(x3.a)",
      "access_type": "aggregate",
      "estimated_rows": 1.0,
      "subquery_location": "condition",
      "estimated_total_cost": 0.36000000014901157,
      "estimated_first_row_cost": 0.36000000014901157
    }
  ],
  "join_type": "inner join",
  "operation": "Inner hash join (x2.a = (select #2))",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 1.0,
  "hash_condition": [
    "(x2.a = (select #2))"
  ],
  "join_algorithm": "hash",
  "estimated_total_cost": 0.77,
  "estimated_first_row_cost": 0.77
}
Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=TREE SELECT * FROM t1 x1 JOIN t1 x2 ON x2.a<
(SELECT MIN(x3.a) FROM t1 x3 WHERE x1.a=x3.a);
EXPLAIN
-> Inner hash join (no condition), extra conditions: (x2.a < (select #2))  (rows=1)
    -> Table scan on x1  (rows=1)
    -> Hash
        -> Table scan on x2  (rows=1)
    -> Select #2 (subquery in extra conditions; dependent)
        -> Aggregate: min(x3.a)  (rows=1)
            -> Filter: (x1.a = x3.a)  (rows=0.1)
                -> Table scan on x3  (rows=1)

Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=JSON SELECT * FROM t1 x1 JOIN t1 x2 ON x2.a<
(SELECT MIN(x3.a) FROM t1 x3 WHERE x1.a=x3.a);
EXPLAIN
{
  "query": "/* select#1 */ select `x1`.`a` AS `a`,`x1`.`b` AS `b`,`x2`.`a` AS `a`,`x2`.`b` AS `b` from `test`.`t1` `x1` join `test`.`t1` `x2` where (`x2`.`a` < (/* select#2 */ select min(`x3`.`a`) from `test`.`t1` `x3` where (`x1`.`a` = `x3`.`a`)))",
  "inputs": [
    {
      "alias": "x1",
      "operation": "Table scan on x1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "a",
        "b"
      ],
      "estimated_rows": 1.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    },
    {
      "alias": "x2",
      "heading": "Hash",
      "operation": "Table scan on x2",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "used_columns": [
        "a",
        "b"
      ],
      "estimated_rows": 1.0,
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    },
    {
      "inputs": [
        {
          "inputs": [
            {
              "alias": "x3",
              "operation": "Table scan on x3",
              "table_name": "t1",
              "access_type": "table",
              "schema_name": "test",
              "used_columns": [
                "a"
              ],
              "estimated_rows": 1.0,
              "estimated_total_cost": 0.25,
              "estimated_first_row_cost": 0.25
            }
          ],
          "condition": "(x1.a = x3.a)",
          "operation": "Filter: (x1.a = x3.a)",
          "access_type": "filter",
          "estimated_rows": 0.10000000149011612,
          "estimated_total_cost": 0.35,
          "estimated_first_row_cost": 0.35
        }
      ],
      "heading": "Select #2 (subquery in extra conditions; dependent)",
      "subquery": true,
      "dependent": true,
      "functions": [
        "min(x3.a)"
      ],
      "operation": "Aggregate: min(x3.a)",
      "access_type": "aggregate",
      "estimated_rows": 1.0,
      "subquery_location": "extra conditions",
      "estimated_total_cost": 0.36000000014901157,
      "estimated_first_row_cost": 0.36000000014901157
    }
  ],
  "join_type": "inner join",
  "operation": "Inner hash join (no condition), extra conditions: (x2.a < (select #2))",
  "query_type": "select",
  "access_type": "join",
  "estimated_rows": 1.0,
  "hash_condition": [],
  "join_algorithm": "hash",
  "extra_condition": [
    "(x2.a < (select #2))"
  ],
  "estimated_total_cost": 0.87,
  "estimated_first_row_cost": 0.87
}
Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
DROP TABLE t1;
#
# Bug#34569685 No explain output for subquery
#
CREATE TABLE t1 (a INT PRIMARY KEY, b INT);
ANALYZE TABLE  t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN FORMAT=TREE SELECT LAST_VALUE((SELECT x1.a FROM t1))
OVER (PARTITION BY b) FROM t1 x1;
EXPLAIN
-> Window aggregate with buffering: last_value(`(select #2)`) OVER (PARTITION BY x1.b )   (...)
    -> Sort: x1.b  (...)
        -> Table scan on x1  (...)
    -> Select #2 (subquery in projection; dependent)
        -> Table scan on t1  (...)

Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=JSON SELECT LAST_VALUE((SELECT x1.a FROM t1))
OVER (PARTITION BY b) FROM t1 x1;
EXPLAIN
{
  "query": "/* select#1 */ select last_value(`(select #2)`) OVER (PARTITION BY `x1`.`b` )  AS `LAST_VALUE((SELECT x1.a FROM t1))\nOVER (PARTITION BY b)` from `test`.`t1` `x1`",
  "inputs": [
    {
      "inputs": [
        {
          "alias": "x1",
          "operation": "Table scan on x1",
          "table_name": "t1",
          "access_type": "table",
          "schema_name": "test",
          "used_columns": [
            "a",
            "b"
          ],
          "estimated_rows": 1.0,
          "estimated_total_cost": 0.25,
          "estimated_first_row_cost": 0.25
        }
      ],
      "operation": "Sort: x1.b",
      "access_type": "sort",
      "sort_fields": [
        "x1.b"
      ],
      "estimated_rows": 1.0,
      "estimated_total_cost": 0.35,
      "estimated_first_row_cost": 0.35
    },
    {
      "heading": "Select #2 (subquery in projection; dependent)",
      "subquery": true,
      "dependent": true,
      "operation": "Table scan on t1",
      "table_name": "t1",
      "access_type": "table",
      "schema_name": "test",
      "estimated_rows": 1.0,
      "subquery_location": "projection",
      "estimated_total_cost": 0.25,
      "estimated_first_row_cost": 0.25
    }
  ],
  "buffering": true,
  "functions": [
    "last_value(`(select #2)`) OVER (PARTITION BY x1.b ) "
  ],
  "operation": "Window aggregate with buffering: last_value(`(select #2)`) OVER (PARTITION BY x1.b ) ",
  "query_type": "select",
  "access_type": "window",
  "estimated_rows": 1.0,
  "estimated_total_cost": 0.44999999999999996,
  "estimated_first_row_cost": 0.44999999999999996
}
Warnings:
Note	1276	Field or reference 'test.x1.a' of SELECT #2 was resolved in SELECT #1
DROP TABLE t1;
#
# Bug#34727172 EXPLAIN FORMAT=JSON returns invalid JSON
#              on INSERT statements with hypergraph
#
CREATE TABLE t (i INT);
INSERT INTO t VALUES (1), (2), (3);
ANALYZE TABLE t;
Table	Op	Msg_type	Msg_text
test.t	analyze	status	OK
EXPLAIN FORMAT=JSON INSERT INTO t VALUES (4), (5), (6);
EXPLAIN
{
  "query": "insert into `test`.`t` values (4),(5),(6)",
  "inputs": [
    {
      "operation": "Rows fetched before execution",
      "access_type": "rows_fetched_before_execution"
    }
  ],
  "operation": "Insert into t",
  "query_type": "insert",
  "table_name": "t",
  "access_type": "insert_values",
  "schema_name": "test",
  "used_columns": [
    "i"
  ]
}
EXPLAIN FORMAT=JSON REPLACE INTO t VALUES (7), (8), (9);
EXPLAIN
{
  "query": "replace into `test`.`t` values (7),(8),(9)",
  "inputs": [
    {
      "operation": "Rows fetched before execution",
      "access_type": "rows_fetched_before_execution"
    }
  ],
  "operation": "Replace into t",
  "query_type": "replace",
  "table_name": "t",
  "access_type": "replace_values",
  "schema_name": "test",
  "used_columns": [
    "i"
  ]
}
DROP TABLE t;
#
# Bug#36134568 Add query type to iterator-based EXPLAIN FORMAT=JSON
#
CREATE TABLE t1 (i1 INT PRIMARY KEY, i2 INT);
CREATE TABLE t2 (i3 INT, i4 INT);
INSERT INTO t1 VALUES (1,2), (2,3), (3,4);
INSERT INTO t2 SELECT i2, i1 FROM t1;
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
EXPLAIN FORMAT=JSON INTO @v1 SELECT * FROM t1 JOIN t2 ON i1 = i3 WHERE i2 = 2;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'select';
JSON_EXTRACT(@v1, '$.query_type') = 'select'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 SELECT * FROM t1;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'select';
JSON_EXTRACT(@v1, '$.query_type') = 'select'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 INSERT INTO t1 VALUES (4,5);
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'insert';
JSON_EXTRACT(@v1, '$.query_type') = 'insert'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 INSERT INTO t1 SELECT * FROM t2;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'insert';
JSON_EXTRACT(@v1, '$.query_type') = 'insert'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 UPDATE t1 SET i2 = i2 + 1 WHERE i1 = 1;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'update';
JSON_EXTRACT(@v1, '$.query_type') = 'update'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 REPLACE t1 SELECT * FROM t2;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'replace';
JSON_EXTRACT(@v1, '$.query_type') = 'replace'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 DELETE FROM t1;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'delete';
JSON_EXTRACT(@v1, '$.query_type') = 'delete'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 UPDATE t1, t2 SET i1 = i1 - 1, i3 = i3 + 1;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'update';
JSON_EXTRACT(@v1, '$.query_type') = 'update'
1
SET @v1 = NULL;
EXPLAIN FORMAT=JSON INTO @v1 DELETE t1, t2 FROM t1, t2;
SELECT JSON_EXTRACT(@v1, '$.query_type') = 'delete';
JSON_EXTRACT(@v1, '$.query_type') = 'delete'
1
DROP TABLE t1, t2;
SET @v1=NULL;
