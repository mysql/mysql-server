# The results where created without innodb persistent stats.
SET @old_innodb_stats_persistent= @@global.innodb_stats_persistent;
SET @@global.innodb_stats_persistent= 0;
# Original tests for WL#4443
# Must have InnoDB as engine to get the same statistics results.
# embedded uses MyISAM as default. CREATE SELECT uses the default engine.
SET @old_default_storage_engine = @@default_storage_engine;
SET @@default_storage_engine = 'InnoDB';
CREATE TABLE t1 (a int PRIMARY KEY, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY AUTO_INCREMENT, b varchar(128))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
#
#
# Test how INSERT prune locks
# First test, no defaults
#
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, p1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, duplicate');
ERROR 23000: Duplicate entry '1' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_ROLLBACK	1
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# 1 rollback
FLUSH STATUS;
INSERT INTO t1 VALUES (0, 'First row, p0'), (2, 'First row, p2'),
(3, 'First row, p3'), (4, 'First row, p4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	10
HANDLER_WRITE	21
# 10 locks (table + 4 partition * lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1 * 13, 'Second row, p0'), (2 * 13, 'Third row, p0'),
(3 * 13, 'Fourth row, p0'), (4 * 13, 'Fifth row, p0');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	21
# 4 locks (table + 1 partition lock/unlock)
# 1 commit
#
# INSERT with auto increment, lock pruning
#
FLUSH STATUS;
INSERT INTO t2 VALUES (NULL, 'First auto-inc row');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# Auto increment value is not known until write.
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t2 (b) VALUES ('Second auto-inc row');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# Auto increment value is not known until write.
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t2 VALUES (10, "First row, p10");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# Insert pruning on tables with auto increment is not yet supported
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
#
# UPDATE with auto increment, lock pruning
#
FLUSH STATUS;
UPDATE t2 SET b = CONCAT(b, ", UPDATED") WHERE a = 10;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (table + 1 partition lock/unlock)
# 1 read_key + 1 update + 1 commit
#
# Test of pruning with secondary column auto_inc INSERT
#
CREATE TABLE t3 (a INT, b INT AUTO_INCREMENT, PRIMARY KEY (a, b))
ENGINE = MyISAM
PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# No commits, since MyISAM!
FLUSH STATUS;
INSERT INTO t3 VALUES (1, NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SELECT @@sql_mode;
@@sql_mode
NO_ENGINE_SUBSTITUTION
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_AUTO_VALUE_ON_ZERO';
SELECT @@sql_mode;
@@sql_mode
NO_AUTO_VALUE_ON_ZERO
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SET @@sql_mode = @old_sql_mode;
SELECT @@sql_mode;
@@sql_mode
NO_ENGINE_SUBSTITUTION
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SELECT * FROM t3;
a	b
1	0
1	1
1	2
1	3
DROP TABLE t3;
#
# Test handling of INSERT INTO <table> VALUES (<all fields specified>)
#
CREATE TABLE t3 (a INT, b CHAR(10)) PARTITION BY HASH (a) PARTITIONS 2;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, "Test 1");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	20
# 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (0, "Test 0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Test 1");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	20
# 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (0, "Test 0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
#
# Test handling of
# INSERT INTO <table> VALUES (<not all fields specified>)
#
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (2), (3), (4);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	20
# 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (6), (8), (10);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (5), (7), (9);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	20
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 1");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 2"), ("Only b 3");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	19
# 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t3 ORDER BY a, b;
a	b
NULL	Only b 1
NULL	Only b 2
NULL	Only b 3
0	Test 0
0	Test 0
1	NULL
1	Test 1
1	Test 1
2	NULL
2	Test 2
2	Test 2
3	NULL
3	Test 3
3	Test 3
4	NULL
4	Test 4
4	Test 4
5	NULL
5	Test 5
5	Test 5
6	NULL
6	Test 6
6	Test 6
7	NULL
7	Test 7
7	Test 7
8	NULL
8	Test 8
8	Test 8
9	NULL
9	Test 9
9	Test 9
10	NULL
10	Test 10
10	Test 10
DROP TABLE t3;
#
# Test of insert pruning with subpartitions
#
# I've placed the varchar column before the int column for better
# distribution by LINEAR KEY.
CREATE TABLE t3
(a int DEFAULT 10,
b varchar(64) DEFAULT "Default",
c varchar(64) DEFAULT "Default",
d int unsigned DEFAULT 9,
e varchar(255) DEFAULT "Default-filler.filler.filler.",
PRIMARY KEY (a,b,c,d))
PARTITION BY RANGE COLUMNS (a, b)
SUBPARTITION BY LINEAR KEY (d, c)
SUBPARTITIONS 4
(PARTITION pNeg VALUES LESS THAN (0, ""),
PARTITION `p0-9` VALUES LESS THAN (9, MAXVALUE),
PARTITION p10 VALUES LESS THAN (10, MAXVALUE),
PARTITION `p11-100` VALUES LESS THAN (99, MAXVALUE));
#
# Test INSERT with
# empty field specifier list and empty value list
#
FLUSH STATUS;
INSERT INTO t3 () VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
#
# Test INSERT with
# no field specifier list and full value list, including DEFAULT
# specifier
#
FLUSH STATUS;
INSERT INTO t3 VALUES (-1, "ZZZzzzz", "yyyYYY", -1, DEFAULT);
Warnings:
Warning	1264	Out of range value for column 'd' at row 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
#
# Test INSERT with
# empty field specifier list and full value list, including NULL
#
FLUSH STATUS;
INSERT INTO t3 () VALUES (0, "", "", 0, NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
#
# Test INSERT with field specifier list for only some fields
#
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Part expr fulfilled"),
(10, "Part expr fulfilled");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (d) VALUES (1), (2);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (c, d) VALUES ("Subpart expr fulfilled", 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b, d) VALUES (10, "Full part, half subpart", 1),
(12, "Full part, half subpart", 1),
(12, "Full part, half subpart", 2),
(12, "Full part, half subpart", 3),
(12, "Full part, half subpart", 4),
(12, "Full part, half subpart", 0);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_WRITE	23
# d = 0 and d = 4 goes to the same subpart!
# 12 locks (1 table, 5 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b, c) VALUES (1, "Full part", "Half subpart");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
# Adding 'Default' as padding to see if LINEAR KEY uses different parts.
FLUSH STATUS;
INSERT INTO t3 (a, c, d) VALUES (12, "Half part, full subpart", 1),
(12, "Half part, full subpartDefault", 1),
(12, "Half part, full subpart Default", 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	20
# First and last row goes to the same subpartition.
# 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b, c, d) VALUES ("Half part", "Full subpart", 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
#
# Test INSERT with full field specifier list and full value list
#
INSERT INTO t3 (a, b, c, d) VALUES (1, "Full part", "Full subpart", 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
#
# Test INSERT with no field specifier list and empty value list
# (need to delete previous inserted default row first...)
#
DELETE FROM t3 WHERE a = 10 AND b = 'Default' AND c = 'Default' AND D = 9;
FLUSH STATUS;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 subpartition lock/unlock)
#
# Verifing result
#
SELECT * FROM t3;
a	b	c	d	e
-1	ZZZzzzz	yyyYYY	0	Default-filler.filler.filler.
0			0	NULL
1	Default	Default	9	Default-filler.filler.filler.
1	Full part	Full subpart	1	Default-filler.filler.filler.
1	Full part	Half subpart	9	Default-filler.filler.filler.
1	Part expr fulfilled	Default	9	Default-filler.filler.filler.
10	Default	Default	1	Default-filler.filler.filler.
10	Default	Default	2	Default-filler.filler.filler.
10	Default	Default	9	Default-filler.filler.filler.
10	Default	Subpart expr fulfilled	1	Default-filler.filler.filler.
10	Full part, half subpart	Default	1	Default-filler.filler.filler.
10	Half part	Full subpart	1	Default-filler.filler.filler.
10	Part expr fulfilled	Default	9	Default-filler.filler.filler.
12	Default	Half part, full subpart	1	Default-filler.filler.filler.
12	Default	Half part, full subpart Default	1	Default-filler.filler.filler.
12	Default	Half part, full subpartDefault	1	Default-filler.filler.filler.
12	Full part, half subpart	Default	0	Default-filler.filler.filler.
12	Full part, half subpart	Default	1	Default-filler.filler.filler.
12	Full part, half subpart	Default	2	Default-filler.filler.filler.
12	Full part, half subpart	Default	3	Default-filler.filler.filler.
12	Full part, half subpart	Default	4	Default-filler.filler.filler.
SELECT d, c FROM t3 PARTITION(`p11-100sp0`);
d	c
0	Default
4	Default
SELECT d, c FROM t3 PARTITION(`p11-100sp1`);
d	c
1	Default
1	Half part, full subpart
1	Half part, full subpart Default
SELECT d, c FROM t3 PARTITION(`p11-100sp2`);
d	c
1	Half part, full subpartDefault
2	Default
SELECT d, c FROM t3 PARTITION(`p11-100sp3`);
d	c
3	Default
#
# Test with LOCK TABLES
#
LOCK TABLES t3 PARTITION (`p11-100sp0`) WRITE;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'PARTITION (`p11-100sp0`) WRITE' at line 1
FLUSH STATUS;
LOCK TABLES t3 WRITE;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	17
HANDLER_WRITE	17
# 17 locks (1 table, 16 partitions lock)
# No further locks/unlocks until UNLOCK TABLES.
#
# Test INSERT with no field specifier list and empty value list
# (need to delete previous inserted default row first...)
#
DELETE FROM t3 WHERE a = 10 AND b = 'Default' AND c = 'Default' AND D = 9;
FLUSH STATUS;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_WRITE	18
FLUSH STATUS;
#
# Test INSERT with field specifier list for only some fields
# (need to delete previous inserted default row first...)
#
DELETE FROM t3
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
INSERT INTO t3 (b, d, e) VALUES (DEFAULT, DEFAULT, "All default!");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_WRITE	18
FLUSH STATUS;
#
# Test UPDATE of non PK field in default row
#
UPDATE t3
SET e = CONCAT(e, ", updated")
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
FLUSH STATUS;
#
# Test UPDATE of PK field + non PK field in default row
#
UPDATE t3
SET a = DEFAULT, b = "Not DEFAULT!", e = CONCAT(e, ", updated2")
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
FLUSH STATUS;
#
# Test REPLACE of default row (INSERT, since not duplicate)
#
REPLACE INTO t3 (e) VALUES ("New default row");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_WRITE	18
FLUSH STATUS;
SELECT * FROM t3
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
a	b	c	d	e
10	Default	Default	9	New default row
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t3
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	p10_p10sp1	const	PRIMARY	PRIMARY	140	const,const,const,const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
#
# Test REPLACE of default row (REPLACE, since duplicate exists)
#
REPLACE INTO t3 (e) VALUES ("Newest default row");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
#
# Test SELECT with explicit partition selection
#
FLUSH STATUS;
SELECT * FROM t3 PARTITION (p10);
a	b	c	d	e
10	Default	Default	1	Default-filler.filler.filler.
10	Default	Default	2	Default-filler.filler.filler.
10	Default	Default	9	Newest default row
10	Default	Subpart expr fulfilled	1	Default-filler.filler.filler.
10	Full part, half subpart	Default	1	Default-filler.filler.filler.
10	Half part	Full subpart	1	Default-filler.filler.filler.
10	Not DEFAULT!	Default	9	All default!, updated, updated2
10	Part expr fulfilled	Default	9	Default-filler.filler.filler.
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_READ_FIRST	4
HANDLER_READ_KEY	4
HANDLER_READ_RND_NEXT	12
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t3 PARTITION (p10);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	p10_p10sp0,p10_p10sp1,p10_p10sp2,p10_p10sp3	ALL	NULL	NULL	NULL	NULL	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_WRITE	17
FLUSH STATUS;
UNLOCK TABLES;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	17
HANDLER_WRITE	17
# 17 locks (1 table, 16 partitions unlock)
DROP TABLE t3;
#
# End of LOCK TABLE test.
#
#
# Test INSERT with timestamp column NO default function
#
SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,
UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,
1234567890 % 3 as part2;
time_t	part	part2
1293829200	0	0
CREATE TABLE t3
(a timestamp DEFAULT 0,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY HASH (UNIX_TIMESTAMP(a))
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567890;
INSERT INTO t3 (a) VALUES (NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
0000-00-00 00:00:00	Replace4
2009-02-14 02:31:30	NULL
2011-01-01 00:00:00	DUP_KEY
2011-01-01 00:00:02	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT INSERT + UPDATE
#
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY HASH (UNIX_TIMESTAMP(a))
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567890;
INSERT INTO t3 (a) VALUES (NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 2 read_key + 1 read_rnd (1 read_key due to index lookup,
# 1 read_rnd + 1 read_key due to positioning before update)
# 1 delete + 1 write due to moved to different partition
# + 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
2009-02-14 02:31:30	NULL
2009-02-14 02:31:31	NULL
2009-02-14 02:31:32	DUP_KEY
2009-02-14 02:31:33	Updated
2009-02-14 02:31:34	Replace4
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT UPDATE
#
CREATE TABLE t3
(a timestamp DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY HASH (UNIX_TIMESTAMP(a))
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567890;
INSERT INTO t3 (a) VALUES (NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 2 read_key + 1 read_rnd (1 read_key due to index lookup,
# 1 read_rnd + 1 read_key due to positioning before update)
# 1 delete + 1 write due to moved to different partition
# + 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
0000-00-00 00:00:00	Replace4
2009-02-14 02:31:30	NULL
2009-02-14 02:31:32	DUP_KEY
2009-02-14 02:31:33	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT INSERT
#
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY HASH (UNIX_TIMESTAMP(a))
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567890;
INSERT INTO t3 (a) VALUES (NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
2009-02-14 02:31:30	NULL
2009-02-14 02:31:31	NULL
2009-02-14 02:31:34	Replace4
2011-01-01 00:00:00	DUP_KEY
2011-01-01 00:00:02	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with DATETIME column NO default function
#
CREATE TABLE t3
(a DATETIME DEFAULT 0,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY KEY (a)
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
0000-00-00 00:00:00	Replace4
2011-01-01 00:00:00	DUP_KEY
2011-01-01 00:00:02	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT INSERT + UPDATE
#
CREATE TABLE t3
(a DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY KEY (a)
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 2 read_key + 1 read_rnd (1 read_key due to index lookup,
# 1 read_rnd + 1 read_key due to positioning before update)
# 1 delete + 1 write due to moved to different partition
# + 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
2009-02-14 02:31:31	NULL
2009-02-14 02:31:32	DUP_KEY
2009-02-14 02:31:33	Updated
2009-02-14 02:31:34	Replace4
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT UPDATE
#
CREATE TABLE t3
(a DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY KEY (a)
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 8 locks (1 table, 3 partition lock/unlock) 
# No pruning due to DEFAULT function on partitioning column
# 2 read_key + 1 read_rnd (1 read_key due to index lookup,
# 1 read_rnd + 1 read_key due to positioning before update)
# 1 delete + 1 write due to moved to different partition
# + 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
0000-00-00 00:00:00	Replace4
2009-02-14 02:31:32	DUP_KEY
2009-02-14 02:31:33	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT INSERT
#
CREATE TABLE t3
(a DATETIME DEFAULT CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY KEY (a)
PARTITIONS 3 */
FLUSH STATUS;
SET TIMESTAMP = 1234567891;
INSERT INTO t3 VALUES ();
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	19
# 6 locks (1 table, 2 partition lock/unlock)
# 2 writes
FLUSH STATUS;
SET TIMESTAMP = 1234567892;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = "DUP_KEY";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01')
ON DUPLICATE KEY UPDATE a = '2011-01-01 00:00:05', b = "DUP_KEY2";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 8 locks (1 table, 3 partition lock/unlock)
# No pruning due to updating partitioning field.
# 1 read_key + 1 delete + 2 write (1 failed + 1 ok)
# 1 delete + 1 write due to moved to different partition
FLUSH STATUS;
SET TIMESTAMP = 1234567893;
UPDATE t3 SET b = 'Updated' WHERE a = '2011-01-01 00:00:02';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock) 
# 1 read_key + 1 update (same partition)
# 1 (failed) write
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
REPLACE INTO t3 VALUES ('2011-01-01 00:00:04', 'Replace2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
#
# Test of replace of default PK (delete might be needed first)
#
DELETE FROM t3 WHERE a = 0;
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace3');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SET TIMESTAMP = 1234567894;
REPLACE INTO t3 (b) VALUES ('Replace4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# 1 read_key + 1 update + 1 failed write
SELECT * FROM t3;
a	b
2009-02-14 02:31:31	NULL
2009-02-14 02:31:34	Replace4
2011-01-01 00:00:00	DUP_KEY
2011-01-01 00:00:02	Updated
2011-01-01 00:00:03	NULL
2011-01-01 00:00:04	Replace2
2011-01-01 00:00:05	DUP_KEY2
DROP TABLE t3;
#
# Test INSERT SELECT
#
FLUSH STATUS;
TRUNCATE TABLE t2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# All partitions needs to be locked
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a IN (1,4);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	34
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	19
# All partitions in t2 needs to be locked (no propagation from t1 yet).
# 2 partitions in t1 needs to be locked (for 1 and 4)
# 34 locks (2 table + 15 partition lock/unlock)
# 2 read_first, read_key and read_next.
# 1 commit
#
# Test TRUNCATE PARTITION
#
FLUSH STATUS;
ALTER TABLE t2 TRUNCATE PARTITION p1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a = 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	18
# 32 locks (2 table + 13 + 1 partitions)
#
# Test insert on duplicated key update
#
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write (insert)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 read_key
# 1 update
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If a partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write (insert)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 read_key
# 1 update
# 1 commit
#
# Test of insert on duplicate key with failed update
#
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE third");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE fail?");
ERROR 23000: Duplicate entry '91' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_ROLLBACK	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 read_key
# 1 update
# 1 rollback
#
# Test of insert on duplicate key with update to different partition
#
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 delete
# 1 write
# 1 read_key
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate 104")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 commit
#
# Test of insert on duplicate key with failed update to different
# partition
#
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate 104 + 1")
ON DUPLICATE KEY UPDATE a = a + 1;
ERROR 23000: Duplicate entry '105' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_ROLLBACK	1
HANDLER_WRITE	19
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 read_key
# 1 rollback
#
# Test replace
#
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE first");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write
# 1 commit
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE second");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write
# 1 read_key
# 1 update (NOTE: write_record() may cheat instead of delete/insert!)
# 1 rollback
#
# Test SELECT
#
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	15
HANDLER_WRITE	17
# 28 locks
# 13 read_first
# 13 read_key
# 15 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	12
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 12 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
a	b
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	9
HANDLER_WRITE	17
# 4 locks (1 table + 1 partitions lock/unlock)
# 1 read_first, read_key
# 9 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
# 28 locks
# 13 read_key
# 5 read_next
#
# Test EXPLAIN SELECT
#
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	#	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p4	index	PRIMARY	PRIMARY	4	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0	index	PRIMARY	b	131	NULL	#	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	const	PRIMARY	PRIMARY	4	const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	b	b	131	NULL	#	Using where; Using index; Using filesort
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
#
# Test pruning of non static values
# They will need to lock all partitions, but will allow scan pruning
# due to a second pruning call in optimize.
#
CREATE TABLE t3 (a INT);
INSERT INTO t3 VALUES (1);
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
# 2 read_rnd_next
FLUSH STATUS;
SELECT t1.a FROM t1 INNER JOIN t3 ON t1.a = t3.a;
a
1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT t1.a, t1.b FROM t1 INNER JOIN t3 ON t1.a = t3.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	eq_ref	PRIMARY	PRIMARY	4	test.t3.a	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 1;
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT COUNT(*) FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first
# 2 read_key, read_rnd_next
#
# Test of non indexed partition column
#
CREATE TABLE t4 SELECT a, b FROM t1;
ALTER TABLE t4 PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
# 14 locks (2 tables + 5 partitions lock/unlock)
# 2 read_first, read_key
# 6 read_rnd_next
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	#	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 14 locks (2 tables + 5 partitions lock/unlock)
INSERT INTO t3 VALUES (3);
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3 LIMIT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	#	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT MAX(a) FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p3	ALL	NULL	NULL	NULL	NULL	#	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
DROP TABLE t3;
DROP TABLE t4;
#
# Test derived tables like SELECT * FROM (SELECT * FROM ...)
#
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	11
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	22
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 11 read_next
# 6 read_rnd_next (tmp table)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	11
HANDLER_READ_RND_NEXT	12
HANDLER_WRITE	27
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 11 read_next
# 12 read_rnd_next (tmp table)
#
# Test EXPLAIN SELECT * FROM (SELECT * FROM ...)
#
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	#	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
3	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	#	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
#
# Test SELECT ... UNION SELECT ...
#
FLUSH STATUS;
SELECT * FROM t1 UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
13	Second row, p0
2	First row, p2
26	Third row, p0
3	First row, p3
39	Fourth row, p0
4	First row, p4
5	REPLACE second
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_FIRST	26
HANDLER_READ_KEY	26
HANDLER_READ_NEXT	15
HANDLER_READ_RND_NEXT	32
HANDLER_WRITE	34
# 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	21
HANDLER_WRITE	23
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	26
HANDLER_WRITE	27
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	16
HANDLER_WRITE	30
# 12 locks (2 tables, 3 + 1 partitions lock/unlock)
#
# Test EXPLAIN SELECT ... UNION SELECT ...
#
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	#	Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
3	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union1,3>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union3,4>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	NULL
NULL	UNION RESULT	<union1,4>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	NULL
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	#	Using where; Using index
4	UNION	t2	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	#	Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 12 locks (2 tables, 3 + 1 partitions lock/unlock)
#
# Test UPDATE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
# This should be prunable (does not change the partitioning key)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", updated 1") WHERE a IN (13, 26, 39, 52);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	4
HANDLER_UPDATE	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# 4 read_key
# 4 update
#
# This should not be prunable (only after implementing 'update pruning')
# i.e if all changed partitioning field is set to constant values,
# set lock_partitions to be a union of read_partition and the matching
# partition for the constants. Easy if all partitioning fields are set,
# probably needs a second round of prune_partitions() with these fields
# set to see if possible to prune locks.
FLUSH STATUS;
UPDATE t1 SET a = 99, b = CONCAT(b, ", updated 2 -> p8") WHERE a = 13;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
#
# This should use ha_update_row instead of ha_write_row + ha_delete_row
FLUSH STATUS;
UPDATE t1 SET a = 13 + 99, b = CONCAT(b, ", updated 3") WHERE a = 99;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 update
#
# This should not be prunable (only after implementing
# 'optimized update pruning', which will probably never happen, since
# it depends on which partitioning type is used (for this only hash is
# simple, but range and list is possible, key is very hard)
FLUSH STATUS;
UPDATE t1 SET a = a + 1, b = CONCAT(b, ", updated 4 -> p9") WHERE a = 112;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", same as min(a) + 2 in t2") WHERE a = (SELECT MIN(a) + 2 FROM t2);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	14
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 56 locks (2 tables, 13 + 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", max(a) in t2: ", (SELECT MAX(a) FROM t2)) WHERE a = 5;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	14
HANDLER_READ_LAST	13
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 32 locks (2 tables, 1 + 13 partitions lock/unlock)
#
# Test multi table UPDATE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4
5	REPLACE second, max(a) in t2: 4
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	#	NULL
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	#	NULL
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	15
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	2
HANDLER_UPDATE	2
HANDLER_WRITE	18
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 rean_rnd_next
# 2 update
#
# Test of views
#
FLUSH STATUS;
CREATE VIEW v1_25 AS SELECT a, b FROM t1 PARTITION (p2, p5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# No locks!
FLUSH STATUS;
CREATE VIEW v1_25_check AS SELECT a, b FROM t1 PARTITION (p2, p5) t1_alias WITH CHECK OPTION;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# No locks!
FLUSH STATUS;
CREATE VIEW v1_9 AS SELECT a, b FROM t1 WHERE a = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# No locks!
FLUSH STATUS;
CREATE VIEW v1_9_check AS SELECT a, b FROM t1 WHERE a = 9 WITH CHECK OPTION;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# No locks!
FLUSH STATUS;
CREATE VIEW v1_all AS SELECT a, b FROM t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# No locks!
SELECT TABLE_NAME, CHECK_OPTION, IS_UPDATABLE, VIEW_DEFINITION
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 'v1_%';
TABLE_NAME	CHECK_OPTION	IS_UPDATABLE	VIEW_DEFINITION
v1_25	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` PARTITION (`p2`,`p5`)
v1_25_check	CASCADED	YES	select `t1_alias`.`a` AS `a`,`t1_alias`.`b` AS `b` from `test`.`t1` PARTITION (`p2`,`p5`) `t1_alias`
v1_9	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`a` = 9)
v1_9_check	CASCADED	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`a` = 9)
v1_all	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1`
FLUSH STATUS;
INSERT INTO v1_all VALUES (23, "Insert in v1_all");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25 VALUES (18, "Insert in v1_25");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25 VALUES (17, "Insert in v1_25 fail");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT IGNORE INTO v1_25 VALUES (17, "Insert ignore in v1_25");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25_check VALUES (31, "Insert in v1_25_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25_check VALUES (30, "Insert in v1_25_check fail");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT IGNORE INTO v1_25_check VALUES (30, "Insert ignore in v1_25_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9 VALUES (9, "Insert in v1_9");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9 VALUES (8, "Insert in v1_9 NO CHECK!");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t1 WHERE a = 8;
a	b
8	Insert in v1_9 NO CHECK!
# DELETE will not find row not in view
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 8;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# 0 locks, impossible where!
EXPLAIN PARTITIONS DELETE FROM v1_9_check WHERE a = 8;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	No matching rows after partition pruning
EXPLAIN PARTITIONS SELECT * FROM v1_9_check WHERE a = 8;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
SELECT * FROM t1 WHERE a = 8;
a	b
8	Insert in v1_9 NO CHECK!
FLUSH STATUS;
INSERT INTO v1_9_check VALUES (10, "Insert in v1_9_check fail");
ERROR HY000: CHECK OPTION failed 'test.v1_9_check'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_ROLLBACK	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t1 WHERE a = 9;
a	b
9	Insert in v1_9
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9_check VALUES (9, "Insert in v1_9_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
FLUSH STATUS;
SELECT * FROM v1_9;
a	b
9	Insert in v1_9_check
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM v1_25;
a	b
18	Insert in v1_25
2	First row, p2
31	Insert in v1_25_check
5	REPLACE second, max(a) in t2: 4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
# 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM v1_all;
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
18	Insert in v1_25
2	First row, p2
23	Insert in v1_all
26	Third row, p0, updated 1
3	First row, p3, same as min(a) + 2 in t2
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
91	No duplicate, INSERT_DUP_KEY_UPDATE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	20
HANDLER_WRITE	17
# 28 locks (1 table, 13 partition lock/unlock)
DROP VIEW v1_all;
DROP VIEW v1_9, v1_9_check;
DROP VIEW v1_25, v1_25_check;
#
# Test CREATE SELECT
#
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE a IN (0, 1, 13, 113);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	10
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	12
HANDLER_WRITE	20
# 10 locks (2 tables, 3 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
DROP TABLE t3;
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE b LIKE 'First%';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	5
HANDLER_WRITE	22
# 30 locks (2 tables, 13 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
DROP TABLE t3;
#
# Test Stored procedures
#
CREATE PROCEDURE sp_insert(a INT, b CHAR(16))
INSERT INTO test.t1 VALUES (a, b);
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16))
BEGIN
SET @str = CONCAT("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)");
SET @x = a, @y = b;
PREPARE stmt FROM @str;
EXECUTE stmt USING @x, @y;
DEALLOCATE PREPARE stmt;
END|
CREATE PROCEDURE sp_select_all()
SELECT * FROM test.t1;
CREATE PROCEDURE sp_select_exact(x INT)
SELECT * FROM test.t1 WHERE a = x;
CREATE PROCEDURE sp_select_partition(p CHAR(16))
BEGIN
SET @str = CONCAT("SELECT * FROM test.t1 PARTITION(", p, ")");
PREPARE stmt FROM @str;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
END|
CREATE PROCEDURE sp_select_range(x INT, y INT)
SELECT * FROM test.t1 WHERE a between x and y;
FLUSH STATUS;
CALL sp_insert(313,"Test313");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7", 98, "Test98");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p8", 111, "Test111");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# no proc locking since already in proc cache.
# 2 locks (1 table, no partitions lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7,p8", 111, "Test111");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_all();
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
18	Insert in v1_25
2	First row, p2
23	Insert in v1_all
26	Third row, p0, updated 1
3	First row, p3, same as min(a) + 2 in t2
31	Insert in v1_25_check
313	Test313
39	Fourth row, p0, updated 1
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	14
HANDLER_READ_NEXT	23
HANDLER_WRITE	17
# 30 locks (procs table, t1 + 13 partitions lock/unlock)
FLUSH STATUS;
CALL sp_select_exact(98);
a	b
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	2
HANDLER_WRITE	17
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p7");
a	b
111	Test111
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p8");
a	b
8	Insert in v1_9 NO CHECK!
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
# no proc locking since already in proc cache.
# 4 locks (t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p7,p8");
a	b
111	Test111
8	Insert in v1_9 NO CHECK!
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
# 6 locks (t1 + 2 partitions lock/unlock)
FLUSH STATUS;
CALL sp_select_range(1,5);
a	b
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_KEY	6
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
# 14 locks (proc table, t1 + 5 partitions lock/unlock)
DROP PROCEDURE sp_insert;
DROP PROCEDURE sp_insert_partition;
DROP PROCEDURE sp_select_all;
DROP PROCEDURE sp_select_partition;
DROP PROCEDURE sp_select_range;
DROP PROCEDURE sp_select_exact;
#
# Test EXPLAIN DELETE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
105	No duplicate
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 105;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE b = "No duplicate";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	PRIMARY,b	b	131	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 105;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE b = "No duplicate";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	PRIMARY,b	b	131	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
#
# Test DELETE
#
FLUSH STATUS;
DELETE FROM t1 WHERE a = 105;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# 1 read_key
# 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE b = "No duplicate";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
# 13 read_key
# 1 read_next (if more matches after the first match)
# 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE a = (SELECT a + 90 FROM t2 WHERE a = 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	2
HANDLER_WRITE	17
# 32 locks (2 table + 13 + 1 partition lock/unlock)
# 2 read_key
# 2 read_next (if more matches after the first match)
# 1 delete
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = (SELECT a + 90 FROM t2 WHERE a = 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t2	p1	const	PRIMARY	PRIMARY	4	const	#	Using index
FLUSH STATUS;
DELETE FROM t1 PARTITION (p0)
WHERE a = (SELECT a + 2 FROM t2 WHERE a = 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# Impossible delete, all partitions pruned away after locking!
# 8 locks (2 table + 1 PARTITION(p0) + 1 (a = 1) partition lock/unlock)
# 1 read_key
EXPLAIN PARTITIONS DELETE FROM t1 PARTITION (p0)
WHERE a = (SELECT a + 2 FROM t2 WHERE a = 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	No matching rows after partition pruning
2	SUBQUERY	t2	p1	const	PRIMARY	PRIMARY	4	const	#	Using index
#
# Test multi table DELETE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4, t1.b:First row, p4
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	PRIMARY,b	b	131	const	#	Using where
1	SIMPLE	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	#	NULL
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 tables , 13 + 1 partition lock/unlock)
FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_KEY	15
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	17
# 56 locks (2 tables + 26 partitions lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 delete
FLUSH STATUS;
DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	14
HANDLER_WRITE	17
# 32 locks (2 tables , 13 + 1 partition lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 delete
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
4	First row, p4, t1.b:First row, p4
#
# Test subquery IN expression
#
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT count(*) FROM t1 p
WHERE a IN (1, 2, 9);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	p	p1,p2,p9	index	PRIMARY	b	131	NULL	4	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table, 3 partitions, lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT count(*) FROM t1 p
WHERE a IN
(SELECT a + 1 FROM t2 WHERE a = 4);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	p	p5	const	PRIMARY	PRIMARY	4	const	1	Using index
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	1	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	2
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions, lock/unlock)
#
# Test triggers
# Tables used in triggers cannot be pruned for locks.
# Tables with triggers cannot be pruned for locks if
# BEFORE INSERT/UPDATE trigger uses any partitioning columns.
#
CREATE TABLE t3
(old_a int,
new_a int,
old_b varchar(255),
new_b varchar(255),
key (new_a, new_b),
key(new_b))
PARTITION BY HASH (new_a) PARTITIONS 5;
CREATE TRIGGER t1_after_insert AFTER INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (2, NEW.a, NULL, CONCAT("AI: ", NEW.b));
CREATE TRIGGER t1_after_update AFTER UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("AU: ", OLD.b), CONCAT("AU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
# (t1 to insert, t3 after insert trigger, t3 after update trigger)
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 16 locks (2 tables, 1 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger)
# Note that since there is no delete trigger, REPLACE cheats by
# doing update instead of delete+insert!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_WRITE	17
# 16 locks (2 tables, 1 + 5 partition lock/unlock)
# (t1 to insert, t3 after update trigger)
CREATE TRIGGER t1_after_delete AFTER DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("AD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	21
# 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger, t3 after delete trigger)
# Note that now it does delete+insert instead, due to delete trigger!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED2
CREATE TRIGGER t1_before_delete BEFORE DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("BD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED3");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	40
HANDLER_READ_KEY	1
HANDLER_WRITE	22
# 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger, t3 before delete trigger,
#  t3 after delete trigger)
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED3
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("BU: ", OLD.b), CONCAT("BU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	64
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	20
# No pruning possible, due to BEFORE UPDATE trigger
# 64 locks (4 tables, 13 + 5 + 5 + 5 partitions lock/unlock)
# t1, t3 after insert, t3 before update, t3 after update
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED4");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	40
HANDLER_READ_KEY	1
HANDLER_WRITE	22
# 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
# t1, t3 after insert, t3 before delete, t3 after delete
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED4
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_WRITE	17
# No pruning possible, due to BEFORE UPDATE trigger
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
EXPLAIN PARTITIONS INSERT INTO t1 VALUES (12, "First row, p12");
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No tables used
FLUSH STATUS;
INSERT INTO t1 VALUES (12, "First row, p12");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_WRITE	19
# 16 locks (2 table, 1 + 5 partition lock/unlock)
# t1, t3 after insert trigger
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (1, NEW.a, NULL, CONCAT("BI: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (11, "First row, p11");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_WRITE	20
# Nothing can be pruned, due to triggers.
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, t3 before insert, t3 after insert.
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 98;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p7	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (3 tables, 1 + 5 + 5 partitions)
# t1, t3 before delete trigger, t3 after delete trigger
# part 7, part 0-4, part 0-4.
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
11	First row, p11
12	First row, p12
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
FLUSH STATUS;
DELETE FROM t1 WHERE a = 98;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 28 locks (3 tables, 1 + 5 + 5 partitions)
# t1, t3 before delete trigger, t3 after delete trigger
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
11	First row, p11
12	First row, p12
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
4	First row, p4, t1.b:First row, p4
SELECT * FROM t3 ORDER BY new_a;
old_a	new_a	old_b	new_b
0	NULL	AD: First row, p0 REPLACED	NULL
0	NULL	AD: First row, p0 REPLACED2	NULL
0	NULL	AD: First row, p0 REPLACED3	NULL
0	NULL	BD: First row, p0 REPLACED2	NULL
0	NULL	BD: First row, p0 REPLACED3	NULL
1	11	NULL	BI: First row, p11
2	0	NULL	AI: First row, p0 REPLACED
2	0	NULL	AI: First row, p0 REPLACED2
2	0	NULL	AI: First row, p0 REPLACED3
2	0	NULL	AI: First row, p0 REPLACED4
2	11	NULL	AI: First row, p11
2	12	NULL	AI: First row, p12
2	2	AU: First row, p2	AU: First row, p2, duplicate key 2
2	2	AU: First row, p2, duplicate key 2	AU: First row, p2, duplicate key 2, duplicate key 2
2	2	BU: First row, p2, duplicate key 2	BU: First row, p2, duplicate key 2, duplicate key 2
3	3	AU: First row, p3, same as min(a) + 2 in t2	AU: First row, p3, same as min(a) + 2 in t2, UPDATED2
3	3	BU: First row, p3, same as min(a) + 2 in t2	BU: First row, p3, same as min(a) + 2 in t2, UPDATED2
98	NULL	AD: Test98	NULL
98	NULL	BD: Test98	NULL
TRUNCATE TABLE t1;
DROP TRIGGER t1_before_insert;
DROP TRIGGER t1_before_update;
DROP TRIGGER t1_before_delete;
DROP TRIGGER t1_after_insert;
DROP TRIGGER t1_after_update;
DROP TRIGGER t1_after_delete;
#
# Test BEFORE INSERT TRIGGER depending on partitioning column
#
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("b: ", NEW.b, " a: ", NEW.a);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "first row, p0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "Second row, p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET a = 1, b = CONCAT(b, ", a was 0") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Updating partitioning column, no lock pruning
# 28 locks (1 tables, 13 partitions lock/unlock)
#
# Test BEFORE INSERT TRIGGER not depending on partitioning column
#
DROP TRIGGER t1_before_insert;
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "first row, p0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "Second row, p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET a = 2, b = CONCAT(b, ", a was 0") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Updating partitioning column, no lock pruning
# 28 locks (1 tables, 13 partitions lock/unlock)
#
# Test BEFORE UPDATE TRIGGER OLD depending on partitioning column.
# Note that it does not update any partitioning column.
#
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("old a: ", OLD.a, " new b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "1st p0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "2nd p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", dup key");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# Lock pruning possible!
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET a = 3, b = CONCAT(b, ", a was 0") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Updating partitioning column, no lock pruning
# 28 locks (1 tables, 13 partitions lock/unlock)
#
# Test BEFORE UPDATE TRIGGER NEW depending on partitioning column.
# Note that it does not update any partitioning column.
#
DROP TRIGGER t1_before_update;
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("new a: ", NEW.a, " new b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "1st p0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "2nd p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", dup key");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 28 locks (1 tables, 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET a = 4, b = CONCAT(b, ", a was 0") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Updating partitioning column, no lock pruning
# 28 locks (1 tables, 13 partitions lock/unlock)
#
# Test BEFORE UPDATE TRIGGER not depending on partitioning column
#
DROP TRIGGER t1_before_update;
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("new b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "1st p0");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "2nd p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", dup key");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 4 locks (1 tables, 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET a = 5, b = CONCAT(b, ", a was 0") WHERE a = 0;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Updating partitioning column, no lock pruning
# 28 locks (1 tables, 13 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
1	b: first row, p0 a: 0, duplicate key, Updated, a was 0
2	b: first row, p0, duplicate key, Updated, a was 0
3	old a: 0 new b: old a: 0 new b: old a: 0 new b: b: 1st p0, dup key, Updated, a was 0
4	new a: 4 new b: new a: 0 new b: new a: 0 new b: b: 1st p0, dup key, Updated, a was 0
5	new b: new b: new b: b: 1st p0, dup key, Updated, a was 0
DROP TABLE t1, t2, t3;
#
# Test of BEFORE UPDATE triggers and multi UPDATE
#
CREATE TABLE t1 (a int, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY, b varchar(128))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
INSERT INTO t1 VALUES (1, "MultiUpdate1");
INSERT INTO t1 VALUES (2, "MultiUpdate2");
INSERT INTO t2 VALUES (1, "MultiUpdate1");
INSERT INTO t2 VALUES (2, "MultiUpdate2");
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("new1 b: ", NEW.b);
CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET NEW.b = CONCAT("new2 a: ", NEW.a, " new2 b: ", NEW.b);
FLUSH STATUS;
EXPLAIN EXTENDED UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(1) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(1) t1.b:", t1.b)
WHERE t2.b = t1.b and t1.a = 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	ALL	b	NULL	NULL	NULL	#	100.00	Using where
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	#	100.00	Using where; Using join buffer (Block Nested Loop)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(1) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(1) t1.b:", t1.b)
WHERE t2.b = t1.b and t1.a = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1	ALL	b	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	#	Using where; Using join buffer (Block Nested Loop)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(1) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(1) t1.b:", t1.b)
WHERE t2.b = t1.b and t1.a = 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_FIRST	14
HANDLER_READ_KEY	16
HANDLER_READ_RND	2
HANDLER_READ_RND_NEXT	21
HANDLER_UPDATE	2
HANDLER_WRITE	19
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
# 14 read_first
# 16 read_key
# 2 read_rnd
# 21 rean_rnd_next
# 2 update
FLUSH STATUS;
EXPLAIN EXTENDED UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(2) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(2) t1.b:", t1.b)
WHERE t1.b = t2.b and t2.a = 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	const	PRIMARY	PRIMARY	4	const	#	100.00	NULL
1	SIMPLE	t1	ref	b	b	131	const	#	100.00	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# Trigger touches partitioning column, unable to prune locks
# 56 locks (2 tables + 2 * 13 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(2) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(2) t1.b:", t1.b)
WHERE t1.b = t2.b and t2.a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# Trigger touches partitioning column, unable to prune locks
# 56 locks (2 tables + 2 * 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(2) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(2) t1.b:", t1.b)
WHERE t1.b = t2.b and t2.a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_KEY	15
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	2
HANDLER_UPDATE	2
HANDLER_WRITE	18
# Due to the BEFORE UPDATE trigger on t2 that looks at 'a',
# no locks can be pruned.
# 56 locks (2 table, 2 * 13 partitions lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 read_rnd_next
# 2 update
SELECT * FROM t1 ORDER BY a;
a	b
1	new1 b: MultiUpdate1,(1) t2.b:MultiUpdate1
2	new1 b: MultiUpdate2,(2) t2.b:MultiUpdate2
SELECT * FROM t2 ORDER BY a;
a	b
1	new2 a: 1 new2 b: MultiUpdate1,(1) t1.b:MultiUpdate1
2	new2 a: 2 new2 b: MultiUpdate2,(2) t1.b:MultiUpdate2
DROP TABLE t1, t2;
#
# Test constant propagation in WHERE clause
# (Currently no propagation is done before locking).
CREATE TABLE t1 (a int, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY RANGE (a)
(PARTITION pNeg VALUES LESS THAN (0),
PARTITION p0 VALUES LESS THAN (1),
PARTITION p1 VALUES LESS THAN (2),
PARTITION p2 VALUES LESS THAN (3),
PARTITION p3 VALUES LESS THAN (4),
PARTITION pMax VALUES LESS THAN MAXVALUE);
CREATE TABLE t2 (a int PRIMARY KEY, b varchar(128))
ENGINE = InnoDB
PARTITION BY RANGE (a)
(PARTITION pNeg VALUES LESS THAN (0),
PARTITION p0 VALUES LESS THAN (1),
PARTITION p1 VALUES LESS THAN (2),
PARTITION p2 VALUES LESS THAN (3),
PARTITION p3 VALUES LESS THAN (4),
PARTITION pMax VALUES LESS THAN MAXVALUE);
INSERT INTO t1 VALUES (1, "Const1");
INSERT INTO t2 VALUES (1, "Const1");
INSERT INTO t1 VALUES (2, "Const2");
INSERT INTO t2 VALUES (2, "Const2");
INSERT INTO t1 VALUES (3, "Const3");
INSERT INTO t2 VALUES (3, "Const3");
# Test simple '=' propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a = 1;
a	b	a	b
1	Const1	1	Const1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 18 locks (2 tables, 6 + 1 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a = 1;
a	b	a	b
1	Const1	1	Const1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 18 locks (2 tables, 1 + 6 partitions lock/unlock)
# Test OR propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND (t2.a = 1 OR t2.a = 2);
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	4
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
# 20 locks (2 tables, 6 + 2 partitions lock/unlock)
# But it will be scanned pruned!
EXPLAIN PARTITIONS SELECT * FROM t1, t2
WHERE t1.a = t2.a AND (t1.a = 1 OR t1.a = 2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1,p2	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p1,p2	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
# Test closed range propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a >= 1 AND t1.a <=3;
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
3	Const3	3	Const3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	22
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	6
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
# 22 locks (2 tables, 6 + 3 partitions lock/unlock)
# But it will be scanned pruned!
EXPLAIN PARTITIONS SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a >= 1 AND t1.a <=3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1,p2,p3	range	PRIMARY	PRIMARY	4	NULL	#	Using where
1	SIMPLE	t1	p1,p2,p3	ALL	NULL	NULL	NULL	NULL	#	Using where; Using join buffer (Block Nested Loop)
# Test open range propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a >= 1;
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
3	Const3	3	Const3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	24
HANDLER_READ_FIRST	4
HANDLER_READ_KEY	7
HANDLER_READ_RND_NEXT	7
HANDLER_WRITE	17
# 24 locks (2 tables, 6 + 4 partitions lock/unlock)
# But is scanned pruned!
EXPLAIN PARTITIONS SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a >= 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1,p2,p3,pMax	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p1,p2,p3,pMax	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a <= 1;
a	b	a	b
1	Const1	1	Const1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	22
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	4
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
# 22 locks (2 tables, 6 + 3 partitions lock/unlock)
# But is scanned pruned!
EXPLAIN PARTITIONS SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a <= 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	pNeg,p0,p1	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	pNeg,p0,p1	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
# Test IN propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a and t2.a IN (1, 3);
a	b	a	b
1	Const1	1	Const1
3	Const3	3	Const3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	4
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
# 20 locks (2 tables, 6 + 2 partitions lock/unlock)
# But is scanned pruned!
EXPLAIN PARTITIONS SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a IN (1, 3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1,p3	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p1,p3	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
# Same for UPDATE
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b)
WHERE t1.a = t2.a and t2.a IN (2, 3);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	6
HANDLER_READ_RND	2
HANDLER_READ_RND_NEXT	7
HANDLER_UPDATE	2
HANDLER_WRITE	19
# 20 locks (2 tables, 6 + 2 partitions lock/unlock)
# But is scanned pruned!
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b)
WHERE t1.a = t2.a and t2.a IN (2, 3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p2,p3	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p2,p3	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	NULL
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t1.a = t2.a and t2.a = 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	3
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	4
HANDLER_UPDATE	2
HANDLER_WRITE	18
# 18 locks (2 tables, 6 + 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t1.a = t2.a and t1.a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	3
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	4
HANDLER_UPDATE	2
HANDLER_WRITE	18
# 18 locks (2 tables, 1 + 6 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
1	Const1, t2.b:Const1
2	Const2, t2.b:Const2, t2.b:Const2
3	Const3, t2.b:Const3
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
3	Const3
# Same for DELETE
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a AND t2.a IN (1, 9);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	3
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 20 locks (2 tables, 6 + 2 partitions lock/unlock)
# But is scanned pruned!
EXPLAIN PARTITIONS DELETE t1 FROM t1, t2
WHERE t1.a = t2.a AND t2.a IN (1, 9);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1,pMax	ALL	NULL	NULL	NULL	NULL	#	Using where
1	SIMPLE	t2	p1,pMax	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	#	Using index
SELECT * FROM t1 ORDER BY a;
a	b
2	Const2, t2.b:Const2, t2.b:Const2
3	Const3, t2.b:Const3
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a and t2.a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 18 locks (2 tables, 6 + 1 partitions lock/unlock)
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a and t1.a = 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	1
HANDLER_WRITE	17
# 18 locks (2 tables, 1 + 6 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
3	Const3, t2.b:Const3
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
3	Const3
FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a and t2.a = 3;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	18
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	3
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 18 locks (2 tables, 6 + 1 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
DROP TABLE t1, t2;
#
# DO is not supported by WL#4443 !!!
# Test of DO (eg. SELECT without returning values)
#
CREATE TABLE t1 (a INT, b VARCHAR(66))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "One"), (2, "Two"), (3, "Three"), (4, "Four"), (5, "Five"), (6, "Six"), (0, "Zero");
DO (SELECT a FROM t1);
Warnings:
Error	1242	Subquery returns more than 1 row
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x;
@x
Five
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x;
@x
Five
#
# SET is not supported by WL#4443 !!!
# Test of SET (eg. SELECT only setting an internal variable from
# the returning value)
#
FLUSH STATUS;
SET @x = (SELECT a FROM t1 WHERE a = 5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x;
@x
5
FLUSH STATUS;
SET @y = (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x, @y;
@x	@y
Five	Five
FLUSH STATUS;
SET @y = (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x, @y;
@x	@y
Five	Five
#
# LOAD DATA is not supported by WL#4443 !!!
#
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (1, 4)
INTO OUTFILE 'MYSQLTEST_VARDIR/tmp/t1.part1';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 4 locks (1 table + 1 partitions lock/unlock)
DELETE FROM t1 WHERE a IN (1, 4);
SELECT * FROM t1 ORDER BY a, b;
a	b
0	Zero
2	Two
3	Three
5	Five
6	Six
FLUSH STATUS;
LOAD DATA INFILE 'MYSQLTEST_VARDIR/tmp/t1.part1' INTO TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	19
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a, b;
a	b
0	Zero
1	One
2	Two
3	Three
4	Four
5	Five
6	Six
DELETE FROM t1 WHERE a IN (1, 4);
SELECT * FROM t1 ORDER BY a, b;
a	b
0	Zero
2	Two
3	Three
5	Five
6	Six
# It is possible to avoid locking with explicit partitioning selection!
FLUSH STATUS;
LOAD DATA INFILE 'MYSQLTEST_VARDIR/tmp/t1.part1' INTO TABLE t1 PARTITION(p1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	19
# 4 locks (1 table + 1 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a, b;
a	b
0	Zero
1	One
2	Two
3	Three
4	Four
5	Five
6	Six
DROP TABLE t1;
#
# Test EXCHANGE PARTITION to only lock exchanged partition
#
CREATE TABLE t1 (a INT, b VARCHAR(44));
CREATE TABLE t2 (a INT, b VARCHAR(44))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (10, "Ten"), (13, "Thirteen"), (16, "Sixteen");
INSERT INTO t2 VALUES (0, "Zero"), (1, "One"), (2, "Two"),
(3, "Three"), (4, "Four"), (5, "Five"),
(6, "Six"), (7, "Seven"), (8, "Eight");
FLUSH STATUS;
ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
# 6 locks (2 table + 1 partition lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
1	One
4	Four
7	Seven
SELECT * FROM t2 ORDER BY a;
a	b
0	Zero
2	Two
3	Three
5	Five
6	Six
8	Eight
10	Ten
13	Thirteen
16	Sixteen
DROP TABLE t1, t2;
#
# Prepared statement
#
CREATE TABLE t1 (N int, M tinyint)
PARTITION BY HASH (N) PARTITIONS 3;
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
FLUSH STATUS;
EXECUTE stmt;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	6
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	4
HANDLER_READ_RND	2
HANDLER_READ_RND_NEXT	20
HANDLER_UPDATE	6
HANDLER_WRITE	22
# 16 locks (2 table + 6 partition lock/unlock)
SELECT * FROM t1 ORDER BY N, M;
N	M
1	2
1	2
2	2
2	2
3	0
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT * FROM t1 WHERE N = 2';
FLUSH STATUS;
EXECUTE stmt;
N	M
2	2
2	2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
DROP TABLE t1;
# Check if we can infer from condition on partition fields that 
# no records will match.
CREATE TABLE t1 ( a int NOT NULL) PARTITION BY HASH(a) PARTITIONS 2;
INSERT INTO t1 VALUES (1),(2),(3);
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a=5 AND a=6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table + 0 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a=5 AND a=6;
a
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table + 0 partition lock/unlock)
DROP TABLE t1;
#
# Test of subqueries in INSERT
#
CREATE TABLE t1 (a INT, b VARCHAR(64));
CREATE TABLE t2 (a INT, b VARCHAR(64)) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "test 1");
INSERT INTO t2 VALUES (SELECT * FROM t1);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SELECT * FROM t1)' at line 1
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT a FROM t1), (SELECT b FROM t1));
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	18
# 12 locks (3 tables + 3 partitions) x lock/unlock
# I.e. No lock pruning possible
FLUSH STATUS;
INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),
CONCAT("subq: ", (SELECT b FROM t1)));
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	18
# 12 locks (3 tables + 3 partitions) x lock/unlock
# I.e. No lock pruning possible
SELECT * FROM t2;
a	b
1	test 1
2	subq: test 1
DROP TABLE t1, t2;
CREATE TABLE t1 (a INT, b INT) PARTITION BY HASH (a) PARTITIONS 3;
CREATE TABLE t2 (a INT, b INT) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, 1), (2, 0), (4, -1), (5, 2), (7, -3), (8, -9),
(10, 5), (11, 9);
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT max(a) FROM t1), (SELECT min(a) FROM t1));
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	24
HANDLER_READ_FIRST	6
HANDLER_READ_KEY	6
HANDLER_READ_RND_NEXT	22
HANDLER_WRITE	18
# 24 locks (3 tables + 3 x 3 partitions) x lock/unlock
# I.e. No lock pruning possible
FLUSH STATUS;
EXPLAIN PARTITIONS INSERT INTO t2 VALUES ((SELECT max(a) FROM t1),
(SELECT min(a) FROM t1));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	No tables used
3	SUBQUERY	t1	p0,p1,p2	ALL	NULL	NULL	NULL	NULL	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ALL	NULL	NULL	NULL	NULL	#	NULL
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	24
HANDLER_WRITE	17
# 24 locks (3 tables + 3 x 3 partitions) x lock/unlock
# I.e. No lock pruning possible
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT a FROM t1 WHERE a = 1),
(SELECT b FROM t1 WHERE a = 2));
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	10
HANDLER_WRITE	18
# 16 locks (3 tables + 3 + 1 + 1 partitions) x lock/unlock
# I.e. No lock pruning possible on insert table
FLUSH STATUS;
EXPLAIN PARTITIONS INSERT INTO t2 VALUES ((SELECT a FROM t1 WHERE a = 1),
(SELECT b FROM t1 WHERE a = 2));
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	No tables used
3	SUBQUERY	t1	p2	ALL	NULL	NULL	NULL	NULL	#	Using where
2	SUBQUERY	t1	p1	ALL	NULL	NULL	NULL	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_WRITE	17
# 16 locks (3 tables + 3 + 1 + 1 partitions) x lock/unlock
# I.e. No lock pruning possible on insert table
SELECT * FROM t2 ORDER BY a, b;
a	b
1	0
11	1
DROP TABLE t1;
DROP TABLE t2;
#
# Test of InnoDB INSERT TABLE with non existing table in trigger
#
CREATE TABLE t1 (a INT)
ENGINE = InnoDB;
# Create a table to be used in a trigger on t1
CREATE TABLE t2 (a INT)
ENGINE = InnoDB;
# Create a trigger on t1 which uses t2
CREATE TRIGGER tr1_1_N  BEFORE INSERT ON t1
FOR EACH ROW BEGIN
UPDATE t2 SET a = 8 WHERE a > 3 LIMIT 0;
END//
# Drop t2 to cause a failure when inserting into t1
DROP TABLE t2;
INSERT INTO t1 VALUES (1);
ERROR 42S02: Table 'test.t2' doesn't exist
DROP TABLE t1;
CREATE TABLE t1 (a INT) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1), (3), (9), (2), (8), (7);
FLUSH STATUS;
CREATE TABLE t2 SELECT * FROM t1 PARTITION (p1, p2);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	21
# 8 locks (2 tables, 2 partitions, lock/unlock)
SELECT * FROM t2;
a
1
2
7
8
DROP TABLE t2;
FLUSH STATUS;
CREATE TABLE t2 SELECT * FROM t1 WHERE a IN (1, 3, 9);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	20
# 8 locks (2 tables, 2 partitions, lock/unlock)
SELECT * FROM t2;
a
1
3
9
DROP TABLE t1, t2;
#
# Test subqueries/stored functions with UPDATE/DELETE/SELECT
#
CREATE TABLE tq (id int PRIMARY KEY auto_increment, query varchar(255), not_select tinyint);
CREATE TABLE tsq (id int PRIMARY KEY auto_increment, subquery varchar(255), can_be_locked tinyint);
CREATE TABLE t1 (a int, b varchar(255), PRIMARY KEY (a), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 3;
CREATE TABLE t2 (a int, b varchar(255), PRIMARY KEY (a), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 3;
START TRANSACTION;
INSERT INTO t1 VALUES (1, "1");
INSERT INTO t1 VALUES (2, "2");
INSERT INTO t1 VALUES (8, "8");
INSERT INTO t2 VALUES (1, "1");
INSERT INTO t2 VALUES (2, "2");
INSERT INTO t2 VALUES (8, "8");
CREATE FUNCTION sf_add_hello(s VARCHAR(240))
RETURNS VARCHAR(246) DETERMINISTIC
RETURN CONCAT('hello ', s);
CREATE FUNCTION sf_add_1(i INT)
RETURNS INT DETERMINISTIC
RETURN i + 1;
CREATE FUNCTION sf_a_from_t1b_d(s varchar(128))
RETURNS INT DETERMINISTIC
BEGIN
DECLARE i INT;
SELECT a INTO i FROM t1 where b = s;
RETURN i;
END|
CREATE FUNCTION sf_a_from_t1b(s varchar(128))
RETURNS INT
BEGIN
DECLARE i INT;
SELECT a INTO i FROM t1 where b = s;
RETURN i;
END|
INSERT INTO tq (query, not_select) VALUES
("SELECT * FROM t2", 0),
("SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2", 0),
("UPDATE t2 SET b = CONCAT('+', b)", 1),
("UPDATE t2 SET b = sf_add_hello(b)", 1),
("UPDATE t2 SET a = sf_add_1(a) + 4", 1),
("DELETE FROM t2", 1);
INSERT INTO tsq (subquery, can_be_locked) VALUES
("(SELECT a FROM t1 WHERE b = '1')", 1),
("7 + (SELECT a FROM t1 WHERE b = '1')", 1),
("sf_a_from_t1b('1')", 1),
("sf_a_from_t1b_d('1')", 1),
("7 + sf_a_from_t1b('1')", 1),
("7 + sf_a_from_t1b_d('1')", 1),
("sf_a_from_t1b('1') AND a = 2", 1),
("sf_a_from_t1b_d('1') AND a = 2", 1),
("(SELECT a FROM t1 WHERE b = '1') AND a = 2", 1),
("(SELECT a FROM t1 WHERE b = '1') OR a = 2", 1),
("(SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2')", 0);
set @old_autocommit= @@autocommit;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	NULL	b	258	NULL	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = sf_a_from_t1b('1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = sf_a_from_t1b('1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1');
a	b
1	1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	NULL	b	258	NULL	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	index	PRIMARY	b	258	NULL	#	Using where; Using index
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
a	b
1	1
2	2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
a	b
1	1
2	2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT * FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
a	b
8	8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	NULL	b	258	NULL	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1');
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	NULL	b	258	NULL	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	6
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	index	PRIMARY	b	258	NULL	#	Using where; Using index
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
2	hello 2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
sf_add_1(a) - 1	sf_add_hello(b)
1	hello 1
2	hello 2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
UNLOCK TABLES;
EXPLAIN PARTITIONS SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	const	PRIMARY	PRIMARY	4	const	#	NULL
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
SELECT sf_add_1(a) - 1, sf_add_hello(b) FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
sf_add_1(a) - 1	sf_add_hello(b)
8	hello 8
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_UPDATE	2
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	+2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_UPDATE	2
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	+1
2	+2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = CONCAT('+', b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	2
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	+8
ROLLBACK;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_UPDATE	2
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	hello 2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_UPDATE	2
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	hello 1
2	hello 2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET b = sf_add_hello(b) WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	2
HANDLER_UPDATE	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	hello 8
ROLLBACK;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	6
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	6
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	11
HANDLER_READ_NEXT	3
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	11
HANDLER_READ_NEXT	3
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
2	2
6	1
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	index	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	6
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	6
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	11
HANDLER_READ_NEXT	3
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	11
HANDLER_READ_NEXT	3
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	1
HANDLER_READ_RND	2
HANDLER_WRITE	19
SELECT * FROM t2;
a	b
6	1
7	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	1
HANDLER_READ_RND	2
HANDLER_WRITE	19
SELECT * FROM t2;
a	b
6	1
7	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where; Using temporary
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
UPDATE t2 SET a = sf_add_1(a) + 4 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	24
HANDLER_READ_KEY	8
HANDLER_READ_NEXT	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
SELECT * FROM t2;
a	b
1	1
13	8
2	2
ROLLBACK;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = 7 + (SELECT a FROM t1 WHERE b = '1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	ALL	PRIMARY,b	NULL	NULL	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p1	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p0,p1,p2	ALL	PRIMARY,b	NULL	NULL	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	12
HANDLER_READ_NEXT	3
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = 7 + sf_a_from_t1b_d('1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	10
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = sf_a_from_t1b('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = sf_a_from_t1b_d('1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	Impossible WHERE
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p1,p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
8	8
ROLLBACK;
FLUSH STATUS;
SET autocommit = 0;
LOCK TABLES t1 read, t2 write;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') OR a = 2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	2
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_KEY	5
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
8	8
ROLLBACK;
UNLOCK TABLES;
EXPLAIN PARTITIONS DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	p2	range	PRIMARY,b	PRIMARY	4	NULL	#	Using where
2	SUBQUERY	t1	p0,p1,p2	ref	b	b	258	const	#	Using where; Using index
FLUSH STATUS;
START TRANSACTION;
DELETE FROM t2 WHERE a = (SELECT a FROM t1 WHERE b = '1') AND a = 2 OR a = 8 AND sf_a_from_t1b('2');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	20
HANDLER_READ_KEY	7
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
SELECT * FROM t2;
a	b
1	1
2	2
ROLLBACK;
set @@autocommit= @old_autocommit;
DROP FUNCTION sf_add_hello;
DROP FUNCTION sf_add_1;
DROP FUNCTION sf_a_from_t1b_d;
DROP FUNCTION sf_a_from_t1b;
DROP TABLE tq, tsq, t1, t2;
SET @@global.innodb_stats_persistent= @old_innodb_stats_persistent;
