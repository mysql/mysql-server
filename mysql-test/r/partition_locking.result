# Original tests for WL#4443
# Must have InnoDB as engine to get the same statistics results.
# embedded uses MyISAM as default. CREATE SELECT uses the default engine.
SET @old_default_storage_engine = @@default_storage_engine;
SET @@default_storage_engine = 'InnoDB';
CREATE TABLE t1 (a int PRIMARY KEY, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY AUTO_INCREMENT, b varchar(128))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
# Test insert
# TODO: Implement lock pruning for INSERT
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, p1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, duplicate');
ERROR 23000: Duplicate entry '1' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_ROLLBACK	1
HANDLER_WRITE	18
FLUSH STATUS;
INSERT INTO t1 VALUES (0, 'First row, p0'), (2, 'First row, p2'),
(3, 'First row, p3'), (4, 'First row, p4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	10
HANDLER_WRITE	21
FLUSH STATUS;
INSERT INTO t1 VALUES (1 * 13, 'Second row, p0'), (2 * 13, 'Third row, p0'),
(3 * 13, 'Fourth row, p0'), (4 * 13, 'Fifth row, p0');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	21
FLUSH STATUS;
INSERT INTO t2 VALUES (NULL, 'First auto-inc row');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# Test insert select
FLUSH STATUS;
TRUNCATE TABLE t2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a IN (1,4);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	34
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	19
# Test insert on duplicated key update
# Test select
FLUSH STATUS;
SELECT * FROM t1;
a	b
0	First row, p0
1	First row, p1
13	Second row, p0
2	First row, p2
26	Third row, p0
3	First row, p3
39	Fourth row, p0
4	First row, p4
52	Fifth row, p0
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	9
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 where a in (0, 1, 4) ORDER BY a;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	7
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 where a in (13, 26, 39, 52);
a	b
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 where a = 3;
a	b
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 where b like 'First%' ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
# Test pruning of non static values
# They will need to lock all partitions, but will allow pruning
# due to a second pruning call in optimize.
CREATE TABLE t3 (a INT);
INSERT INTO t3 VALUES (1);
SHOW CREATE TABLE t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `a` int(11) NOT NULL,
  `b` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`a`),
  KEY `b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY HASH (a)
PARTITIONS 13 */
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# TODO: Partition wise joins ?
FLUSH STATUS;
SELECT t1.a FROM t1 INNER JOIN t3 ON t1.a = t3.a;
a
1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT t1.a, t1.b FROM t1 INNER JOIN t3 ON t1.a = t3.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	Using where
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	eq_ref	PRIMARY	PRIMARY	4	test.t3.a	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p1	const	PRIMARY	PRIMARY	4	const	1	
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 1;
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT COUNT(*) FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
CREATE TABLE t4 SELECT a, b FROM t1;
ALTER TABLE t4 PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	5
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	2	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
INSERT INTO t3 VALUES (3);
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3 LIMIT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	2	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT MAX(a) FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p3	ALL	NULL	NULL	NULL	NULL	2	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	
DROP TABLE t3;
DROP TABLE t4;
# Test select * from (select * from ...)
# Currently derived tables can only be optimized/pruned after locking?
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	22
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3) t4;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	12
HANDLER_WRITE	27
# Test EXPLAIN select * from (select * from ...)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	5	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	7	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a in (0,2,3,13,26)) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	5	
3	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	7	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# Test select ... UNION select ...
FLUSH STATUS;
SELECT * FROM t1 UNION SELECT * from t2;
a	b
52	Fifth row, p0
0	First row, p0
39	Fourth row, p0
13	Second row, p0
26	Third row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_FIRST	26
HANDLER_READ_KEY	26
HANDLER_READ_NEXT	9
HANDLER_READ_RND_NEXT	26
HANDLER_WRITE	28
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	21
HANDLER_WRITE	23
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	26
HANDLER_WRITE	27
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2) t3) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * from t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2 WHERE a = 1) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	7
HANDLER_READ_RND_NEXT	16
HANDLER_WRITE	30
# Test EXPLAIN select ... UNION select ...
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 UNION SELECT * from t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	index	NULL	b	131	NULL	17	Using index
2	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
2	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
3	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,3>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2) t3) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	17	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union3,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union2,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * from t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2 WHERE a = 1) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	const	PRIMARY	PRIMARY	4	const	1	
NULL	UNION RESULT	<union2,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 UNION SELECT * from t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	17	Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
3	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * from t2) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	17	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union3,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * from t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * from t2 WHERE a = 1) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	7	Using where; Using index
4	UNION	t2	p1	const	PRIMARY	PRIMARY	4	const	1	
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# Test EXPLAIN select
FLUSH STATUS;
EXPLAIN SELECT * FROM t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	NULL	b	131	NULL	17	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 where a in (0, 1, 4) ORDER BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	PRIMARY	PRIMARY	4	NULL	7	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 where a in (13, 26, 39, 52);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	PRIMARY	b	131	NULL	5	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 where a = 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	const	PRIMARY	PRIMARY	4	const	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 where b like 'First%' ORDER BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	b	b	131	NULL	13	Using where; Using index; Using filesort
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	17	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 where a in (0, 1, 4) ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p4	index	PRIMARY	PRIMARY	4	NULL	7	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 where a in (13, 26, 39, 52);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0	index	PRIMARY	b	131	NULL	5	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 where a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	const	PRIMARY	PRIMARY	4	const	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 where b like 'First%' ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	b	b	131	NULL	13	Using where; Using index; Using filesort
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# Test EXPLAIN select * from (select * from ...)
# Test EXPLAIN select ... UNION select ...
# Test delete
# Test multi table delete
# Test load ?
# Test load ?
# Test insert
# Test insert on duplicated key update
# Test insert select
# Test replace
# Test update
SELECT * FROM t1;
a	b
0	First row, p0
1	First row, p1
13	Second row, p0
2	First row, p2
26	Third row, p0
3	First row, p3
39	Fourth row, p0
4	First row, p4
52	Fifth row, p0
# This should be prunable (does not change the partitioning key)
FLUSH STATUS;
UPDATE t1 set b = concat(b, ", updated 1") WHERE a IN (13, 26, 39, 52);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	6
HANDLER_UPDATE	4
HANDLER_WRITE	17
# This should not be prunable (only after implementing 'update pruning')
# i.e if all changed partitioning field is set to constant values,
# set lock_partitions to be a union of read_partition and the matching
# partition for the constants. Easy if all partitioning fields are set,
# probably needs a second round of prune_partitions() with these fields
# set to see if possible to prune locks.
FLUSH STATUS;
UPDATE t1 set a = 99, b = concat(b, ", updated 2 -> p8") WHERE a = 13;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# This should use ha_update_row instead of ha_write_row + ha_delete_row
FLUSH STATUS;
UPDATE t1 set a = 13 + 99, b = concat(b, ", updated 3") WHERE a = 99;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# This should not be prunable (only after implementing
# 'optimized update pruning', which will probably never happen, since
# it depends on which partitioning type is used (for this only hash is
# simple, but range and list is possible, key is very hard)
FLUSH STATUS;
UPDATE t1 set a = a + 1, b = concat(b, ", updated 4 -> p9") WHERE a = 112;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# Test multi table update
SELECT * FROM t1;
a	b
0	First row, p0
1	First row, p1
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
2	First row, p2
26	Third row, p0, updated 1
3	First row, p3
39	Fourth row, p0, updated 1
4	First row, p4
52	Fifth row, p0, updated 1
# Test CREATE SELECT
# Test Stored procedures
DROP PROCEDURE IF EXISTS sp_insert;
DROP PROCEDURE IF EXISTS sp_insert_partition;
DROP PROCEDURE IF EXISTS sp_select_all;
DROP PROCEDURE IF EXISTS sp_select_exact;
DROP PROCEDURE IF EXISTS sp_select_partition;
DROP PROCEDURE IF EXISTS sp_select_range;
CREATE PROCEDURE sp_insert(a INT, b CHAR(16))
INSERT INTO test.t1 VALUES (a, b);
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16))
BEGIN
SET @str = concat("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)");
set @x = a, @y = b;
PREPARE stmt FROM @str;
EXECUTE stmt USING @x, @y;
END|
CREATE PROCEDURE sp_select_all()
SELECT * FROM test.t1;
CREATE PROCEDURE sp_select_exact(x INT)
SELECT * FROM test.t1 WHERE a = x;
CREATE PROCEDURE sp_select_partition(p CHAR(16))
BEGIN
SET @str = concat("SELECT * FROM test.t1 PARTITION(", p, ")");
PREPARE stmt FROM @str;
EXECUTE stmt;
END|
CREATE PROCEDURE sp_select_range(x INT, y INT)
SELECT * FROM test.t1 WHERE a between x and y;
FLUSH STATUS;
CALL sp_insert(313,"Test313");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
FLUSH STATUS;
CALL sp_insert_partition("p7", 98, "Test98");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
FLUSH STATUS;
CALL sp_insert_partition("p8", 111, "Test111");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_insert_partition("p7,p8", 111, "Test111");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
FLUSH STATUS;
CALL sp_select_all();
a	b
0	First row, p0
1	First row, p1
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
2	First row, p2
26	Third row, p0, updated 1
3	First row, p3
313	Test313
39	Fourth row, p0, updated 1
4	First row, p4
52	Fifth row, p0, updated 1
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	14
HANDLER_READ_NEXT	12
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_select_exact(98);
a	b
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	2
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_select_partition("p7");
a	b
111	Test111
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_select_partition("p8");
a	b
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_select_partition("p7,p8");
a	b
111	Test111
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
FLUSH STATUS;
CALL sp_select_range(1,5);
a	b
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_KEY	6
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
DROP PROCEDURE sp_insert;
DROP PROCEDURE sp_insert_partition;
DROP PROCEDURE sp_select_all;
DROP PROCEDURE sp_select_partition;
DROP PROCEDURE sp_select_range;
DROP PROCEDURE sp_select_exact;
DROP TABLE t1, t2;
# DO is not supported by WL#4443 !!!
# Test of DO (eg. SELECT without returning values)
CREATE TABLE t1 (a INT, b VARCHAR(66))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "One"), (2, "Two"), (3, "Three"), (4, "Four"), (5, "Five"), (6, "Six"), (0, "Zero");
DO (SELECT a FROM t1);
Warnings:
Error	1242	Subquery returns more than 1 row
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
SELECT @x;
@x
Five
# TODO: Report this as a bug:
# EXPLAIN PARTITIONS DO (SELECT @x:= b FROM t1 WHERE a = 5);
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT @x;
@x
Five
# TODO: Report this as a bug:
# EXPLAIN PARTITIONS DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
DROP TABLE t1;
# Test EXCHANGE PARTITION to only lock exchanged partition
CREATE TABLE t1 (a INT, b VARCHAR(44));
CREATE TABLE t2 (a INT, b VARCHAR(44))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (10, "Ten"), (13, "Thirteen"), (16, "Sixteen");
INSERT INTO t2 VALUES (0, "Zero"), (1, "One"), (2, "Two"),
(3, "Three"), (4, "Four"), (5, "Five"),
(6, "Six"), (7, "Seven"), (8, "Eight");
FLUSH STATUS;
ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
SELECT * FROM t1 ORDER BY a;
a	b
1	One
4	Four
7	Seven
SELECT * FROM t2 ORDER BY a;
a	b
0	Zero
2	Two
3	Three
5	Five
6	Six
8	Eight
10	Ten
13	Thirteen
16	Sixteen
DROP TABLE t1, t2;
# TODO: Add variants for LOCK TABLES
# TODO: add delayed locking/pruning for multi-table update
# TODO: Document that functions in WHERE clause can now be evaluated
#       before any locks are taken (i.e. if optimization is possible
#       before locking).
# Prepared statement
CREATE TABLE t1 (N int, M tinyint);
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
# Check if we can infer from condition on partition fields that 
# no records will match.
create table t1 ( a int not null) partition by hash(a) partitions 2;
insert into t1 values (1),(2),(3);
explain select * from t1 where a=5 and a=6;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
drop table t1;
