drop table if exists t1,t2,t3,t4,t9,`t1a``b`,v1,v2,v3,v4,v5,v6;
drop view if exists t1,t2,`t1a``b`,v1,v2,v3,v4,v5,v6;
drop database if exists mysqltest;
use test;
create view v1 (c,d) as select a,b from t1;
ERROR 42S02: Table 'test.t1' doesn't exist
create temporary table t1 (a int, b int);
create view v1 (c) as select b+1 from t1;
ERROR HY000: View's SELECT refers to a temporary table 't1'
drop table t1;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1 (c,d) as select a,b+@@global.max_user_connections from t1;
ERROR HY000: View's SELECT contains a variable or parameter
create view v1 (c,d) as select a,b from t1
where a = @@global.max_user_connections;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT @a=1 FROM DUAL;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE @a>1;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT (@a:= 1) AS one FROM DUAL;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE (@a:= 1);
ERROR HY000: View's SELECT contains a variable or parameter
create view v1 (c) as select b+1 from t1;
select c from v1;
c
3
4
5
6
11
select is_updatable from information_schema.views where table_name='v1';
IS_UPDATABLE
NO
create temporary table t1 (a int, b int);
select * from t1;
a	b
select c from v1;
c
3
4
5
6
11
show create table v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
show create view t1;
ERROR HY000: 'test.t1' is not VIEW
drop table t1;
select a from v1;
ERROR 42S22: Unknown column 'a' in 'field list'
select v1.a from v1;
ERROR 42S22: Unknown column 'v1.a' in 'field list'
select b from v1;
ERROR 42S22: Unknown column 'b' in 'field list'
select v1.b from v1;
ERROR 42S22: Unknown column 'v1.b' in 'field list'
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
explain select c from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`b` + 1) AS `c` from `test`.`t1`
create algorithm=temptable view v2 (c) as select b+1 from t1;
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select c from v2;
c
3
4
5
6
11
explain select c from v2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`v2`.`c` AS `c` from `test`.`v2`
create view v3 (c) as select a+1 from v1;
ERROR 42S22: Unknown column 'a' in 'field list'
create view v3 (c) as select b+1 from v1;
ERROR 42S22: Unknown column 'b' in 'field list'
create view v3 (c) as select c+1 from v1;
select c from v3;
c
4
5
6
7
12
explain select c from v3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`b` + 1) + 1) AS `c` from `test`.`t1`
create algorithm=temptable view v4 (c) as select c+1 from v2;
select c from v4;
c
4
5
6
7
12
explain select c from v4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`v4`.`c` AS `c` from `test`.`v4`
create view v5 (c) as select c+1 from v2;
select c from v5;
c
4
5
6
7
12
explain select c from v5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`v2`.`c` + 1) AS `c` from `test`.`v2`
create algorithm=temptable view v6 (c) as select c+1 from v1;
select c from v6;
c
4
5
6
7
12
explain select c from v6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`v6`.`c` AS `c` from `test`.`v6`
show tables;
Tables_in_test
t1
v1
v2
v3
v4
v5
v6
show full tables;
Tables_in_test	Table_type
t1	BASE TABLE
v1	VIEW
v2	VIEW
v3	VIEW
v4	VIEW
v5	VIEW
v6	VIEW
show table status;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	InnoDB	10	Dynamic	#	#	#	#	0	0	NULL	#	#	NULL	utf8mb4_0900_ai_ci	NULL		
v1	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v2	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v3	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v4	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v5	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v6	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
drop view v1,v2,v3,v4,v5,v6;
create view v1 (c,d,e,f) as select a,b,
a in (select a+2 from t1), a = all (select a from t1) from t1;
create view v2 as select c, d from v1;
select * from v1;
c	d	e	f
1	2	0	0
1	3	0	0
2	4	0	0
2	5	0	0
3	10	1	0
select * from v2;
c	d
1	2
1	3
2	4
2	5
3	10
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1;
ERROR 42S01: Table 'v1' already exists
create or replace view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1;
drop view v2;
alter view v2 as select c, d from v1;
ERROR 42S02: Table 'test.v2' doesn't exist
create or replace view v2 as select c, d from v1;
alter view v1 (c,d) as select a,max(b) from t1 group by a;
select * from v1;
c	d
1	3
2	5
3	10
select * from v2;
c	d
1	3
2	5
3	10
drop view v100;
ERROR 42S02: Unknown table 'test.v100'
drop view t1;
ERROR HY000: 'test.t1' is not VIEW
drop table v1;
ERROR 42S02: Unknown table 'test.v1'
drop view v1,v2;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3);
create view v1 (a) as select a+1 from t1;
create view v2 (a) as select a-1 from t1;
select * from t1 natural left join v1;
a
1
2
3
select * from v2 natural left join t1;
a
0
1
2
select * from v2 natural left join v1;
a
0
1
2
drop view v1, v2;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3), (1), (2), (3);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select distinct a from t1;
select * from v1;
a
1
2
3
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
select * from t1;
a
1
2
3
1
2
3
drop view v1;
drop table t1;
create table t1 (a int);
create view v1 as select distinct a from t1 WITH CHECK OPTION;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v1'
create view v1 as select a from t1 WITH CHECK OPTION;
create view v2 as select a from t1 WITH CASCADED CHECK OPTION;
create view v3 as select a from t1 WITH LOCAL CHECK OPTION;
drop view v3 RESTRICT;
drop view v2 CASCADE;
drop view v1;
drop table t1;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1 (c) as select b+1 from t1;
select test.c from v1 test;
c
3
4
5
6
11
create algorithm=temptable view v2 (c) as select b+1 from t1;
select test.c from v2 test;
c
3
4
5
6
11
select test1.* from v1 test1, v2 test2 where test1.c=test2.c;
c
3
4
5
6
11
select test2.* from v1 test1, v2 test2 where test1.c=test2.c;
c
3
4
5
6
11
drop table t1;
drop view v1,v2;
create table t1 (a int);
insert into t1 values (1), (2), (3), (4);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select a+1 from t1 order by 1 desc limit 2;
select * from v1;
a+1
5
4
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a+1` AS `a+1` from `test`.`v1`
drop view v1;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3), (4);
create view v1 as select a+1 from t1;
create table t2 select * from v1;
show columns from t2;
Field	Type	Null	Key	Default	Extra
a+1	bigint	YES		NULL	
select * from t2;
a+1
2
3
4
5
drop view v1;
drop table t1,t2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (10,2), (20,3), (30,4), (40,5), (50,10);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
select is_updatable from information_schema.views where table_name='v2';
IS_UPDATABLE
NO
select is_updatable from information_schema.views where table_name='v1';
IS_UPDATABLE
YES
update v1 set c=a+c;
ERROR HY000: Column 'c' is not updatable
update v2 set a=a+c;
ERROR HY000: The target table v2 of the UPDATE is not updatable
update v1 set a=a+c;
select * from v1;
a	c
13	3
24	4
35	5
46	6
61	11
select * from t1;
a	b
13	2
24	3
35	4
46	5
61	10
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (10,2), (20,3), (30,4), (40,5), (50,10);
create table t2 (x int);
insert into t2 values (10), (20);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
update t2,v1 set v1.c=v1.a+v1.c where t2.x=v1.a;
ERROR HY000: Column 'c' is not updatable
update t2,v2 set v2.a=v2.a+c where t2.x=v2.a;
ERROR HY000: The target table v2 of the UPDATE is not updatable
update t2,v1 set v1.a=v1.a+v1.c where t2.x=v1.a;
select * from v1;
a	c
13	3
24	4
30	5
40	6
50	11
select * from t1;
a	b
13	2
24	3
30	4
40	5
50	10
drop table t1,t2;
drop view v1,v2;
create table t1 (a int, b int, primary key(b));
insert into t1 values (1,20), (2,30), (3,40), (4,50), (5,100);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 (c) as select b from t1 where a<3;
select * from v1;
c
20
30
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`b` AS `c` from `test`.`t1` where (`test`.`t1`.`a` < 3)
update v1 set c=c+1;
select * from t1;
a	b
1	21
2	31
3	40
4	50
5	100
create view v2 (c) as select b from t1 where a>=3;
select * from v1, v2;
c	c
21	100
21	40
21	50
31	100
31	40
31	50
drop view v1, v2;
drop table t1;
create table t1 (a int, b int, primary key(a));
insert into t1 values (1,2), (2,3), (3,4), (4,5), (5,10);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
delete from v2 where c < 4;
ERROR HY000: The target table v2 of the DELETE is not updatable
delete from v1 where c < 4;
select * from v1;
a	c
2	4
3	5
4	6
5	11
select * from t1;
a	b
2	3
3	4
4	5
5	10
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (1,2), (2,3), (3,4), (4,5), (5,10);
create table t2 (x int);
insert into t2 values (1), (2), (3), (4);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
delete v2 from t2,v2 where t2.x=v2.a;
ERROR HY000: The target table v2 of the DELETE is not updatable
delete v1 from t2,v1 where t2.x=v1.a;
select * from v1;
a	c
5	11
select * from t1;
a	b
5	10
drop table t1,t2;
drop view v1,v2;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2), (30,4,-3), (40,5,-4), (50,10,-5);
create view v1 (x,y) as select a, b from t1;
create view v2 (x,y) as select a, c from t1;
set updatable_views_with_limit=NO;
update v1 set x=x+1;
update v2 set x=x+1;
update v1 set x=x+1 limit 1;
update v2 set x=x+1 limit 1;
ERROR HY000: The target table v2 of the UPDATE is not updatable
delete from v2 limit 1;
ERROR HY000: The target table v2 of the DELETE is not updatable
set updatable_views_with_limit=YES;
update v1 set x=x+1 limit 1;
update v2 set x=x+1 limit 1;
Warnings:
Note	1355	View being updated does not have complete key of underlying table in it
set updatable_views_with_limit=DEFAULT;
show variables like "updatable_views_with_limit";
Variable_name	Value
updatable_views_with_limit	YES
select * from t1;
a	b	c
15	2	-1
22	3	-2
32	4	-3
42	5	-4
52	10	-5
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2);
create view v1 (x,y,z) as select c, b, a from t1;
create view v2 (x,y) as select b, a from t1;
create view v3 (x,y,z) as select b, a, b from t1;
create view v4 (x,y,z) as select c+1, b, a from t1;
create algorithm=temptable view v5 (x,y,z) as select c, b, a from t1;
insert into v3 values (-60,4,30);
ERROR HY000: The target table v3 of the INSERT is not insertable-into
insert into v4 values (-60,4,30);
ERROR HY000: Column 'x' is not updatable
insert into v5 values (-60,4,30);
ERROR HY000: The target table v5 of the INSERT is not insertable-into
insert into v1 values (-60,4,30);
insert into v1 (z,y,x) values (50,6,-100);
insert into v2 values (5,40);
select * from t1;
a	b	c
10	2	-1
20	3	-2
30	4	-60
40	5	NULL
50	6	-100
drop table t1;
drop view v1,v2,v3,v4,v5;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2);
create table t2 (a int, b int, c int, primary key(a,b));
insert into t2 values (30,4,-60);
create view v1 (x,y,z) as select c, b, a from t1;
create view v2 (x,y) as select b, a from t1;
create view v3 (x,y,z) as select b, a, b from t1;
create view v4 (x,y,z) as select c+1, b, a from t1;
create algorithm=temptable view v5 (x,y,z) as select c, b, a from t1;
insert into v3 select c, b, a from t2;
ERROR HY000: The target table v3 of the INSERT is not insertable-into
insert into v4 select c, b, a from t2;
ERROR HY000: Column 'x' is not updatable
insert into v5 select c, b, a from t2;
ERROR HY000: The target table v5 of the INSERT is not insertable-into
insert into v1 select c, b, a from t2;
insert into v1 (z,y,x) select a+20,b+2,-100 from t2;
insert into v2 select b+1, a+10 from t2;
select * from t1;
a	b	c
10	2	-1
20	3	-2
30	4	-60
40	5	NULL
50	6	-100
drop table t1, t2;
drop view v1,v2,v3,v4,v5;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3);
create view v1 (x) as select a from t1 where a > 1;
select t1.a, v1.x from t1 left join v1 on (t1.a= v1.x);
a	x
1	NULL
2	2
3	3
drop table t1;
drop view v1;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3), (200);
create view v1 (x) as select a from t1 where a > 1;
create view v2 (y) as select x from v1 where x < 100;
select * from v2;
y
2
3
drop table t1;
drop view v1,v2;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3), (200);
create ALGORITHM=TEMPTABLE view v1 (x) as select a from t1;
create view v2 (y) as select x from v1;
update v2 set y=10 where y=2;
ERROR HY000: The target table v2 of the UPDATE is not updatable
drop table t1;
drop view v1,v2;
create table t1 (a int not null auto_increment, b int not null, primary key(a), unique(b));
create view v1 (x) as select b from t1;
insert into v1 values (1);
select last_insert_id();
last_insert_id()
0
insert into t1 (b) values (2);
select last_insert_id();
last_insert_id()
2
select * from t1;
a	b
1	1
2	2
drop view v1;
drop table t1;
set sql_mode='ansi';
create table t1 ("a*b" int);
create view v1 as select "a*b" from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE VIEW "v1" AS select "t1"."a*b" AS "a*b" from "t1"	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
set sql_mode=default;
create table t1 (t_column int);
create view v1 as select 'a';
select * from v1, t1;
a	t_column
drop view v1;
drop table t1;
create table `t1a``b` (col1 char(2));
create view v1 as select * from `t1a``b`;
select * from v1;
col1
describe v1;
Field	Type	Null	Key	Default	Extra
col1	char(2)	YES		NULL	
drop view v1;
drop table `t1a``b`;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
create table t1 (col1 char(5),col2 char(5));
create view v1 as select * from t1;
drop table t1;
create table t1 (col1 char(5),newcol2 char(5));
insert into v1 values('a','aa');
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop table t1;
select * from v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop view v1;
SET sql_mode = default;
create view v1 (a,a) as select 'a','a';
ERROR 42S21: Duplicate column name 'a'
create table t1 (col1 int,col2 char(22));
insert into t1 values(5,'Hello, world of views');
create view v1 as select * from t1;
create view v2 as select * from v1;
update v2 set col2='Hello, view world';
select is_updatable from information_schema.views where
table_schema != 'sys' and table_schema != 'information_schema';
IS_UPDATABLE
YES
YES
select * from t1;
col1	col2
5	Hello, view world
drop view v2, v1;
drop table t1;
create table t1 (a int, b int);
create view v1 as select a, sum(b) from t1 group by a;
select b from v1 use index (some_index) where b=1;
ERROR 42000: Key 'some_index' doesn't exist in table 'v1'
drop view v1;
drop table t1;
create table t1 (col1 char(5),col2 char(5));
create view v1 (col1,col2) as select col1,col2 from t1;
insert into v1 values('s1','p1'),('s1','p2'),('s1','p3'),('s1','p4'),('s2','p1'),('s3','p2'),('s4','p4');
select distinct first.col2 from t1 first where first.col2 in (select second.col2 from t1 second where second.col1<>first.col1);
col2
p1
p2
p4
select distinct first.col2 from v1 first where first.col2 in (select second.col2 from t1 second where second.col1<>first.col1);
col2
p1
p2
p4
drop view v1;
drop table t1;
create table t1 (a int);
create view v1 as select a from t1;
insert into t1 values (1);
SET @v0 = '2';
PREPARE stmt FROM 'UPDATE v1 SET a = ?';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
SET @v0 = '3';
PREPARE stmt FROM 'insert into v1 values (?)';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
SET @v0 = '4';
PREPARE stmt FROM 'insert into v1 (a) values (?)';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
select * from t1;
a
2
3
4
drop view v1;
drop table t1;
CREATE VIEW v02 AS SELECT * FROM DUAL;
ERROR HY000: No tables used
SHOW TABLES;
Tables_in_test
CREATE VIEW v1 AS SELECT EXISTS (SELECT 1 UNION SELECT 2);
select * from v1;
EXISTS (SELECT 1 UNION SELECT 2)
1
drop view v1;
create table t1 (col1 int,col2 char(22));
create view v1 as select * from t1;
create index i1 on v1 (col1);
ERROR HY000: 'test.v1' is not BASE TABLE
drop view v1;
drop table t1;
CREATE VIEW v1 (f1,f2,f3,f4) AS SELECT connection_id(), pi(), current_user(), version();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`f1`,`f2`,`f3`,`f4`) AS select connection_id() AS `connection_id()`,pi() AS `pi()`,current_user() AS `current_user()`,version() AS `version()`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create table t1 (s1 int);
create table t2 (s2 int);
insert into t1 values (1), (2);
insert into t2 values (2), (3);
create view v1 as select * from t1,t2 union all select * from t1,t2;
select * from v1;
s1	s2
1	2
1	2
1	3
1	3
2	2
2	2
2	3
2	3
drop view v1;
drop tables t1, t2;
create table t1 (col1 int);
insert into t1 values (1);
create view v1 as select count(*) from t1;
insert into t1 values (null);
select * from v1;
count(*)
2
drop view v1;
drop table t1;
create table t1 (a int);
create table t2 (a int);
create view v1 as select a from t1;
create view v2 as select a from t2 where a in (select a from v1);
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t2`.`a` AS `a` from `t2` where `t2`.`a` in (select `v1`.`a` from `v1`)	utf8mb4	utf8mb4_0900_ai_ci
drop view v2, v1;
drop table t1, t2;
CREATE VIEW `v 1` AS select 5 AS `5`;
show create view `v 1`;
View	Create View	character_set_client	collation_connection
v 1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v 1` AS select 5 AS `5`	utf8mb4	utf8mb4_0900_ai_ci
drop view `v 1`;
create database mysqltest;
create table mysqltest.t1 (a int, b int);
create view mysqltest.v1 as select a from mysqltest.t1;
alter view mysqltest.v1 as select b from mysqltest.t1;
alter view mysqltest.v1 as select a from mysqltest.t1;
drop database mysqltest;
CREATE TABLE t1 (c1 int not null auto_increment primary key, c2 varchar(20), fulltext(c2));
insert into t1 (c2) VALUES ('real Beer'),('Water'),('Kossu'),('Coca-Cola'),('Vodka'),('Wine'),('almost real Beer');
select * from t1 WHERE match (c2) against ('Beer');
c1	c2
1	real Beer
7	almost real Beer
CREATE VIEW v1 AS SELECT  * from t1 WHERE match (c2) against ('Beer');
select * from v1;
c1	c2
1	real Beer
7	almost real Beer
drop view v1;
drop table t1;
create table t1 (a int);
insert into t1 values (1),(1),(2),(2),(3),(3);
create view v1 as select a from t1;
select distinct a from v1;
a
1
2
3
select distinct a from v1 limit 2;
a
1
2
select distinct a from t1 limit 2;
a
1
2
prepare stmt1 from "select distinct a from v1 limit 2";
execute stmt1;
a
1
2
execute stmt1;
a
1
2
deallocate prepare stmt1;
drop view v1;
drop table t1;
create table t1 (tg_column bigint);
create view v1 as select count(tg_column) as vg_column from t1;
select avg(vg_column) from v1;
avg(vg_column)
0.0000
drop view v1;
drop table t1;
create table t1 (col1 bigint not null, primary key (col1));
create table t2 (col1 bigint not null, key (col1));
create view v1 as select * from t1;
create view v2 as select * from t2;
insert into v1 values (1);
insert into v2 values (1);
create view v3 (a,b) as select v1.col1 as a, v2.col1 as b from v1, v2 where v1.col1 = v2.col1;
select * from v3;
a	b
1	1
show create view v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` (`a`,`b`) AS select `v1`.`col1` AS `a`,`v2`.`col1` AS `b` from (`v1` join `v2`) where (`v1`.`col1` = `v2`.`col1`)	utf8mb4	utf8mb4_0900_ai_ci
drop view v3, v2, v1;
drop table t2, t1;
create function `f``1` () returns int return 5;
create view v1 as select test.`f``1` ();
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `test`.`f``1`() AS `test.``f````1`` ()`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
test.`f``1` ()
5
drop view v1;
drop function `f``1`;
create function a() returns int return 5;
create view v1 as select a();
select * from v1;
a()
5
drop view v1;
drop function a;
create table t2 (col1 char collate latin1_german2_ci);
create view v2 as select col1 collate latin1_german1_ci from t2;
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select (`t2`.`col1` collate latin1_german1_ci) AS `col1 collate latin1_german1_ci` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select (`t2`.`col1` collate latin1_german1_ci) AS `col1 collate latin1_german1_ci` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
drop view v2;
drop table t2;
create table t1 (a int);
insert into t1 values (1), (2);
create view v1 as select 5 from t1 order by 1;
select * from v1;
5
5
5
drop view v1;
drop table t1;
create function x1 () returns int return 5;
create table t1 (s1 int);
create view v1 as select x1() from t1;
drop function x1;
select * from v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
show table status;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	InnoDB	10	Dynamic	#	#	#	#	0	0	NULL	#	#	NULL	utf8mb4_0900_ai_ci	NULL		
v1	NULL	NULL	NULL	#	#	#	#	NULL	NULL	NULL	#	#	NULL	NULL	NULL	NULL	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
Warnings:
Warning	1356	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop view v1;
drop table t1;
create view v1 as select 99999999999999999999999999999999999999999999999999999 as col1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 99999999999999999999999999999999999999999999999999999 AS `col1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
SET @old_cs_client = @@character_set_client;
SET @old_cs_results = @@character_set_results;
SET @old_cs_connection = @@character_set_connection;
set names utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
create table tü (cü char);
create view vü as select cü from tü;
insert into vü values ('ü');
select * from vü;
cü
ü
drop view vü;
drop table tü;
SET character_set_client = @old_cs_client;
SET character_set_results = @old_cs_results;
SET character_set_connection = @old_cs_connection;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1(c) as select a+1 from t1 where b >= 4;
select c from v1 where exists (select * from t1 where a=2 and b=c);
c
4
drop view v1;
drop table t1;
create view v1 as select cast(1 as char(3));
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select cast(1 as char(3) charset utf8mb4) AS `cast(1 as char(3))`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
cast(1 as char(3))
1
drop view v1;
create table t1 (a int);
create view v1 as select a from t1;
create view v3 as select a from t1;
create database mysqltest;
rename table v1 to mysqltest.v1;
ERROR HY000: Changing schema from 'test' to 'mysqltest' is not allowed.
rename table v1 to v2;
rename table v3 to v1, v2 to t1;
ERROR 42S01: Table 't1' already exists
drop table t1;
drop view v2,v3;
drop database mysqltest;
create view v1 as select 'a',1;
create view v2 as select * from v1 union all select * from v1;
create view v3 as select * from v2 where 1 = (select `1` from v2);
create view v4 as select * from v3;
select * from v4;
ERROR 21000: Subquery returns more than 1 row
drop view v4, v3, v2, v1;
create view v1 as select 5 into @w;
ERROR HY000: View's SELECT contains a 'INTO' clause
create view v1 as select 5 into outfile 'ttt';
ERROR HY000: View's SELECT contains a 'INTO' clause
create table t1 (a int);
create view v1 as select 1 from (select 1) as d1;
drop view v1;
drop table t1;
create table t1 (s1 int, primary key (s1));
create view v1 as select * from t1;
insert into v1 values (1) on duplicate key update s1 = 7;
insert into v1 values (1) on duplicate key update s1 = 7;
select * from t1;
s1
7
drop view v1;
drop table t1;
create table t1 (col1 int);
create table t2 (col1 int);
create table t3 (col1 datetime not null);
create view v1 as select * from t1;
create view v2 as select * from v1;
create view v3 as select v2.col1 from v2,t2 where v2.col1 = t2.col1;
update v2 set col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v2'.
update v2 set col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v2'.
update v2 set col1 = (select max(col1) from v2);
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
update v2,t2 set v2.col1 = (select max(col1) from v1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v2'.
update t1,t2 set t1.col1 = (select max(col1) from v1) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't1'.
update v1,t2 set v1.col1 = (select max(col1) from v1) where v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v1' for update in FROM clause
update t2,v2 set v2.col1 = (select max(col1) from v1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update t2,t1 set t1.col1 = (select max(col1) from v1) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update t2,v1 set v1.col1 = (select max(col1) from v1) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update v2,t2 set v2.col1 = (select max(col1) from t1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v2'.
update t1,t2 set t1.col1 = (select max(col1) from t1) where t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't1' for update in FROM clause
update v1,t2 set v1.col1 = (select max(col1) from t1) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v1'.
update t2,v2 set v2.col1 = (select max(col1) from t1) where v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update t2,t1 set t1.col1 = (select max(col1) from t1) where t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update t2,v1 set v1.col1 = (select max(col1) from t1) where v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update v2,t2 set v2.col1 = (select max(col1) from v2) where v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
update t1,t2 set t1.col1 = (select max(col1) from v2) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't1'.
update v1,t2 set v1.col1 = (select max(col1) from v2) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v1'.
update t2,v2 set v2.col1 = (select max(col1) from v2) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update t2,t1 set t1.col1 = (select max(col1) from v2) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update t2,v1 set v1.col1 = (select max(col1) from v2) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update v3 set v3.col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v3' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from v2);
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from v3);
ERROR HY000: You can't specify target table 'v3' for update in FROM clause
delete from v2 where col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v2'.
delete from v2 where col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v2'.
delete from v2 where col1 = (select max(col1) from v2);
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
delete v2 from v2,t2 where (select max(col1) from v1) > 0 and v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v2'.
delete t1 from t1,t2 where (select max(col1) from v1) > 0 and t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 't1'.
delete v1 from v1,t2 where (select max(col1) from v1) > 0 and v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v1' for update in FROM clause
delete v2 from v2,t2 where (select max(col1) from t1) > 0 and v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v2'.
delete t1 from t1,t2 where (select max(col1) from t1) > 0 and t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't1' for update in FROM clause
delete v1 from v1,t2 where (select max(col1) from t1) > 0 and v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v1'.
delete v2 from v2,t2 where (select max(col1) from v2) > 0 and v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
delete t1 from t1,t2 where (select max(col1) from v2) > 0 and t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 't1'.
delete v1 from v1,t2 where (select max(col1) from v2) > 0 and v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v1'.
insert into v2 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v2'.
insert into t1 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 't1'.
insert into v2 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v2'.
insert into v2 values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v2'.
insert into t1 values ((select max(col1) from t1));
ERROR HY000: You can't specify target table 't1' for update in FROM clause
insert into v2 values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v2'.
insert into v2 values ((select max(col1) from v2));
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
insert into t1 values ((select max(col1) from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 't1'.
insert into v2 values ((select max(col1) from v2));
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
insert into v3 (col1) values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v3' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select max(col1) from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select CONVERT_TZ('20050101000000','UTC','MET') from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select CONVERT_TZ('20050101000000','UTC','MET') from t2));
insert into t3 values ((select CONVERT_TZ('20050101000000','UTC','MET') from t2));
ERROR 23000: Column 'col1' cannot be null
create algorithm=temptable view v4 as select * from t1;
insert into t1 values (1),(2),(3);
insert into t1 (col1) values ((select max(col1) from v4));
select * from t1;
col1
NULL
1
2
3
3
drop view v4,v3,v2,v1;
drop table t1,t2,t3;
create table t1 (s1 int);
create view v1 as select * from t1;
handler v1 open as xx;
ERROR HY000: 'test.v1' is not BASE TABLE
drop view v1;
drop table t1;
create table t1(a int);
insert into t1 values (0), (1), (2), (3);
create table t2 (a int);
insert into t2 select a from t1 where a > 1;
create view v1 as select a from t1 where a > 1;
select * from t1 left join (t2 as t, v1) on v1.a=t1.a;
a	a	a
0	NULL	NULL
1	NULL	NULL
2	2	2
2	3	2
3	2	3
3	3	3
select * from t1 left join (t2 as t, t2) on t2.a=t1.a;
a	a	a
0	NULL	NULL
1	NULL	NULL
2	2	2
2	3	2
3	2	3
3	3	3
drop view v1;
drop table t1, t2;
create table t1 (s1 char) charset latin1;
create view v1 as select s1 collate latin1_german1_ci as s1 from t1;
insert into v1 values ('a');
select * from v1;
s1
a
update v1 set s1='b';
select * from v1;
s1
b
update v1,t1 set v1.s1='c' where t1.s1=v1.s1;
select * from v1;
s1
c
prepare stmt1 from "update v1,t1 set v1.s1=? where t1.s1=v1.s1";
set @arg='d';
execute stmt1 using @arg;
select * from v1;
s1
d
set @arg='e';
execute stmt1 using @arg;
select * from v1;
s1
e
deallocate prepare stmt1;
drop view v1;
drop table t1;
create table t1 (a int);
create table t2 (a int);
create view v1 as select * from t1;
lock tables t1 read, v1 read;
select * from v1;
a
select * from t2;
ERROR HY000: Table 't2' was not locked with LOCK TABLES
unlock tables;
drop view v1;
drop table t1, t2;
create table t1 (a int);
create view v1 as select * from t1 where a < 2 with check option;
insert into v1 values(1);
insert into v1 values(3);
ERROR HY000: CHECK OPTION failed 'test.v1'
insert ignore into v1 values (2),(3),(0);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
0
delete from t1;
insert into v1 SELECT 1;
insert into v1 SELECT 3;
ERROR HY000: CHECK OPTION failed 'test.v1'
create table t2 (a int);
insert into t2 values (2),(3),(0);
insert ignore into v1 SELECT a from t2;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1 order by a desc;
a
1
0
update v1 set a=-1 where a=0;
update v1 set a=2 where a=1;
ERROR HY000: CHECK OPTION failed 'test.v1'
select * from t1 order by a desc;
a
1
-1
update v1 set a=0 where a=0;
insert into t2 values (1);
update v1,t2 set v1.a=v1.a-1 where v1.a=t2.a;
select * from t1 order by a desc;
a
0
-1
update v1 set a=a+1;
update ignore v1,t2 set v1.a=v1.a+1 where v1.a=t2.a;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
1
drop view v1;
drop table t1, t2;
create table t1 (a int);
create view v1 as select * from t1 where a < 2 with check option;
create view v2 as select * from v1 where a > 0 with local check option;
create view v3 as select * from v1 where a > 0 with cascaded check option;
insert into v2 values (1);
insert into v3 values (1);
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into v3 values (0);
ERROR HY000: CHECK OPTION failed 'test.v3'
insert into v2 values (2);
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into v3 values (2);
ERROR HY000: CHECK OPTION failed 'test.v3'
select * from t1;
a
1
1
drop view v3,v2,v1;
drop table t1;
create table t1 (a int, primary key (a));
create view v1 as select * from t1 where a < 2 with check option;
insert into v1 values (1) on duplicate key update a=2;
insert into v1 values (1) on duplicate key update a=2;
ERROR HY000: CHECK OPTION failed 'test.v1'
insert ignore into v1 values (1) on duplicate key update a=2;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
drop view v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select * from t1;
create view v2 as select * from v1;
alter view v1 as select * from v2;
ERROR 42S02: Table 'test.v1' doesn't exist
alter view v1 as select * from v1;
ERROR 42S02: Table 'test.v1' doesn't exist
create or replace view v1 as select * from v2;
ERROR 42S02: Table 'test.v1' doesn't exist
create or replace view v1 as select * from v1;
ERROR 42S02: Table 'test.v1' doesn't exist
drop view v2,v1;
drop table t1;
create table t1 (a int);
create view v1 as select * from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=undefined view v1 as select * from t1 with check option;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=merge view v1 as select * from t1 with cascaded check option;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=MERGE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=temptable view v1 as select * from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
create table t1 (s1 int);
create table t2 (s1 int);
create view v2 as select * from t2 where s1 in (select s1 from t1);
insert into v2 values (5);
insert into t1 values (5);
select * from v2;
s1
5
update v2 set s1 = 0;
select * from v2;
s1
select * from t2;
s1
0
alter view v2 as select * from t2 where s1 in (select s1 from t1) with check option;
insert into v2 values (5);
update v2 set s1 = 1;
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into t1 values (1);
update v2 set s1 = 1;
select * from v2;
s1
1
select * from t2;
s1
0
1
prepare stmt1 from "select * from v2;";
execute stmt1;
s1
1
insert into t1 values (0);
execute stmt1;
s1
0
1
deallocate prepare stmt1;
drop view v2;
drop table t1, t2;
create table t1 (t time);
create view v1 as select substring_index(t,':',2) as t from t1;
insert into t1 (t) values ('12:24:10');
select substring_index(t,':',2) from t1;
substring_index(t,':',2)
12:24
select substring_index(t,':',2) from v1;
substring_index(t,':',2)
12:24
drop view v1;
drop table t1;
create table t1 (s1 tinyint);
create view v1 as select * from t1 where s1 <> 0 with local check option;
create view v2 as select * from v1 with cascaded check option;
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
drop view v2, v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select * from t1 where s1 < 5 with check option;
insert ignore into v1 values (6);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
insert ignore into v1 values (6),(3);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
s1
3
drop view v1;
drop table t1;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
create table t1 (s1 tinyint);
create trigger t1_bi before insert on t1 for each row set new.s1 = 500;
create view v1 as select * from t1 where s1 <> 127 with check option;
insert into v1 values (0);
ERROR HY000: CHECK OPTION failed 'test.v1'
select * from v1;
s1
select * from t1;
s1
drop trigger t1_bi;
drop view v1;
drop table t1;
SET sql_mode = default;
create table t1 (s1 tinyint);
create view v1 as select * from t1 where s1 <> 0;
create view v2 as select * from v1 where s1 <> 1 with cascaded check option;
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
select * from v2;
s1
select * from t1;
s1
drop view v2, v1;
drop table t1;
create table t1 (a text, b text);
create view v1 as select * from t1 where a <> 'Field A' with check option;
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by '''';
ERROR HY000: CHECK OPTION failed 'test.v1'
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
delete from t1;
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by '''';
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1261	Row 2 doesn't contain data for all columns
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
drop view v1;
drop table t1;
create table t1 (a int, b char(10)) charset latin1;
create view v1 as select * from t1 where a != 0 with check option;
load data infile '../../std_data/loaddata3.dat' into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
ERROR HY000: Incorrect integer value: 'error      ' for column 'a' at row 3
select * from t1;
a	b
select * from v1;
a	b
delete from t1;
load data infile '../../std_data/loaddata3.dat' ignore into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
Warnings:
Warning	1366	Incorrect integer value: 'error      ' for column 'a' at row 3
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1366	Incorrect integer value: 'wrong end  ' for column 'a' at row 4
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a	b
1	row 1
2	row 2
3	row 3
select * from v1;
a	b
1	row 1
2	row 2
3	row 3
drop view v1;
drop table t1;
create table t1 (a text, b text) ;
create view v1 as select * from t1 where a <> 'Field A' with check option;
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by '''';
ERROR HY000: CHECK OPTION failed 'test.v1'
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
delete from t1;
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by '''';
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1261	Row 2 doesn't contain data for all columns
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
drop view v1;
drop table t1;
create table t1 (s1 smallint);
create view v1 as select * from t1 where 20 < (select (s1) from t1);
insert into v1 values (30);
ERROR HY000: The target table v1 of the INSERT is not insertable-into
create view v2 as select * from t1;
create view v3 as select * from t1 where 20 < (select (s1) from v2);
insert into v3 values (30);
ERROR HY000: The target table v3 of the INSERT is not insertable-into
create view v4 as select * from v2 where 20 < (select (s1) from t1);
insert into v4 values (30);
ERROR HY000: The target table v4 of the INSERT is not insertable-into
drop view v4, v3, v2, v1;
drop table t1;
create table t1 (a int);
create view v1 as select * from t1;
check table t1,v1;
Table	Op	Msg_type	Msg_text
test.t1	check	status	OK
test.v1	check	status	OK
check table v1,t1;
Table	Op	Msg_type	Msg_text
test.v1	check	status	OK
test.t1	check	status	OK
drop table t1;
check table v1;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	error	Corrupt
drop view v1;
create table t1 (a int);
create table t2 (a int);
create table t3 (a int);
insert into t1 values (1), (2), (3);
insert into t2 values (1), (3);
insert into t3 values (1), (2), (4);
analyze table t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
create view v3 (a,b) as select t1.a as a, t2.a as b from t1 left join t2 on (t1.a=t2.a);
select * from t3 left join v3 on (t3.a = v3.a);
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
explain select * from t3 left join v3 on (t3.a = v3.a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `b` from `test`.`t3` left join (`test`.`t1` left join `test`.`t2` on((`test`.`t2`.`a` = `test`.`t1`.`a`))) on((`test`.`t1`.`a` = `test`.`t3`.`a`)) where true
create view v1 (a) as select a from t1;
create view v2 (a) as select a from t2;
create view v4 (a,b) as select v1.a as a, v2.a as b from v1 left join v2 on (v1.a=v2.a);
select * from t3 left join v4 on (t3.a = v4.a);
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
explain select * from t3 left join v4 on (t3.a = v4.a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `b` from `test`.`t3` left join (`test`.`t1` left join (`test`.`t2`) on(((`test`.`t1`.`a` = `test`.`t2`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`)))) on((`test`.`t1`.`a` = `test`.`t3`.`a`)) where true
prepare stmt1 from "select * from t3 left join v4 on (t3.a = v4.a);";
execute stmt1;
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
execute stmt1;
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
deallocate prepare stmt1;
drop view v4,v3,v2,v1;
drop tables t1,t2,t3;
create table t1 (a int, primary key (a), b int);
create table t2 (a int, primary key (a));
insert into t1 values (1,100), (2,200);
insert into t2 values (1), (3);
create view v3 (a,b) as select t1.a as a, t2.a as b from t1, t2;
update v3 set a= 10 where a=1;
select * from t1;
a	b
10	100
2	200
select * from t2;
a
1
3
create view v2 (a,b) as select t1.b as a, t2.a as b from t1, t2;
set updatable_views_with_limit=NO;
update v2 set a= 10 where a=200 limit 1;
Got one of the listed errors
set updatable_views_with_limit=DEFAULT;
select * from v3;
a	b
10	1
10	3
2	1
2	3
select * from v2;
a	b
100	1
100	3
200	1
200	3
set @a= 10;
set @b= 100;
prepare stmt1 from "update v3 set a= ? where a=?";
execute stmt1 using @a,@b;
select * from v3;
a	b
10	1
10	3
2	1
2	3
set @a= 300;
set @b= 10;
execute stmt1 using @a,@b;
select * from v3;
a	b
2	1
2	3
300	1
300	3
deallocate prepare stmt1;
drop view v3,v2;
drop tables t1,t2;
create table t1 (a int, primary key (a), b int);
create table t2 (a int, primary key (a), b int);
insert into t2 values (1000, 2000);
create view v3 (a,b) as select t1.a as a, t2.a as b from t1, t2;
insert into v3 values (1,2);
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3 select * from t2;
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3(a,b) values (1,2);
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a,b) select * from t2;
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
update v3 set a=1,b=2;
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a) values (1);
insert into v3(b) values (10);
insert into v3(a) select a from t2;
insert into v3(b) select b from t2;
ERROR 23000: Column 'a' cannot be null
insert into v3(a) values (1) on duplicate key update a=a+10000+VALUES(a);
Warnings:
Warning	1287	'VALUES function' is deprecated and will be removed in a future release. Please use an alias (INSERT INTO ... VALUES (...) AS alias) and replace VALUES(col) in the ON DUPLICATE KEY UPDATE clause with alias.col instead
select * from t1;
a	b
10	NULL
1000	NULL
10002	NULL
select * from t2;
a	b
10	NULL
1000	2000
delete from v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete v3,t1 from v3,t1;
ERROR HY000: Can not delete from join view 'test.v3'
delete t1,v3 from t1,v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete from t1;
prepare stmt1 from "insert into v3(a) values (?);";
set @a= 100;
execute stmt1 using @a;
set @a= 300;
execute stmt1 using @a;
deallocate prepare stmt1;
prepare stmt1 from "insert into v3(a) select ?;";
set @a= 101;
execute stmt1 using @a;
set @a= 301;
execute stmt1 using @a;
deallocate prepare stmt1;
select * from v3;
a	b
100	10
100	1000
101	10
101	1000
300	10
300	1000
301	10
301	1000
drop view v3;
drop tables t1,t2;
create table t1(f1 int);
create view v1 as select f1 from t1;
select * from v1 where F1 = 1;
f1
drop view v1;
drop table t1;
create table t1(c1 int);
create table t2(c2 int);
insert into t1 values (1),(2),(3);
insert into t2 values (1);
SELECT c1 FROM t1 WHERE c1 IN (SELECT c2 FROM t2);
c1
1
SELECT c1 FROM t1 WHERE EXISTS (SELECT c2 FROM t2 WHERE c2 = c1);
c1
1
create view v1 as SELECT c1 FROM t1 WHERE c1 IN (SELECT c2 FROM t2);
create view v2 as SELECT c1 FROM t1 WHERE EXISTS (SELECT c2 FROM t2 WHERE c2 = c1);
select * from v1;
c1
1
select * from v2;
c1
1
select * from (select c1 from v2) X;
c1
1
drop view v2, v1;
drop table t1, t2;
CREATE TABLE t1 (C1 INT, C2 INT);
CREATE TABLE t2 (C2 INT);
CREATE VIEW v1 AS SELECT C2 FROM t2;
CREATE VIEW v2 AS SELECT C1 FROM t1 LEFT OUTER JOIN v1 USING (C2);
SELECT * FROM v2;
C1
drop view v2, v1;
drop table t1, t2;
create table t1 (col1 char(5),col2 int,col3 int);
insert into t1 values ('one',10,25), ('two',10,50), ('two',10,50), ('one',20,25), ('one',30,25);
create view v1 as select * from t1;
select col1,group_concat(col2,col3) from t1 group by col1;
col1	group_concat(col2,col3)
one	1025,2025,3025
two	1050,1050
select col1,group_concat(col2,col3) from v1 group by col1;
col1	group_concat(col2,col3)
one	1025,2025,3025
two	1050,1050
drop view v1;
drop table t1;
create table t1 (s1 int, s2 char);
create view v1 as select s1, s2 from t1;
select s2 from v1 vq1 where 2 = (select count(*) from v1 vq2 having vq1.s2 = vq2.s2);
ERROR 42S22: Unknown column 'vq2.s2' in 'having clause'
select s2 from v1 vq1 where 2 = (select count(*) aa from v1 vq2 having vq1.s2 = aa);
s2
drop view v1;
drop table t1;
CREATE TABLE t1 (a1 int);
CREATE TABLE t2 (a2 int);
INSERT INTO t1 VALUES (1), (2), (3), (4);
INSERT INTO t2 VALUES (1), (2), (3);
CREATE VIEW v1(a,b) AS SELECT a1,a2 FROM t1 JOIN t2 ON a1=a2 WHERE a1>1;
SELECT * FROM v1;
a	b
2	2
3	3
CREATE TABLE t3 SELECT * FROM v1;
SELECT * FROM t3;
a	b
2	2
3	3
DROP VIEW v1;
DROP TABLE t1,t2,t3;
create table t1 (a int);
create table t2 like t1;
create table t3 like t1;
create view v1 as select t1.a x, t2.a y from t1 join t2 where t1.a=t2.a;
insert into t3 select x from v1;
insert into t2 select x from v1;
drop view v1;
drop table t1,t2,t3;
CREATE TABLE t1 (col1 int PRIMARY KEY, col2 varchar(10));
INSERT INTO t1 VALUES(1,'trudy');
INSERT INTO t1 VALUES(2,'peter');
INSERT INTO t1 VALUES(3,'sanja');
INSERT INTO t1 VALUES(4,'monty');
INSERT INTO t1 VALUES(5,'david');
INSERT INTO t1 VALUES(6,'kent');
INSERT INTO t1 VALUES(7,'carsten');
INSERT INTO t1 VALUES(8,'ranger');
INSERT INTO t1 VALUES(10,'matt');
CREATE TABLE t2 (col1 int, col2 int, col3 char(1));
INSERT INTO t2 VALUES (1,1,'y');
INSERT INTO t2 VALUES (1,2,'y');
INSERT INTO t2 VALUES (2,1,'n');
INSERT INTO t2 VALUES (3,1,'n');
INSERT INTO t2 VALUES (4,1,'y');
INSERT INTO t2 VALUES (4,2,'n');
INSERT INTO t2 VALUES (4,3,'n');
INSERT INTO t2 VALUES (6,1,'n');
INSERT INTO t2 VALUES (8,1,'y');
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT a.col1,a.col2,b.col2,b.col3
FROM t1 a LEFT JOIN t2 b ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM t2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
SELECT a.col1,a.col2,b.col2,b.col3
FROM v1 a LEFT JOIN t2 b ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM t2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
CREATE VIEW v2 AS SELECT * FROM t2;
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v1 a ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v1 a ON a.col1=b.col1
WHERE a.col1 IN (1,5,9) AND
(b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1));
col1	col2	col2	col3
1	trudy	2	y
5	david	NULL	NULL
CREATE VIEW v3 AS SELECT * FROM t1 WHERE col1 IN (1,5,9);
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v3 a ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
5	david	NULL	NULL
DROP VIEW v1,v2,v3;
DROP TABLE t1,t2;
create table t1 as select 1 A union select 2 union select 3;
create table t2 as select * from t1;
create view v1 as select * from t1 where a in (select * from t2);
select * from v1 A, v1 B where A.a = B.a;
A	A
1	1
2	2
3	3
create table t3 as select a a,a b from t2;
create view v2 as select * from t3 where
a in (select * from t1) or b in (select * from t2);
select * from v2 A, v2 B where A.a = B.b;
a	b	a	b
1	1	1	1
2	2	2	2
3	3	3	3
drop view v1, v2;
drop table t1, t2, t3;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
INSERT INTO t1 VALUES (1), (2), (3), (4);
INSERT INTO t2 VALUES (4), (2);
CREATE VIEW v1 AS SELECT * FROM t1,t2 WHERE t1.a=t2.b;
SELECT * FROM v1;
a	b
2	2
4	4
CREATE VIEW v2 AS SELECT * FROM v1;
SELECT * FROM v2;
a	b
2	2
4	4
DROP VIEW v2,v1;
DROP TABLE t1, t2;
create table t1 (a int);
create view v1 as select sum(a) from t1 group by a;
create procedure p1()
begin
select * from v1;
end//
call p1();
sum(a)
call p1();
sum(a)
drop procedure p1;
drop view v1;
drop table t1;
CREATE TABLE t1(a char(2) primary key, b char(2));
CREATE TABLE t2(a char(2), b char(2), index i(a));
INSERT INTO t1 VALUES ('a','1'), ('b','2');
INSERT INTO t2 VALUES ('a','5'), ('a','6'), ('b','5'), ('b','6');
CREATE VIEW v1 AS
SELECT t1.b as c, t2.b as d FROM t1,t2 WHERE t1.a=t2.a;
SELECT d, c FROM v1 ORDER BY d,c;
d	c
5	1
5	2
6	1
6	2
DROP VIEW v1;
DROP TABLE t1, t2;
create table t1 (s1 int);
create view  v1 as select sum(distinct s1) from t1;
select * from v1;
sum(distinct s1)
NULL
drop view v1;
create view  v1 as select avg(distinct s1) from t1;
select * from v1;
avg(distinct s1)
NULL
drop view v1;
drop table t1;
create view v1 as select cast(1 as decimal);
select * from v1;
cast(1 as decimal)
1
drop view v1;
create table t1(f1 int);
create table t2(f2 int);
insert into t1 values(1),(2),(3);
insert into t2 values(1),(2),(3);
create view v1 as select * from t1,t2 where f1=f2;
create table t3 (f1 int, f2 int);
insert into t3 select * from v1 order by 1;
select * from t3;
f1	f2
1	1
2	2
3	3
drop view v1;
drop table t1,t2,t3;
create view v1 as select '\\','\\shazam';
select * from v1;
\	\shazam
\	\shazam
drop view v1;
create view v1 as select '\'','\shazam';
select * from v1;
'	shazam
'	shazam
drop view v1;
create view v1 as select 'k','K';
select * from v1;
k	Name_exp_K
k	K
drop view v1;
create table t1 (s1 int);
create view v1 as select s1, 's1' from t1;
select * from v1;
s1	Name_exp_s1
drop view v1;
create view v1 as select 's1', s1 from t1;
select * from v1;
Name_exp_s1	s1
drop view v1;
create view v1 as select 's1', s1, 1 as Name_exp_s1 from t1;
select * from v1;
Name_exp_1_s1	s1	Name_exp_s1
drop view v1;
create view v1 as select 1 as Name_exp_s1, 's1', s1  from t1;
select * from v1;
Name_exp_s1	Name_exp_1_s1	s1
drop view v1;
create view v1 as select 1 as s1, 's1', 's1' from t1;
select * from v1;
s1	Name_exp_s1	Name_exp_1_s1
drop view v1;
create view v1 as select 's1', 's1', 1 as s1 from t1;
select * from v1;
Name_exp_1_s1	Name_exp_s1	s1
drop view v1;
create view v1 as select s1, 's1', 's1' from t1;
select * from v1;
s1	Name_exp_s1	Name_exp_1_s1
drop view v1;
create view v1 as select 's1', 's1', s1 from t1;
select * from v1;
Name_exp_1_s1	Name_exp_s1	s1
drop view v1;
create view v1 as select 1 as s1, 's1', s1 from t1;
ERROR 42S21: Duplicate column name 's1'
create view v1 as select 's1', s1, 1 as s1 from t1;
ERROR 42S21: Duplicate column name 's1'
drop table t1;
create view v1(k, K) as select 1,2;
ERROR 42S21: Duplicate column name 'k'
create view v1 as SELECT TIME_FORMAT(SEC_TO_TIME(3600),'%H:%i') as t;
select * from v1;
t
01:00
drop view v1;
create table t1 (a timestamp default now());
create table t2 (b timestamp default now());
create view v1 as select a,b,t1.a < now() from t1,t2 where t1.a < now();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,`t2`.`b` AS `b`,(`t1`.`a` < now()) AS `t1.a < now()` from (`t1` join `t2`) where (`t1`.`a` < now())	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1, t2;
CREATE TABLE t1 ( a varchar(50) );
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = CURRENT_USER();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = current_user())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = VERSION();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = version())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = DATABASE();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = database())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (col1 time);
CREATE TABLE t2 (col1 time);
CREATE VIEW v1 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v2 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
CREATE VIEW v3 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v4 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
CREATE VIEW v5 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v6 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
DROP TABLE t1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	error	Corrupt
test.v2	check	status	OK
test.v3	check	Error	View 'test.v3' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v3	check	error	Corrupt
test.v4	check	status	OK
test.v5	check	Error	View 'test.v5' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v5	check	error	Corrupt
test.v6	check	status	OK
drop view v1, v2, v3, v4, v5, v6;
drop table t2;
drop function if exists f1;
drop function if exists f2;
CREATE TABLE t1 (col1 time);
CREATE TABLE t2 (col1 time);
CREATE TABLE t3 (col1 time);
create function f1 () returns int return (select max(col1) from t1);
create function f2 () returns int return (select max(col1) from t2);
CREATE VIEW v1 AS SELECT f1() FROM t3;
CREATE VIEW v2 AS SELECT f2() FROM t3;
CREATE VIEW v3 AS SELECT f1() FROM t3;
CREATE VIEW v4 AS SELECT f2() FROM t3;
CREATE VIEW v5 AS SELECT f1() FROM t3;
CREATE VIEW v6 AS SELECT f2() FROM t3;
drop function f1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	status	Operation failed
test.v2	check	status	OK
test.v3	check	Error	View 'test.v3' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v3	check	status	Operation failed
test.v4	check	status	OK
test.v5	check	Error	View 'test.v5' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v5	check	status	Operation failed
test.v6	check	status	OK
create function f1 () returns int return (select max(col1) from t1);
DROP TABLE t1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	status	OK
test.v2	check	status	OK
test.v3	check	status	OK
test.v4	check	status	OK
test.v5	check	status	OK
test.v6	check	status	OK
drop function f1;
drop function f2;
drop view v1, v2, v3, v4, v5, v6;
drop table t2,t3;
create table t1 (f1 date);
insert into t1 values ('2005-01-01'),('2005-02-02');
create view v1 as select * from t1;
select * from v1 where f1='2005.02.02';
f1
2005-02-02
Warnings:
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.02.02' at row 1 is deprecated. Prefer the standard '-'.
select * from v1 where '2005.02.02'=f1;
f1
2005-02-02
Warnings:
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.02.02' at row 1 is deprecated. Prefer the standard '-'.
drop view v1;
drop table t1;
CREATE VIEW v1 AS SELECT SUBSTRING_INDEX("dkjhgd:kjhdjh", ":", 1);
SELECT * FROM v1;
SUBSTRING_INDEX("dkjhgd:kjhdjh", ":", 1)
dkjhgd
drop view v1;
create table t1 (f59 int, f60 int, f61 int);
insert into t1 values (19,41,32);
create view v1 as select f59, f60 from t1 where f59 in
(select f59 from t1);
update v1 set f60=2345;
ERROR HY000: The target table v1 of the UPDATE is not updatable
update t1 set f60=(select max(f60) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't1'.
drop view v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select var_samp(s1) from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select var_samp(`t1`.`s1`) AS `var_samp(s1)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
CREATE TABLE t1 (col1 INT NOT NULL, col2 INT NOT NULL);
CREATE VIEW v1 (vcol1) AS SELECT col1 FROM t1;
CREATE VIEW v2 (vcol1) AS SELECT col1 FROM t1 WHERE col2 > 2;
INSERT INTO t1 (col1) VALUES(12);
ERROR HY000: Field 'col2' doesn't have a default value
INSERT INTO v1 (vcol1) VALUES(12);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
INSERT INTO v2 (vcol1) VALUES(12);
ERROR HY000: Field of view 'test.v2' underlying table doesn't have a default value
drop view v2,v1;
drop table t1;
create table t1 (f1 int);
insert into t1 values (1);
create view v1 as select f1 from t1;
select f1 as alias from v1;
alias
1
drop view v1;
drop table t1;
CREATE TABLE t1 (s1 int, s2 int);
INSERT  INTO t1 VALUES (1,2);
CREATE VIEW v1 AS SELECT s2 AS s1, s1 AS s2 FROM t1;
SELECT * FROM v1;
s1	s2
2	1
CREATE PROCEDURE p1 () SELECT * FROM v1;
CALL p1();
s1	s2
2	1
ALTER VIEW v1 AS SELECT s1 AS s1, s2 AS s2 FROM t1;
CALL p1();
s1	s2
1	2
DROP VIEW v1;
CREATE VIEW v1 AS SELECT s2 AS s1, s1 AS s2 FROM t1;
CALL p1();
s1	s2
2	1
DROP PROCEDURE p1;
DROP VIEW v1;
DROP TABLE t1;
create table t1 (f1 int, f2 int);
create view v1 as select f1 as f3, f2 as f1 from t1;
insert into t1 values (1,3),(2,1),(3,2);
select * from v1 order by f1;
f3	f1
2	1
3	2
1	3
drop view v1;
drop table t1;
CREATE TABLE t1 (f1 char);
INSERT INTO t1 VALUES ('A');
CREATE VIEW  v1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES('B');
SELECT * FROM v1;
f1
A
B
SELECT * FROM t1;
f1
A
B
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 ( bug_table_seq   INTEGER NOT NULL);
CREATE OR REPLACE VIEW v1 AS SELECT * from t1;
DROP PROCEDURE IF EXISTS p1;
Warnings:
Note	1305	PROCEDURE test.p1 does not exist
CREATE PROCEDURE p1 ( )
BEGIN
DO (SELECT  @next := IFNULL(max(bug_table_seq),0) + 1 FROM v1);
INSERT INTO t1 VALUES (1);
END //
Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
DROP TABLE t1;
create table t1(f1 datetime);
insert into t1 values('2005.01.01 12:0:0');
Warnings:
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.01 12:0:0' at row 1 is deprecated. Prefer the standard '-'.
create view v1 as select f1, subtime(f1, '1:1:1') as sb from t1;
select * from v1;
f1	sb
2005-01-01 12:00:00	2005-01-01 10:58:59
drop view v1;
drop table t1;
CREATE TABLE t1 (
aid int PRIMARY KEY,
fn varchar(20) NOT NULL,
ln varchar(20) NOT NULL
);
CREATE TABLE t2 (
aid int NOT NULL,
pid int NOT NULL
);
INSERT INTO t1 VALUES(1,'a','b'), (2,'c','d');
INSERT INTO t2 values (1,1), (2,1), (2,2);
CREATE VIEW v1 AS SELECT t1.*,t2.pid FROM t1,t2 WHERE t1.aid = t2.aid;
SELECT pid,GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1) FROM t1,t2
WHERE t1.aid = t2.aid GROUP BY pid;
pid	GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1)
1	a b,c d
2	c d
SELECT pid,GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1) FROM v1 GROUP BY pid;
pid	GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1)
1	a b,c d
2	c d
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int PRIMARY KEY, f varchar(255));
CREATE VIEW v1 AS SELECT id, f FROM t1 WHERE id <= 2;
INSERT INTO t1 VALUES (2, 'foo2');
INSERT INTO t1 VALUES (1, 'foo1');
SELECT * FROM v1;
id	f
1	foo1
2	foo2
SELECT * FROM v1;
id	f
1	foo1
2	foo2
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (pk int PRIMARY KEY, b int);
CREATE TABLE t2 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t3 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t4 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t5 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE VIEW v1 AS
SELECT t1.pk as a FROM t1,t2,t3,t4,t5
WHERE t1.b IS NULL AND
t1.pk=t2.fk AND t2.pk=t3.fk AND t3.pk=t4.fk AND t4.pk=t5.fk;
SELECT a FROM v1;
a
DROP VIEW v1;
DROP TABLE t1,t2,t3,t4,t5;
create view v1 as select timestampdiff(day,'1997-01-01 00:00:00','1997-01-02 00:00:00') as f1;
select * from v1;
f1
1
drop view v1;
create table t1(a int);
create procedure p1() create view v1 as select * from t1;
drop table t1;
call p1();
ERROR 42S02: Table 'test.t1' doesn't exist
call p1();
ERROR 42S02: Table 'test.t1' doesn't exist
drop procedure p1;
create table t1 (f1 int);
create table t2 (f1 int);
insert into t1 values (1);
insert into t2 values (2);
create view v1 as select * from t1 union select * from t2 union all select * from t2;
select * from v1;
f1
1
2
2
drop view v1;
drop table t1,t2;
CREATE TEMPORARY TABLE t1 (a int);
CREATE FUNCTION f1 () RETURNS int RETURN (SELECT COUNT(*) FROM t1);
CREATE VIEW v1 AS SELECT f1();
ERROR HY000: View's SELECT refers to a temporary table 't1'
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
DROP VIEW  IF EXISTS v1;
CREATE TABLE t1 (f4 CHAR(5));
CREATE VIEW v1 AS SELECT * FROM t1;
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
f4	char(5)	YES		NULL	
ALTER TABLE t1 CHANGE COLUMN f4 f4x CHAR(5);
DESCRIBE v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP TABLE t1;
DROP VIEW v1;
create table t1 (f1 char);
create view v1 as select strcmp(f1,'a') from t1;
select * from v1;
strcmp(f1,'a')
drop view v1;
drop table t1;
create table t1 (f1 int, f2 int,f3 int);
insert into t1 values (1,10,20),(2,0,0);
create view v1 as select * from t1;
select if(sum(f1)>1,f2,f3) from v1 group by f1;
if(sum(f1)>1,f2,f3)
20
0
drop view v1;
drop table t1;
create table t1 (
r_object_id char(16) NOT NULL,
group_name varchar(32) NOT NULL
) engine = InnoDB;
create table t2 (
r_object_id char(16) NOT NULL,
i_position int(11) NOT NULL,
users_names varchar(32) default NULL
) Engine = InnoDB;
create view v1 as select r_object_id, group_name from t1;
create view v2 as select r_object_id, i_position, users_names from t2;
create unique index r_object_id on t1(r_object_id);
create index group_name on t1(group_name);
create unique index r_object_id_i_position on t2(r_object_id,i_position);
create index users_names on t2(users_names);
insert into t1 values('120001a080000542','tstgroup1');
insert into t2 values('120001a080000542',-1, 'guser01');
insert into t2 values('120001a080000542',-2, 'guser02');
select v1.r_object_id, v2.users_names from v1, v2
where (v1.group_name='tstgroup1') and v2.r_object_id=v1.r_object_id
order by users_names;
r_object_id	users_names
120001a080000542	guser01
120001a080000542	guser02
drop view v1, v2;
drop table t1, t2;
create table t1 (s1 int);
create view abc as select * from t1 as abc;
drop table t1;
drop view abc;
create table t1(f1 char(1));
create view v1 as select * from t1;
select * from (select f1 as f2 from v1) v where v.f2='a';
f2
drop view v1;
drop table t1;
create view v1 as SELECT CONVERT_TZ('2004-01-01 12:00:00','GMT','MET');
select * from v1;
CONVERT_TZ('2004-01-01 12:00:00','GMT','MET')
NULL
drop view v1;
CREATE TABLE t1 (date DATE NOT NULL);
INSERT INTO  t1 VALUES ('2005-09-06');
CREATE VIEW v1 AS SELECT DAYNAME(date) FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select dayname(`t1`.`date`) AS `DAYNAME(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v2 AS SELECT DAYOFWEEK(date) FROM t1;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select dayofweek(`t1`.`date`) AS `DAYOFWEEK(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v3 AS SELECT WEEKDAY(date) FROM t1;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select weekday(`t1`.`date`) AS `WEEKDAY(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
SELECT DAYNAME('2005-09-06');
DAYNAME('2005-09-06')
Tuesday
SELECT DAYNAME(date) FROM t1;
DAYNAME(date)
Tuesday
SELECT * FROM v1;
DAYNAME(date)
Tuesday
SELECT DAYOFWEEK('2005-09-06');
DAYOFWEEK('2005-09-06')
3
SELECT DAYOFWEEK(date) FROM t1;
DAYOFWEEK(date)
3
SELECT * FROM v2;
DAYOFWEEK(date)
3
SELECT WEEKDAY('2005-09-06');
WEEKDAY('2005-09-06')
1
SELECT WEEKDAY(date) FROM t1;
WEEKDAY(date)
1
SELECT * FROM v3;
WEEKDAY(date)
1
DROP TABLE t1;
DROP VIEW  v1, v2, v3;
CREATE TABLE t1 ( a int, b int );
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
CREATE VIEW v1 AS SELECT a,b FROM t1;
SELECT t1.a FROM t1 GROUP BY t1.a HAVING a > 1;
a
2
3
SELECT v1.a FROM v1 GROUP BY v1.a HAVING a > 1;
a
2
3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 ( a int, b int );
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
CREATE VIEW v1 AS SELECT a,b FROM t1;
SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a > 1;
a
2
3
SELECT v1.a FROM v1 GROUP BY v1.a HAVING v1.a > 1;
a
2
3
SELECT t_1.a FROM t1 AS t_1 GROUP BY t_1.a HAVING t_1.a IN (1,2,3);
a
1
2
3
SELECT v_1.a FROM v1 AS v_1 GROUP BY v_1.a HAVING v_1.a IN (1,2,3);
a
1
2
3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT, INDEX(a,b));
CREATE TABLE t2 LIKE t1;
CREATE TABLE t3 (a INT);
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
INSERT INTO t2 VALUES (1,1),(2,2),(3,3);
INSERT INTO t3 VALUES (1),(2),(3);
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
CREATE VIEW v1 AS SELECT t1.* FROM t1,t2 WHERE t1.a=t2.a AND t1.b=t2.b;
CREATE VIEW v2 AS SELECT t3.* FROM t1,t3 WHERE t1.a=t3.a;
EXPLAIN SELECT t1.* FROM t1 JOIN t2 WHERE t1.a=t2.a AND t1.b=t2.b AND t1.a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using where; Using index
1	SIMPLE	t2	NULL	ref	a	a	10	const,test.t1.b	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t1`.`b`) and (`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1))
EXPLAIN SELECT * FROM v1 WHERE a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using where; Using index
1	SIMPLE	t2	NULL	ref	a	a	10	const,test.t1.b	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t1`.`b`) and (`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1))
EXPLAIN SELECT * FROM v2 WHERE a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using index
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t3` where ((`test`.`t1`.`a` = 1) and (`test`.`t3`.`a` = 1))
DROP VIEW v1,v2;
DROP TABLE t1,t2,t3;
create table t1 (f1 int);
create view v1 as select t1.f1 as '123
456' from t1;
select * from v1;
123
456
drop view v1;
drop table t1;
create table t1 (f1 int, f2 int);
insert into t1 values(1,1),(1,2),(1,3);
create view v1 as select f1 ,group_concat(f2 order by f2 asc) from t1 group by f1;
create view v2 as select f1 ,group_concat(f2 order by f2 desc) from t1 group by f1;
select * from v1;
f1	group_concat(f2 order by f2 asc)
1	1,2,3
select * from v2;
f1	group_concat(f2 order by f2 desc)
1	3,2,1
drop view v1,v2;
drop table t1;
create table t1 (x int, y int);
create table t2 (x int, y int, z int);
create table t3 (x int, y int, z int);
create table t4 (x int, y int, z int);
create view v1 as
select t1.x
from (
(t1 join t2 on ((t1.y = t2.y)))
join
(t3 left join t4 on (t3.y = t4.y) and (t3.z = t4.z))
);
prepare stmt1 from "select count(*) from v1 where x = ?";
set @parm1=1;
execute stmt1 using @parm1;
count(*)
0
execute stmt1 using @parm1;
count(*)
0
drop view v1;
drop table t1,t2,t3,t4;
CREATE TABLE t1(id INT);
CREATE VIEW v1 AS SELECT id FROM t1;
OPTIMIZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	optimize	Error	'test.v1' is not BASE TABLE
test.v1	optimize	status	Operation failed
ANALYZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	analyze	Error	'test.v1' is not BASE TABLE
test.v1	analyze	status	Operation failed
REPAIR TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	repair	Error	'test.v1' is not BASE TABLE
test.v1	repair	status	Operation failed
DROP TABLE t1;
OPTIMIZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	optimize	Error	'test.v1' is not BASE TABLE
test.v1	optimize	status	Operation failed
ANALYZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	analyze	Error	'test.v1' is not BASE TABLE
test.v1	analyze	status	Operation failed
REPAIR TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	repair	Error	'test.v1' is not BASE TABLE
test.v1	repair	status	Operation failed
DROP VIEW v1;
create definer = current_user() sql security invoker view v1 as select 1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create definer = current_user sql security invoker view v1 as select 1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create table t1 (id INT, primary key(id));
insert into t1 values (1),(2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select * from t1;
explain select id from v1 order by id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id` from `test`.`t1` order by `test`.`t1`.`id`
drop view v1;
drop table t1;
create table t1(f1 int, f2 int);
insert into t1 values (null, 10), (null,2);
select f1, sum(f2) from t1 group by f1;
f1	sum(f2)
NULL	12
create view v1 as select * from t1;
select f1, sum(f2) from v1 group by f1;
f1	sum(f2)
NULL	12
drop view v1;
drop table t1;
drop procedure if exists p1;
create procedure p1 () deterministic
begin
create view v1 as select 1;
end;
//
call p1();
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop procedure p1;
CREATE VIEW v1 AS SELECT 42 AS Meaning;
DROP FUNCTION IF EXISTS f1;
CREATE FUNCTION f1() RETURNS INTEGER
BEGIN
DECLARE retn INTEGER;
SELECT Meaning FROM v1 INTO retn;
RETURN retn;
END
//
CREATE VIEW v2 AS SELECT f1();
select * from v2;
f1()
42
drop view v2,v1;
drop function f1;
create table t1 (id numeric, warehouse_id numeric);
create view v1 as select id from t1;
create view v2 as
select t1.warehouse_id, v1.id as receipt_id
from t1, v1 where t1.id = v1.id;
insert into t1 (id, warehouse_id) values(3, 2);
insert into t1 (id, warehouse_id) values(4, 2);
insert into t1 (id, warehouse_id) values(5, 1);
select v2.receipt_id as alias1, v2.receipt_id as alias2 from v2
order by v2.receipt_id;
alias1	alias2
3	3
4	4
5	5
drop view v2, v1;
drop table t1;
CREATE TABLE t1 (a int PRIMARY KEY, b int);
INSERT INTO t1 VALUES (2,20), (3,10), (1,10), (0,30), (5,10);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT MAX(a) FROM t1;
MAX(a)
5
SELECT MAX(a) FROM v1;
MAX(a)
5
EXPLAIN SELECT MAX(a) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`a`) AS `MAX(a)` from `test`.`t1`
EXPLAIN SELECT MAX(a) FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`a`) AS `MAX(a)` from `test`.`t1`
SELECT MIN(a) FROM t1;
MIN(a)
0
SELECT MIN(a) FROM v1;
MIN(a)
0
EXPLAIN SELECT MIN(a) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`
EXPLAIN SELECT MIN(a) FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (x varchar(10));
INSERT INTO t1 VALUES (null), ('foo'), ('bar'), (null);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT IF(x IS NULL, 'blank', 'not blank') FROM v1 GROUP BY x;
IF(x IS NULL, 'blank', 'not blank')
blank
not blank
not blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM t1 GROUP BY x;
x
blank
not blank
not blank
Warnings:
Warning	1052	Column 'x' in group statement is ambiguous
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM v1;
x
blank
not blank
not blank
blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS y FROM v1 GROUP BY y;
y
blank
not blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM v1 GROUP BY x;
x
blank
not blank
not blank
Warnings:
Warning	1052	Column 'x' in group statement is ambiguous
DROP VIEW v1;
DROP TABLE t1;
drop table if exists t1;
drop view if exists v1;
create table t1 (id int);
create view v1 as select * from t1;
drop table t1;
show create view v1;
drop view v1;
//
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`id` AS `id` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
create table t1(f1 int, f2 int);
create view v1 as select ta.f1 as a, tb.f1 as b from t1 ta, t1 tb where ta.f1=tb
.f1 and ta.f2=tb.f2;
insert into t1 values(1,1),(2,2);
create view v2 as select * from v1 where a > 1 with local check option;
select * from v2;
a	b
2	2
update v2 set b=3 where a=2;
select * from v2;
a	b
3	3
drop view v2, v1;
drop table t1;
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT SQRT(a) my_sqrt FROM t1;
SELECT my_sqrt FROM v1 ORDER BY my_sqrt;
my_sqrt
1
1.4142135623730951
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (id int PRIMARY KEY);
CREATE TABLE t2 (id int PRIMARY KEY);
INSERT INTO t1 VALUES (1), (3);
INSERT INTO t2 VALUES (1), (2), (3);
CREATE VIEW v2 AS SELECT * FROM t2;
SELECT COUNT(*) FROM t1 LEFT JOIN t2 ON t1.id=t2.id;
COUNT(*)
2
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id;
id	id
1	1
3	3
SELECT COUNT(*) FROM t1 LEFT JOIN v2 ON t1.id=v2.id;
COUNT(*)
2
DROP VIEW v2;
DROP TABLE t1, t2;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY,
td date DEFAULT NULL, KEY idx(td));
INSERT INTO t1 VALUES
(1, '2005-01-01'), (2, '2005-01-02'), (3, '2005-01-02'),
(4, '2005-01-03'), (5, '2005-01-04'), (6, '2005-01-05'),
(7, '2005-01-05'), (8, '2005-01-05'), (9, '2005-01-06');
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT * FROM t1 WHERE td BETWEEN CAST('2005.01.02' AS DATE) AND CAST('2005.01.04' AS DATE);
id	td
2	2005-01-02
3	2005-01-02
4	2005-01-03
5	2005-01-04
Warnings:
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
SELECT * FROM v1 WHERE td BETWEEN CAST('2005.01.02' AS DATE) AND CAST('2005.01.04' AS DATE);
id	td
2	2005-01-02
3	2005-01-02
4	2005-01-03
5	2005-01-04
Warnings:
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.02' at row 1 is deprecated. Prefer the standard '-'.
Warning	4095	Delimiter '.' in position 4 in datetime value '2005.01.04' at row 1 is deprecated. Prefer the standard '-'.
DROP VIEW v1;
DROP TABLE t1;
create table t1 (a int);
create view v1 as select * from t1;
create view v2 as select * from v1;
drop table t1;
rename table v2 to t1;
select * from v1;
ERROR HY000: `test`.`v1` contains view recursion
drop view t1, v1;
create table t1 (a int);
create function f1() returns int
begin
declare mx int;
select max(a) from t1 into mx;
return mx;
end//
create view v1 as select f1() as a;
create view v2 as select * from v1;
drop table t1;
rename table v2 to t1;
select * from v1;
ERROR HY000: Recursive stored functions and triggers are not allowed.
drop function f1;
drop view t1, v1;
create table t1 (dt datetime);
insert into t1 values (20040101000000), (20050101000000), (20060101000000);
create view v1 as select convert_tz(dt, 'UTC', 'Europe/Moscow') as ldt from t1;
select * from v1;
ldt
2004-01-01 03:00:00
2005-01-01 03:00:00
2006-01-01 03:00:00
drop view v1;
create view v1 as select * from t1 where convert_tz(dt, 'UTC', 'Europe/Moscow') >= 20050101000000;
select * from v1;
dt
2005-01-01 00:00:00
2006-01-01 00:00:00
create view v2 as select * from v1 where dt < 20060101000000;
select * from v2;
dt
2005-01-01 00:00:00
drop view v2;
create view v2 as select convert_tz(dt, 'UTC', 'Europe/Moscow') as ldt from v1;
select * from v2;
ldt
2005-01-01 03:00:00
2006-01-01 03:00:00
drop view v1, v2;
drop table t1;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY, d datetime);
CREATE VIEW v1 AS
SELECT id, date(d) + INTERVAL TIME_TO_SEC(d) SECOND AS t, COUNT(*)
FROM t1 GROUP BY id, t;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`id` AS `id`,(cast(`t1`.`d` as date) + interval time_to_sec(`t1`.`d`) second) AS `t`,count(0) AS `COUNT(*)` from `t1` group by `t1`.`id`,`t`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM v1;
id	t	COUNT(*)
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (i INT, j BIGINT);
INSERT INTO t1 VALUES (1, 2), (2, 2), (3, 2);
CREATE VIEW v1 AS SELECT MIN(j) AS j FROM t1;
CREATE VIEW v2 AS SELECT MIN(i) FROM t1 WHERE j = ( SELECT * FROM v1 );
SELECT * FROM v2;
MIN(i)
1
DROP VIEW v2, v1;
DROP TABLE t1;
CREATE TABLE t1(
fName varchar(25) NOT NULL,
lName varchar(25) NOT NULL,
DOB date NOT NULL,
test_date date NOT NULL,
uID int unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY);
INSERT INTO t1(fName, lName, DOB, test_date) VALUES
('Hank', 'Hill', '1964-09-29', '2007-01-01'),
('Tom', 'Adams', '1908-02-14', '2007-01-01'),
('Homer', 'Simpson', '1968-03-05', '2007-01-01');
CREATE VIEW v1 AS
SELECT (year(test_date)-year(DOB)) AS Age
FROM t1 HAVING Age < 75;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select (year(`t1`.`test_date`) - year(`t1`.`DOB`)) AS `Age` from `t1` having (`Age` < 75)	utf8mb4	utf8mb4_0900_ai_ci
SELECT (year(test_date)-year(DOB)) AS Age FROM t1 HAVING Age < 75;
Age
43
39
SELECT * FROM v1;
Age
43
39
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY, a char(6) DEFAULT 'xxx');
INSERT INTO t1(id) VALUES (1), (2), (3), (4);
INSERT INTO t1 VALUES (5,'yyy'), (6,'yyy');
SELECT * FROM t1;
id	a
1	xxx
2	xxx
3	xxx
4	xxx
5	yyy
6	yyy
CREATE VIEW v1(a, m) AS SELECT a, MIN(id) FROM t1 GROUP BY a;
SELECT * FROM v1;
a	m
xxx	1
yyy	5
CREATE TABLE t2 SELECT * FROM v1;
INSERT INTO t2(m) VALUES (0);
SELECT * FROM t2;
a	m
xxx	1
yyy	5
xxx	0
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int PRIMARY KEY, e ENUM('a','b') NOT NULL DEFAULT 'b');
INSERT INTO t1(id) VALUES (1), (2), (3);
INSERT INTO t1 VALUES (4,'a');
SELECT * FROM t1;
id	e
1	b
2	b
3	b
4	a
CREATE VIEW v1(m, e) AS SELECT MIN(id), e FROM t1 GROUP BY e;
CREATE TABLE t2 SELECT * FROM v1;
SELECT * FROM t2;
m	e
1	b
4	a
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (a INT NOT NULL, b INT NULL DEFAULT NULL);
CREATE VIEW v1 AS SELECT a, b FROM t1;
INSERT IGNORE INTO v1 (b) VALUES (2);
Warnings:
Warning	1423	Field of view 'test.v1' underlying table doesn't have a default value
SET SQL_MODE = STRICT_ALL_TABLES;
Warnings:
Warning	3135	'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode. They will be merged with strict mode in a future release.
INSERT INTO v1 (b) VALUES (4);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
SET SQL_MODE = '';
SELECT * FROM t1;
a	b
0	2
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (firstname text, surname text);
INSERT INTO t1 VALUES
("Bart","Simpson"),("Milhouse","van Houten"),("Montgomery","Burns");
CREATE VIEW v1 AS SELECT CONCAT(firstname," ",surname) AS name FROM t1;
SELECT CONCAT(LEFT(name,LENGTH(name)-INSTR(REVERSE(name)," ")),
LEFT(name,LENGTH(name)-INSTR(REVERSE(name)," "))) AS f1
FROM v1;
f1
BartBart
Milhouse vanMilhouse van
MontgomeryMontgomery
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (i int, j int);
CREATE VIEW v1 AS SELECT COALESCE(i,j) FROM t1;
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
COALESCE(i,j)	bigint	YES		NULL	
CREATE TABLE t2 SELECT COALESCE(i,j) FROM t1;
DESCRIBE t2;
Field	Type	Null	Key	Default	Extra
COALESCE(i,j)	int	YES		NULL	
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (s varchar(10));
INSERT INTO t1 VALUES ('yadda'), ('yady');
SELECT TRIM(BOTH 'y' FROM s) FROM t1;
TRIM(BOTH 'y' FROM s)
adda
ad
CREATE VIEW v1 AS SELECT TRIM(BOTH 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(BOTH 'y' FROM s)
adda
ad
DROP VIEW v1;
SELECT TRIM(LEADING 'y' FROM s) FROM t1;
TRIM(LEADING 'y' FROM s)
adda
ady
CREATE VIEW v1 AS SELECT TRIM(LEADING 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(LEADING 'y' FROM s)
adda
ady
DROP VIEW v1;
SELECT TRIM(TRAILING 'y' FROM s) FROM t1;
TRIM(TRAILING 'y' FROM s)
yadda
yad
CREATE VIEW v1 AS SELECT TRIM(TRAILING 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(TRAILING 'y' FROM s)
yadda
yad
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (x INT, y INT);
CREATE ALGORITHM=TEMPTABLE SQL SECURITY INVOKER VIEW v1 AS SELECT x FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select `t1`.`x` AS `x` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
ALTER VIEW v1 AS SELECT x, y FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select `t1`.`x` AS `x`,`t1`.`y` AS `y` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (s1 char) charset latin1;
INSERT INTO t1 VALUES ('Z');
CREATE VIEW v1 AS SELECT s1 collate latin1_german1_ci AS col FROM t1;
CREATE VIEW v2 (col) AS SELECT s1 collate latin1_german1_ci FROM t1;
INSERT INTO v1 (col) VALUES ('b');
INSERT INTO v2 (col) VALUES ('c');
SELECT s1 FROM t1;
s1
Z
b
c
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE TABLE t1 (id INT);
CREATE VIEW v1 AS SELECT id FROM t1;
SHOW TABLES;
Tables_in_test
t1
v1
DROP VIEW v2,v1;
ERROR 42S02: Unknown table 'test.v2'
SHOW TABLES;
Tables_in_test
t1
v1
DROP VIEW t1,v1;
ERROR HY000: 'test.t1' is not VIEW
SHOW TABLES;
Tables_in_test
t1
v1
DROP TABLE t1;
DROP VIEW IF EXISTS v1;
CREATE DATABASE bug21261DB;
USE bug21261DB;
CREATE TABLE t1 (x INT);
CREATE SQL SECURITY INVOKER VIEW v1 AS SELECT x FROM t1;
CREATE USER 'user21261'@'localhost';
GRANT INSERT, UPDATE ON v1 TO 'user21261'@'localhost';
GRANT INSERT, UPDATE ON t1 TO 'user21261'@'localhost';
CREATE TABLE t2 (y INT);
GRANT SELECT ON t2 TO 'user21261'@'localhost';
INSERT INTO v1 (x) VALUES (5);
UPDATE v1 SET x=1;
GRANT SELECT ON v1 TO 'user21261'@'localhost';
GRANT SELECT ON t1 TO 'user21261'@'localhost';
UPDATE v1,t2 SET x=1 WHERE x=y;
SELECT * FROM t1;
x
1
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 'user21261'@'localhost';
DROP USER 'user21261'@'localhost';
DROP VIEW v1;
DROP TABLE t1;
DROP DATABASE bug21261DB;
USE test;
create table t1 (f1 datetime);
create view v1 as select * from t1 where f1 between now() and now() + interval 1 minute;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`f1` AS `f1` from `t1` where (`t1`.`f1` between now() and (now() + interval 1 minute))	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
DROP TABLE IF EXISTS t1;
DROP VIEW IF EXISTS v1;
DROP VIEW IF EXISTS v2;
CREATE TABLE t1(a INT, b INT);
CREATE DEFINER=1234567890abcdefGHIKL1234567890abcdefGHIKL@localhost
VIEW v1 AS SELECT a FROM t1;
ERROR HY000: String '1234567890abcdefGHIKL1234567890abcdefGHIKL' is too long for user name (should be no longer than 32)
CREATE DEFINER=some_user_name@host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij1234567890X
VIEW v2 AS SELECT b FROM t1;
ERROR HY000: String 'host_1234567890abcdefghij1234567890abcdefghij1234567890abcdefghij12345' is too long for host name (should be no longer than 255)
DROP TABLE t1;
DROP FUNCTION IF EXISTS f1;
DROP FUNCTION IF EXISTS f2;
DROP VIEW IF EXISTS v1, v2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE FUNCTION f1() RETURNS INT
BEGIN
INSERT INTO v1 VALUES (0);
RETURN 0;
END |
SELECT f1();
f1()
0
CREATE ALGORITHM=TEMPTABLE VIEW v2 AS SELECT * FROM t1;
CREATE FUNCTION f2() RETURNS INT
BEGIN
INSERT INTO v2 VALUES (0);
RETURN 0;
END |
SELECT f2();
ERROR HY000: The target table v2 of the INSERT is not insertable-into
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE TABLE t1 (s1 int);
CREATE VIEW v1 AS SELECT * FROM t1;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1`
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1`
INSERT INTO t1 VALUES (1), (3), (2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT * FROM t1 t WHERE t.s1+1 < (SELECT MAX(t1.s1) FROM t1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t	NULL	ALL	NULL	NULL	NULL	#	#	#	Using where
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`s1` AS `s1` from `test`.`t1` `t` where ((`test`.`t`.`s1` + 1) < (/* select#2 */ select max(`test`.`t1`.`s1`) from `test`.`t1`))
EXPLAIN SELECT * FROM v1 t WHERE t.s1+1 < (SELECT MAX(t1.s1) FROM t1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	Using where
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1` where ((`test`.`t1`.`s1` + 1) < (/* select#2 */ select max(`test`.`t1`.`s1`) from `test`.`t1`))
DROP VIEW v1;
DROP TABLE t1;
create table t1 (s1 int);
create view v1 as select s1 as a, s1 as b from t1;
insert into v1 values (1,1);
ERROR HY000: The target table v1 of the INSERT is not insertable-into
update v1 set a = 5;
drop view v1;
drop table t1;
CREATE TABLE t1(pk int PRIMARY KEY);
CREATE TABLE t2(pk int PRIMARY KEY, fk int, ver int, org int);
CREATE ALGORITHM=MERGE VIEW v1 AS
SELECT t1.*
FROM t1 JOIN t2
ON t2.fk = t1.pk AND
t2.ver = (SELECT MAX(t.ver) FROM t2 t WHERE t.org = t2.org);
SHOW WARNINGS;
Level	Code	Message
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=MERGE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`pk` AS `pk` from (`t1` join `t2` on(((`t2`.`fk` = `t1`.`pk`) and (`t2`.`ver` = (select max(`t`.`ver`) from `t2` `t` where (`t`.`org` = `t2`.`org`))))))	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1, t2;
DROP FUNCTION IF EXISTS f1;
DROP VIEW IF EXISTS v1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT);
INSERT INTO t1 VALUES (1);
CREATE VIEW v1 AS SELECT MAX(i) FROM t1;
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW
SET NEW.i = (SELECT * FROM v1) + 1;
INSERT INTO t1 VALUES (1);
CREATE FUNCTION f1() RETURNS INT RETURN (SELECT * FROM v1);
UPDATE t1 SET i= f1();
DROP FUNCTION f1;
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1(id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, val INT UNSIGNED NOT NULL);
CREATE VIEW v1 AS SELECT id, val FROM t1 WHERE val >= 1 AND val <= 5 WITH CHECK OPTION;
INSERT INTO v1 (val) VALUES (2);
INSERT INTO v1 (val) VALUES (4);
INSERT INTO v1 (val) VALUES (6);
ERROR HY000: CHECK OPTION failed 'test.v1'
UPDATE v1 SET val=6 WHERE id=2;
ERROR HY000: CHECK OPTION failed 'test.v1'
DROP VIEW v1;
DROP TABLE t1;
DROP VIEW IF EXISTS v1, v2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT AUTO_INCREMENT PRIMARY KEY, j INT);
CREATE VIEW v1 AS SELECT j FROM t1;
CREATE VIEW v2 AS SELECT * FROM t1;
INSERT INTO t1 (j) VALUES (1);
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
1
INSERT INTO v1 (j) VALUES (2);
# LAST_INSERT_ID() should not change.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
1
INSERT INTO v2 (j) VALUES (3);
# LAST_INSERT_ID() should be updated.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
3
INSERT INTO v1 (j) SELECT j FROM t1;
# LAST_INSERT_ID() should not change.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
3
SELECT * FROM t1;
i	j
1	1
2	2
3	3
4	1
5	2
6	3
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE VIEW v AS SELECT !0 * 5 AS x FROM DUAL;
Warnings:
Warning	1287	'!' is deprecated and will be removed in a future release. Please use NOT instead
SHOW CREATE VIEW v;
View	Create View	character_set_client	collation_connection
v	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v` AS select ((0 = 0) * 5) AS `x`	utf8mb4	utf8mb4_0900_ai_ci
SELECT !0 * 5 AS x FROM DUAL;
x
5
Warnings:
Warning	1287	'!' is deprecated and will be removed in a future release. Please use NOT instead
SELECT * FROM v;
x
5
DROP VIEW v;
DROP VIEW IF EXISTS v1;
CREATE VIEW v1 AS SELECT 'The\ZEnd';
SELECT * FROM v1;
TheEnd
TheEnd
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 'The\ZEnd' AS `TheEnd`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE TABLE t1 (mydate DATETIME);
INSERT INTO t1 VALUES
('2007-01-01'), ('2007-01-02'), ('2007-01-30'), ('2007-01-31');
CREATE VIEW v1 AS SELECT mydate from t1;
SELECT * FROM t1 WHERE mydate BETWEEN '2007-01-01' AND '2007-01-31';
mydate
2007-01-01 00:00:00
2007-01-02 00:00:00
2007-01-30 00:00:00
2007-01-31 00:00:00
SELECT * FROM v1 WHERE mydate BETWEEN '2007-01-01' AND '2007-01-31';
mydate
2007-01-01 00:00:00
2007-01-02 00:00:00
2007-01-30 00:00:00
2007-01-31 00:00:00
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW v1 AS
SELECT t2.b FROM t1,t2 WHERE t1.a = t2.b WITH CHECK OPTION;
SELECT * FROM v1;
b
1
2
UPDATE v1 SET b=3;
ERROR HY000: CHECK OPTION failed 'test.v1'
SELECT * FROM v1;
b
1
2
SELECT * FROM t1;
a
1
2
SELECT * FROM t2;
b
1
2
DROP VIEW v1;
DROP TABLE t1,t2;
create table t1(f1 int, f2 int);
insert into t1 values(1,2),(1,3),(1,1),(2,3),(2,1),(2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select * from t1;
f1	f2
1	2
1	3
1	1
2	3
2	1
2	2
create view v1 as select * from t1 order by f2;
select * from v1;
f1	f2
1	1
2	1
1	2
2	2
1	3
2	3
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1` order by `test`.`t1`.`f2`
select * from v1 order by f1;
f1	f2
1	2
1	3
1	1
2	3
2	1
2	2
explain select * from v1 order by f1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1` order by `test`.`t1`.`f1`
drop view v1;
drop table t1;
CREATE TABLE t1 (
id int(11) NOT NULL PRIMARY KEY,
country varchar(32),
code int(11) default NULL
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES
(1,'ITALY',100),(2,'ITALY',200),(3,'FRANCE',100), (4,'ITALY',100);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT code, COUNT(DISTINCT country) FROM t1 GROUP BY code ORDER BY MAX(id);
code	COUNT(DISTINCT country)
200	1
100	2
SELECT code, COUNT(DISTINCT country) FROM v1 GROUP BY code ORDER BY MAX(id);
code	COUNT(DISTINCT country)
200	1
100	2
DROP VIEW v1;
DROP TABLE t1;
DROP VIEW IF EXISTS v1;
SELECT * FROM (SELECT 1) AS t;
1
1
CREATE VIEW v1 AS SELECT * FROM (SELECT 1) AS t;
DROP VIEW v1;
# Previously the following would fail.
SELECT * FROM (SELECT 1) AS t;
1
1
drop view if exists view_24532_a;
drop view if exists view_24532_b;
drop table if exists table_24532;
create table table_24532 (
a int,
b bigint,
c int(4),
d bigint(48)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create view view_24532_a as
select
a IS TRUE,
a IS NOT TRUE,
a IS FALSE,
a IS NOT FALSE,
a IS UNKNOWN,
a IS NOT UNKNOWN,
a is NULL,
a IS NOT NULL,
ISNULL(a),
b IS TRUE,
b IS NOT TRUE,
b IS FALSE,
b IS NOT FALSE,
b IS UNKNOWN,
b IS NOT UNKNOWN,
b is NULL,
b IS NOT NULL,
ISNULL(b),
c IS TRUE,
c IS NOT TRUE,
c IS FALSE,
c IS NOT FALSE,
c IS UNKNOWN,
c IS NOT UNKNOWN,
c is NULL,
c IS NOT NULL,
ISNULL(c),
d IS TRUE,
d IS NOT TRUE,
d IS FALSE,
d IS NOT FALSE,
d IS UNKNOWN,
d IS NOT UNKNOWN,
d is NULL,
d IS NOT NULL,
ISNULL(d)
from table_24532;
describe view_24532_a;
Field	Type	Null	Key	Default	Extra
a IS TRUE	int	NO		0	
a IS NOT TRUE	int	NO		0	
a IS FALSE	int	NO		0	
a IS NOT FALSE	int	NO		0	
a IS UNKNOWN	int	NO		0	
a IS NOT UNKNOWN	int	NO		0	
a is NULL	int	NO		0	
a IS NOT NULL	int	NO		0	
ISNULL(a)	int	NO		0	
b IS TRUE	int	NO		0	
b IS NOT TRUE	int	NO		0	
b IS FALSE	int	NO		0	
b IS NOT FALSE	int	NO		0	
b IS UNKNOWN	int	NO		0	
b IS NOT UNKNOWN	int	NO		0	
b is NULL	int	NO		0	
b IS NOT NULL	int	NO		0	
ISNULL(b)	int	NO		0	
c IS TRUE	int	NO		0	
c IS NOT TRUE	int	NO		0	
c IS FALSE	int	NO		0	
c IS NOT FALSE	int	NO		0	
c IS UNKNOWN	int	NO		0	
c IS NOT UNKNOWN	int	NO		0	
c is NULL	int	NO		0	
c IS NOT NULL	int	NO		0	
ISNULL(c)	int	NO		0	
d IS TRUE	int	NO		0	
d IS NOT TRUE	int	NO		0	
d IS FALSE	int	NO		0	
d IS NOT FALSE	int	NO		0	
d IS UNKNOWN	int	NO		0	
d IS NOT UNKNOWN	int	NO		0	
d is NULL	int	NO		0	
d IS NOT NULL	int	NO		0	
ISNULL(d)	int	NO		0	
create view view_24532_b as
select
a IS TRUE,
if(ifnull(a, 0), 1, 0) as old_istrue,
a IS NOT TRUE,
if(ifnull(a, 0), 0, 1) as old_isnottrue,
a IS FALSE,
if(ifnull(a, 1), 0, 1) as old_isfalse,
a IS NOT FALSE,
if(ifnull(a, 1), 1, 0) as old_isnotfalse
from table_24532;
describe view_24532_b;
Field	Type	Null	Key	Default	Extra
a IS TRUE	int	NO		0	
old_istrue	int	NO		0	
a IS NOT TRUE	int	NO		0	
old_isnottrue	int	NO		0	
a IS FALSE	int	NO		0	
old_isfalse	int	NO		0	
a IS NOT FALSE	int	NO		0	
old_isnotfalse	int	NO		0	
show create view view_24532_b;
View	Create View	character_set_client	collation_connection
view_24532_b	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `view_24532_b` AS select ((0 <> `table_24532`.`a`) is true) AS `a IS TRUE`,if(ifnull(`table_24532`.`a`,0),1,0) AS `old_istrue`,((0 <> `table_24532`.`a`) is not true) AS `a IS NOT TRUE`,if(ifnull(`table_24532`.`a`,0),0,1) AS `old_isnottrue`,((0 <> `table_24532`.`a`) is false) AS `a IS FALSE`,if(ifnull(`table_24532`.`a`,1),0,1) AS `old_isfalse`,((0 <> `table_24532`.`a`) is not false) AS `a IS NOT FALSE`,if(ifnull(`table_24532`.`a`,1),1,0) AS `old_isnotfalse` from `table_24532`	utf8mb4	utf8mb4_0900_ai_ci
insert into table_24532 values (0, 0, 0, 0);
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
0	0	1	1	1	1	0	0
update table_24532 set a=1;
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
1	1	0	0	0	0	1	1
update table_24532 set a=NULL;
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
0	0	1	1	0	0	1	1
drop view view_24532_a;
drop view view_24532_b;
drop table table_24532;
CREATE TABLE t1 (
lid int NOT NULL PRIMARY KEY,
name char(10) NOT NULL
);
INSERT INTO t1 (lid, name) VALUES
(1, 'YES'), (2, 'NO');
CREATE TABLE t2 (
id int NOT NULL PRIMARY KEY,
gid int NOT NULL,
lid int NOT NULL,
dt date
);
CREATE TABLE t3 (
id int NOT NULL PRIMARY KEY,
gid int NOT NULL,
lid int NOT NULL,
dt date
);
INSERT INTO t2 (id, gid, lid, dt) VALUES
(1, 1, 1, '2007-01-01'),(2, 1, 2, '2007-01-02'),
(3, 2, 2, '2007-02-01'),(4, 2, 1, '2007-02-02');
INSERT INTO t3 (id, gid, lid, dt) VALUES
(1, 1, 1, '2007-01-01'),(2, 1, 2, '2007-01-02'),
(3, 2, 2, '2007-02-01'),(4, 2, 1, '2007-02-02');
SELECT DISTINCT t2.gid AS lgid,
(SELECT t1.name FROM t1, t3
WHERE t1.lid  = t3.lid AND t3.gid = t2.gid
ORDER BY t3.dt DESC LIMIT 1
) as clid
FROM t2;
lgid	clid
1	NO
2	YES
CREATE VIEW v1 AS
SELECT DISTINCT t2.gid AS lgid,
(SELECT t1.name FROM t1, t3
WHERE t1.lid  = t3.lid AND t3.gid = t2.gid
ORDER BY t3.dt DESC LIMIT 1
) as clid
FROM t2;
SELECT * FROM v1;
lgid	clid
1	NO
2	YES
DROP VIEW v1;
DROP table t1,t2,t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT a FROM t1 ORDER BY a;
SELECT * FROM t1 UNION SELECT * FROM v1;
a
1
2
3
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
SELECT * FROM v1 UNION SELECT * FROM t1;
a
1
2
3
EXPLAIN SELECT * FROM v1 UNION SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
SELECT * FROM t1 UNION SELECT * FROM v1 ORDER BY a;
a
1
2
3
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM v1 ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` order by `a`
DROP VIEW v1;
DROP TABLE t1;
CREATE VIEW v1 AS SELECT CAST( 1.23456789 AS DECIMAL( 7,5 ) ) AS col;
SELECT * FROM v1;
col
1.23457
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
col	decimal(7,5)	NO		0.00000	
DROP VIEW v1;
CREATE VIEW v1 AS SELECT CAST(1.23456789 AS DECIMAL(8,0)) AS col;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select cast(1.23456789 as decimal(8,0)) AS `col`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (b INT, c INT DEFAULT 0);
INSERT INTO t1 (a) VALUES (1), (2);
INSERT INTO t2 (b) VALUES (1), (2);
CREATE VIEW v1 AS SELECT t2.b,t2.c FROM t1, t2
WHERE t1.a=t2.b AND t2.b < 3 WITH CHECK OPTION;
SELECT * FROM v1;
b	c
1	0
2	0
UPDATE v1 SET c=1 WHERE b=1;
SELECT * FROM v1;
b	c
1	1
2	0
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int);
CREATE TABLE t2 (id int, c int DEFAULT 0);
INSERT INTO t1 (id) VALUES (1);
INSERT INTO t2 (id) VALUES (1);
CREATE VIEW v1 AS
SELECT t2.c FROM t1, t2
WHERE t1.id=t2.id AND 1 IN (SELECT id FROM t1) WITH CHECK OPTION;
UPDATE v1 SET c=1;
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (a1 INT, c INT DEFAULT 0);
CREATE TABLE t2 (a2 INT);
CREATE TABLE t3 (a3 INT);
CREATE TABLE t4 (a4 INT);
INSERT INTO t1 (a1) VALUES (1),(2);
INSERT INTO t2 (a2) VALUES (1),(2);
INSERT INTO t3 (a3) VALUES (1),(2);
INSERT INTO t4 (a4) VALUES (1),(2);
CREATE VIEW v1 AS
SELECT t1.a1, t1.c FROM t1 JOIN t2 ON t1.a1=t2.a2 AND t1.c < 3
WITH CHECK OPTION;
SELECT * FROM v1;
a1	c
1	0
2	0
UPDATE v1 SET c=3;
ERROR HY000: CHECK OPTION failed 'test.v1'
PREPARE t FROM 'UPDATE v1 SET c=3';
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v1'
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v1'
INSERT INTO v1(a1, c) VALUES (3, 3);
ERROR HY000: CHECK OPTION failed 'test.v1'
UPDATE v1 SET c=1 WHERE a1=1;
SELECT * FROM v1;
a1	c
1	1
2	0
SELECT * FROM t1;
a1	c
1	1
2	0
CREATE VIEW v2 AS SELECT t1.a1, t1.c
FROM (t1 JOIN t2 ON t1.a1=t2.a2 AND t1.c < 3)
JOIN (t3 JOIN t4 ON t3.a3=t4.a4)
ON t2.a2=t3.a3 WITH CHECK OPTION;
SELECT * FROM v2;
a1	c
1	1
2	0
UPDATE v2 SET c=3;
ERROR HY000: CHECK OPTION failed 'test.v2'
PREPARE t FROM 'UPDATE v2 SET c=3';
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v2'
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v2'
INSERT INTO v2(a1, c) VALUES (3, 3);
ERROR HY000: CHECK OPTION failed 'test.v2'
UPDATE v2 SET c=2 WHERE a1=1;
SELECT * FROM v2;
a1	c
1	2
2	0
SELECT * FROM t1;
a1	c
1	2
2	0
DROP VIEW v1,v2;
DROP TABLE t1,t2,t3,t4;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 VALUES (1,2), (2,2), (1,3), (1,2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT a, b+1 as b FROM t1;
SELECT b, SUM(a) FROM v1 WHERE b=3 GROUP BY b;
b	SUM(a)
3	4
EXPLAIN SELECT b, SUM(a) FROM v1 WHERE b=3 GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`b` + 1) AS `b`,sum(`test`.`t1`.`a`) AS `SUM(a)` from `test`.`t1` where ((`test`.`t1`.`b` + 1) = 3) group by (`test`.`t1`.`b` + 1)
SELECT a, SUM(b) FROM v1 WHERE b=3 GROUP BY a;
a	SUM(b)
1	6
2	3
EXPLAIN SELECT a, SUM(b) FROM v1 WHERE b=3 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,sum((`test`.`t1`.`b` + 1)) AS `SUM(b)` from `test`.`t1` where ((`test`.`t1`.`b` + 1) = 3) group by `test`.`t1`.`a`
SELECT a, SUM(b) FROM v1 WHERE a=1 GROUP BY a;
a	SUM(b)
1	10
EXPLAIN SELECT a, SUM(b) FROM v1 WHERE a=1 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,sum((`test`.`t1`.`b` + 1)) AS `SUM(b)` from `test`.`t1` where (`test`.`t1`.`a` = 1) group by `test`.`t1`.`a`
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (
person_id int NOT NULL PRIMARY KEY,
username varchar(40) default NULL,
status_flg char(1) NOT NULL default 'A'
);
CREATE TABLE t2 (
person_role_id int NOT NULL auto_increment PRIMARY KEY,
role_id int NOT NULL,
person_id int NOT NULL,
INDEX idx_person_id (person_id),
INDEX idx_role_id (role_id)
);
CREATE TABLE t3 (
role_id int NOT NULL auto_increment PRIMARY KEY,
role_name varchar(100) default NULL,
app_name varchar(40) NOT NULL,
INDEX idx_app_name(app_name)
);
CREATE VIEW v1 AS
SELECT profile.person_id AS person_id
FROM t1 profile, t2 userrole, t3 `role`
    WHERE userrole.person_id = profile.person_id AND
role.role_id = userrole.role_id AND
profile.status_flg = 'A'
  ORDER BY profile.person_id,role.app_name,role.role_name;
INSERT INTO  t1 VALUES
(6,'Sw','A'), (-1136332546,'ols','e'), (0,'    *\n','0'),
(-717462680,'ENTS Ta','0'), (-904346964,'ndard SQL\n','0');
INSERT INTO t2 VALUES
(1,3,6),(2,4,7),(3,5,8),(4,6,9),(5,1,6),(6,1,7),(7,1,8),(8,1,9),(9,1,10);
INSERT INTO t3 VALUES
(1,'NUCANS_APP_USER','NUCANSAPP'),(2,'NUCANS_TRGAPP_USER','NUCANSAPP'),
(3,'IA_INTAKE_COORDINATOR','IACANS'),(4,'IA_SCREENER','IACANS'),
(5,'IA_SUPERVISOR','IACANS'),(6,'IA_READONLY','IACANS'),
(7,'SOC_USER','SOCCANS'),(8,'CAYIT_USER','CAYITCANS'),
(9,'RTOS_DCFSPOS_SUPERVISOR','RTOS');
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN SELECT t.person_id AS a, t.person_id AS b FROM v1 t WHERE t.person_id=6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	profile	NULL	const	PRIMARY	PRIMARY	4	const	#	#	Using temporary; Using filesort
1	SIMPLE	userrole	NULL	ref	idx_person_id,idx_role_id	idx_person_id	4	const	#	#	NULL
1	SIMPLE	role	NULL	eq_ref	PRIMARY	PRIMARY	4	test.userrole.role_id	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select '6' AS `a`,'6' AS `b` from `test`.`t1` `profile` join `test`.`t2` `userrole` join `test`.`t3` `role` where ((`test`.`role`.`role_id` = `test`.`userrole`.`role_id`) and (`test`.`userrole`.`person_id` = 6)) order by '6',`test`.`role`.`app_name`,`test`.`role`.`role_name`
SELECT t.person_id AS a, t.person_id AS b FROM v1 t WHERE t.person_id=6;
a	b
6	6
6	6
DROP VIEW v1;
DROP TABLE t1,t2,t3;
create table t1 (i int);
insert into t1 values (1), (2), (1), (3), (2), (4);
create view v1 as select distinct i from t1;
select * from v1;
i
1
2
3
4
select table_name, is_updatable from information_schema.views
where table_name = 'v1';
TABLE_NAME	IS_UPDATABLE
v1	NO
drop view v1;
drop table t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT * FROM v1 USE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a INT NOT NULL AUTO_INCREMENT, b INT NOT NULL DEFAULT 0,
PRIMARY KEY(a), KEY (b));
INSERT INTO t1 VALUES (),(),(),(),(),(),(),(),(),(),(),(),(),(),();
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT * FROM t1 FORCE KEY (PRIMARY,b) ORDER BY a;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` FORCE INDEX (PRIMARY) FORCE INDEX (`b`) order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` FORCE INDEX (PRIMARY) FORCE INDEX (`b`) order by `test`.`t1`.`a`
CREATE VIEW v2 AS SELECT * FROM t1 USE KEY () ORDER BY a;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` USE INDEX () order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` USE INDEX () order by `test`.`t1`.`a`
CREATE VIEW v3 AS SELECT * FROM t1 IGNORE KEY (b) ORDER BY a;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` IGNORE INDEX (`b`) order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` IGNORE INDEX (`b`) order by `test`.`t1`.`a`
DROP VIEW v1;
DROP VIEW v2;
DROP VIEW v3;
DROP TABLE t1;
#
# Bug#29477 Not all fields of the target table were checked to have
#           a default value when inserting into a view.
#
create table t1(f1 int, f2 int not null);
create view v1 as select f1 from t1;
insert into v1 values(1);
Warnings:
Warning	1423	Field of view 'test.v1' underlying table doesn't have a default value
set @old_mode=@@sql_mode;
set @@sql_mode=traditional;
insert into v1 values(1);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
set @@sql_mode=@old_mode;
drop view v1;
drop table t1;
create table t1 (a int, key(a));
create table t2 (c int);
create view v1 as select a b from t1;
create view v2 as select 1 a from t2, v1 where c in
(select 1 from t1 where b = a);
insert into t1 values (1), (1);
insert into t2 values (1), (1);
prepare stmt from "select * from v2 where a = 1";
execute stmt;
a
1
1
1
1
drop view v1, v2;
drop table t1, t2;
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT p.a AS a FROM t1 p, t1 q;
INSERT INTO t1 VALUES (1), (1);
SELECT MAX(a), COUNT(DISTINCT a) FROM v1 GROUP BY a;
MAX(a)	COUNT(DISTINCT a)
1	1
DROP VIEW v1;
DROP TABLE t1;
# -----------------------------------------------------------------
# -- Bug#34337 Server crash when Altering a view using a table name.
# -----------------------------------------------------------------

DROP TABLE IF EXISTS t1;

CREATE TABLE t1(c1 INT);

SELECT * FROM t1;
c1
ALTER ALGORITHM=TEMPTABLE SQL SECURITY INVOKER VIEW t1 (c2) AS SELECT (1);
ERROR HY000: 'test.t1' is not VIEW

DROP TABLE t1;

# -- End of test case for Bug#34337.

# -----------------------------------------------------------------
# -- Bug#35193 VIEW query is rewritten without "FROM DUAL",
# --           causing syntax error
# -----------------------------------------------------------------

CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE 1;

SELECT * FROM v1;
1
1
SHOW CREATE TABLE v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1` from DUAL  where (0 <> 1)	utf8mb4	utf8mb4_0900_ai_ci

DROP VIEW v1;

# -- End of test case for Bug#35193.

CREATE VIEW v1 AS SELECT 1;
DROP VIEW v1;
CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 INT, INDEX (c2));
INSERT INTO t1 VALUES (1,1), (2,2), (3,3);
SELECT * FROM t1 USE INDEX (PRIMARY) WHERE c1=2;
c1	c2
2	2
SELECT * FROM t1 USE INDEX (c2) WHERE c2=2;
c1	c2
2	2
CREATE VIEW v1 AS SELECT c1, c2 FROM t1;
SHOW INDEX FROM v1;
Table	Non_unique	Key_name	Seq_in_index	Column_name	Collation	Cardinality	Sub_part	Packed	Null	Index_type	Comment	Index_comment	Visible	Expression
SELECT * FROM v1 USE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 USE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
DROP VIEW v1;
DROP TABLE t1;
# 
# Bug #45806 crash when replacing into a view with a join!
# 
CREATE TABLE t1(a INT UNIQUE);
CREATE VIEW v1 AS SELECT t1.a FROM t1, t1 AS a;
INSERT INTO t1 VALUES (1), (2);
REPLACE INTO v1(a) SELECT 1 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v1'
SELECT * FROM v1;
a
1
1
2
2
REPLACE INTO v1(a) SELECT 3 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v1'
SELECT * FROM v1;
a
1
1
2
2
DELETE FROM t1 WHERE a=3;
INSERT INTO v1(a) SELECT 1 FROM t1,t1 AS c
ON DUPLICATE KEY UPDATE `v1`.`a`= 1;
SELECT * FROM v1;
a
1
1
2
2
CREATE VIEW v2 AS SELECT t1.a FROM t1, v1 AS a;
REPLACE INTO v2(a) SELECT 1 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v2'
SELECT * FROM v2;
a
1
1
1
1
2
2
2
2
REPLACE INTO v2(a) SELECT 3 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v2'
SELECT * FROM v2;
a
1
1
1
1
2
2
2
2
INSERT INTO v2(a) SELECT 1 FROM t1,t1 AS c
ON DUPLICATE KEY UPDATE `v2`.`a`= 1;
SELECT * FROM v2;
a
1
1
1
1
2
2
2
2
DROP VIEW v1;
DROP VIEW v2;
DROP TABLE t1;
# -- End of test case for Bug#45806
# -----------------------------------------------------------------
# -- Bug#40825: Error 1356 while selecting from a view 
# --            with a "HAVING" clause though query works
# -----------------------------------------------------------------

CREATE TABLE t1 (c INT);

CREATE VIEW v1 (view_column) AS SELECT c AS alias FROM t1 HAVING alias;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`view_column`) AS select `t1`.`c` AS `alias` from `t1` having (0 <> `alias`)	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM v1;
view_column

DROP VIEW v1;
DROP TABLE t1;

# -- End of test case for Bug#40825

# -----------------------------------------------------------------
# -- End of 5.0 tests.
# -----------------------------------------------------------------
DROP DATABASE IF EXISTS `d-1`;
CREATE DATABASE `d-1`;
USE `d-1`;
CREATE TABLE `t-1` (c1 INT);
CREATE VIEW  `v-1` AS SELECT c1 FROM `t-1`;
SHOW TABLES;
Tables_in_d-1
t-1
v-1
RENAME TABLE `t-1` TO `t-2`;
RENAME TABLE `v-1` TO `v-2`;
SHOW TABLES;
Tables_in_d-1
t-2
v-2
DROP TABLE `t-2`;
DROP VIEW  `v-2`;
DROP DATABASE `d-1`;
USE test;

#
# Bug#26676 VIEW using old table schema in a session.
#

DROP VIEW IF EXISTS v1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(c1 INT, c2 INT);
INSERT INTO t1 VALUES (1, 2), (3, 4);

SELECT * FROM t1;
c1	c2
1	2
3	4

CREATE VIEW v1 AS SELECT * FROM t1;

SELECT * FROM v1;
c1	c2
1	2
3	4

ALTER TABLE t1 ADD COLUMN c3 INT AFTER c2;

SELECT * FROM t1;
c1	c2	c3
1	2	NULL
3	4	NULL

SELECT * FROM v1;
c1	c2
1	2
3	4

SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1`,`t1`.`c2` AS `c2` from `t1`	utf8mb4	utf8mb4_0900_ai_ci

DROP VIEW v1;
DROP TABLE t1;

# End of test case for Bug#26676.

# -----------------------------------------------------------------
# -- Bug#32538 View definition picks up character set, but not collation
# -----------------------------------------------------------------

DROP VIEW IF EXISTS v1;

SET collation_connection = latin1_general_ci;
CREATE VIEW v1 AS SELECT _latin1 'text1' AS c1, 'text2' AS c2;

SELECT COLLATION(c1), COLLATION(c2) FROM v1;
COLLATION(c1)	COLLATION(c2)
latin1_swedish_ci	latin1_general_ci

SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select _latin1'text1' AS `c1`,'text2' AS `c2`	utf8mb4	latin1_general_ci

SELECT * FROM v1 WHERE c1 = 'text1';
ERROR HY000: Illegal mix of collations (latin1_swedish_ci,COERCIBLE) and (latin1_general_ci,COERCIBLE) for operation '='

SELECT * FROM v1 WHERE c2 = 'text2';
c1	c2
text1	text2

use test;
SET names latin1;

SELECT COLLATION(c1), COLLATION(c2) FROM v1;
COLLATION(c1)	COLLATION(c2)
latin1_swedish_ci	latin1_general_ci

SELECT * FROM v1 WHERE c1 = 'text1';
c1	c2
text1	text2

SELECT * FROM v1 WHERE c2 = 'text2';
ERROR HY000: Illegal mix of collations (latin1_general_ci,COERCIBLE) and (latin1_swedish_ci,COERCIBLE) for operation '='

DROP VIEW v1;
SET NAMES DEFAULT;

# -- End of test case for Bug#32538.

drop view if exists a;
drop procedure if exists p;
create procedure p()
begin
declare continue handler for sqlexception begin end;
create view a as select 1;
end|
call p();
call p();
drop view a;
drop procedure p;
#
# Bug #44860: ALTER TABLE on view crashes server
#
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT a FROM t1;
ALTER TABLE v1;
ERROR HY000: 'test.v1' is not BASE TABLE
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1(f1 INT);
INSERT INTO t1 VALUES ();
CREATE VIEW v1 AS SELECT 1 FROM t1 WHERE
ROW(1,1) >= ROW(1, (SELECT 1 FROM t1 WHERE  f1 >= ANY ( SELECT '1' )));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#52120 create view cause Assertion failed: 0, file .\item_subselect.cc, line 817
#
CREATE TABLE t1 (a CHAR(1) CHARSET latin1, b CHAR(1) CHARSET utf8mb3);
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
CREATE VIEW v1 AS SELECT 1 from t1
WHERE t1.b <=> (SELECT a FROM t1 WHERE a < SOME(SELECT '1'));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#57703 create view cause Assertion failed: 0, file .\item_subselect.cc, line 846
#
CREATE TABLE t1(a int);
CREATE VIEW v1 AS SELECT 1 FROM t1 GROUP BY
SUBSTRING(1 FROM (SELECT 3 FROM t1 WHERE a >= ANY(SELECT 1)));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#57352 valgrind warnings when creating view
#
CREATE VIEW v1 AS SELECT 1 IN (1 LIKE 2,0) AS f;
DROP VIEW v1;
#
# Bug 11829681 - 60295: ERROR 1356 ON VIEW THAT EXECUTES FINE AS A QUERY
#
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT s.* FROM t1 s, t1 b HAVING a;
SELECT * FROM v1;
a
DROP VIEW v1;
DROP TABLE t1;
# -----------------------------------------------------------------
# -- End of 5.1 tests.
# -----------------------------------------------------------------
drop table if exists t_9801;
drop view if exists v_9801;
create table t_9801 (s1 int);
create view v_9801 as
select sum(s1) from t_9801 with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
create view v_9801 as
select sum(s1) from t_9801 group by s1 with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
create view v_9801 as
select sum(s1) from t_9801 group by s1 with rollup with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
drop table t_9801;
#
# Bug #47335 assert in get_table_share
#
DROP TABLE IF EXISTS t1;
DROP VIEW IF EXISTS v1;
CREATE TEMPORARY TABLE t1 (id INT);
ALTER VIEW t1 AS SELECT 1 AS f1;
ERROR 42S02: Table 'test.t1' doesn't exist
DROP TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS f1;
CREATE TEMPORARY TABLE v1 (id INT);
ALTER VIEW v1 AS SELECT 2 AS f1;
DROP TABLE v1;
SELECT * FROM v1;
f1
2
DROP VIEW v1;
#
# Bug #47635 assert in start_waiting_global_read_lock 
#            during CREATE VIEW
#
DROP TABLE IF EXISTS t1, t2;
DROP VIEW IF EXISTS t2;
CREATE TABLE t1 (f1 integer);
CREATE TEMPORARY TABLE IF NOT EXISTS t1 (f1 integer);
CREATE TEMPORARY TABLE t2 (f1 integer);
DROP TABLE t1;
FLUSH TABLES WITH READ LOCK;
CREATE VIEW t2 AS SELECT * FROM t1;
ERROR HY000: Can't execute the query because you have a conflicting read lock
UNLOCK TABLES;
DROP TABLE t1, t2;
#
# Bug#48315 Metadata lock is not taken for merged views that
#           use an INFORMATION_SCHEMA table
#
DROP VIEW IF EXISTS v1;
DROP PROCEDURE IF EXISTS p1;
# Connection default
CREATE VIEW v1 AS SELECT schema_name FROM information_schema.schemata;
CREATE PROCEDURE p1() SELECT COUNT(*), GET_LOCK('blocker', 100) FROM v1;
# CALL p1() so the view is merged.
CALL p1();
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection 3
SELECT GET_LOCK('blocker', 100);
GET_LOCK('blocker', 100)
1
# Connection default
# Try to CALL p1() again, this time it should block for t1.
# Sending:
CALL p1();
# Connection 2
# ... then try to drop the view. This should block.
# Sending:
DROP VIEW v1;
# Connection 3
# Now allow CALL p1() to complete
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection default
# Reaping: CALL p1()
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection 2
# Reaping: DROP VIEW v1
# Connection default
DROP PROCEDURE p1;
#
# Bug#11766440 59546: Assertion m_sp == __null fails in
# Item_func_sp::init_result_field with functions
#
CREATE TABLE t1 (a INT);
CREATE FUNCTION f1 () RETURNS INTEGER RETURN 1;
CREATE FUNCTION f2 (i INTEGER) RETURNS INTEGER RETURN 1;
CREATE VIEW v1 AS SELECT f1() AS a FROM t1;
CREATE VIEW v2 AS SELECT f2(a) AS a FROM v1;
DROP FUNCTION f1;
SELECT f2(a) FROM v2;
ERROR HY000: View 'test.v2' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP VIEW v2;
DROP VIEW v1;
DROP FUNCTION f2;
DROP TABLE t1;
#
# Bug#13418197: ASSERTION `(*TABLES)->REGINFO.LOCK_TYPE >=
#               TL_READ' FAILED | MYSQL_LOCK_TABLES
#
DROP TABLE IF EXISTS t1;
CREATE TEMPORARY TABLE t1 (a INT) engine=InnoDB;
CREATE VIEW t1 AS SELECT 1;
DROP VIEW t1;
DROP TEMPORARY TABLE t1;
#
# Bug#13601606: FAILED VIEW CREATION ERROR MESSAGE (FOR DB NOT PRESENT) 
#               NEEDS BIG IMPROVEMENT 
#
DROP DATABASE IF EXISTS nodb;
CREATE VIEW nodb.a AS SELECT 1;
ERROR 42000: Unknown database 'nodb'
#
# Bug#13633549 HANDLE_FATAL_SIGNAL IN 
#              TEST_IF_SKIP_SORT_ORDER/CREATE_SORT_INDEX
#
CREATE TABLE t1 (
pk        INT AUTO_INCREMENT,
c_int_key INT,
PRIMARY KEY (pk),
KEY (c_int_key)
) 
ENGINE=innodb;
CREATE VIEW v_t1 AS SELECT * FROM t1;
CREATE TABLE t2 (
pk              INT auto_increment,
c_varchar_600_x VARCHAR(600),
c_int_key       INT,
c_varchar_600_y VARCHAR(600),
c_varchar_600_z VARCHAR(600),
PRIMARY KEY (pk),
KEY (c_int_key)
) 
ENGINE=innodb;
CREATE VIEW v_t2 AS SELECT * FROM t2;
INSERT INTO t2 VALUES
(
NULL,
repeat('x', 600),
3,
repeat('y', 600),
repeat('z', 600)
);
SELECT a1.pk AS f1
FROM v_t1 AS a1 LEFT JOIN v_t2 AS a2 ON a1.pk=a2.c_int_key
WHERE 
a1.pk > 8
OR ((a1.pk BETWEEN 9 AND 13) AND a1.pk = 90)
ORDER BY f1 ;
f1
DROP TABLE t1, t2;
DROP VIEW v_t1, v_t2;
#
# Bug#13783777 CONSTANT PROPAGATION IS WRONG FOR
#              DISJUNCTIVE PREDICATES IN VIEWS
#
CREATE TABLE t1 (
pk INTEGER,
PRIMARY KEY (pk)
);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v_t1 AS SELECT * FROM t1;
SELECT pk
FROM t1
WHERE
pk > 8
OR ((pk BETWEEN 9 AND 13) AND pk = 90)
;
pk
SELECT pk
FROM v_t1
WHERE
pk > 8
OR ((pk BETWEEN 9 AND 13) AND pk = 90)
;
pk
DROP VIEW v_t1;
DROP TABLE t1;
#
# WL#5275 Process subqueries in FROM clause in the same way as view
#
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER, b INTEGER);
INSERT INTO t1 VALUES(1, 10), (2, 20);
INSERT INTO t2 VALUES(1, 100), (2, 200);
CREATE VIEW v2 AS SELECT * FROM t2;
CREATE VIEW v2_sj AS SELECT * FROM t2
WHERE a IN (SELECT a FROM t1);
CREATE VIEW v12_1 AS SELECT t2.a, t2.b FROM t1 JOIN t2 USING (a);
CREATE VIEW v12_2 AS SELECT t1.a, t2.b FROM t1 JOIN t2 USING (a);
CREATE VIEW v12_3 AS SELECT t2.a, t2.b FROM t1 JOIN t2 USING (a)
WHERE t1.b > 15;
CREATE VIEW vu_1 AS SELECT * FROM t2 UNION SELECT * FROM t2;
CREATE VIEW vu_2 AS SELECT * FROM t2 UNION ALL SELECT * FROM t2;
CREATE VIEW vd_1 AS SELECT DISTINCT a, b FROM t2;
CREATE VIEW va_1 AS SELECT SUM(a) AS a, SUM(b) AS b FROM t2;
CREATE VIEW vg_1 AS SELECT a, SUM(b) AS b FROM t2 GROUP BY a;
CREATE VIEW vh_1 AS SELECT 1 AS a FROM t2 HAVING COUNT(*) > 1;
CREATE VIEW vl_1 AS SELECT * FROM t2 LIMIT 1;
CREATE VIEW vlo_1 AS SELECT * FROM t2 LIMIT 2 OFFSET 1;
CREATE VIEW vrow AS SELECT 1 AS a;
CREATE VIEW vo_1 AS SELECT * FROM t2 ORDER BY a;
CREATE VIEW vo_2 AS SELECT * FROM t2 ORDER BY a DESC;
CREATE VIEW vx AS SELECT a, (SELECT b) AS b FROM t2;
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
SELECT *
FROM t1 JOIN v2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1, v2 AS dt WHERE t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1, v2 AS dt WHERE t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM (t1 JOIN t2 ON t1.a=t2.a) JOIN v2 AS dt ON t1.a=dt.a;
a	b	a	b	a	b
1	10	1	100	1	100
2	20	2	200	2	200
explain SELECT *
FROM (t1 JOIN t2 ON t1.a=t2.a) JOIN v2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN v12_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v12_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_2 AS dt1
ON t1.a=dt1.a AND t2.b=dt1.b
JOIN v12_1 AS dt2
ON dt1.a=dt2.a;
a	b	b	a	b	a	b
1	10	100	1	100	1	100
2	20	200	2	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_2 AS dt1
ON t1.a=dt1.a AND t2.b=dt1.b
JOIN v12_1 AS dt2
ON dt1.a=dt2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t2`.`b`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN v12_3 AS dt ON t1.a=dt.a;
a	b	a	b
2	20	2	200
explain SELECT *
FROM t1 JOIN v12_3 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` > 15))
SELECT *
FROM t1 JOIN v2_sj AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v2_sj AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; FirstMatch(t2); Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` semi join (`test`.`t1`) where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN vu_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vu_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key1>	<auto_key1>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
4	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`vu_1` `dt` where (`test`.`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vu_2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
1	10	1	100
2	20	2	200
2	20	2	200
explain SELECT *
FROM t1 JOIN vu_2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`vu_2` `dt` where (`test`.`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vd_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vd_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`vd_1` `dt` where (`test`.`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN va_1 AS dt ON t1.a=dt.a;
a	b	a	b
explain SELECT *
FROM t1 JOIN va_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'3' AS `a`,'300' AS `b` from `test`.`t1` where (`test`.`t1`.`a` = '3')
SELECT *
FROM t1 JOIN vg_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vg_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`vg_1` `dt` where (`test`.`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vh_1 AS dt ON t1.a=dt.a;
a	b	a
1	10	1
explain SELECT *
FROM t1 JOIN vh_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM t1 JOIN vl_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
explain SELECT *
FROM t1 JOIN vl_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a`,'100' AS `b` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM t1 JOIN vlo_1 AS dt ON t1.a=dt.a;
a	b	a	b
2	20	2	200
explain SELECT *
FROM t1 JOIN vlo_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`vlo_1` `dt` where (`test`.`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vrow AS dt ON t1.a=dt.a;
a	b	a
1	10	1
explain SELECT *
FROM t1 JOIN vrow AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	#	No tables used
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM vo_1 AS dt;
a	b
1	100
2	200
explain SELECT *
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` order by `test`.`t2`.`a`
SELECT *
FROM vo_2 AS dt;
a	b
2	200
1	100
explain SELECT *
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` order by `test`.`t2`.`a` desc
SELECT *
FROM vo_1 AS dt
WHERE dt.a > 0;
a	b
1	100
2	200
explain SELECT *
FROM vo_1 AS dt
WHERE dt.a > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` where (`test`.`t2`.`a` > 0) order by `test`.`t2`.`a`
SELECT *
FROM vo_2 AS dt
WHERE dt.a > 0;
a	b
2	200
1	100
explain SELECT *
FROM vo_2 AS dt
WHERE dt.a > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` where (`test`.`t2`.`a` > 0) order by `test`.`t2`.`a` desc
SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT dt.a, COUNT(*)
FROM vo_1 AS dt
GROUP BY dt.a;
a	COUNT(*)
1	1
2	1
explain SELECT dt.a, COUNT(*)
FROM vo_1 AS dt
GROUP BY dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,count(0) AS `COUNT(*)` from `test`.`t2` group by `test`.`t2`.`a`
SELECT dt.a, COUNT(*)
FROM vo_2 AS dt
GROUP BY dt.a;
a	COUNT(*)
1	1
2	1
explain SELECT dt.a, COUNT(*)
FROM vo_2 AS dt
GROUP BY dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,count(0) AS `COUNT(*)` from `test`.`t2` group by `test`.`t2`.`a`
SELECT COUNT(*)
FROM vo_1 AS dt;
COUNT(*)
2
explain SELECT COUNT(*)
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t2`
SELECT COUNT(*)
FROM vo_2 AS dt;
COUNT(*)
2
explain SELECT COUNT(*)
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t2`
SELECT DISTINCT *
FROM vo_1 AS dt;
a	b
1	100
2	200
explain SELECT DISTINCT *
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2`
SELECT DISTINCT *
FROM vo_2 AS dt;
a	b
1	100
2	200
explain SELECT DISTINCT *
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2`
SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a
ORDER BY t1.b;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a
ORDER BY t1.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`) order by `test`.`t1`.`b`
SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a
ORDER BY t1.b;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a
ORDER BY t1.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`) order by `test`.`t1`.`b`
SELECT *
FROM t1 JOIN vx AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vx AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1276	Field or reference 'test.t2.b' of SELECT #3 was resolved in SELECT #2
Note	1249	Select 3 was reduced during optimization
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SET @optimizer_switch_saved= @@optimizer_switch;
SET @@optimizer_switch="derived_merge=off";
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`dt`.`a` AS `a`,`test`.`dt`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`v12_1` `dt` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`dt`.`a` = `test`.`t1`.`a`))
SET @@optimizer_switch="derived_merge=on";
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SET @@optimizer_switch= @optimizer_switch_saved;
DROP VIEW v2, v2_sj, v12_1, v12_2, v12_3;
DROP VIEW vu_1, vu_2, vd_1, va_1, vg_1, vh_1, vl_1;
DROP VIEW vlo_1, vrow, vo_1, vo_2, vx;
DROP TABLE t1, t2;
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER);
INSERT INTO t1 VALUES
(1, 10),
(2, 20), (2, 21),
(3, NULL),
(4, 40), (4, 41), (4, 42), (4, 43), (4, 44);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (NULL);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t2) AS dt;
SELECT * FROM v1;
a
1
2
3
4
5
NULL
SELECT * FROM (SELECT * FROM t2) AS dt;
a
1
2
3
4
5
NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`
explain SELECT * FROM (SELECT * FROM t2) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
SELECT * FROM v1;
a	b
1	10
2	20
4	40
SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
a	b
1	10
2	20
4	40
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = (`test`.`t1`.`a` * 10))
explain SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = (`test`.`t1`.`a` * 10))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
SELECT * FROM v1;
a	s	c
1	10	1
2	41	2
3	NULL	1
4	210	5
SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
a	s	c
1	10	1
2	41	2
3	NULL	1
4	210	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`s` AS `s`,`dt`.`c` AS `c` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,sum(`test`.`t1`.`b`) AS `s`,count(0) AS `c` from `test`.`t1` group by `test`.`t1`.`a` order by `test`.`t1`.`a`) `dt`
explain SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`s` AS `s`,`dt`.`c` AS `c` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,sum(`test`.`t1`.`b`) AS `s`,count(0) AS `c` from `test`.`t1` group by `test`.`t1`.`a` order by `test`.`t1`.`a`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
SELECT * FROM v1;
a
1
2
3
4
SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
a
1
2
3
4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#3 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`) `dt`
explain SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#2 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
SELECT * FROM v1;
a	b
3	NULL
4	40
4	41
SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
a	b
3	NULL
4	40
4	41
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`b` AS `b` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` limit 3,3) `dt`
explain SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`b` AS `b` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` limit 3,3) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
SELECT * FROM v1;
a
1
2
3
4
1
2
3
4
5
NULL
SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
a
1
2
3
4
1
2
3
4
5
NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
4	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#3 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` union all /* select#4 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`) `dt`
explain SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#2 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` union all /* select#3 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
SELECT * FROM v1;
a	b
1	10
SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
a	b
1	10
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
4	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((/* select#4 */ select `test`.`t1`.`a` from `test`.`t1` limit 1) = (`test`.`t1`.`b` / 10))
explain SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
3	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((/* select#3 */ select `test`.`t1`.`a` from `test`.`t1` limit 1) = (`test`.`t1`.`b` / 10))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
SELECT * FROM v1;
a	b
2	20
2	21
4	40
4	41
4	42
4	43
4	44
SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
a	b
2	20
2	21
4	40
4	41
4	42
4	43
4	44
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` semi join (`test`.`t2`) where ((`test`.`t1`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`a` % 2) = 0))
explain SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` semi join (`test`.`t2`) where ((`test`.`t1`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`a` % 2) = 0))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
SELECT * FROM v1;
a	(SELECT a FROM t2 WHERE a=t1.a)
1	1
2	2
4	4
SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
a	(SELECT a FROM t2 WHERE a=t1.a)
1	1
2	2
4	4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
5	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #5 was resolved in SELECT #3
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`(SELECT a FROM t2 WHERE a=t1.a)` AS `(SELECT a FROM t2 WHERE a=t1.a)` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,(/* select#5 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `(SELECT a FROM t2 WHERE a=t1.a)` from `test`.`t1` semi join (`test`.`t2`) where (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10))) `dt`
explain SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`(SELECT a FROM t2 WHERE a=t1.a)` AS `(SELECT a FROM t2 WHERE a=t1.a)` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,(/* select#3 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `(SELECT a FROM t2 WHERE a=t1.a)` from `test`.`t1` semi join (`test`.`t2`) where (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10))) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, (SELECT a FROM t2) FROM t1 WHERE b=a*10) AS dt;
SELECT * FROM v1;
ERROR 21000: Subquery returns more than 1 row
SELECT * FROM (SELECT a, (SELECT a FROM t2) FROM t1 WHERE b=a*10) AS dt;
ERROR 21000: Subquery returns more than 1 row
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
SELECT * FROM v1 JOIN t2 ON v1.a=t2.a;
a	b	a
1	10	1
2	20	2
4	40	4
SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt JOIN t2 ON dt.a=t2.a;
a	b	a
1	10	1
2	20	2
4	40	4
explain SELECT * FROM v1 JOIN t2 ON v1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a` from `test`.`t1` semi join (`test`.`t2`) join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10)))
explain SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt JOIN t2 ON dt.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (hash join)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a` from `test`.`t1` semi join (`test`.`t2`) join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10)))
DROP VIEW v1;
DROP TABLE t1, t2;
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER);
INSERT INTO t1 VALUES
(1, 10),
(2, 20), (2, 21),
(3, NULL),
(4, 40), (4, 41), (4, 42), (4, 43), (4, 44);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (NULL);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 3)) AS `s` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 3)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	NULL
2	20	NULL
2	21	NULL
3	NULL	NULL
4	40	NULL
4	41	NULL
4	42	NULL
4	43	NULL
4	44	NULL
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
a	b	s
1	10	NULL
2	20	NULL
2	21	NULL
3	NULL	NULL
4	40	NULL
4	41	NULL
4	42	NULL
4	43	NULL
4	44	NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6)) AS `s` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a>=3) AS s
FROM t1;
SELECT * FROM v1;
ERROR 21000: Subquery returns more than 1 row
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a>=3) AS s
FROM t1;
ERROR 21000: Subquery returns more than 1 row
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
a	b	s
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,<in_optimizer>(`test`.`t1`.`a`,`test`.`t1`.`a` in ( <materialize> (/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6) ), <primary_index_lookup>(`test`.`t1`.`a` in <temporary table> on <auto_distinct_key> where ((`test`.`t1`.`a` = `<materialized_subquery>`.`1`))))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
SELECT * FROM v1;
a	b	c
1	10	6
2	20	6
2	21	6
3	NULL	6
4	40	6
4	41	6
4	42	6
4	43	6
4	44	6
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
a	b	c
1	10	6
2	20	6
2	21	6
3	NULL	6
4	40	6
4	41	6
4	42	6
4	43	6
4	44	6
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select count(0) from `test`.`t2`) AS `c` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select count(0) from `test`.`t2`) AS `c` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
SELECT * FROM v1;
a	b	c
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
a	b	c
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`c` AS `c` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,<in_optimizer>(`test`.`t1`.`a`,`test`.`t1`.`a` in ( <materialize> (/* select#2 */ select count(0) from `test`.`t2` having true ), <primary_index_lookup>(`test`.`t1`.`a` in <temporary table> on <auto_distinct_key> where ((`test`.`t1`.`a` = `<materialized_subquery>`.`COUNT(*)`))))) AS `c` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	2
2	20	4
2	21	4
3	NULL	6
4	40	8
4	41	8
4	42	8
4	43	8
4	44	8
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	2
2	20	4
2	21	4
3	NULL	6
4	40	8
4	41	8
4	42	8
4	43	8
4	44	8
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select (`test`.`t2`.`a` * 2) from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,exists(/* select#2 */ select (`test`.`t2`.`a` * 2) from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	2
2	21	2
3	NULL	1
4	40	5
4	41	5
4	42	5
4	43	5
4	44	5
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	2
2	21	2
3	NULL	1
4	40	5
4	41	5
4	42	5
4	43	5
4	44	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select count(0) from `test`.`t1` `t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`b` AS `b`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,exists(/* select#2 */ select count(0) from `test`.`t1` `t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
s
4
SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
s
4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '4' AS `s` from dual
explain SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2)))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
a	s
9	4
SELECT a FROM v1;
a
9
SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
a	s
9	4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a`,'4' AS `s` from dual
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a` from dual
explain SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select count(0) AS `a`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2)))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
s
0
SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
s
0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '0' AS `s` from dual
explain SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select <in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2))) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
a	s
9	0
SELECT a FROM v1;
a
9
SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
a	s
9	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a`,'0' AS `s` from dual
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a` from dual
explain SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select count(0) AS `a`,<in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2))) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
SELECT * FROM v1;
a	c	s
1	1	1
2	2	2
3	1	1
4	5	5
SELECT a FROM v1;
a
1
2
3
4
SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
a	c	s
1	1	1
2	2	2
3	1	1
4	5	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`c` AS `c`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,count(0) AS `c`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = count(`test`.`t1`.`a`))) AS `s` from `test`.`t1` group by `test`.`t1`.`a`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
SELECT * FROM v1;
a	c	s
1	1	1
2	2	1
3	1	0
4	5	0
SELECT a FROM v1;
a
1
2
3
4
SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
a	c	s
1	1	1
2	2	1
3	1	0
4	5	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a`,`test`.`v1`.`c` AS `c`,`test`.`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,count(0) AS `c`,<in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = count(`test`.`t1`.`a`)) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1` group by `test`.`t1`.`a`
DROP VIEW v1;
DROP TABLE t1, t2;
#
# Bug#19789450 Assert fail in add_key_field
#
CREATE TABLE t1 (
pk int NOT NULL,
col_date_key date DEFAULT NULL,
PRIMARY KEY (pk),
KEY col_date_key (col_date_key)
) ;
CREATE TABLE t2 (
pk int NOT NULL,
col_time_key time DEFAULT NULL,
col_datetime_key datetime DEFAULT NULL,
PRIMARY KEY (pk),
KEY col_time_key (col_time_key),
KEY col_datetime_key (col_datetime_key)
);
CREATE ALGORITHM=MERGE VIEW v1 AS 
SELECT col_date_key
FROM t1 WHERE (pk, pk, col_date_key) IN
(SELECT col_datetime_key,
col_time_key,
col_time_key
FROM t2
WHERE pk <= 7);
SELECT * FROM v1;
col_date_key
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#14117018 - MYSQL SERVER CREATES INVALID VIEW DEFINITION 
# BUG#18405221 - SHOW CREATE VIEW OUTPUT INCCORRECT 
#
CREATE VIEW v1 AS (SELECT '' FROM DUAL);
CREATE VIEW v2 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
CREATE VIEW v3 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
CREATE VIEW v4 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' AS col2 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
# Name for the column in select1 is set properly with or
# without this fix.
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select '' AS `Name_exp_1`	utf8mb4	utf8mb4_0900_ai_ci
# Name for the column in select2 is set with this fix.
# Without this fix, name would not have set for the
# columns in select2.
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select 'BUG#14117018' AS `col1` union all select '' AS `Name_exp_2`	utf8mb4	utf8mb4_0900_ai_ci
# Name for the field item in select2 & select3 is set with this fix.
# Without this fix, name would not have set for the
# columns in select2 & select3.
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select 'BUG#14117018' AS `col1` union all select '' AS `Name_exp_2` union all select '' AS `Name_exp_3`	utf8mb4	utf8mb4_0900_ai_ci
# Name for the field item in select3 is set with this fix.
# Without this fix, name would not have set for the
# columns in select3.
SHOW CREATE VIEW v4;
View	Create View	character_set_client	collation_connection
v4	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v4` AS select 'BUG#14117018' AS `col1` union all select '' AS `col2` union all select '' AS `Name_exp_3`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1, v2, v3, v4;
# Bug#20087932 Assert fail in Join_tab_compare_straight::operator()
CREATE TABLE t1 (
pk int NOT NULL,
col_varchar_key varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE TABLE t2 (
pk int NOT NULL,
col_varchar_key varchar(1) NOT NULL,
col_varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE TABLE t3 (
pk int NOT NULL,
col_int_key int NOT NULL,
col_varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE VIEW v2 AS SELECT * FROM t2;
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
explain SELECT STRAIGHT_JOIN alias1.pk
FROM t2 AS alias1
RIGHT JOIN
(SELECT sq1_alias2.*
FROM t1 AS sq1_alias1
RIGHT OUTER JOIN
v2 AS sq1_alias2
ON sq1_alias2.col_varchar_key = sq1_alias1.col_varchar_key AND
sq1_alias2.col_varchar_nokey IN
(SELECT c_sq1_alias1.col_varchar_nokey AS c_sq1_field1
FROM t3 AS c_sq1_alias1
WHERE c_sq1_alias1.col_int_key <> c_sq1_alias1.col_int_key
)
) AS alias2
ON alias2.col_varchar_key = alias1.col_varchar_key;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (hash join)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	sq1_alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	c_sq1_alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; FirstMatch(sq1_alias1)
Warnings:
Note	1003	/* select#1 */ select straight_join `test`.`alias1`.`pk` AS `pk` from (/* select#2 */ select `test`.`t2`.`pk` AS `pk`,`test`.`t2`.`col_varchar_key` AS `col_varchar_key`,`test`.`t2`.`col_varchar_nokey` AS `col_varchar_nokey` from `test`.`t2` left join (`test`.`t1` `sq1_alias1` semi join (`test`.`t3` `c_sq1_alias1`)) on(((`test`.`c_sq1_alias1`.`col_varchar_nokey` = `test`.`t2`.`col_varchar_nokey`) and (`test`.`sq1_alias1`.`col_varchar_key` = `test`.`t2`.`col_varchar_key`) and (`test`.`c_sq1_alias1`.`col_int_key` <> `test`.`c_sq1_alias1`.`col_int_key`))) where true) `alias2` left join `test`.`t2` `alias1` on((`test`.`alias1`.`col_varchar_key` = `alias2`.`col_varchar_key`)) where true
SELECT STRAIGHT_JOIN alias1.pk
FROM t2 AS alias1
RIGHT JOIN
(SELECT sq1_alias2.*
FROM t1 AS sq1_alias1
RIGHT OUTER JOIN
v2 AS sq1_alias2
ON sq1_alias2.col_varchar_key = sq1_alias1.col_varchar_key AND
sq1_alias2.col_varchar_nokey IN
(SELECT c_sq1_alias1.col_varchar_nokey AS c_sq1_field1
FROM t3 AS c_sq1_alias1
WHERE c_sq1_alias1.col_int_key <> c_sq1_alias1.col_int_key
)
) AS alias2
ON alias2.col_varchar_key = alias1.col_varchar_key;
pk
DROP VIEW v2;
DROP TABLE t1, t2, t3;
CREATE TABLE t0(x INTEGER);
INSERT INTO t0 VALUES(0);
CREATE TABLE t1(a1 INTEGER PRIMARY KEY, b1 INTEGER);
CREATE TABLE t2(a2 INTEGER PRIMARY KEY, b2 INTEGER);
CREATE VIEW v0 AS SELECT DISTINCT x FROM t0;
CREATE VIEW vmat1 AS SELECT DISTINCT * FROM t1;
CREATE VIEW vmat2 AS SELECT DISTINCT * FROM t2;
CREATE VIEW vtt AS
SELECT * FROM t1 JOIN t2 ON t1.a1=t2.a2;
CREATE VIEW vtr AS
SELECT * FROM t1 JOIN vmat2 AS dt2 ON t1.a1=dt2.a2;
CREATE VIEW vtrd AS
SELECT * FROM t1 JOIN (SELECT DISTINCT * FROM t2) AS dt2 ON t1.a1=dt2.a2;
CREATE VIEW vrt AS
SELECT * FROM vmat1 AS dt1 JOIN t2 ON dt1.a1=t2.a2;
CREATE VIEW vrtd AS
SELECT * FROM (SELECT DISTINCT * FROM t1) AS dt1 JOIN t2 ON dt1.a1=t2.a2;
CREATE VIEW vrr AS
SELECT * FROM vmat1 AS dt1 JOIN vmat2 AS dt2 ON dt1.a1=dt2.a2;
CREATE VIEW vrrd AS
SELECT * FROM (SELECT DISTINCT * FROM t1) AS dt1 JOIN
(SELECT DISTINCT * FROM t2) AS dt2 ON dt1.a1=dt2.a2;
INSERT INTO vtt(a1,b1) VALUES (1,100);
INSERT INTO vtt(a2,b2) VALUES (1,100);
INSERT INTO vtr(a1,b1) VALUES (2,100);
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a1,b1) VALUES (3,100);
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vtr(a2,b2) VALUES (2,100);
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a2,b2) VALUES (3,100);
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vrt(a1,b1) VALUES (4,100);
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a1,b1) VALUES (5,100);
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrt(a2,b2) VALUES (4,100);
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a2,b2) VALUES (5,100);
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrr(a1,b1) VALUES (6,100);
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a1,b1) VALUES (7,100);
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
INSERT INTO vrr(a2,b2) VALUES (6,100);
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a2,b2) VALUES (7,100);
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO vtt(a1,b1) SELECT 1,100;
INSERT INTO vtt(a2,b2) SELECT 1,100;
INSERT INTO vtr(a1,b1) SELECT 2,100;
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a1,b1) SELECT 3,100;
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vtr(a2,b2) SELECT 2,100;
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a2,b2) SELECT 3,100;
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vrt(a1,b1) SELECT 4,100;
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a1,b1) SELECT 5,100;
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrt(a2,b2) SELECT 4,100;
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a2,b2) SELECT 5,100;
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrr(a1,b1) SELECT 6,100;
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a1,b1) SELECT 7,100;
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
INSERT INTO vrr(a2,b2) SELECT 6,100;
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a2,b2) SELECT 7,100;
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES
(1,100), (2,100), (3,100), (4,100), (5,100),
(6,100), (7,100), (8,100), (9,100), (10,100),
(11,100), (12,100), (13,100), (14,100);
INSERT INTO t2 VALUES
(1,100), (2,100), (3,100), (4,100), (5,100),
(6,100), (7,100), (8,100), (9,100), (10,100),
(11,100), (12,100), (13,100), (14,100);
DELETE FROM vtt WHERE a1=1;
ERROR HY000: Can not delete from join view 'test.vtt'
DELETE FROM vtr WHERE a1=2;
ERROR HY000: Can not delete from join view 'test.vtr'
DELETE FROM vtrd WHERE a1=3;
ERROR HY000: Can not delete from join view 'test.vtrd'
DELETE FROM vrt WHERE a1=4;
ERROR HY000: Can not delete from join view 'test.vrt'
DELETE FROM vrtd WHERE a1=5;
ERROR HY000: Can not delete from join view 'test.vrtd'
DELETE FROM vrr WHERE a1=6;
ERROR HY000: The target table vrr of the DELETE is not updatable
DELETE FROM vrrd WHERE a1=7;
ERROR HY000: The target table vrrd of the DELETE is not updatable
DELETE vtt FROM vtt WHERE a1=8;
ERROR HY000: Can not delete from join view 'test.vtt'
DELETE vtr FROM vtr WHERE a1=9;
ERROR HY000: Can not delete from join view 'test.vtr'
DELETE vtrd FROM vtrd WHERE a1=10;
ERROR HY000: Can not delete from join view 'test.vtrd'
DELETE vrt FROM vrt WHERE a1=11;
ERROR HY000: Can not delete from join view 'test.vrt'
DELETE vrtd FROM vrtd WHERE a1=12;
ERROR HY000: Can not delete from join view 'test.vrtd'
DELETE vrr FROM vrr WHERE a1=13;
ERROR HY000: The target table vrr of the DELETE is not updatable
DELETE vrrd FROM vrrd WHERE a1=14;
ERROR HY000: The target table vrrd of the DELETE is not updatable
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
2	100	2	100
3	100	3	100
4	100	4	100
5	100	5	100
6	100	6	100
7	100	7	100
8	100	8	100
9	100	9	100
10	100	10	100
11	100	11	100
12	100	12	100
13	100	13	100
14	100	14	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES (1,100);
INSERT INTO t2 VALUES (1,100);
UPDATE vtt SET b1=b1+1 WHERE a1=1;
UPDATE vtt SET b2=b2+1 WHERE a2=1;
UPDATE vtr SET b1=b1+1 WHERE a1=1;
UPDATE vtrd SET b1=b1+1 WHERE a1=1;
UPDATE vtr SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtr of the UPDATE is not updatable
UPDATE vtrd SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtrd of the UPDATE is not updatable
UPDATE vrt SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrt of the UPDATE is not updatable
UPDATE vrtd SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrtd of the UPDATE is not updatable
UPDATE vrt SET b2=b2+1 WHERE a2=1;
UPDATE vrtd SET b2=b2+1 WHERE a2=1;
UPDATE vrr SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vrr SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vtt, v0 AS dt SET b1=b1+1 WHERE a1=1;
UPDATE vtt, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vtr, v0 SET b1=b1+1 WHERE a1=1;
UPDATE vtrd, v0 SET b1=b1+1 WHERE a1=1;
UPDATE vtr, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtr of the UPDATE is not updatable
UPDATE vtrd, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtrd of the UPDATE is not updatable
UPDATE vrt, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrt of the UPDATE is not updatable
UPDATE vrtd, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrtd of the UPDATE is not updatable
UPDATE vrt, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vrtd, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vrr, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vrr, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
SELECT * FROM vtt;
a1	b1	a2	b2
1	106	1	106
DROP VIEW v0, vtt, vtr, vrt, vrr, vmat1, vmat2;
DROP VIEW vtrd, vrtd, vrrd;
DROP TABLE t0, t1, t2;
#
# Bug#20407961 VIEW'S CHECK OPTION SOMETIMES NOT HONOURED IF INCLUDED IN A TOP VIEW
#
create table t1 (a varchar(100));
# n/c/l letter suffix means: no/cascaded/local check option
create view v1n as select * from t1 where a like '%v1n%';
create view v2c as select * from t1 where a like '%v2c%'
 with check option;
show create view v2c;
View	Create View	character_set_client	collation_connection
v2c	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2c` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` like '%v2c%') WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
create view v3l as select * from t1 where a like '%v3l%'
 with local check option;
show create view v3l;
View	Create View	character_set_client	collation_connection
v3l	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3l` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` like '%v3l%') WITH LOCAL CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
# The basic, single-view feature works:
insert into t1 values('');
insert into v1n values('');
insert into v2c values('');
ERROR HY000: CHECK OPTION failed 'test.v2c'
insert into v2c values('v2c');
insert into v3l values('');
ERROR HY000: CHECK OPTION failed 'test.v3l'
insert into v3l values('v3l');
# We also test UPDATE of the successfully inserted row
update v1n set a='_';
# if this update to v2c was allowed, it would be produce a row in t1
# not matching v2c's filter, which is against the goal of CHECK
# OPTION.
update v2c set a='';
ERROR HY000: CHECK OPTION failed 'test.v2c'
update v3l set a='';
ERROR HY000: CHECK OPTION failed 'test.v3l'
# Top view without no CHECK OPTION, still CHECK OPTION conditions
# of underlying views are checked.
create view v4n as select * from v2c where a like '%v4n%';
create view v5n as select * from v3l where a like '%v5n%';
# The view's nesting structure is:
# v4n -> v2c -> t1
# We present the query with needed tags, verify that it passes,
# then we take each tag away and verify that it fails.
insert into v4n values('v2c');
insert into v4n values('');
ERROR HY000: CHECK OPTION failed 'test.v4n'
# To check UPDATE on v4n, we need to update a row originally
# visible in v4n, so we create it:
insert into v4n values('v4n v2c');
# This row can legally disappear from v4n:
update v4n set a='v2c';
insert into v4n values('v4n v2c');
# But this row cannot disappear from v2c:
update v4n set a='v4n';
ERROR HY000: CHECK OPTION failed 'test.v4n'
# Lest we delete it:
delete from v4n;
# v5n -> v3l -> t1
insert into v5n values('v3l');
insert into v5n values('');
ERROR HY000: CHECK OPTION failed 'test.v5n'
# Top view with LOCAL CHECK OPTION, still CHECK OPTION conditions
# of underlying views are checked.
create view v4l as select * from v2c where a like '%v4l%'
 with local check option;
create view v5l as select * from v3l where a like '%v5l%'
 with local check option;
# v4l -> v2c -> t1
insert into v4l values('v4l v2c');
insert into v4l values('v2c');
ERROR HY000: CHECK OPTION failed 'test.v4l'
update v4l set a='v2c';
ERROR HY000: CHECK OPTION failed 'test.v4l'
insert into v4l values('v4l');
ERROR HY000: CHECK OPTION failed 'test.v4l'
update v4l set a='v4l';
ERROR HY000: CHECK OPTION failed 'test.v4l'
# v5l -> v3l -> t1
insert into v5l values('v5l v3l');
insert into v5l values('v3l');
ERROR HY000: CHECK OPTION failed 'test.v5l'
update v5l set a='v3l';
ERROR HY000: CHECK OPTION failed 'test.v5l'
insert into v5l values('v5l');
ERROR HY000: CHECK OPTION failed 'test.v5l'
update v5l set a='v5l';
ERROR HY000: CHECK OPTION failed 'test.v5l'
# CASCADED makes all filtering conditions a requirement
create view v6c as select * from v5n where a like '%v6c%'
 with cascaded check option;
# v6c -> v5n -> v3l -> t1
insert into v6c values('v6c v5n v3l');
insert into v6c values('v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v6c'
insert into v6c values('v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v6c'
insert into v6c values('v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v6c v5n';
ERROR HY000: CHECK OPTION failed 'test.v6c'
# Also true if top view has no check option:
create view v7n as select * from v6c where a like '%v7n%';
# v7n -> v6c -> v5n -> v3l -> t1
insert into v7n values('v6c v5n v3l');
insert into v7n values('v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v7n'
insert into v7n values('v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v7n'
insert into v7n values('v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v7n'
# Make a visible row to update:
insert into v7n values('v7n v6c v5n v3l');
update v7n set a='v7n v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v7n'
update v7n set a='v7n v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v7n'
update v7n set a='v7n v6c v5nà';
ERROR HY000: CHECK OPTION failed 'test.v7n'
# Also true if top view has LOCAL:
create view v8l as select * from v7n where a like '%v8l%'
 with local check option;
# v8l -> v7n -> v6c -> v5n -> v3l -> t1
insert into v8l values('v8l v6c v5n v3l');
insert into v8l values('v6c v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v8l'
# Make a visible row (=> satisfy v7n's WHERE clause):
insert into v8l values('v8l v7n v6c v5n v3l');
update v8l set a='v7n v6c v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v6c v5n';
ERROR HY000: CHECK OPTION failed 'test.v8l'
drop view v1n,v2c,v3l,v4n,v5n,v4l,v5l,v6c,v7n,v8l;
drop table t1;
# Bug#20982756 Crash in Table_list::fetch_number_of_rows
CREATE TABLE t1(a INTEGER) engine=innodb;
CREATE VIEW v3 AS SELECT 1 FROM t1;
CREATE VIEW v2 AS SELECT 1 FROM v3 LEFT JOIN t1 ON 1;
PREPARE s FROM "set @a:=(SELECT 1 FROM t1,v2);";
EXECUTE s;
EXECUTE s;
DROP VIEW  v2,v3;
DROP TABLE t1;
# Bug#21097485 *insert_table_ref && (*insert_table_ref)->is_insertable
CREATE TABLE t1 (r INTEGER) engine=innodb;
CREATE VIEW v1 AS
SELECT 1 AS z from t1;
INSERT INTO v1(z) VALUES(1);
ERROR HY000: Column 'z' is not updatable
DROP VIEW  v1;
DROP TABLE t1;
# Bug#21277074: crash (segfault) in THD::change_item_tree on exec of prep
CREATE TABLE t (i INTEGER);
PREPARE s1 FROM
"SELECT (SELECT MAX(i)) AS field1
   FROM (SELECT * FROM t) AS table1"
;
EXECUTE s1;
field1
NULL
CREATE VIEW v AS SELECT * FROM t;
PREPARE s2 FROM
"SELECT (SELECT MAX(i)) AS field1
   FROM v AS table1"
;
EXECUTE s2;
field1
NULL
DEALLOCATE PREPARE s1;
DEALLOCATE PREPARE s2;
DROP VIEW v;
DROP TABLE t;
#
# BUG#19886430: VIEW CREATION WITH NAMED COLUMNS, OVER UNION,
#               IS REJECTED
# Without the patch, reports an error.
CREATE VIEW v1 (fld1, fld2) AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
# The column names are explicitly specified and not duplicates, hence
# succeeds.
CREATE VIEW v2 (fld1, fld2) AS
SELECT 1 AS a, 2 AS a
UNION ALL
SELECT 1 AS a, 1 AS a;
# The column name in the first SELECT are not duplicates, hence succeeds.
CREATE VIEW v3 AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
# Should report an error, since the explicitly specified column names are
# duplicates.
CREATE VIEW v4 (fld1, fld1) AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
ERROR 42S21: Duplicate column name 'fld1'
# Should report an error, since duplicate column name is specified in the
# First SELECT.
CREATE VIEW v4 AS
SELECT 1 AS a, 2 AS a
UNION ALL
SELECT 1 AS a, 1 AS a;
ERROR 42S21: Duplicate column name 'a'
# Cleanup
DROP VIEW v1, v2, v3;
#
# Bug #22108567 ASSERTION `TABLE != 0' FAILED
#
PREPARE X FROM 'CREATE VIEW bug22108567_v1 AS SELECT 1 FROM (SELECT 1) AS D1';
EXECUTE X;
DROP VIEW bug22108567_v1;
#
# BUG#21877062: MIN/MAX IN VIEW ON TIMESTAMDIFF IN VIEW CONFUSES
#               OPTIMIZER TO THROW SYNTAX ERROR
#
CREATE TABLE t(ts1 DATETIME(6), ts2 DATETIME(6));
INSERT INTO t VALUES('2016-01-11 09:15:25','2016-01-11 21:15:25');
CREATE VIEW v1 AS
SELECT TIMESTAMPDIFF(MICROSECOND, ts1, ts2) duration FROM t;
# Without the patch, a syntax error is reported.
SELECT * FROM v1;
duration
43200000000
CREATE VIEW v2 AS
SELECT MIN(duration) AS dmin, MAX(duration) AS dmax FROM v1;
DROP VIEW v1, v2;
DROP TABLE t;
#
# Bug24786327 SIG 11 IN __STPCPY_SSE2_UNALIGNED FROM MY_STPCPY() IN SQL/AUTH/SQL_AUTH_CACHE.CC
#
CREATE TABLE t1_base_N3 (pk INT, col_int INT);
CREATE VIEW t1_view_N3 AS SELECT * FROM t1_base_N3 WHERE `pk` BETWEEN 1 AND
2;
CREATE VIEW t1_view_N4 AS SELECT * FROM ( SELECT * FROM t1_view_N3 ) AS A;
UPDATE t1_view_N3 AS A JOIN t1_view_N4 B SET A. col_int = 1 , B. col_int = 2;
ERROR HY000: The target table B of the UPDATE is not updatable
DROP VIEW t1_view_N3, t1_view_N4;
DROP TABLE t1_base_N3;
#
# WL#7743: New data dictionary: changes to DDL-related parts of SE API
#
CREATE TABLE t1(a INT);
CREATE VIEW v1 AS SELECT * FROM t1;
RENAME TABLE t1 TO t2, v1 TO v2;
SELECT * FROM information_schema.views WHERE table_schema='test';
TABLE_CATALOG	TABLE_SCHEMA	TABLE_NAME	VIEW_DEFINITION	CHECK_OPTION	IS_UPDATABLE	DEFINER	SECURITY_TYPE	CHARACTER_SET_CLIENT	COLLATION_CONNECTION
def	test	v2	select `test`.`t1`.`a` AS `a` from `test`.`t1`	NONE	YES	root@localhost	DEFINER	utf8mb4	utf8mb4_0900_ai_ci
Warnings:
Warning	1356	View 'test.v2' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP VIEW v2;
DROP TABLE t2;
CREATE TABLE t1(a INT);
CREATE TABLE t2(b INT);
CREATE TABLE t3(a INT);
CREATE TABLE t4(b INT);
CREATE VIEW v1 AS SELECT * FROM t1, t2;
DROP TABLE t1, t2;
RENAME TABLE t3 TO t1, t4 TO t2;
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#25634576: DATABASE NAME IN SHOW CREATE VIEW
#
CREATE DATABASE db;
CREATE TABLE db.t1(fld1 INT);
CREATE TABLE db.t2(fld2 INT);
CREATE TABLE t1(fld1 INT);
CREATE TABLE t2(fld2 INT);
# With patch, db name is appended only to those tables
# which are not present in the current database.
# Test cases with reference to table within current
# db and outside current db.
CREATE VIEW v1 AS SELECT * FROM t1 UNION SELECT * FROM t2;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`fld1` AS `fld1` from `t1` union select `t2`.`fld2` AS `fld2` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v2 AS SELECT * FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v3 AS SELECT fld1 FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v4 AS SELECT t1.fld1 FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v4;
View	Create View	character_set_client	collation_connection
v4	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v4` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v5 AS SELECT * FROM db.t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v5;
View	Create View	character_set_client	collation_connection
v5	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v5` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
# Test cases with subquery.
CREATE VIEW v6 AS SELECT * FROM t2 WHERE fld2 IN (SELECT fld1 FROM t1);
SHOW CREATE VIEW v6;
View	Create View	character_set_client	collation_connection
v6	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v6` AS select `t2`.`fld2` AS `fld2` from `t2` where `t2`.`fld2` in (select `t1`.`fld1` from `t1`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v7 AS SELECT * FROM db.t2 WHERE fld2 IN (SELECT fld1 FROM t1);
SHOW CREATE VIEW v7;
View	Create View	character_set_client	collation_connection
v7	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v7` AS select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2` where `db`.`t2`.`fld2` in (select `t1`.`fld1` from `t1`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v8 AS SELECT * FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v8;
View	Create View	character_set_client	collation_connection
v8	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v8` AS select `t1`.`fld1` AS `fld1` from `t1` where `t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`) is false	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v9 AS SELECT fld1 FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v9;
View	Create View	character_set_client	collation_connection
v9	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v9` AS select `t1`.`fld1` AS `fld1` from `t1` where `t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`) is false	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v10 AS SELECT t1.fld1 FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v10;
View	Create View	character_set_client	collation_connection
v10	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v10` AS select `t1`.`fld1` AS `fld1` from `t1` where `t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`) is false	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v11 AS SELECT * FROM db.t1 WHERE fld1 NOT IN
(SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v11;
View	Create View	character_set_client	collation_connection
v11	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v11` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` where `db`.`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`) is false	utf8mb4	utf8mb4_0900_ai_ci
# Test cases which uses derived table in sub query.
CREATE VIEW v12 AS SELECT * FROM (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW v12;
View	Create View	character_set_client	collation_connection
v12	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v12` AS select `dummy`.`fld1` AS `fld1` from (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v13 AS SELECT * FROM (SELECT fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v13;
View	Create View	character_set_client	collation_connection
v13	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v13` AS select `dummy`.`fld1` AS `fld1` from (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v14 AS SELECT * FROM db.t2, (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW v14;
View	Create View	character_set_client	collation_connection
v14	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v14` AS select `db`.`t2`.`fld2` AS `fld2`,`dummy`.`fld1` AS `fld1` from (`db`.`t2` join (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v15 AS SELECT * FROM db.t2, (SELECT fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v15;
View	Create View	character_set_client	collation_connection
v15	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v15` AS select `db`.`t2`.`fld2` AS `fld2`,`dummy`.`fld1` AS `fld1` from (`db`.`t2` join (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v16 AS SELECT db.t2.fld2 FROM db.t2, (SELECT t1.fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v16;
View	Create View	character_set_client	collation_connection
v16	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v16` AS select `db`.`t2`.`fld2` AS `fld2` from (`db`.`t2` join (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
# Test cases using CTE.
CREATE VIEW v17 AS WITH cte AS (SELECT * FROM t1) SELECT * FROM cte;
SHOW CREATE VIEW v17;
View	Create View	character_set_client	collation_connection
v17	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v17` AS with `cte` as (select `t1`.`fld1` AS `fld1` from `t1`) select `cte`.`fld1` AS `fld1` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v18 AS WITH cte AS (SELECT fld1 FROM t1) SELECT * FROM cte;
SHOW CREATE VIEW v18;
View	Create View	character_set_client	collation_connection
v18	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v18` AS with `cte` as (select `t1`.`fld1` AS `fld1` from `t1`) select `cte`.`fld1` AS `fld1` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v19 AS WITH cte AS (SELECT db.t2.fld2 FROM db.t2) SELECT * FROM cte;
SHOW CREATE VIEW v19;
View	Create View	character_set_client	collation_connection
v19	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v19` AS with `cte` as (select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`) select `cte`.`fld2` AS `fld2` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
# Test case added for coverage where view is created in different db.
CREATE VIEW db.v1 AS SELECT * FROM db.t1 UNION SELECT * FROM t2;
SHOW CREATE VIEW db.v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v1` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` union select `t2`.`fld2` AS `fld2` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW db.v2 AS SELECT * FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW db.v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v2` AS select `t1`.`fld1` AS `fld1` from `t1` where `t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`) is false	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW db.v3 AS SELECT * FROM (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW db.v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v3` AS select `dummy`.`fld1` AS `fld1` from (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
# Cleanup.
DROP VIEW v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
v16, v17, v18, v19;
DROP TABLE t1, t2;
DROP DATABASE db;
#
# Bug#25832861: TABLE_SHARE->TMP_TABLE != NO_TMP_TABLE || M_LOCK_TYPE == 1' AT HANDLER::HA_UPDAT
#
CREATE TABLE t1 (a INTEGER);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT a FROM t1;
CREATE VIEW v2 AS SELECT 1;
CREATE VIEW v3 AS SELECT a FROM (SELECT a FROM v1) AS dt;
CREATE VIEW v4 AS SELECT a FROM (SELECT a FROM t1) AS dt;
CREATE VIEW v5 AS SELECT a FROM (SELECT a FROM v3) AS dt2;
UPDATE v3 SET v3.a=3;
ERROR HY000: The target table v3 of the UPDATE is not updatable
UPDATE v3, v2 SET v3.a=3;
ERROR HY000: The target table v3 of the UPDATE is not updatable
UPDATE v3, v1 SET v1.a=3;
SELECT * FROM t1;
a
3
3
UPDATE v3, t1 SET t1.a=4;
SELECT * FROM t1;
a
4
4
UPDATE v4 SET v4.a=6;
ERROR HY000: The target table v4 of the UPDATE is not updatable
SELECT * FROM t1;
a
4
4
UPDATE v4, v2 SET v4.a=6;
ERROR HY000: The target table v4 of the UPDATE is not updatable
UPDATE v4, v1 SET v1.a=6;
SELECT * FROM t1;
a
6
6
UPDATE v4, t1 SET t1.a=7;
SELECT * FROM t1;
a
7
7
UPDATE v5 SET v5.a=9;
ERROR HY000: The target table v5 of the UPDATE is not updatable
UPDATE v5, v2 SET v5.a=9;
ERROR HY000: The target table v5 of the UPDATE is not updatable
UPDATE v5, v1 SET v1.a=9;
SELECT * FROM t1;
a
9
9
UPDATE v5, t1 SET t1.a=10;
SELECT * FROM t1;
a
10
10
DROP TABLE t1;
DROP VIEW v1, v2, v3, v4, v5;
# Bug#26659699 Assertion !(thd->lex->context_analysis_only & 2) failed
CREATE TABLE t1(pk INTEGER, cik INTEGER, UNIQUE KEY(cik))
PARTITION BY KEY(cik) PARTITIONS 10;
CREATE TABLE t2(pk INTEGER, cvk VARCHAR(20), cik INTEGER, UNIQUE KEY(cik))
PARTITION BY KEY(cik) PARTITIONS 10;
CREATE VIEW v1 AS
SELECT MAX(t2.pk) AS field1
FROM t1, t2
WHERE (SELECT 7 FROM DUAL) IS NOT NULL AND
t1.pk BETWEEN 123 AND (123 + 128) AND
t2.cvk <= 'p'
ORDER BY t1.pk DESC;
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#26266789: ON SERVER 8.0 CREATE OR REPLACE VIEW FAILS FOR COLUMN SIZE > 64
#
CREATE TABLE t1(fld1 INT, fld2 INT);
INSERT INTO t1 VALUES(1, 1);
# Without patch, a dictionary store error is triggered on release
# build and an assert on debug build.
CREATE OR REPLACE VIEW v1
(`x12345678901234567890123456789012345678901234567890123456789012322`) AS
SELECT fld1 FROM t1;
ERROR 42000: Incorrect column name 'x12345678901234567890123456789012345678901234567890123456789012322'
# Clean up.
DROP TABLE t1;
#
# Bug#26360114 WRONG RESULT WITH AGGREGATE AND HAVING CLAUSE IN VIEW
#
CREATE TABLE t1 (
col_date_key DATE,
KEY col_date_key (col_date_key)
);
INSERT INTO t1 VALUES ('2007-02-08');
INSERT INTO t1 VALUES ('2007-02-08');
INSERT INTO t1 VALUES ('2008-11-04');
INSERT INTO t1 VALUES ('2008-11-04');
INSERT INTO t1 VALUES ('2009-01-14');
INSERT INTO t1 VALUES ('2009-01-14');
SELECT MAX(col_date_key) AS x
FROM t1
HAVING x >= CAST('2009-01-01' AS DATE)
;
x
2009-01-14
CREATE VIEW v1 AS
SELECT MAX(col_date_key) AS x
FROM t1
HAVING x >= CAST('2009-01-01' AS DATE)
;
SELECT * FROM v1;
x
2009-01-14
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#27121663: SIG 11 IN FILL_DD_VIEW_TABLES | SQL/DD/DD_VIEW.CC
#
CREATE TABLE t1 (pk INT);
CREATE VIEW v1 AS SELECT COUNT(*) FROM t1
ORDER BY (SELECT 1 FROM t1 WHERE 1 IN (SELECT * FROM (SELECT 1 as field) AS dt));
DROP TABLE t1;
DROP VIEW v1;
#
# Bug #28278220 - WRONG COLUMN TYPE , VIEW , BINARY
#
CREATE VIEW v AS SELECT null AS 'c' UNION SELECT 'a' AS 'c';
# Without fix, type for field c is listed as binary instead of
# varchar(1). With fix type is listed correctly.
SHOW FIELDS FROM v;
Field	Type	Null	Key	Default	Extra
c	varchar(1)	YES		NULL	
DROP VIEW v;
#
# Bug#32050275 - can't create synonym of information_schema using create_synonym_db()
#
PREPARE stmt FROM "CREATE VIEW v1 AS SELECT * FROM
                   JSON_TABLE('[]', '$[*]' COLUMNS (c1 INT PATH '$.x')) AS jt";
EXECUTE stmt;
EXECUTE stmt;
ERROR 42S01: Table 'v1' already exists
DROP VIEW v1;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
PREPARE stmt FROM "CREATE VIEW v1 AS WITH RECURSIVE cte (n) AS
                    (
                      SELECT 1
                      UNION ALL
                      SELECT n + 1 FROM cte WHERE n < 5
                    )
                    SELECT * FROM cte";
EXECUTE stmt;
EXECUTE stmt;
ERROR 42S01: Table 'v1' already exists
DROP VIEW v1;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
call sys.create_synonym_db("INFORMATION_SCHEMA", "I_S");
summary
Created XX views in the `I_S` database
DROP DATABASE I_S;
# Bug#32694458: Assertion `thd->is_error()' failed|sql/sql_select.cc
CREATE VIEW v AS SELECT INSERT('a', 1, 1, YEAR(UNHEX('w'))) AS c;
SHOW CREATE VIEW v;
View	Create View	character_set_client	collation_connection
v	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v` AS select insert('a',1,1,year(unhex('w'))) AS `c`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM v;
c
NULL
Warnings:
Warning	1411	Incorrect string value: ''w'' for function unhex
DROP VIEW v;
#
# Bug #32854203: DUMP/RESTORE FAILS WITH NESTED VIEWS HAVING ROLLUP OVER DISTINCT GROUPS
#
CREATE VIEW v2 AS SELECT 1 AS c;
CREATE VIEW v1 AS SELECT 4711 AS a, COUNT(DISTINCT c) FROM v2 GROUP BY a WITH ROLLUP;
DROP VIEW v2;
CREATE VIEW v2 AS SELECT 1 AS c;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 4711 AS `a`,count(distinct `v2`.`c`) AS `COUNT(DISTINCT c)` from `v2` group by `a` with rollup	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1, v2;
#
# BUG#30909064 Explain neglects db part of identifier after create view
#
CREATE TABLE t1 (
pk INT,
col_int_key INT,
col_int_nokey INT,
col_varchar_key VARCHAR(10),
col_varchar_nokey VARCHAR(10),
KEY col_int_key (col_int_key),
KEY col_varchar_key (col_varchar_key)
);
INSERT INTO t1 VALUES (), ();
CREATE VIEW v1 AS
SELECT alias1.col_int_nokey AS field1,
(SELECT alias2.col_int_key
FROM t1 AS alias2
WHERE alias1.col_varchar_key <= alias1.col_varchar_nokey
) AS field2
FROM t1 AS alias1;
DROP VIEW v1;
EXPLAIN SELECT pk AS foo, col_int_key AS bar FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `foo`,`test`.`t1`.`col_int_key` AS `bar` from `test`.`t1`
DROP TABLE t1;
# Bug#34239456: Assertion '!thd->is_error()' failed in MySQL 8.0.29
CREATE TABLE t0 (c0 INTEGER, c1 INTEGER);
CREATE VIEW v0 AS
SELECT c0
FROM t0
WHERE c1 = (SELECT 1
UNION
SELECT c0 FROM t0
ORDER BY c1
);
SELECT * FROM v0;
ERROR 42000: Table 't0' from one of the SELECTs cannot be used in global ORDER clause
DROP VIEW v0;
DROP TABLE t0;
#
# Bug#34800905 - View definition changes latin 1 Invalid utf8mb4 character
#
CREATE TABLE `t1` (`c1` SMALLINT DEFAULT NULL);
CREATE VIEW v1 AS SELECT c1,'á' AS c2 FROM t1;
INSERT INTO t1 (c1) VALUES ('0'), ('1');
SET NAMES 'latin1';
ALTER TABLE t1 RENAME t1_aux;
ALTER TABLE t1_aux RENAME t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1`,'' AS `c2` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
SET NAMES DEFAULT;
# Without fix, invalid character string error is reported for column c2.
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1`,'á' AS `c2` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
# Without fix, incorrect values listed for column c2.
SELECT * FROM v1;
c1	c2
0	á
1	á
DROP VIEW v1;
DROP TABLE t1;
