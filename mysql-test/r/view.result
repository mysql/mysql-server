drop table if exists t1,t2,t3,t4,t9,`t1a``b`,v1,v2,v3,v4,v5,v6;
drop view if exists t1,t2,`t1a``b`,v1,v2,v3,v4,v5,v6;
drop database if exists mysqltest;
use test;
create view v1 (c,d) as select a,b from t1;
ERROR 42S02: Table 'test.t1' doesn't exist
create temporary table t1 (a int, b int);
create view v1 (c) as select b+1 from t1;
ERROR HY000: View's SELECT refers to a temporary table 't1'
drop table t1;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1 (c,d) as select a,b+@@global.max_user_connections from t1;
ERROR HY000: View's SELECT contains a variable or parameter
create view v1 (c,d) as select a,b from t1
where a = @@global.max_user_connections;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT @a=1 FROM DUAL;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE @a>1;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT (@a:= 1) AS one FROM DUAL;
ERROR HY000: View's SELECT contains a variable or parameter
CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE (@a:= 1);
ERROR HY000: View's SELECT contains a variable or parameter
create view v1 (c) as select b+1 from t1;
select c from v1;
c
3
4
5
6
11
select is_updatable from information_schema.views where table_name='v1';
IS_UPDATABLE
NO
create temporary table t1 (a int, b int);
select * from t1;
a	b
select c from v1;
c
3
4
5
6
11
show create table v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
show create view t1;
ERROR HY000: 'test.t1' is not VIEW
drop table t1;
select a from v1;
ERROR 42S22: Unknown column 'a' in 'field list'
select v1.a from v1;
ERROR 42S22: Unknown column 'v1.a' in 'field list'
select b from v1;
ERROR 42S22: Unknown column 'b' in 'field list'
select v1.b from v1;
ERROR 42S22: Unknown column 'v1.b' in 'field list'
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
explain select c from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`b` + 1) AS `c` from `test`.`t1`
create algorithm=temptable view v2 (c) as select b+1 from t1;
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select c from v2;
c
3
4
5
6
11
explain select c from v2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `v2`.`c` AS `c` from `test`.`v2`
create view v3 (c) as select a+1 from v1;
ERROR 42S22: Unknown column 'a' in 'field list'
create view v3 (c) as select b+1 from v1;
ERROR 42S22: Unknown column 'b' in 'field list'
create view v3 (c) as select c+1 from v1;
select c from v3;
c
4
5
6
7
12
explain select c from v3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select ((`test`.`t1`.`b` + 1) + 1) AS `c` from `test`.`t1`
create algorithm=temptable view v4 (c) as select c+1 from v2;
select c from v4;
c
4
5
6
7
12
explain select c from v4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `v4`.`c` AS `c` from `test`.`v4`
create view v5 (c) as select c+1 from v2;
select c from v5;
c
4
5
6
7
12
explain select c from v5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select (`v2`.`c` + 1) AS `c` from `test`.`v2`
create algorithm=temptable view v6 (c) as select c+1 from v1;
select c from v6;
c
4
5
6
7
12
explain select c from v6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `v6`.`c` AS `c` from `test`.`v6`
show tables;
Tables_in_test
t1
v1
v2
v3
v4
v5
v6
show full tables;
Tables_in_test	Table_type
t1	BASE TABLE
v1	VIEW
v2	VIEW
v3	VIEW
v4	VIEW
v5	VIEW
v6	VIEW
show table status;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	InnoDB	10	Dynamic	#	#	#	#	0	0	NULL	#	#	NULL	utf8mb4_0900_ai_ci	NULL		
v1	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v2	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v3	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v4	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v5	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
v6	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	VIEW
drop view v1,v2,v3,v4,v5,v6;
create view v1 (c,d,e,f) as select a,b,
a in (select a+2 from t1), a = all (select a from t1) from t1;
create view v2 as select c, d from v1;
select * from v1;
c	d	e	f
1	2	0	0
1	3	0	0
2	4	0	0
2	5	0	0
3	10	1	0
select * from v2;
c	d
1	2
1	3
2	4
2	5
3	10
create view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1;
ERROR 42S01: Table 'v1' already exists
create or replace view v1 (c,d,e,f) as select a,b, a in (select a+2 from t1), a = all (select a from t1) from t1;
drop view v2;
alter view v2 as select c, d from v1;
ERROR 42S02: Table 'test.v2' doesn't exist
create or replace view v2 as select c, d from v1;
alter view v1 (c,d) as select a,max(b) from t1 group by a;
select * from v1;
c	d
1	3
2	5
3	10
select * from v2;
c	d
1	3
2	5
3	10
drop view v100;
ERROR 42S02: Unknown table 'test.v100'
drop view t1;
ERROR HY000: 'test.t1' is not VIEW
drop table v1;
ERROR 42S02: Unknown table 'test.v1'
drop view v1,v2;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3);
create view v1 (a) as select a+1 from t1;
create view v2 (a) as select a-1 from t1;
select * from t1 natural left join v1;
a
1
2
3
select * from v2 natural left join t1;
a
0
1
2
select * from v2 natural left join v1;
a
0
1
2
drop view v1, v2;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3), (1), (2), (3);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select distinct a from t1;
select * from v1;
a
1
2
3
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
select * from t1;
a
1
2
3
1
2
3
drop view v1;
drop table t1;
create table t1 (a int);
create view v1 as select distinct a from t1 WITH CHECK OPTION;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v1'
create view v1 as select a from t1 WITH CHECK OPTION;
create view v2 as select a from t1 WITH CASCADED CHECK OPTION;
create view v3 as select a from t1 WITH LOCAL CHECK OPTION;
drop view v3 RESTRICT;
drop view v2 CASCADE;
drop view v1;
drop table t1;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1 (c) as select b+1 from t1;
select test.c from v1 test;
c
3
4
5
6
11
create algorithm=temptable view v2 (c) as select b+1 from t1;
select test.c from v2 test;
c
3
4
5
6
11
select test1.* from v1 test1, v2 test2 where test1.c=test2.c;
c
3
4
5
6
11
select test2.* from v1 test1, v2 test2 where test1.c=test2.c;
c
3
4
5
6
11
drop table t1;
drop view v1,v2;
create table t1 (a int);
insert into t1 values (1), (2), (3), (4);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select a+1 from t1 order by 1 desc limit 2;
select * from v1;
a+1
5
4
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `v1`.`a+1` AS `a+1` from `test`.`v1`
drop view v1;
drop table t1;
create table t1 (a int);
insert into t1 values (1), (2), (3), (4);
create view v1 as select a+1 from t1;
create table t2 select * from v1;
show columns from t2;
Field	Type	Null	Key	Default	Extra
a+1	bigint(12)	YES		NULL	
select * from t2;
a+1
2
3
4
5
drop view v1;
drop table t1,t2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (10,2), (20,3), (30,4), (40,5), (50,10);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
select is_updatable from information_schema.views where table_name='v2';
IS_UPDATABLE
NO
select is_updatable from information_schema.views where table_name='v1';
IS_UPDATABLE
YES
update v1 set c=a+c;
ERROR HY000: Column 'c' is not updatable
update v2 set a=a+c;
ERROR HY000: The target table v2 of the UPDATE is not updatable
update v1 set a=a+c;
select * from v1;
a	c
13	3
24	4
35	5
46	6
61	11
select * from t1;
a	b
13	2
24	3
35	4
46	5
61	10
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (10,2), (20,3), (30,4), (40,5), (50,10);
create table t2 (x int);
insert into t2 values (10), (20);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
update t2,v1 set v1.c=v1.a+v1.c where t2.x=v1.a;
ERROR HY000: Column 'c' is not updatable
update t2,v2 set v2.a=v2.a+c where t2.x=v2.a;
ERROR HY000: The target table v2 of the UPDATE is not updatable
update t2,v1 set v1.a=v1.a+v1.c where t2.x=v1.a;
select * from v1;
a	c
13	3
24	4
30	5
40	6
50	11
select * from t1;
a	b
13	2
24	3
30	4
40	5
50	10
drop table t1,t2;
drop view v1,v2;
create table t1 (a int, b int, primary key(b));
insert into t1 values (1,20), (2,30), (3,40), (4,50), (5,100);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 (c) as select b from t1 where a<3;
select * from v1;
c
20
30
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`b` AS `c` from `test`.`t1` where (`test`.`t1`.`a` < 3)
update v1 set c=c+1;
select * from t1;
a	b
1	21
2	31
3	40
4	50
5	100
create view v2 (c) as select b from t1 where a>=3;
select * from v1, v2;
c	c
21	40
31	40
21	50
31	50
21	100
31	100
drop view v1, v2;
drop table t1;
create table t1 (a int, b int, primary key(a));
insert into t1 values (1,2), (2,3), (3,4), (4,5), (5,10);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
delete from v2 where c < 4;
ERROR HY000: The target table v2 of the DELETE is not updatable
delete from v1 where c < 4;
select * from v1;
a	c
2	4
3	5
4	6
5	11
select * from t1;
a	b
2	3
3	4
4	5
5	10
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, primary key(a));
insert into t1 values (1,2), (2,3), (3,4), (4,5), (5,10);
create table t2 (x int);
insert into t2 values (1), (2), (3), (4);
create view v1 (a,c) as select a, b+1 from t1;
create algorithm=temptable view v2 (a,c) as select a, b+1 from t1;
delete v2 from t2,v2 where t2.x=v2.a;
ERROR HY000: The target table v2 of the DELETE is not updatable
delete v1 from t2,v1 where t2.x=v1.a;
select * from v1;
a	c
5	11
select * from t1;
a	b
5	10
drop table t1,t2;
drop view v1,v2;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2), (30,4,-3), (40,5,-4), (50,10,-5);
create view v1 (x,y) as select a, b from t1;
create view v2 (x,y) as select a, c from t1;
set updatable_views_with_limit=NO;
update v1 set x=x+1;
update v2 set x=x+1;
update v1 set x=x+1 limit 1;
update v2 set x=x+1 limit 1;
ERROR HY000: The target table v2 of the UPDATE is not updatable
delete from v2 limit 1;
ERROR HY000: The target table v2 of the DELETE is not updatable
set updatable_views_with_limit=YES;
update v1 set x=x+1 limit 1;
update v2 set x=x+1 limit 1;
Warnings:
Note	1355	View being updated does not have complete key of underlying table in it
set updatable_views_with_limit=DEFAULT;
show variables like "updatable_views_with_limit";
Variable_name	Value
updatable_views_with_limit	YES
select * from t1;
a	b	c
15	2	-1
22	3	-2
32	4	-3
42	5	-4
52	10	-5
drop table t1;
drop view v1,v2;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2);
create view v1 (x,y,z) as select c, b, a from t1;
create view v2 (x,y) as select b, a from t1;
create view v3 (x,y,z) as select b, a, b from t1;
create view v4 (x,y,z) as select c+1, b, a from t1;
create algorithm=temptable view v5 (x,y,z) as select c, b, a from t1;
insert into v3 values (-60,4,30);
ERROR HY000: The target table v3 of the INSERT is not insertable-into
insert into v4 values (-60,4,30);
ERROR HY000: Column 'x' is not updatable
insert into v5 values (-60,4,30);
ERROR HY000: The target table v5 of the INSERT is not insertable-into
insert into v1 values (-60,4,30);
insert into v1 (z,y,x) values (50,6,-100);
insert into v2 values (5,40);
select * from t1;
a	b	c
10	2	-1
20	3	-2
30	4	-60
40	5	NULL
50	6	-100
drop table t1;
drop view v1,v2,v3,v4,v5;
create table t1 (a int, b int, c int, primary key(a,b));
insert into t1 values (10,2,-1), (20,3,-2);
create table t2 (a int, b int, c int, primary key(a,b));
insert into t2 values (30,4,-60);
create view v1 (x,y,z) as select c, b, a from t1;
create view v2 (x,y) as select b, a from t1;
create view v3 (x,y,z) as select b, a, b from t1;
create view v4 (x,y,z) as select c+1, b, a from t1;
create algorithm=temptable view v5 (x,y,z) as select c, b, a from t1;
insert into v3 select c, b, a from t2;
ERROR HY000: The target table v3 of the INSERT is not insertable-into
insert into v4 select c, b, a from t2;
ERROR HY000: Column 'x' is not updatable
insert into v5 select c, b, a from t2;
ERROR HY000: The target table v5 of the INSERT is not insertable-into
insert into v1 select c, b, a from t2;
insert into v1 (z,y,x) select a+20,b+2,-100 from t2;
insert into v2 select b+1, a+10 from t2;
select * from t1;
a	b	c
10	2	-1
20	3	-2
30	4	-60
40	5	NULL
50	6	-100
drop table t1, t2;
drop view v1,v2,v3,v4,v5;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3);
create view v1 (x) as select a from t1 where a > 1;
select t1.a, v1.x from t1 left join v1 on (t1.a= v1.x);
a	x
1	NULL
2	2
3	3
drop table t1;
drop view v1;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3), (200);
create view v1 (x) as select a from t1 where a > 1;
create view v2 (y) as select x from v1 where x < 100;
select * from v2;
y
2
3
drop table t1;
drop view v1,v2;
create table t1 (a int, primary key(a));
insert into t1 values (1), (2), (3), (200);
create ALGORITHM=TEMPTABLE view v1 (x) as select a from t1;
create view v2 (y) as select x from v1;
update v2 set y=10 where y=2;
ERROR HY000: The target table v2 of the UPDATE is not updatable
drop table t1;
drop view v1,v2;
create table t1 (a int not null auto_increment, b int not null, primary key(a), unique(b));
create view v1 (x) as select b from t1;
insert into v1 values (1);
select last_insert_id();
last_insert_id()
0
insert into t1 (b) values (2);
select last_insert_id();
last_insert_id()
2
select * from t1;
a	b
1	1
2	2
drop view v1;
drop table t1;
set sql_mode='ansi';
create table t1 ("a*b" int);
create view v1 as select "a*b" from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE VIEW "v1" AS select "t1"."a*b" AS "a*b" from "t1"	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
set sql_mode=default;
create table t1 (t_column int);
create view v1 as select 'a';
select * from v1, t1;
a	t_column
drop view v1;
drop table t1;
create table `t1a``b` (col1 char(2));
create view v1 as select * from `t1a``b`;
select * from v1;
col1
describe v1;
Field	Type	Null	Key	Default	Extra
col1	char(2)	YES		NULL	
drop view v1;
drop table `t1a``b`;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
create table t1 (col1 char(5),col2 char(5));
create view v1 as select * from t1;
drop table t1;
create table t1 (col1 char(5),newcol2 char(5));
insert into v1 values('a','aa');
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop table t1;
select * from v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop view v1;
SET sql_mode = default;
create view v1 (a,a) as select 'a','a';
ERROR 42S21: Duplicate column name 'a'
create table t1 (col1 int,col2 char(22));
insert into t1 values(5,'Hello, world of views');
create view v1 as select * from t1;
create view v2 as select * from v1;
update v2 set col2='Hello, view world';
select is_updatable from information_schema.views where
table_schema != 'sys' and table_schema != 'information_schema';
IS_UPDATABLE
YES
YES
select * from t1;
col1	col2
5	Hello, view world
drop view v2, v1;
drop table t1;
create table t1 (a int, b int);
create view v1 as select a, sum(b) from t1 group by a;
select b from v1 use index (some_index) where b=1;
ERROR 42000: Key 'some_index' doesn't exist in table 'v1'
drop view v1;
drop table t1;
create table t1 (col1 char(5),col2 char(5));
create view v1 (col1,col2) as select col1,col2 from t1;
insert into v1 values('s1','p1'),('s1','p2'),('s1','p3'),('s1','p4'),('s2','p1'),('s3','p2'),('s4','p4');
select distinct first.col2 from t1 first where first.col2 in (select second.col2 from t1 second where second.col1<>first.col1);
col2
p1
p2
p4
select distinct first.col2 from v1 first where first.col2 in (select second.col2 from t1 second where second.col1<>first.col1);
col2
p1
p2
p4
drop view v1;
drop table t1;
create table t1 (a int);
create view v1 as select a from t1;
insert into t1 values (1);
SET @v0 = '2';
PREPARE stmt FROM 'UPDATE v1 SET a = ?';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
SET @v0 = '3';
PREPARE stmt FROM 'insert into v1 values (?)';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
SET @v0 = '4';
PREPARE stmt FROM 'insert into v1 (a) values (?)';
EXECUTE stmt USING @v0;
DEALLOCATE PREPARE stmt;
select * from t1;
a
2
3
4
drop view v1;
drop table t1;
CREATE VIEW v02 AS SELECT * FROM DUAL;
ERROR HY000: No tables used
SHOW TABLES;
Tables_in_test
CREATE VIEW v1 AS SELECT EXISTS (SELECT 1 UNION SELECT 2);
select * from v1;
EXISTS (SELECT 1 UNION SELECT 2)
1
drop view v1;
create table t1 (col1 int,col2 char(22));
create view v1 as select * from t1;
create index i1 on v1 (col1);
ERROR HY000: 'test.v1' is not BASE TABLE
drop view v1;
drop table t1;
CREATE VIEW v1 (f1,f2,f3,f4) AS SELECT connection_id(), pi(), current_user(), version();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`f1`,`f2`,`f3`,`f4`) AS select connection_id() AS `connection_id()`,pi() AS `pi()`,current_user() AS `current_user()`,version() AS `version()`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create table t1 (s1 int);
create table t2 (s2 int);
insert into t1 values (1), (2);
insert into t2 values (2), (3);
create view v1 as select * from t1,t2 union all select * from t1,t2;
select * from v1;
s1	s2
1	2
2	2
1	3
2	3
1	2
2	2
1	3
2	3
drop view v1;
drop tables t1, t2;
create table t1 (col1 int);
insert into t1 values (1);
create view v1 as select count(*) from t1;
insert into t1 values (null);
select * from v1;
count(*)
2
drop view v1;
drop table t1;
create table t1 (a int);
create table t2 (a int);
create view v1 as select a from t1;
create view v2 as select a from t2 where a in (select a from v1);
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t2`.`a` AS `a` from `t2` where `t2`.`a` in (select `v1`.`a` from `v1`)	utf8mb4	utf8mb4_0900_ai_ci
drop view v2, v1;
drop table t1, t2;
CREATE VIEW `v 1` AS select 5 AS `5`;
show create view `v 1`;
View	Create View	character_set_client	collation_connection
v 1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v 1` AS select 5 AS `5`	utf8mb4	utf8mb4_0900_ai_ci
drop view `v 1`;
create database mysqltest;
create table mysqltest.t1 (a int, b int);
create view mysqltest.v1 as select a from mysqltest.t1;
alter view mysqltest.v1 as select b from mysqltest.t1;
alter view mysqltest.v1 as select a from mysqltest.t1;
drop database mysqltest;
CREATE TABLE t1 (c1 int not null auto_increment primary key, c2 varchar(20), fulltext(c2));
insert into t1 (c2) VALUES ('real Beer'),('Water'),('Kossu'),('Coca-Cola'),('Vodka'),('Wine'),('almost real Beer');
select * from t1 WHERE match (c2) against ('Beer');
c1	c2
1	real Beer
7	almost real Beer
CREATE VIEW v1 AS SELECT  * from t1 WHERE match (c2) against ('Beer');
select * from v1;
c1	c2
1	real Beer
7	almost real Beer
drop view v1;
drop table t1;
create table t1 (a int);
insert into t1 values (1),(1),(2),(2),(3),(3);
create view v1 as select a from t1;
select distinct a from v1;
a
1
2
3
select distinct a from v1 limit 2;
a
1
2
select distinct a from t1 limit 2;
a
1
2
prepare stmt1 from "select distinct a from v1 limit 2";
execute stmt1;
a
1
2
execute stmt1;
a
1
2
deallocate prepare stmt1;
drop view v1;
drop table t1;
create table t1 (tg_column bigint);
create view v1 as select count(tg_column) as vg_column from t1;
select avg(vg_column) from v1;
avg(vg_column)
0.0000
drop view v1;
drop table t1;
create table t1 (col1 bigint not null, primary key (col1));
create table t2 (col1 bigint not null, key (col1));
create view v1 as select * from t1;
create view v2 as select * from t2;
insert into v1 values (1);
insert into v2 values (1);
create view v3 (a,b) as select v1.col1 as a, v2.col1 as b from v1, v2 where v1.col1 = v2.col1;
select * from v3;
a	b
1	1
show create view v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` (`a`,`b`) AS select `v1`.`col1` AS `a`,`v2`.`col1` AS `b` from (`v1` join `v2`) where (`v1`.`col1` = `v2`.`col1`)	utf8mb4	utf8mb4_0900_ai_ci
drop view v3, v2, v1;
drop table t2, t1;
create function `f``1` () returns int return 5;
create view v1 as select test.`f``1` ();
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `test`.`f``1`() AS `test.``f````1`` ()`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
test.`f``1` ()
5
drop view v1;
drop function `f``1`;
create function a() returns int return 5;
create view v1 as select a();
select * from v1;
a()
5
drop view v1;
drop function a;
create table t2 (col1 char collate latin1_german2_ci);
create view v2 as select col1 collate latin1_german1_ci from t2;
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select (`t2`.`col1` collate latin1_german1_ci) AS `col1 collate latin1_german1_ci` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
show create view v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select (`t2`.`col1` collate latin1_german1_ci) AS `col1 collate latin1_german1_ci` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
drop view v2;
drop table t2;
create table t1 (a int);
insert into t1 values (1), (2);
create view v1 as select 5 from t1 order by 1;
select * from v1;
5
5
5
drop view v1;
drop table t1;
create function x1 () returns int return 5;
create table t1 (s1 int);
create view v1 as select x1() from t1;
drop function x1;
select * from v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
show table status;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	InnoDB	10	Dynamic	#	#	#	#	0	0	NULL	#	#	NULL	utf8mb4_0900_ai_ci	NULL		
v1	NULL	NULL	NULL	#	#	#	#	0	0	NULL	#	#	NULL	NULL	NULL	NULL	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
Warnings:
Warning	1356	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop view v1;
drop table t1;
create view v1 as select 99999999999999999999999999999999999999999999999999999 as col1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 99999999999999999999999999999999999999999999999999999 AS `col1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
SET @old_cs_client = @@character_set_client;
SET @old_cs_results = @@character_set_results;
SET @old_cs_connection = @@character_set_connection;
set names utf8;
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
create table tü (cü char);
create view vü as select cü from tü;
insert into vü values ('ü');
select * from vü;
cü
ü
drop view vü;
drop table tü;
SET character_set_client = @old_cs_client;
SET character_set_results = @old_cs_results;
SET character_set_connection = @old_cs_connection;
create table t1 (a int, b int);
insert into t1 values (1,2), (1,3), (2,4), (2,5), (3,10);
create view v1(c) as select a+1 from t1 where b >= 4;
select c from v1 where exists (select * from t1 where a=2 and b=c);
c
4
drop view v1;
drop table t1;
create view v1 as select cast(1 as char(3));
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select cast(1 as char(3) charset utf8mb4) AS `cast(1 as char(3))`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
cast(1 as char(3))
1
drop view v1;
create table t1 (a int);
create view v1 as select a from t1;
create view v3 as select a from t1;
create database mysqltest;
rename table v1 to mysqltest.v1;
ERROR HY000: Changing schema from 'test' to 'mysqltest' is not allowed.
rename table v1 to v2;
rename table v3 to v1, v2 to t1;
ERROR 42S01: Table 't1' already exists
drop table t1;
drop view v2,v3;
drop database mysqltest;
create view v1 as select 'a',1;
create view v2 as select * from v1 union all select * from v1;
create view v3 as select * from v2 where 1 = (select `1` from v2);
create view v4 as select * from v3;
select * from v4;
ERROR 21000: Subquery returns more than 1 row
drop view v4, v3, v2, v1;
create view v1 as select 5 into @w;
ERROR HY000: View's SELECT contains a 'INTO' clause
create view v1 as select 5 into outfile 'ttt';
ERROR HY000: View's SELECT contains a 'INTO' clause
create table t1 (a int);
create view v1 as select 1 from (select 1) as d1;
drop view v1;
drop table t1;
create table t1 (s1 int, primary key (s1));
create view v1 as select * from t1;
insert into v1 values (1) on duplicate key update s1 = 7;
insert into v1 values (1) on duplicate key update s1 = 7;
select * from t1;
s1
7
drop view v1;
drop table t1;
create table t1 (col1 int);
create table t2 (col1 int);
create table t3 (col1 datetime not null);
create view v1 as select * from t1;
create view v2 as select * from v1;
create view v3 as select v2.col1 from v2,t2 where v2.col1 = t2.col1;
update v2 set col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v2'.
update v2 set col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v2'.
update v2 set col1 = (select max(col1) from v2);
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
update v2,t2 set v2.col1 = (select max(col1) from v1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v2'.
update t1,t2 set t1.col1 = (select max(col1) from v1) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't1'.
update v1,t2 set v1.col1 = (select max(col1) from v1) where v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v1' for update in FROM clause
update t2,v2 set v2.col1 = (select max(col1) from v1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update t2,t1 set t1.col1 = (select max(col1) from v1) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update t2,v1 set v1.col1 = (select max(col1) from v1) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't2'.
update v2,t2 set v2.col1 = (select max(col1) from t1) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v2'.
update t1,t2 set t1.col1 = (select max(col1) from t1) where t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't1' for update in FROM clause
update v1,t2 set v1.col1 = (select max(col1) from t1) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v1'.
update t2,v2 set v2.col1 = (select max(col1) from t1) where v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update t2,t1 set t1.col1 = (select max(col1) from t1) where t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update t2,v1 set v1.col1 = (select max(col1) from t1) where v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't2' for update in FROM clause
update v2,t2 set v2.col1 = (select max(col1) from v2) where v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
update t1,t2 set t1.col1 = (select max(col1) from v2) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't1'.
update v1,t2 set v1.col1 = (select max(col1) from v2) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v1'.
update t2,v2 set v2.col1 = (select max(col1) from v2) where v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update t2,t1 set t1.col1 = (select max(col1) from v2) where t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update t2,v1 set v1.col1 = (select max(col1) from v2) where v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 't2'.
update v3 set v3.col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v3' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from v2);
ERROR HY000: The definition of table 'v2' prevents operation UPDATE on table 'v3'.
update v3 set v3.col1 = (select max(col1) from v3);
ERROR HY000: You can't specify target table 'v3' for update in FROM clause
delete from v2 where col1 = (select max(col1) from v1);
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v2'.
delete from v2 where col1 = (select max(col1) from t1);
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v2'.
delete from v2 where col1 = (select max(col1) from v2);
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
delete v2 from v2,t2 where (select max(col1) from v1) > 0 and v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v2'.
delete t1 from t1,t2 where (select max(col1) from v1) > 0 and t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 't1'.
delete v1 from v1,t2 where (select max(col1) from v1) > 0 and v1.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v1' for update in FROM clause
delete v2 from v2,t2 where (select max(col1) from t1) > 0 and v2.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v2'.
delete t1 from t1,t2 where (select max(col1) from t1) > 0 and t1.col1 = t2.col1;
ERROR HY000: You can't specify target table 't1' for update in FROM clause
delete v1 from v1,t2 where (select max(col1) from t1) > 0 and v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v1' prevents operation DELETE on table 'v1'.
delete v2 from v2,t2 where (select max(col1) from v2) > 0 and v2.col1 = t2.col1;
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
delete t1 from t1,t2 where (select max(col1) from v2) > 0 and t1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 't1'.
delete v1 from v1,t2 where (select max(col1) from v2) > 0 and v1.col1 = t2.col1;
ERROR HY000: The definition of table 'v2' prevents operation DELETE on table 'v1'.
insert into v2 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v2'.
insert into t1 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 't1'.
insert into v2 values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v2'.
insert into v2 values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v2'.
insert into t1 values ((select max(col1) from t1));
ERROR HY000: You can't specify target table 't1' for update in FROM clause
insert into v2 values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v2'.
insert into v2 values ((select max(col1) from v2));
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
insert into t1 values ((select max(col1) from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 't1'.
insert into v2 values ((select max(col1) from v2));
ERROR HY000: You can't specify target table 'v2' for update in FROM clause
insert into v3 (col1) values ((select max(col1) from v1));
ERROR HY000: The definition of table 'v1' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select max(col1) from t1));
ERROR HY000: The definition of table 'v3' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select max(col1) from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select CONVERT_TZ('20050101000000','UTC','MET') from v2));
ERROR HY000: The definition of table 'v2' prevents operation INSERT on table 'v3'.
insert into v3 (col1) values ((select CONVERT_TZ('20050101000000','UTC','MET') from t2));
insert into t3 values ((select CONVERT_TZ('20050101000000','UTC','MET') from t2));
ERROR 23000: Column 'col1' cannot be null
create algorithm=temptable view v4 as select * from t1;
insert into t1 values (1),(2),(3);
insert into t1 (col1) values ((select max(col1) from v4));
select * from t1;
col1
NULL
1
2
3
3
drop view v4,v3,v2,v1;
drop table t1,t2,t3;
create table t1 (s1 int);
create view v1 as select * from t1;
handler v1 open as xx;
ERROR HY000: 'test.v1' is not BASE TABLE
drop view v1;
drop table t1;
create table t1(a int);
insert into t1 values (0), (1), (2), (3);
create table t2 (a int);
insert into t2 select a from t1 where a > 1;
create view v1 as select a from t1 where a > 1;
select * from t1 left join (t2 as t, v1) on v1.a=t1.a;
a	a	a
0	NULL	NULL
1	NULL	NULL
2	2	2
2	3	2
3	2	3
3	3	3
select * from t1 left join (t2 as t, t2) on t2.a=t1.a;
a	a	a
0	NULL	NULL
1	NULL	NULL
2	2	2
2	3	2
3	2	3
3	3	3
drop view v1;
drop table t1, t2;
create table t1 (s1 char) charset latin1;
create view v1 as select s1 collate latin1_german1_ci as s1 from t1;
insert into v1 values ('a');
select * from v1;
s1
a
update v1 set s1='b';
select * from v1;
s1
b
update v1,t1 set v1.s1='c' where t1.s1=v1.s1;
select * from v1;
s1
c
prepare stmt1 from "update v1,t1 set v1.s1=? where t1.s1=v1.s1";
set @arg='d';
execute stmt1 using @arg;
select * from v1;
s1
d
set @arg='e';
execute stmt1 using @arg;
select * from v1;
s1
e
deallocate prepare stmt1;
drop view v1;
drop table t1;
create table t1 (a int);
create table t2 (a int);
create view v1 as select * from t1;
lock tables t1 read, v1 read;
select * from v1;
a
select * from t2;
ERROR HY000: Table 't2' was not locked with LOCK TABLES
unlock tables;
drop view v1;
drop table t1, t2;
create table t1 (a int);
create view v1 as select * from t1 where a < 2 with check option;
insert into v1 values(1);
insert into v1 values(3);
ERROR HY000: CHECK OPTION failed 'test.v1'
insert ignore into v1 values (2),(3),(0);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
0
delete from t1;
insert into v1 SELECT 1;
insert into v1 SELECT 3;
ERROR HY000: CHECK OPTION failed 'test.v1'
create table t2 (a int);
insert into t2 values (2),(3),(0);
insert ignore into v1 SELECT a from t2;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1 order by a desc;
a
1
0
update v1 set a=-1 where a=0;
update v1 set a=2 where a=1;
ERROR HY000: CHECK OPTION failed 'test.v1'
select * from t1 order by a desc;
a
1
-1
update v1 set a=0 where a=0;
insert into t2 values (1);
update v1,t2 set v1.a=v1.a-1 where v1.a=t2.a;
select * from t1 order by a desc;
a
0
-1
update v1 set a=a+1;
update ignore v1,t2 set v1.a=v1.a+1 where v1.a=t2.a;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
1
drop view v1;
drop table t1, t2;
create table t1 (a int);
create view v1 as select * from t1 where a < 2 with check option;
create view v2 as select * from v1 where a > 0 with local check option;
create view v3 as select * from v1 where a > 0 with cascaded check option;
insert into v2 values (1);
insert into v3 values (1);
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into v3 values (0);
ERROR HY000: CHECK OPTION failed 'test.v3'
insert into v2 values (2);
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into v3 values (2);
ERROR HY000: CHECK OPTION failed 'test.v3'
select * from t1;
a
1
1
drop view v3,v2,v1;
drop table t1;
create table t1 (a int, primary key (a));
create view v1 as select * from t1 where a < 2 with check option;
insert into v1 values (1) on duplicate key update a=2;
insert into v1 values (1) on duplicate key update a=2;
ERROR HY000: CHECK OPTION failed 'test.v1'
insert ignore into v1 values (1) on duplicate key update a=2;
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a
1
drop view v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select * from t1;
create view v2 as select * from v1;
alter view v1 as select * from v2;
ERROR 42S02: Table 'test.v1' doesn't exist
alter view v1 as select * from v1;
ERROR 42S02: Table 'test.v1' doesn't exist
create or replace view v1 as select * from v2;
ERROR 42S02: Table 'test.v1' doesn't exist
create or replace view v1 as select * from v1;
ERROR 42S02: Table 'test.v1' doesn't exist
drop view v2,v1;
drop table t1;
create table t1 (a int);
create view v1 as select * from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=undefined view v1 as select * from t1 with check option;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=merge view v1 as select * from t1 with cascaded check option;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=MERGE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
alter algorithm=temptable view v1 as select * from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
create table t1 (s1 int);
create table t2 (s1 int);
create view v2 as select * from t2 where s1 in (select s1 from t1);
insert into v2 values (5);
insert into t1 values (5);
select * from v2;
s1
5
update v2 set s1 = 0;
select * from v2;
s1
select * from t2;
s1
0
alter view v2 as select * from t2 where s1 in (select s1 from t1) with check option;
insert into v2 values (5);
update v2 set s1 = 1;
ERROR HY000: CHECK OPTION failed 'test.v2'
insert into t1 values (1);
update v2 set s1 = 1;
select * from v2;
s1
1
select * from t2;
s1
0
1
prepare stmt1 from "select * from v2;";
execute stmt1;
s1
1
insert into t1 values (0);
execute stmt1;
s1
1
0
deallocate prepare stmt1;
drop view v2;
drop table t1, t2;
create table t1 (t time);
create view v1 as select substring_index(t,':',2) as t from t1;
insert into t1 (t) values ('12:24:10');
select substring_index(t,':',2) from t1;
substring_index(t,':',2)
12:24
select substring_index(t,':',2) from v1;
substring_index(t,':',2)
12:24
drop view v1;
drop table t1;
create table t1 (s1 tinyint);
create view v1 as select * from t1 where s1 <> 0 with local check option;
create view v2 as select * from v1 with cascaded check option;
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
drop view v2, v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select * from t1 where s1 < 5 with check option;
insert ignore into v1 values (6);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
insert ignore into v1 values (6),(3);
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
s1
3
drop view v1;
drop table t1;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
create table t1 (s1 tinyint);
create trigger t1_bi before insert on t1 for each row set new.s1 = 500;
create view v1 as select * from t1 where s1 <> 127 with check option;
insert into v1 values (0);
ERROR HY000: CHECK OPTION failed 'test.v1'
select * from v1;
s1
select * from t1;
s1
drop trigger t1_bi;
drop view v1;
drop table t1;
SET sql_mode = default;
create table t1 (s1 tinyint);
create view v1 as select * from t1 where s1 <> 0;
create view v2 as select * from v1 where s1 <> 1 with cascaded check option;
insert into v2 values (0);
ERROR HY000: CHECK OPTION failed 'test.v2'
select * from v2;
s1
select * from t1;
s1
drop view v2, v1;
drop table t1;
create table t1 (a int, b char(10)) charset latin1 engine=Myisam;
create view v1 as select * from t1 where a != 0 with check option;
load data infile '../../std_data/loaddata3.dat' into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
ERROR HY000: CHECK OPTION failed 'test.v1'
select * from t1;
a	b
1	row 1
2	row 2
select * from v1;
a	b
1	row 1
2	row 2
delete from t1;
load data infile '../../std_data/loaddata3.dat' ignore into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
Warnings:
Warning	1366	Incorrect integer value: 'error      ' for column 'a' at row 3
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1366	Incorrect integer value: 'wrong end  ' for column 'a' at row 4
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1 order by a,b;
a	b
1	row 1
2	row 2
3	row 3
select * from v1 order by a,b;
a	b
1	row 1
2	row 2
3	row 3
drop view v1;
drop table t1;
create table t1 (a text, b text);
create view v1 as select * from t1 where a <> 'Field A' with check option;
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by '''';
ERROR HY000: CHECK OPTION failed 'test.v1'
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
delete from t1;
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by '''';
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1261	Row 2 doesn't contain data for all columns
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
drop view v1;
drop table t1;
create table t1 (a int, b char(10)) charset latin1;
create view v1 as select * from t1 where a != 0 with check option;
load data infile '../../std_data/loaddata3.dat' into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
ERROR HY000: Incorrect integer value: 'error      ' for column 'a' at row 3
select * from t1;
a	b
select * from v1;
a	b
delete from t1;
load data infile '../../std_data/loaddata3.dat' ignore into table v1 fields terminated by '' enclosed by '' ignore 1 lines;
Warnings:
Warning	1366	Incorrect integer value: 'error      ' for column 'a' at row 3
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1366	Incorrect integer value: 'wrong end  ' for column 'a' at row 4
Warning	1369	CHECK OPTION failed 'test.v1'
select * from t1;
a	b
1	row 1
2	row 2
3	row 3
select * from v1;
a	b
1	row 1
2	row 2
3	row 3
drop view v1;
drop table t1;
create table t1 (a text, b text) ;
create view v1 as select * from t1 where a <> 'Field A' with check option;
load data infile '../../std_data/loaddata2.dat' into table v1 fields terminated by ',' enclosed by '''';
ERROR HY000: CHECK OPTION failed 'test.v1'
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
delete from t1;
load data infile '../../std_data/loaddata2.dat' ignore into table v1 fields terminated by ',' enclosed by '''';
Warnings:
Warning	1369	CHECK OPTION failed 'test.v1'
Warning	1261	Row 2 doesn't contain data for all columns
select concat('|',a,'|'), concat('|',b,'|') from t1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
select concat('|',a,'|'), concat('|',b,'|') from v1;
concat('|',a,'|')	concat('|',b,'|')
|Field 1|	|Field 2' 
Field 3,'Field 4|
|Field 5' ,'Field 6|	NULL
|Field 6|	| 'Field 7'|
drop view v1;
drop table t1;
create table t1 (s1 smallint);
create view v1 as select * from t1 where 20 < (select (s1) from t1);
insert into v1 values (30);
ERROR HY000: The target table v1 of the INSERT is not insertable-into
create view v2 as select * from t1;
create view v3 as select * from t1 where 20 < (select (s1) from v2);
insert into v3 values (30);
ERROR HY000: The target table v3 of the INSERT is not insertable-into
create view v4 as select * from v2 where 20 < (select (s1) from t1);
insert into v4 values (30);
ERROR HY000: The target table v4 of the INSERT is not insertable-into
drop view v4, v3, v2, v1;
drop table t1;
create table t1 (a int);
create view v1 as select * from t1;
check table t1,v1;
Table	Op	Msg_type	Msg_text
test.t1	check	status	OK
test.v1	check	status	OK
check table v1,t1;
Table	Op	Msg_type	Msg_text
test.v1	check	status	OK
test.t1	check	status	OK
drop table t1;
check table v1;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	Table 'test.t1' doesn't exist
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	error	Corrupt
drop view v1;
create table t1 (a int);
create table t2 (a int);
create table t3 (a int);
insert into t1 values (1), (2), (3);
insert into t2 values (1), (3);
insert into t3 values (1), (2), (4);
analyze table t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
create view v3 (a,b) as select t1.a as a, t2.a as b from t1 left join t2 on (t1.a=t2.a);
select * from t3 left join v3 on (t3.a = v3.a);
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
explain select * from t3 left join v3 on (t3.a = v3.a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `b` from `test`.`t3` left join (`test`.`t1` left join `test`.`t2` on((`test`.`t2`.`a` = `test`.`t3`.`a`))) on((`test`.`t1`.`a` = `test`.`t3`.`a`)) where 1
create view v1 (a) as select a from t1;
create view v2 (a) as select a from t2;
create view v4 (a,b) as select v1.a as a, v2.a as b from v1 left join v2 on (v1.a=v2.a);
select * from t3 left join v4 on (t3.a = v4.a);
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
explain select * from t3 left join v4 on (t3.a = v4.a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `b` from `test`.`t3` left join (`test`.`t1` left join (`test`.`t2`) on(((`test`.`t1`.`a` = `test`.`t3`.`a`) and (`test`.`t2`.`a` = `test`.`t3`.`a`)))) on((`test`.`t1`.`a` = `test`.`t3`.`a`)) where 1
prepare stmt1 from "select * from t3 left join v4 on (t3.a = v4.a);";
execute stmt1;
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
execute stmt1;
a	a	b
1	1	1
2	2	NULL
4	NULL	NULL
deallocate prepare stmt1;
drop view v4,v3,v2,v1;
drop tables t1,t2,t3;
create table t1 (a int, primary key (a), b int);
create table t2 (a int, primary key (a));
insert into t1 values (1,100), (2,200);
insert into t2 values (1), (3);
create view v3 (a,b) as select t1.a as a, t2.a as b from t1, t2;
update v3 set a= 10 where a=1;
select * from t1;
a	b
10	100
2	200
select * from t2;
a
1
3
create view v2 (a,b) as select t1.b as a, t2.a as b from t1, t2;
set updatable_views_with_limit=NO;
update v2 set a= 10 where a=200 limit 1;
Got one of the listed errors
set updatable_views_with_limit=DEFAULT;
select * from v3;
a	b
2	1
10	1
2	3
10	3
select * from v2;
a	b
200	1
100	1
200	3
100	3
set @a= 10;
set @b= 100;
prepare stmt1 from "update v3 set a= ? where a=?";
execute stmt1 using @a,@b;
select * from v3;
a	b
2	1
10	1
2	3
10	3
set @a= 300;
set @b= 10;
execute stmt1 using @a,@b;
select * from v3;
a	b
2	1
300	1
2	3
300	3
deallocate prepare stmt1;
drop view v3,v2;
drop tables t1,t2;
create table t1 (a int, primary key (a), b int) engine=myisam;
create table t2 (a int, primary key (a), b int) engine=myisam;
insert into t2 values (1000, 2000);
create view v3 (a,b) as select t1.a as a, t2.a as b from t1, t2;
insert into v3 values (1,2);
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3 select * from t2;
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3(a,b) values (1,2);
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a,b) select * from t2;
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a) values (1);
insert into v3(b) values (10);
insert into v3(a) select a from t2;
insert into v3(b) select b from t2;
Warnings:
Warning	1048	Column 'a' cannot be null
insert into v3(a) values (1) on duplicate key update a=a+10000+VALUES(a);
select * from t1 ;
a	b
10002	NULL
10	NULL
1000	NULL
select * from t2 ;
a	b
1000	2000
10	NULL
2000	NULL
0	NULL
delete from v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete v3,t1 from v3,t1;
ERROR HY000: Can not delete from join view 'test.v3'
delete t1,v3 from t1,v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete from t1;
prepare stmt1 from "insert into v3(a) values (?);";
set @a= 100;
execute stmt1 using @a;
set @a= 300;
execute stmt1 using @a;
deallocate prepare stmt1;
prepare stmt1 from "insert into v3(a) select ?;";
set @a= 101;
execute stmt1 using @a;
set @a= 301;
execute stmt1 using @a;
deallocate prepare stmt1;
select * from v3 ;
a	b
100	0
101	0
300	0
301	0
100	10
101	10
300	10
301	10
100	1000
101	1000
300	1000
301	1000
100	2000
101	2000
300	2000
301	2000
drop view v3;
drop tables t1,t2;
create table t1 (a int, primary key (a), b int);
create table t2 (a int, primary key (a), b int);
insert into t2 values (1000, 2000);
create view v3 (a,b) as select t1.a as a, t2.a as b from t1, t2;
insert into v3 values (1,2);
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3 select * from t2;
ERROR HY000: Can not insert into join view 'test.v3' without fields list
insert into v3(a,b) values (1,2);
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a,b) select * from t2;
ERROR HY000: Can not modify more than one base table through a join view 'test.v3'
insert into v3(a) values (1);
insert into v3(b) values (10);
insert into v3(a) select a from t2;
insert into v3(b) select b from t2;
ERROR 23000: Column 'a' cannot be null
insert into v3(a) values (1) on duplicate key update a=a+10000+VALUES(a);
select * from t1;
a	b
10	NULL
1000	NULL
10002	NULL
select * from t2;
a	b
10	NULL
1000	2000
delete from v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete v3,t1 from v3,t1;
ERROR HY000: Can not delete from join view 'test.v3'
delete t1,v3 from t1,v3;
ERROR HY000: Can not delete from join view 'test.v3'
delete from t1;
prepare stmt1 from "insert into v3(a) values (?);";
set @a= 100;
execute stmt1 using @a;
set @a= 300;
execute stmt1 using @a;
deallocate prepare stmt1;
prepare stmt1 from "insert into v3(a) select ?;";
set @a= 101;
execute stmt1 using @a;
set @a= 301;
execute stmt1 using @a;
deallocate prepare stmt1;
select * from v3;
a	b
100	10
100	1000
101	10
101	1000
300	10
300	1000
301	10
301	1000
drop view v3;
drop tables t1,t2;
create table t1(f1 int);
create view v1 as select f1 from t1;
select * from v1 where F1 = 1;
f1
drop view v1;
drop table t1;
create table t1(c1 int);
create table t2(c2 int);
insert into t1 values (1),(2),(3);
insert into t2 values (1);
SELECT c1 FROM t1 WHERE c1 IN (SELECT c2 FROM t2);
c1
1
SELECT c1 FROM t1 WHERE EXISTS (SELECT c2 FROM t2 WHERE c2 = c1);
c1
1
create view v1 as SELECT c1 FROM t1 WHERE c1 IN (SELECT c2 FROM t2);
create view v2 as SELECT c1 FROM t1 WHERE EXISTS (SELECT c2 FROM t2 WHERE c2 = c1);
select * from v1;
c1
1
select * from v2;
c1
1
select * from (select c1 from v2) X;
c1
1
drop view v2, v1;
drop table t1, t2;
CREATE TABLE t1 (C1 INT, C2 INT);
CREATE TABLE t2 (C2 INT);
CREATE VIEW v1 AS SELECT C2 FROM t2;
CREATE VIEW v2 AS SELECT C1 FROM t1 LEFT OUTER JOIN v1 USING (C2);
SELECT * FROM v2;
C1
drop view v2, v1;
drop table t1, t2;
create table t1 (col1 char(5),col2 int,col3 int);
insert into t1 values ('one',10,25), ('two',10,50), ('two',10,50), ('one',20,25), ('one',30,25);
create view v1 as select * from t1;
select col1,group_concat(col2,col3) from t1 group by col1;
col1	group_concat(col2,col3)
one	1025,2025,3025
two	1050,1050
select col1,group_concat(col2,col3) from v1 group by col1;
col1	group_concat(col2,col3)
one	1025,2025,3025
two	1050,1050
drop view v1;
drop table t1;
create table t1 (s1 int, s2 char);
create view v1 as select s1, s2 from t1;
select s2 from v1 vq1 where 2 = (select count(*) from v1 vq2 having vq1.s2 = vq2.s2);
ERROR 42S22: Unknown column 'vq2.s2' in 'having clause'
select s2 from v1 vq1 where 2 = (select count(*) aa from v1 vq2 having vq1.s2 = aa);
s2
drop view v1;
drop table t1;
CREATE TABLE t1 (a1 int);
CREATE TABLE t2 (a2 int);
INSERT INTO t1 VALUES (1), (2), (3), (4);
INSERT INTO t2 VALUES (1), (2), (3);
CREATE VIEW v1(a,b) AS SELECT a1,a2 FROM t1 JOIN t2 ON a1=a2 WHERE a1>1;
SELECT * FROM v1;
a	b
2	2
3	3
CREATE TABLE t3 SELECT * FROM v1;
SELECT * FROM t3;
a	b
2	2
3	3
DROP VIEW v1;
DROP TABLE t1,t2,t3;
create table t1 (a int);
create table t2 like t1;
create table t3 like t1;
create view v1 as select t1.a x, t2.a y from t1 join t2 where t1.a=t2.a;
insert into t3 select x from v1;
insert into t2 select x from v1;
drop view v1;
drop table t1,t2,t3;
CREATE TABLE t1 (col1 int PRIMARY KEY, col2 varchar(10));
INSERT INTO t1 VALUES(1,'trudy');
INSERT INTO t1 VALUES(2,'peter');
INSERT INTO t1 VALUES(3,'sanja');
INSERT INTO t1 VALUES(4,'monty');
INSERT INTO t1 VALUES(5,'david');
INSERT INTO t1 VALUES(6,'kent');
INSERT INTO t1 VALUES(7,'carsten');
INSERT INTO t1 VALUES(8,'ranger');
INSERT INTO t1 VALUES(10,'matt');
CREATE TABLE t2 (col1 int, col2 int, col3 char(1));
INSERT INTO t2 VALUES (1,1,'y');
INSERT INTO t2 VALUES (1,2,'y');
INSERT INTO t2 VALUES (2,1,'n');
INSERT INTO t2 VALUES (3,1,'n');
INSERT INTO t2 VALUES (4,1,'y');
INSERT INTO t2 VALUES (4,2,'n');
INSERT INTO t2 VALUES (4,3,'n');
INSERT INTO t2 VALUES (6,1,'n');
INSERT INTO t2 VALUES (8,1,'y');
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT a.col1,a.col2,b.col2,b.col3
FROM t1 a LEFT JOIN t2 b ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM t2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
SELECT a.col1,a.col2,b.col2,b.col3
FROM v1 a LEFT JOIN t2 b ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM t2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
CREATE VIEW v2 AS SELECT * FROM t2;
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v1 a ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
10	matt	NULL	NULL
2	peter	1	n
3	sanja	1	n
4	monty	3	n
5	david	NULL	NULL
6	kent	1	n
7	carsten	NULL	NULL
8	ranger	1	y
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v1 a ON a.col1=b.col1
WHERE a.col1 IN (1,5,9) AND
(b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1));
col1	col2	col2	col3
1	trudy	2	y
5	david	NULL	NULL
CREATE VIEW v3 AS SELECT * FROM t1 WHERE col1 IN (1,5,9);
SELECT a.col1,a.col2,b.col2,b.col3
FROM v2 b RIGHT JOIN v3 a ON a.col1=b.col1
WHERE b.col2 IS NULL OR
b.col2=(SELECT MAX(col2) FROM v2 b WHERE b.col1=a.col1);
col1	col2	col2	col3
1	trudy	2	y
5	david	NULL	NULL
DROP VIEW v1,v2,v3;
DROP TABLE t1,t2;
create table t1 as select 1 A union select 2 union select 3;
create table t2 as select * from t1;
create view v1 as select * from t1 where a in (select * from t2);
select * from v1 A, v1 B where A.a = B.a;
A	A
1	1
2	2
3	3
create table t3 as select a a,a b from t2;
create view v2 as select * from t3 where
a in (select * from t1) or b in (select * from t2);
select * from v2 A, v2 B where A.a = B.b;
a	b	a	b
1	1	1	1
2	2	2	2
3	3	3	3
drop view v1, v2;
drop table t1, t2, t3;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
INSERT INTO t1 VALUES (1), (2), (3), (4);
INSERT INTO t2 VALUES (4), (2);
CREATE VIEW v1 AS SELECT * FROM t1,t2 WHERE t1.a=t2.b;
SELECT * FROM v1;
a	b
2	2
4	4
CREATE VIEW v2 AS SELECT * FROM v1;
SELECT * FROM v2;
a	b
2	2
4	4
DROP VIEW v2,v1;
DROP TABLE t1, t2;
create table t1 (a int);
create view v1 as select sum(a) from t1 group by a;
create procedure p1()
begin
select * from v1;
end//
call p1();
sum(a)
call p1();
sum(a)
drop procedure p1;
drop view v1;
drop table t1;
CREATE TABLE t1(a char(2) primary key, b char(2));
CREATE TABLE t2(a char(2), b char(2), index i(a));
INSERT INTO t1 VALUES ('a','1'), ('b','2');
INSERT INTO t2 VALUES ('a','5'), ('a','6'), ('b','5'), ('b','6');
CREATE VIEW v1 AS
SELECT t1.b as c, t2.b as d FROM t1,t2 WHERE t1.a=t2.a;
SELECT d, c FROM v1 ORDER BY d,c;
d	c
5	1
5	2
6	1
6	2
DROP VIEW v1;
DROP TABLE t1, t2;
create table t1 (s1 int);
create view  v1 as select sum(distinct s1) from t1;
select * from v1;
sum(distinct s1)
NULL
drop view v1;
create view  v1 as select avg(distinct s1) from t1;
select * from v1;
avg(distinct s1)
NULL
drop view v1;
drop table t1;
create view v1 as select cast(1 as decimal);
select * from v1;
cast(1 as decimal)
1
drop view v1;
create table t1(f1 int);
create table t2(f2 int);
insert into t1 values(1),(2),(3);
insert into t2 values(1),(2),(3);
create view v1 as select * from t1,t2 where f1=f2;
create table t3 (f1 int, f2 int);
insert into t3 select * from v1 order by 1;
select * from t3;
f1	f2
1	1
2	2
3	3
drop view v1;
drop table t1,t2,t3;
create view v1 as select '\\','\\shazam';
select * from v1;
\	\shazam
\	\shazam
drop view v1;
create view v1 as select '\'','\shazam';
select * from v1;
'	shazam
'	shazam
drop view v1;
create view v1 as select 'k','K';
select * from v1;
k	My_exp_K
k	K
drop view v1;
create table t1 (s1 int);
create view v1 as select s1, 's1' from t1;
select * from v1;
s1	My_exp_s1
drop view v1;
create view v1 as select 's1', s1 from t1;
select * from v1;
My_exp_s1	s1
drop view v1;
create view v1 as select 's1', s1, 1 as My_exp_s1 from t1;
select * from v1;
My_exp_1_s1	s1	My_exp_s1
drop view v1;
create view v1 as select 1 as My_exp_s1, 's1', s1  from t1;
select * from v1;
My_exp_s1	My_exp_1_s1	s1
drop view v1;
create view v1 as select 1 as s1, 's1', 's1' from t1;
select * from v1;
s1	My_exp_s1	My_exp_1_s1
drop view v1;
create view v1 as select 's1', 's1', 1 as s1 from t1;
select * from v1;
My_exp_1_s1	My_exp_s1	s1
drop view v1;
create view v1 as select s1, 's1', 's1' from t1;
select * from v1;
s1	My_exp_s1	My_exp_1_s1
drop view v1;
create view v1 as select 's1', 's1', s1 from t1;
select * from v1;
My_exp_1_s1	My_exp_s1	s1
drop view v1;
create view v1 as select 1 as s1, 's1', s1 from t1;
ERROR 42S21: Duplicate column name 's1'
create view v1 as select 's1', s1, 1 as s1 from t1;
ERROR 42S21: Duplicate column name 's1'
drop table t1;
create view v1(k, K) as select 1,2;
ERROR 42S21: Duplicate column name 'k'
create view v1 as SELECT TIME_FORMAT(SEC_TO_TIME(3600),'%H:%i') as t;
select * from v1;
t
01:00
drop view v1;
create table t1 (a timestamp default now());
create table t2 (b timestamp default now());
create view v1 as select a,b,t1.a < now() from t1,t2 where t1.a < now();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,`t2`.`b` AS `b`,(`t1`.`a` < now()) AS `t1.a < now()` from (`t1` join `t2`) where (`t1`.`a` < now())	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1, t2;
CREATE TABLE t1 ( a varchar(50) );
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = CURRENT_USER();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = current_user())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = VERSION();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = version())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a = DATABASE();
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` = database())	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (col1 time);
CREATE TABLE t2 (col1 time);
CREATE VIEW v1 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v2 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
CREATE VIEW v3 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v4 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
CREATE VIEW v5 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t1;
CREATE VIEW v6 AS SELECT CONVERT_TZ(col1,'GMT','MET') FROM t2;
DROP TABLE t1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	Table 'test.t1' doesn't exist
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	error	Corrupt
test.v2	check	status	OK
test.v3	check	Error	Table 'test.t1' doesn't exist
test.v3	check	Error	View 'test.v3' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v3	check	error	Corrupt
test.v4	check	status	OK
test.v5	check	Error	Table 'test.t1' doesn't exist
test.v5	check	Error	View 'test.v5' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v5	check	error	Corrupt
test.v6	check	status	OK
drop view v1, v2, v3, v4, v5, v6;
drop table t2;
drop function if exists f1;
drop function if exists f2;
CREATE TABLE t1 (col1 time);
CREATE TABLE t2 (col1 time);
CREATE TABLE t3 (col1 time);
create function f1 () returns int return (select max(col1) from t1);
create function f2 () returns int return (select max(col1) from t2);
CREATE VIEW v1 AS SELECT f1() FROM t3;
CREATE VIEW v2 AS SELECT f2() FROM t3;
CREATE VIEW v3 AS SELECT f1() FROM t3;
CREATE VIEW v4 AS SELECT f2() FROM t3;
CREATE VIEW v5 AS SELECT f1() FROM t3;
CREATE VIEW v6 AS SELECT f2() FROM t3;
drop function f1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	Error	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v1	check	status	Operation failed
test.v2	check	status	OK
test.v3	check	Error	View 'test.v3' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v3	check	status	Operation failed
test.v4	check	status	OK
test.v5	check	Error	View 'test.v5' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
test.v5	check	status	Operation failed
test.v6	check	status	OK
create function f1 () returns int return (select max(col1) from t1);
DROP TABLE t1;
CHECK TABLE v1, v2, v3, v4, v5, v6;
Table	Op	Msg_type	Msg_text
test.v1	check	status	OK
test.v2	check	status	OK
test.v3	check	status	OK
test.v4	check	status	OK
test.v5	check	status	OK
test.v6	check	status	OK
drop function f1;
drop function f2;
drop view v1, v2, v3, v4, v5, v6;
drop table t2,t3;
create table t1 (f1 date);
insert into t1 values ('2005-01-01'),('2005-02-02');
create view v1 as select * from t1;
select * from v1 where f1='2005.02.02';
f1
2005-02-02
select * from v1 where '2005.02.02'=f1;
f1
2005-02-02
drop view v1;
drop table t1;
CREATE VIEW v1 AS SELECT SUBSTRING_INDEX("dkjhgd:kjhdjh", ":", 1);
SELECT * FROM v1;
SUBSTRING_INDEX("dkjhgd:kjhdjh", ":", 1)
dkjhgd
drop view v1;
create table t1 (f59 int, f60 int, f61 int);
insert into t1 values (19,41,32);
create view v1 as select f59, f60 from t1 where f59 in
(select f59 from t1);
update v1 set f60=2345;
ERROR HY000: The target table v1 of the UPDATE is not updatable
update t1 set f60=(select max(f60) from v1);
ERROR HY000: The definition of table 'v1' prevents operation UPDATE on table 't1'.
drop view v1;
drop table t1;
create table t1 (s1 int);
create view v1 as select var_samp(s1) from t1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select var_samp(`t1`.`s1`) AS `var_samp(s1)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
CREATE TABLE t1 (col1 INT NOT NULL, col2 INT NOT NULL);
CREATE VIEW v1 (vcol1) AS SELECT col1 FROM t1;
CREATE VIEW v2 (vcol1) AS SELECT col1 FROM t1 WHERE col2 > 2;
INSERT INTO t1 (col1) VALUES(12);
ERROR HY000: Field 'col2' doesn't have a default value
INSERT INTO v1 (vcol1) VALUES(12);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
INSERT INTO v2 (vcol1) VALUES(12);
ERROR HY000: Field of view 'test.v2' underlying table doesn't have a default value
drop view v2,v1;
drop table t1;
create table t1 (f1 int);
insert into t1 values (1);
create view v1 as select f1 from t1;
select f1 as alias from v1;
alias
1
drop view v1;
drop table t1;
CREATE TABLE t1 (s1 int, s2 int);
INSERT  INTO t1 VALUES (1,2);
CREATE VIEW v1 AS SELECT s2 AS s1, s1 AS s2 FROM t1;
SELECT * FROM v1;
s1	s2
2	1
CREATE PROCEDURE p1 () SELECT * FROM v1;
CALL p1();
s1	s2
2	1
ALTER VIEW v1 AS SELECT s1 AS s1, s2 AS s2 FROM t1;
CALL p1();
s1	s2
1	2
DROP VIEW v1;
CREATE VIEW v1 AS SELECT s2 AS s1, s1 AS s2 FROM t1;
CALL p1();
s1	s2
2	1
DROP PROCEDURE p1;
DROP VIEW v1;
DROP TABLE t1;
create table t1 (f1 int, f2 int);
create view v1 as select f1 as f3, f2 as f1 from t1;
insert into t1 values (1,3),(2,1),(3,2);
select * from v1 order by f1;
f3	f1
2	1
3	2
1	3
drop view v1;
drop table t1;
CREATE TABLE t1 (f1 char);
INSERT INTO t1 VALUES ('A');
CREATE VIEW  v1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES('B');
SELECT * FROM v1;
f1
A
B
SELECT * FROM t1;
f1
A
B
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 ( bug_table_seq   INTEGER NOT NULL);
CREATE OR REPLACE VIEW v1 AS SELECT * from t1;
DROP PROCEDURE IF EXISTS p1;
Warnings:
Note	1305	PROCEDURE test.p1 does not exist
CREATE PROCEDURE p1 ( )
BEGIN
DO (SELECT  @next := IFNULL(max(bug_table_seq),0) + 1 FROM v1);
INSERT INTO t1 VALUES (1);
END //
Warnings:
Warning	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Please set variables in separate statements instead.
CALL p1();
DROP PROCEDURE p1;
DROP VIEW v1;
DROP TABLE t1;
create table t1(f1 datetime);
insert into t1 values('2005.01.01 12:0:0');
create view v1 as select f1, subtime(f1, '1:1:1') as sb from t1;
select * from v1;
f1	sb
2005-01-01 12:00:00	2005-01-01 10:58:59
drop view v1;
drop table t1;
CREATE TABLE t1 (
aid int PRIMARY KEY,
fn varchar(20) NOT NULL,
ln varchar(20) NOT NULL
);
CREATE TABLE t2 (
aid int NOT NULL,
pid int NOT NULL
);
INSERT INTO t1 VALUES(1,'a','b'), (2,'c','d');
INSERT INTO t2 values (1,1), (2,1), (2,2);
CREATE VIEW v1 AS SELECT t1.*,t2.pid FROM t1,t2 WHERE t1.aid = t2.aid;
SELECT pid,GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1) FROM t1,t2
WHERE t1.aid = t2.aid GROUP BY pid;
pid	GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1)
1	a b,c d
2	c d
SELECT pid,GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1) FROM v1 GROUP BY pid;
pid	GROUP_CONCAT(CONCAT(fn,' ',ln) ORDER BY 1)
1	a b,c d
2	c d
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int PRIMARY KEY, f varchar(255));
CREATE VIEW v1 AS SELECT id, f FROM t1 WHERE id <= 2;
INSERT INTO t1 VALUES (2, 'foo2');
INSERT INTO t1 VALUES (1, 'foo1');
SELECT * FROM v1;
id	f
1	foo1
2	foo2
SELECT * FROM v1;
id	f
1	foo1
2	foo2
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (pk int PRIMARY KEY, b int);
CREATE TABLE t2 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t3 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t4 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE TABLE t5 (pk int PRIMARY KEY, fk int, INDEX idx(fk));
CREATE VIEW v1 AS
SELECT t1.pk as a FROM t1,t2,t3,t4,t5
WHERE t1.b IS NULL AND
t1.pk=t2.fk AND t2.pk=t3.fk AND t3.pk=t4.fk AND t4.pk=t5.fk;
SELECT a FROM v1;
a
DROP VIEW v1;
DROP TABLE t1,t2,t3,t4,t5;
create view v1 as select timestampdiff(day,'1997-01-01 00:00:00','1997-01-02 00:00:00') as f1;
select * from v1;
f1
1
drop view v1;
create table t1(a int);
create procedure p1() create view v1 as select * from t1;
drop table t1;
call p1();
ERROR 42S02: Table 'test.t1' doesn't exist
call p1();
ERROR 42S02: Table 'test.t1' doesn't exist
drop procedure p1;
create table t1 (f1 int);
create table t2 (f1 int);
insert into t1 values (1);
insert into t2 values (2);
create view v1 as select * from t1 union select * from t2 union all select * from t2;
select * from v1;
f1
1
2
2
drop view v1;
drop table t1,t2;
CREATE TEMPORARY TABLE t1 (a int);
CREATE FUNCTION f1 () RETURNS int RETURN (SELECT COUNT(*) FROM t1);
CREATE VIEW v1 AS SELECT f1();
ERROR HY000: View's SELECT refers to a temporary table 't1'
DROP FUNCTION f1;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
DROP VIEW  IF EXISTS v1;
CREATE TABLE t1 (f4 CHAR(5));
CREATE VIEW v1 AS SELECT * FROM t1;
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
f4	char(5)	YES		NULL	
ALTER TABLE t1 CHANGE COLUMN f4 f4x CHAR(5);
DESCRIBE v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP TABLE t1;
DROP VIEW v1;
create table t1 (f1 char);
create view v1 as select strcmp(f1,'a') from t1;
select * from v1;
strcmp(f1,'a')
drop view v1;
drop table t1;
create table t1 (f1 int, f2 int,f3 int);
insert into t1 values (1,10,20),(2,0,0);
create view v1 as select * from t1;
select if(sum(f1)>1,f2,f3) from v1 group by f1;
if(sum(f1)>1,f2,f3)
20
0
drop view v1;
drop table t1;
create table t1 (
r_object_id char(16) NOT NULL,
group_name varchar(32) NOT NULL
) engine = InnoDB;
create table t2 (
r_object_id char(16) NOT NULL,
i_position int(11) NOT NULL,
users_names varchar(32) default NULL
) Engine = InnoDB;
create view v1 as select r_object_id, group_name from t1;
create view v2 as select r_object_id, i_position, users_names from t2;
create unique index r_object_id on t1(r_object_id);
create index group_name on t1(group_name);
create unique index r_object_id_i_position on t2(r_object_id,i_position);
create index users_names on t2(users_names);
insert into t1 values('120001a080000542','tstgroup1');
insert into t2 values('120001a080000542',-1, 'guser01');
insert into t2 values('120001a080000542',-2, 'guser02');
select v1.r_object_id, v2.users_names from v1, v2
where (v1.group_name='tstgroup1') and v2.r_object_id=v1.r_object_id
order by users_names;
r_object_id	users_names
120001a080000542	guser01
120001a080000542	guser02
drop view v1, v2;
drop table t1, t2;
create table t1 (s1 int);
create view abc as select * from t1 as abc;
drop table t1;
drop view abc;
create table t1(f1 char(1));
create view v1 as select * from t1;
select * from (select f1 as f2 from v1) v where v.f2='a';
f2
drop view v1;
drop table t1;
create view v1 as SELECT CONVERT_TZ('2004-01-01 12:00:00','GMT','MET');
select * from v1;
CONVERT_TZ('2004-01-01 12:00:00','GMT','MET')
NULL
drop view v1;
CREATE TABLE t1 (date DATE NOT NULL);
INSERT INTO  t1 VALUES ('2005-09-06');
CREATE VIEW v1 AS SELECT DAYNAME(date) FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select dayname(`t1`.`date`) AS `DAYNAME(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v2 AS SELECT DAYOFWEEK(date) FROM t1;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select dayofweek(`t1`.`date`) AS `DAYOFWEEK(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v3 AS SELECT WEEKDAY(date) FROM t1;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select weekday(`t1`.`date`) AS `WEEKDAY(date)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
SELECT DAYNAME('2005-09-06');
DAYNAME('2005-09-06')
Tuesday
SELECT DAYNAME(date) FROM t1;
DAYNAME(date)
Tuesday
SELECT * FROM v1;
DAYNAME(date)
Tuesday
SELECT DAYOFWEEK('2005-09-06');
DAYOFWEEK('2005-09-06')
3
SELECT DAYOFWEEK(date) FROM t1;
DAYOFWEEK(date)
3
SELECT * FROM v2;
DAYOFWEEK(date)
3
SELECT WEEKDAY('2005-09-06');
WEEKDAY('2005-09-06')
1
SELECT WEEKDAY(date) FROM t1;
WEEKDAY(date)
1
SELECT * FROM v3;
WEEKDAY(date)
1
DROP TABLE t1;
DROP VIEW  v1, v2, v3;
CREATE TABLE t1 ( a int, b int );
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
CREATE VIEW v1 AS SELECT a,b FROM t1;
SELECT t1.a FROM t1 GROUP BY t1.a HAVING a > 1;
a
2
3
SELECT v1.a FROM v1 GROUP BY v1.a HAVING a > 1;
a
2
3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 ( a int, b int );
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
CREATE VIEW v1 AS SELECT a,b FROM t1;
SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a > 1;
a
2
3
SELECT v1.a FROM v1 GROUP BY v1.a HAVING v1.a > 1;
a
2
3
SELECT t_1.a FROM t1 AS t_1 GROUP BY t_1.a HAVING t_1.a IN (1,2,3);
a
1
2
3
SELECT v_1.a FROM v1 AS v_1 GROUP BY v_1.a HAVING v_1.a IN (1,2,3);
a
1
2
3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT, INDEX(a,b));
CREATE TABLE t2 LIKE t1;
CREATE TABLE t3 (a INT);
INSERT INTO t1 VALUES (1,1),(2,2),(3,3);
INSERT INTO t2 VALUES (1,1),(2,2),(3,3);
INSERT INTO t3 VALUES (1),(2),(3);
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
CREATE VIEW v1 AS SELECT t1.* FROM t1,t2 WHERE t1.a=t2.a AND t1.b=t2.b;
CREATE VIEW v2 AS SELECT t3.* FROM t1,t3 WHERE t1.a=t3.a;
EXPLAIN SELECT t1.* FROM t1 JOIN t2 WHERE t1.a=t2.a AND t1.b=t2.b AND t1.a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using where; Using index
1	SIMPLE	t2	NULL	ref	a	a	10	const,test.t1.b	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t1`.`b`) and (`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1))
EXPLAIN SELECT * FROM v1 WHERE a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using where; Using index
1	SIMPLE	t2	NULL	ref	a	a	10	const,test.t1.b	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t1`.`b`) and (`test`.`t1`.`a` = 1) and (`test`.`t2`.`a` = 1))
EXPLAIN SELECT * FROM v2 WHERE a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	a	a	5	const	#	#	Using index
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t3` where ((`test`.`t1`.`a` = 1) and (`test`.`t3`.`a` = 1))
DROP VIEW v1,v2;
DROP TABLE t1,t2,t3;
create table t1 (f1 int);
create view v1 as select t1.f1 as '123
456' from t1;
select * from v1;
123
456
drop view v1;
drop table t1;
create table t1 (f1 int, f2 int);
insert into t1 values(1,1),(1,2),(1,3);
create view v1 as select f1 ,group_concat(f2 order by f2 asc) from t1 group by f1;
create view v2 as select f1 ,group_concat(f2 order by f2 desc) from t1 group by f1;
select * from v1;
f1	group_concat(f2 order by f2 asc)
1	1,2,3
select * from v2;
f1	group_concat(f2 order by f2 desc)
1	3,2,1
drop view v1,v2;
drop table t1;
create table t1 (x int, y int);
create table t2 (x int, y int, z int);
create table t3 (x int, y int, z int);
create table t4 (x int, y int, z int);
create view v1 as
select t1.x
from (
(t1 join t2 on ((t1.y = t2.y)))
join
(t3 left join t4 on (t3.y = t4.y) and (t3.z = t4.z))
);
prepare stmt1 from "select count(*) from v1 where x = ?";
set @parm1=1;
execute stmt1 using @parm1;
count(*)
0
execute stmt1 using @parm1;
count(*)
0
drop view v1;
drop table t1,t2,t3,t4;
CREATE TABLE t1(id INT);
CREATE VIEW v1 AS SELECT id FROM t1;
OPTIMIZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	optimize	Error	'test.v1' is not BASE TABLE
test.v1	optimize	status	Operation failed
ANALYZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	analyze	Error	'test.v1' is not BASE TABLE
test.v1	analyze	status	Operation failed
REPAIR TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	repair	Error	'test.v1' is not BASE TABLE
test.v1	repair	status	Operation failed
DROP TABLE t1;
OPTIMIZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	optimize	Error	'test.v1' is not BASE TABLE
test.v1	optimize	status	Operation failed
ANALYZE TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	analyze	Error	'test.v1' is not BASE TABLE
test.v1	analyze	status	Operation failed
REPAIR TABLE v1;
Table	Op	Msg_type	Msg_text
test.v1	repair	Error	'test.v1' is not BASE TABLE
test.v1	repair	status	Operation failed
DROP VIEW v1;
create definer = current_user() sql security invoker view v1 as select 1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create definer = current_user sql security invoker view v1 as select 1;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
create table t1 (id INT, primary key(id));
insert into t1 values (1),(2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
create view v1 as select * from t1;
explain select id from v1 order by id;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id` AS `id` from `test`.`t1` order by `test`.`t1`.`id`
drop view v1;
drop table t1;
create table t1(f1 int, f2 int);
insert into t1 values (null, 10), (null,2);
select f1, sum(f2) from t1 group by f1;
f1	sum(f2)
NULL	12
create view v1 as select * from t1;
select f1, sum(f2) from v1 group by f1;
f1	sum(f2)
NULL	12
drop view v1;
drop table t1;
drop procedure if exists p1;
create procedure p1 () deterministic
begin
create view v1 as select 1;
end;
//
call p1();
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop procedure p1;
CREATE VIEW v1 AS SELECT 42 AS Meaning;
DROP FUNCTION IF EXISTS f1;
CREATE FUNCTION f1() RETURNS INTEGER
BEGIN
DECLARE retn INTEGER;
SELECT Meaning FROM v1 INTO retn;
RETURN retn;
END
//
CREATE VIEW v2 AS SELECT f1();
select * from v2;
f1()
42
drop view v2,v1;
drop function f1;
create table t1 (id numeric, warehouse_id numeric);
create view v1 as select id from t1;
create view v2 as
select t1.warehouse_id, v1.id as receipt_id
from t1, v1 where t1.id = v1.id;
insert into t1 (id, warehouse_id) values(3, 2);
insert into t1 (id, warehouse_id) values(4, 2);
insert into t1 (id, warehouse_id) values(5, 1);
select v2.receipt_id as alias1, v2.receipt_id as alias2 from v2
order by v2.receipt_id;
alias1	alias2
3	3
4	4
5	5
drop view v2, v1;
drop table t1;
CREATE TABLE t1 (a int PRIMARY KEY, b int);
INSERT INTO t1 VALUES (2,20), (3,10), (1,10), (0,30), (5,10);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT MAX(a) FROM t1;
MAX(a)
5
SELECT MAX(a) FROM v1;
MAX(a)
5
EXPLAIN SELECT MAX(a) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`a`) AS `MAX(a)` from `test`.`t1`
EXPLAIN SELECT MAX(a) FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`a`) AS `MAX(a)` from `test`.`t1`
SELECT MIN(a) FROM t1;
MIN(a)
0
SELECT MIN(a) FROM v1;
MIN(a)
0
EXPLAIN SELECT MIN(a) FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`
EXPLAIN SELECT MIN(a) FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`a`) AS `MIN(a)` from `test`.`t1`
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (x varchar(10));
INSERT INTO t1 VALUES (null), ('foo'), ('bar'), (null);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT IF(x IS NULL, 'blank', 'not blank') FROM v1 GROUP BY x;
IF(x IS NULL, 'blank', 'not blank')
blank
not blank
not blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM t1 GROUP BY x;
x
blank
not blank
not blank
Warnings:
Warning	1052	Column 'x' in group statement is ambiguous
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM v1;
x
blank
not blank
not blank
blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS y FROM v1 GROUP BY y;
y
blank
not blank
SELECT IF(x IS NULL, 'blank', 'not blank') AS x FROM v1 GROUP BY x;
x
blank
not blank
not blank
Warnings:
Warning	1052	Column 'x' in group statement is ambiguous
DROP VIEW v1;
DROP TABLE t1;
drop table if exists t1;
drop view if exists v1;
create table t1 (id int);
create view v1 as select * from t1;
drop table t1;
show create view v1;
drop view v1;
//
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`id` AS `id` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
create table t1(f1 int, f2 int);
create view v1 as select ta.f1 as a, tb.f1 as b from t1 ta, t1 tb where ta.f1=tb
.f1 and ta.f2=tb.f2;
insert into t1 values(1,1),(2,2);
create view v2 as select * from v1 where a > 1 with local check option;
select * from v2;
a	b
2	2
update v2 set b=3 where a=2;
select * from v2;
a	b
3	3
drop view v2, v1;
drop table t1;
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT SQRT(a) my_sqrt FROM t1;
SELECT my_sqrt FROM v1 ORDER BY my_sqrt;
my_sqrt
1
1.4142135623730951
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (id int PRIMARY KEY);
CREATE TABLE t2 (id int PRIMARY KEY);
INSERT INTO t1 VALUES (1), (3);
INSERT INTO t2 VALUES (1), (2), (3);
CREATE VIEW v2 AS SELECT * FROM t2;
SELECT COUNT(*) FROM t1 LEFT JOIN t2 ON t1.id=t2.id;
COUNT(*)
2
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id;
id	id
1	1
3	3
SELECT COUNT(*) FROM t1 LEFT JOIN v2 ON t1.id=v2.id;
COUNT(*)
2
DROP VIEW v2;
DROP TABLE t1, t2;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY,
td date DEFAULT NULL, KEY idx(td));
INSERT INTO t1 VALUES
(1, '2005-01-01'), (2, '2005-01-02'), (3, '2005-01-02'),
(4, '2005-01-03'), (5, '2005-01-04'), (6, '2005-01-05'),
(7, '2005-01-05'), (8, '2005-01-05'), (9, '2005-01-06');
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT * FROM t1 WHERE td BETWEEN CAST('2005.01.02' AS DATE) AND CAST('2005.01.04' AS DATE);
id	td
2	2005-01-02
3	2005-01-02
4	2005-01-03
5	2005-01-04
SELECT * FROM v1 WHERE td BETWEEN CAST('2005.01.02' AS DATE) AND CAST('2005.01.04' AS DATE);
id	td
2	2005-01-02
3	2005-01-02
4	2005-01-03
5	2005-01-04
DROP VIEW v1;
DROP TABLE t1;
create table t1 (a int);
create view v1 as select * from t1;
create view v2 as select * from v1;
drop table t1;
rename table v2 to t1;
select * from v1;
ERROR HY000: `test`.`v1` contains view recursion
drop view t1, v1;
create table t1 (a int);
create function f1() returns int
begin
declare mx int;
select max(a) from t1 into mx;
return mx;
end//
create view v1 as select f1() as a;
create view v2 as select * from v1;
drop table t1;
rename table v2 to t1;
select * from v1;
ERROR HY000: Recursive stored functions and triggers are not allowed.
drop function f1;
drop view t1, v1;
create table t1 (dt datetime);
insert into t1 values (20040101000000), (20050101000000), (20060101000000);
create view v1 as select convert_tz(dt, 'UTC', 'Europe/Moscow') as ldt from t1;
select * from v1;
ldt
2004-01-01 03:00:00
2005-01-01 03:00:00
2006-01-01 03:00:00
drop view v1;
create view v1 as select * from t1 where convert_tz(dt, 'UTC', 'Europe/Moscow') >= 20050101000000;
select * from v1;
dt
2005-01-01 00:00:00
2006-01-01 00:00:00
create view v2 as select * from v1 where dt < 20060101000000;
select * from v2;
dt
2005-01-01 00:00:00
drop view v2;
create view v2 as select convert_tz(dt, 'UTC', 'Europe/Moscow') as ldt from v1;
select * from v2;
ldt
2005-01-01 03:00:00
2006-01-01 03:00:00
drop view v1, v2;
drop table t1;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY, d datetime);
CREATE VIEW v1 AS
SELECT id, date(d) + INTERVAL TIME_TO_SEC(d) SECOND AS t, COUNT(*)
FROM t1 GROUP BY id, t;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`id` AS `id`,(cast(`t1`.`d` as date) + interval time_to_sec(`t1`.`d`) second) AS `t`,count(0) AS `COUNT(*)` from `t1` group by `t1`.`id`,`t`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM v1;
id	t	COUNT(*)
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (i INT, j BIGINT);
INSERT INTO t1 VALUES (1, 2), (2, 2), (3, 2);
CREATE VIEW v1 AS SELECT MIN(j) AS j FROM t1;
CREATE VIEW v2 AS SELECT MIN(i) FROM t1 WHERE j = ( SELECT * FROM v1 );
SELECT * FROM v2;
MIN(i)
1
DROP VIEW v2, v1;
DROP TABLE t1;
CREATE TABLE t1(
fName varchar(25) NOT NULL,
lName varchar(25) NOT NULL,
DOB date NOT NULL,
test_date date NOT NULL,
uID int unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY);
INSERT INTO t1(fName, lName, DOB, test_date) VALUES
('Hank', 'Hill', '1964-09-29', '2007-01-01'),
('Tom', 'Adams', '1908-02-14', '2007-01-01'),
('Homer', 'Simpson', '1968-03-05', '2007-01-01');
CREATE VIEW v1 AS
SELECT (year(test_date)-year(DOB)) AS Age
FROM t1 HAVING Age < 75;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select (year(`t1`.`test_date`) - year(`t1`.`DOB`)) AS `Age` from `t1` having (`Age` < 75)	utf8mb4	utf8mb4_0900_ai_ci
SELECT (year(test_date)-year(DOB)) AS Age FROM t1 HAVING Age < 75;
Age
43
39
SELECT * FROM v1;
Age
43
39
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY, a char(6) DEFAULT 'xxx');
INSERT INTO t1(id) VALUES (1), (2), (3), (4);
INSERT INTO t1 VALUES (5,'yyy'), (6,'yyy');
SELECT * FROM t1;
id	a
1	xxx
2	xxx
3	xxx
4	xxx
5	yyy
6	yyy
CREATE VIEW v1(a, m) AS SELECT a, MIN(id) FROM t1 GROUP BY a;
SELECT * FROM v1;
a	m
xxx	1
yyy	5
CREATE TABLE t2 SELECT * FROM v1;
INSERT INTO t2(m) VALUES (0);
SELECT * FROM t2;
a	m
xxx	1
yyy	5
xxx	0
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int PRIMARY KEY, e ENUM('a','b') NOT NULL DEFAULT 'b');
INSERT INTO t1(id) VALUES (1), (2), (3);
INSERT INTO t1 VALUES (4,'a');
SELECT * FROM t1;
id	e
1	b
2	b
3	b
4	a
CREATE VIEW v1(m, e) AS SELECT MIN(id), e FROM t1 GROUP BY e;
CREATE TABLE t2 SELECT * FROM v1;
SELECT * FROM t2;
m	e
1	b
4	a
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (a INT NOT NULL, b INT NULL DEFAULT NULL);
CREATE VIEW v1 AS SELECT a, b FROM t1;
INSERT IGNORE INTO v1 (b) VALUES (2);
Warnings:
Warning	1423	Field of view 'test.v1' underlying table doesn't have a default value
SET SQL_MODE = STRICT_ALL_TABLES;
Warnings:
Warning	3135	'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and 'ERROR_FOR_DIVISION_BY_ZERO' sql modes should be used with strict mode. They will be merged with strict mode in a future release.
INSERT INTO v1 (b) VALUES (4);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
SET SQL_MODE = '';
SELECT * FROM t1;
a	b
0	2
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (firstname text, surname text);
INSERT INTO t1 VALUES
("Bart","Simpson"),("Milhouse","van Houten"),("Montgomery","Burns");
CREATE VIEW v1 AS SELECT CONCAT(firstname," ",surname) AS name FROM t1;
SELECT CONCAT(LEFT(name,LENGTH(name)-INSTR(REVERSE(name)," ")),
LEFT(name,LENGTH(name)-INSTR(REVERSE(name)," "))) AS f1
FROM v1;
f1
BartBart
Milhouse vanMilhouse van
MontgomeryMontgomery
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (i int, j int);
CREATE VIEW v1 AS SELECT COALESCE(i,j) FROM t1;
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
COALESCE(i,j)	bigint(11)	YES		NULL	
CREATE TABLE t2 SELECT COALESCE(i,j) FROM t1;
DESCRIBE t2;
Field	Type	Null	Key	Default	Extra
COALESCE(i,j)	int(11)	YES		NULL	
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (s varchar(10));
INSERT INTO t1 VALUES ('yadda'), ('yady');
SELECT TRIM(BOTH 'y' FROM s) FROM t1;
TRIM(BOTH 'y' FROM s)
adda
ad
CREATE VIEW v1 AS SELECT TRIM(BOTH 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(BOTH 'y' FROM s)
adda
ad
DROP VIEW v1;
SELECT TRIM(LEADING 'y' FROM s) FROM t1;
TRIM(LEADING 'y' FROM s)
adda
ady
CREATE VIEW v1 AS SELECT TRIM(LEADING 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(LEADING 'y' FROM s)
adda
ady
DROP VIEW v1;
SELECT TRIM(TRAILING 'y' FROM s) FROM t1;
TRIM(TRAILING 'y' FROM s)
yadda
yad
CREATE VIEW v1 AS SELECT TRIM(TRAILING 'y' FROM s) FROM t1;
SELECT * FROM v1;
TRIM(TRAILING 'y' FROM s)
yadda
yad
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (x INT, y INT);
CREATE ALGORITHM=TEMPTABLE SQL SECURITY INVOKER VIEW v1 AS SELECT x FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select `t1`.`x` AS `x` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
ALTER VIEW v1 AS SELECT x, y FROM t1;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost` SQL SECURITY INVOKER VIEW `v1` AS select `t1`.`x` AS `x`,`t1`.`y` AS `y` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (s1 char) charset latin1;
INSERT INTO t1 VALUES ('Z');
CREATE VIEW v1 AS SELECT s1 collate latin1_german1_ci AS col FROM t1;
CREATE VIEW v2 (col) AS SELECT s1 collate latin1_german1_ci FROM t1;
INSERT INTO v1 (col) VALUES ('b');
INSERT INTO v2 (col) VALUES ('c');
SELECT s1 FROM t1;
s1
Z
b
c
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE TABLE t1 (id INT);
CREATE VIEW v1 AS SELECT id FROM t1;
SHOW TABLES;
Tables_in_test
t1
v1
DROP VIEW v2,v1;
ERROR 42S02: Unknown table 'test.v2'
SHOW TABLES;
Tables_in_test
t1
v1
DROP VIEW t1,v1;
ERROR HY000: 'test.t1' is not VIEW
SHOW TABLES;
Tables_in_test
t1
v1
DROP TABLE t1;
DROP VIEW IF EXISTS v1;
CREATE DATABASE bug21261DB;
USE bug21261DB;
CREATE TABLE t1 (x INT);
CREATE SQL SECURITY INVOKER VIEW v1 AS SELECT x FROM t1;
CREATE USER 'user21261'@'localhost';
GRANT INSERT, UPDATE ON v1 TO 'user21261'@'localhost';
GRANT INSERT, UPDATE ON t1 TO 'user21261'@'localhost';
CREATE TABLE t2 (y INT);
GRANT SELECT ON t2 TO 'user21261'@'localhost';
INSERT INTO v1 (x) VALUES (5);
UPDATE v1 SET x=1;
GRANT SELECT ON v1 TO 'user21261'@'localhost';
GRANT SELECT ON t1 TO 'user21261'@'localhost';
UPDATE v1,t2 SET x=1 WHERE x=y;
SELECT * FROM t1;
x
1
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 'user21261'@'localhost';
DROP USER 'user21261'@'localhost';
DROP VIEW v1;
DROP TABLE t1;
DROP DATABASE bug21261DB;
USE test;
create table t1 (f1 datetime);
create view v1 as select * from t1 where f1 between now() and now() + interval 1 minute;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`f1` AS `f1` from `t1` where (`t1`.`f1` between now() and (now() + interval 1 minute))	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
drop table t1;
DROP TABLE IF EXISTS t1;
DROP VIEW IF EXISTS v1;
DROP VIEW IF EXISTS v2;
CREATE TABLE t1(a INT, b INT);
CREATE DEFINER=1234567890abcdefGHIKL1234567890abcdefGHIKL@localhost
VIEW v1 AS SELECT a FROM t1;
ERROR HY000: String '1234567890abcdefGHIKL1234567890abcdefGHIKL' is too long for user name (should be no longer than 32)
CREATE DEFINER=some_user_name@1234567890abcdefghij1234567890abcdefghij1234567890abcdefghijQWERTY
VIEW v2 AS SELECT b FROM t1;
ERROR HY000: String '1234567890abcdefghij1234567890abcdefghij1234567890abcdefghijQWERTY' is too long for host name (should be no longer than 60)
DROP TABLE t1;
DROP FUNCTION IF EXISTS f1;
DROP FUNCTION IF EXISTS f2;
DROP VIEW IF EXISTS v1, v2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT);
CREATE VIEW v1 AS SELECT * FROM t1;
CREATE FUNCTION f1() RETURNS INT
BEGIN
INSERT INTO v1 VALUES (0);
RETURN 0;
END |
SELECT f1();
f1()
0
CREATE ALGORITHM=TEMPTABLE VIEW v2 AS SELECT * FROM t1;
CREATE FUNCTION f2() RETURNS INT
BEGIN
INSERT INTO v2 VALUES (0);
RETURN 0;
END |
SELECT f2();
ERROR HY000: The target table v2 of the INSERT is not insertable-into
DROP FUNCTION f1;
DROP FUNCTION f2;
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE TABLE t1 (s1 int);
CREATE VIEW v1 AS SELECT * FROM t1;
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1`
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1`
INSERT INTO t1 VALUES (1), (3), (2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
EXPLAIN SELECT * FROM t1 t WHERE t.s1+1 < (SELECT MAX(t1.s1) FROM t1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t	NULL	ALL	NULL	NULL	NULL	#	#	#	Using where
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t`.`s1` AS `s1` from `test`.`t1` `t` where ((`test`.`t`.`s1` + 1) < (/* select#2 */ select max(`test`.`t1`.`s1`) from `test`.`t1`))
EXPLAIN SELECT * FROM v1 t WHERE t.s1+1 < (SELECT MAX(t1.s1) FROM t1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	Using where
2	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	#	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`s1` AS `s1` from `test`.`t1` where ((`test`.`t1`.`s1` + 1) < (/* select#2 */ select max(`test`.`t1`.`s1`) from `test`.`t1`))
DROP VIEW v1;
DROP TABLE t1;
create table t1 (s1 int);
create view v1 as select s1 as a, s1 as b from t1;
insert into v1 values (1,1);
ERROR HY000: The target table v1 of the INSERT is not insertable-into
update v1 set a = 5;
drop view v1;
drop table t1;
CREATE TABLE t1(pk int PRIMARY KEY);
CREATE TABLE t2(pk int PRIMARY KEY, fk int, ver int, org int);
CREATE ALGORITHM=MERGE VIEW v1 AS
SELECT t1.*
FROM t1 JOIN t2
ON t2.fk = t1.pk AND
t2.ver = (SELECT MAX(t.ver) FROM t2 t WHERE t.org = t2.org);
SHOW WARNINGS;
Level	Code	Message
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=MERGE DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`pk` AS `pk` from (`t1` join `t2` on(((`t2`.`fk` = `t1`.`pk`) and (`t2`.`ver` = (select max(`t`.`ver`) from `t2` `t` where (`t`.`org` = `t2`.`org`))))))	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
DROP TABLE t1, t2;
DROP FUNCTION IF EXISTS f1;
DROP VIEW IF EXISTS v1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT);
INSERT INTO t1 VALUES (1);
CREATE VIEW v1 AS SELECT MAX(i) FROM t1;
CREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW
SET NEW.i = (SELECT * FROM v1) + 1;
INSERT INTO t1 VALUES (1);
CREATE FUNCTION f1() RETURNS INT RETURN (SELECT * FROM v1);
UPDATE t1 SET i= f1();
DROP FUNCTION f1;
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1(id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, val INT UNSIGNED NOT NULL);
CREATE VIEW v1 AS SELECT id, val FROM t1 WHERE val >= 1 AND val <= 5 WITH CHECK OPTION;
INSERT INTO v1 (val) VALUES (2);
INSERT INTO v1 (val) VALUES (4);
INSERT INTO v1 (val) VALUES (6);
ERROR HY000: CHECK OPTION failed 'test.v1'
UPDATE v1 SET val=6 WHERE id=2;
ERROR HY000: CHECK OPTION failed 'test.v1'
DROP VIEW v1;
DROP TABLE t1;
DROP VIEW IF EXISTS v1, v2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT AUTO_INCREMENT PRIMARY KEY, j INT);
CREATE VIEW v1 AS SELECT j FROM t1;
CREATE VIEW v2 AS SELECT * FROM t1;
INSERT INTO t1 (j) VALUES (1);
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
1
INSERT INTO v1 (j) VALUES (2);
# LAST_INSERT_ID() should not change.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
1
INSERT INTO v2 (j) VALUES (3);
# LAST_INSERT_ID() should be updated.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
3
INSERT INTO v1 (j) SELECT j FROM t1;
# LAST_INSERT_ID() should not change.
SELECT LAST_INSERT_ID();
LAST_INSERT_ID()
3
SELECT * FROM t1;
i	j
1	1
2	2
3	3
4	1
5	2
6	3
DROP VIEW v1, v2;
DROP TABLE t1;
CREATE VIEW v AS SELECT !0 * 5 AS x FROM DUAL;
SHOW CREATE VIEW v;
View	Create View	character_set_client	collation_connection
v	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v` AS select ((not(0)) * 5) AS `x`	utf8mb4	utf8mb4_0900_ai_ci
SELECT !0 * 5 AS x FROM DUAL;
x
5
SELECT * FROM v;
x
5
DROP VIEW v;
DROP VIEW IF EXISTS v1;
CREATE VIEW v1 AS SELECT 'The\ZEnd';
SELECT * FROM v1;
TheEnd
TheEnd
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 'The\ZEnd' AS `TheEnd`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE TABLE t1 (mydate DATETIME);
INSERT INTO t1 VALUES
('2007-01-01'), ('2007-01-02'), ('2007-01-30'), ('2007-01-31');
CREATE VIEW v1 AS SELECT mydate from t1;
SELECT * FROM t1 WHERE mydate BETWEEN '2007-01-01' AND '2007-01-31';
mydate
2007-01-01 00:00:00
2007-01-02 00:00:00
2007-01-30 00:00:00
2007-01-31 00:00:00
SELECT * FROM v1 WHERE mydate BETWEEN '2007-01-01' AND '2007-01-31';
mydate
2007-01-01 00:00:00
2007-01-02 00:00:00
2007-01-30 00:00:00
2007-01-31 00:00:00
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (1), (2);
CREATE VIEW v1 AS
SELECT t2.b FROM t1,t2 WHERE t1.a = t2.b WITH CHECK OPTION;
SELECT * FROM v1;
b
1
2
UPDATE v1 SET b=3;
ERROR HY000: CHECK OPTION failed 'test.v1'
SELECT * FROM v1;
b
1
2
SELECT * FROM t1;
a
1
2
SELECT * FROM t2;
b
1
2
DROP VIEW v1;
DROP TABLE t1,t2;
create table t1(f1 int, f2 int);
insert into t1 values(1,2),(1,3),(1,1),(2,3),(2,1),(2,2);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
select * from t1;
f1	f2
1	2
1	3
1	1
2	3
2	1
2	2
create view v1 as select * from t1 order by f2;
select * from v1;
f1	f2
1	1
2	1
1	2
2	2
1	3
2	3
explain select * from v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1` order by `test`.`t1`.`f2`
select * from v1 order by f1;
f1	f2
1	2
1	3
1	1
2	3
2	1
2	2
explain select * from v1 order by f1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`f2` AS `f2` from `test`.`t1` order by `test`.`t1`.`f1`
drop view v1;
drop table t1;
CREATE TABLE t1 (
id int(11) NOT NULL PRIMARY KEY,
country varchar(32),
code int(11) default NULL
);
INSERT INTO t1 VALUES
(1,'ITALY',100),(2,'ITALY',200),(3,'FRANCE',100), (4,'ITALY',100);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT code, COUNT(DISTINCT country) FROM t1 GROUP BY code ORDER BY MAX(id);
code	COUNT(DISTINCT country)
200	1
100	2
SELECT code, COUNT(DISTINCT country) FROM v1 GROUP BY code ORDER BY MAX(id);
code	COUNT(DISTINCT country)
200	1
100	2
DROP VIEW v1;
DROP TABLE t1;
DROP VIEW IF EXISTS v1;
SELECT * FROM (SELECT 1) AS t;
1
1
CREATE VIEW v1 AS SELECT * FROM (SELECT 1) AS t;
DROP VIEW v1;
# Previously the following would fail.
SELECT * FROM (SELECT 1) AS t;
1
1
drop view if exists view_24532_a;
drop view if exists view_24532_b;
drop table if exists table_24532;
create table table_24532 (
a int,
b bigint,
c int(4),
d bigint(48)
);
create view view_24532_a as
select
a IS TRUE,
a IS NOT TRUE,
a IS FALSE,
a IS NOT FALSE,
a IS UNKNOWN,
a IS NOT UNKNOWN,
a is NULL,
a IS NOT NULL,
ISNULL(a),
b IS TRUE,
b IS NOT TRUE,
b IS FALSE,
b IS NOT FALSE,
b IS UNKNOWN,
b IS NOT UNKNOWN,
b is NULL,
b IS NOT NULL,
ISNULL(b),
c IS TRUE,
c IS NOT TRUE,
c IS FALSE,
c IS NOT FALSE,
c IS UNKNOWN,
c IS NOT UNKNOWN,
c is NULL,
c IS NOT NULL,
ISNULL(c),
d IS TRUE,
d IS NOT TRUE,
d IS FALSE,
d IS NOT FALSE,
d IS UNKNOWN,
d IS NOT UNKNOWN,
d is NULL,
d IS NOT NULL,
ISNULL(d)
from table_24532;
describe view_24532_a;
Field	Type	Null	Key	Default	Extra
a IS TRUE	int(1)	NO		0	
a IS NOT TRUE	int(1)	NO		0	
a IS FALSE	int(1)	NO		0	
a IS NOT FALSE	int(1)	NO		0	
a IS UNKNOWN	int(1)	NO		0	
a IS NOT UNKNOWN	int(1)	NO		0	
a is NULL	int(1)	NO		0	
a IS NOT NULL	int(1)	NO		0	
ISNULL(a)	int(1)	NO		0	
b IS TRUE	int(1)	NO		0	
b IS NOT TRUE	int(1)	NO		0	
b IS FALSE	int(1)	NO		0	
b IS NOT FALSE	int(1)	NO		0	
b IS UNKNOWN	int(1)	NO		0	
b IS NOT UNKNOWN	int(1)	NO		0	
b is NULL	int(1)	NO		0	
b IS NOT NULL	int(1)	NO		0	
ISNULL(b)	int(1)	NO		0	
c IS TRUE	int(1)	NO		0	
c IS NOT TRUE	int(1)	NO		0	
c IS FALSE	int(1)	NO		0	
c IS NOT FALSE	int(1)	NO		0	
c IS UNKNOWN	int(1)	NO		0	
c IS NOT UNKNOWN	int(1)	NO		0	
c is NULL	int(1)	NO		0	
c IS NOT NULL	int(1)	NO		0	
ISNULL(c)	int(1)	NO		0	
d IS TRUE	int(1)	NO		0	
d IS NOT TRUE	int(1)	NO		0	
d IS FALSE	int(1)	NO		0	
d IS NOT FALSE	int(1)	NO		0	
d IS UNKNOWN	int(1)	NO		0	
d IS NOT UNKNOWN	int(1)	NO		0	
d is NULL	int(1)	NO		0	
d IS NOT NULL	int(1)	NO		0	
ISNULL(d)	int(1)	NO		0	
create view view_24532_b as
select
a IS TRUE,
if(ifnull(a, 0), 1, 0) as old_istrue,
a IS NOT TRUE,
if(ifnull(a, 0), 0, 1) as old_isnottrue,
a IS FALSE,
if(ifnull(a, 1), 0, 1) as old_isfalse,
a IS NOT FALSE,
if(ifnull(a, 1), 1, 0) as old_isnotfalse
from table_24532;
describe view_24532_b;
Field	Type	Null	Key	Default	Extra
a IS TRUE	int(1)	NO		0	
old_istrue	int(1)	NO		0	
a IS NOT TRUE	int(1)	NO		0	
old_isnottrue	int(1)	NO		0	
a IS FALSE	int(1)	NO		0	
old_isfalse	int(1)	NO		0	
a IS NOT FALSE	int(1)	NO		0	
old_isnotfalse	int(1)	NO		0	
show create view view_24532_b;
View	Create View	character_set_client	collation_connection
view_24532_b	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `view_24532_b` AS select (`table_24532`.`a` is true) AS `a IS TRUE`,if(ifnull(`table_24532`.`a`,0),1,0) AS `old_istrue`,(`table_24532`.`a` is not true) AS `a IS NOT TRUE`,if(ifnull(`table_24532`.`a`,0),0,1) AS `old_isnottrue`,(`table_24532`.`a` is false) AS `a IS FALSE`,if(ifnull(`table_24532`.`a`,1),0,1) AS `old_isfalse`,(`table_24532`.`a` is not false) AS `a IS NOT FALSE`,if(ifnull(`table_24532`.`a`,1),1,0) AS `old_isnotfalse` from `table_24532`	utf8mb4	utf8mb4_0900_ai_ci
insert into table_24532 values (0, 0, 0, 0);
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
0	0	1	1	1	1	0	0
update table_24532 set a=1;
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
1	1	0	0	0	0	1	1
update table_24532 set a=NULL;
select * from view_24532_b;
a IS TRUE	old_istrue	a IS NOT TRUE	old_isnottrue	a IS FALSE	old_isfalse	a IS NOT FALSE	old_isnotfalse
0	0	1	1	0	0	1	1
drop view view_24532_a;
drop view view_24532_b;
drop table table_24532;
CREATE TABLE t1 (
lid int NOT NULL PRIMARY KEY,
name char(10) NOT NULL
);
INSERT INTO t1 (lid, name) VALUES
(1, 'YES'), (2, 'NO');
CREATE TABLE t2 (
id int NOT NULL PRIMARY KEY,
gid int NOT NULL,
lid int NOT NULL,
dt date
);
CREATE TABLE t3 (
id int NOT NULL PRIMARY KEY,
gid int NOT NULL,
lid int NOT NULL,
dt date
);
INSERT INTO t2 (id, gid, lid, dt) VALUES
(1, 1, 1, '2007-01-01'),(2, 1, 2, '2007-01-02'),
(3, 2, 2, '2007-02-01'),(4, 2, 1, '2007-02-02');
INSERT INTO t3 (id, gid, lid, dt) VALUES
(1, 1, 1, '2007-01-01'),(2, 1, 2, '2007-01-02'),
(3, 2, 2, '2007-02-01'),(4, 2, 1, '2007-02-02');
SELECT DISTINCT t2.gid AS lgid,
(SELECT t1.name FROM t1, t3
WHERE t1.lid  = t3.lid AND t3.gid = t2.gid
ORDER BY t3.dt DESC LIMIT 1
) as clid
FROM t2;
lgid	clid
1	NO
2	YES
CREATE VIEW v1 AS
SELECT DISTINCT t2.gid AS lgid,
(SELECT t1.name FROM t1, t3
WHERE t1.lid  = t3.lid AND t3.gid = t2.gid
ORDER BY t3.dt DESC LIMIT 1
) as clid
FROM t2;
SELECT * FROM v1;
lgid	clid
1	NO
2	YES
DROP VIEW v1;
DROP table t1,t2,t3;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT a FROM t1 ORDER BY a;
SELECT * FROM t1 UNION SELECT * FROM v1;
a
1
2
3
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
SELECT * FROM v1 UNION SELECT * FROM t1;
a
1
2
3
EXPLAIN SELECT * FROM v1 UNION SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
SELECT * FROM t1 UNION SELECT * FROM v1 ORDER BY a;
a
1
2
3
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM v1 ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	UNION	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` union /* select#2 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` order by `a`
DROP VIEW v1;
DROP TABLE t1;
CREATE VIEW v1 AS SELECT CAST( 1.23456789 AS DECIMAL( 7,5 ) ) AS col;
SELECT * FROM v1;
col
1.23457
DESCRIBE v1;
Field	Type	Null	Key	Default	Extra
col	decimal(7,5)	NO		0.00000	
DROP VIEW v1;
CREATE VIEW v1 AS SELECT CAST(1.23456789 AS DECIMAL(8,0)) AS col;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select cast(1.23456789 as decimal(8,0)) AS `col`	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1;
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (b INT, c INT DEFAULT 0);
INSERT INTO t1 (a) VALUES (1), (2);
INSERT INTO t2 (b) VALUES (1), (2);
CREATE VIEW v1 AS SELECT t2.b,t2.c FROM t1, t2
WHERE t1.a=t2.b AND t2.b < 3 WITH CHECK OPTION;
SELECT * FROM v1;
b	c
1	0
2	0
UPDATE v1 SET c=1 WHERE b=1;
SELECT * FROM v1;
b	c
1	1
2	0
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (id int);
CREATE TABLE t2 (id int, c int DEFAULT 0);
INSERT INTO t1 (id) VALUES (1);
INSERT INTO t2 (id) VALUES (1);
CREATE VIEW v1 AS
SELECT t2.c FROM t1, t2
WHERE t1.id=t2.id AND 1 IN (SELECT id FROM t1) WITH CHECK OPTION;
UPDATE v1 SET c=1;
DROP VIEW v1;
DROP TABLE t1,t2;
CREATE TABLE t1 (a1 INT, c INT DEFAULT 0);
CREATE TABLE t2 (a2 INT);
CREATE TABLE t3 (a3 INT);
CREATE TABLE t4 (a4 INT);
INSERT INTO t1 (a1) VALUES (1),(2);
INSERT INTO t2 (a2) VALUES (1),(2);
INSERT INTO t3 (a3) VALUES (1),(2);
INSERT INTO t4 (a4) VALUES (1),(2);
CREATE VIEW v1 AS
SELECT t1.a1, t1.c FROM t1 JOIN t2 ON t1.a1=t2.a2 AND t1.c < 3
WITH CHECK OPTION;
SELECT * FROM v1;
a1	c
1	0
2	0
UPDATE v1 SET c=3;
ERROR HY000: CHECK OPTION failed 'test.v1'
PREPARE t FROM 'UPDATE v1 SET c=3';
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v1'
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v1'
INSERT INTO v1(a1, c) VALUES (3, 3);
ERROR HY000: CHECK OPTION failed 'test.v1'
UPDATE v1 SET c=1 WHERE a1=1;
SELECT * FROM v1;
a1	c
1	1
2	0
SELECT * FROM t1;
a1	c
1	1
2	0
CREATE VIEW v2 AS SELECT t1.a1, t1.c
FROM (t1 JOIN t2 ON t1.a1=t2.a2 AND t1.c < 3)
JOIN (t3 JOIN t4 ON t3.a3=t4.a4)
ON t2.a2=t3.a3 WITH CHECK OPTION;
SELECT * FROM v2;
a1	c
1	1
2	0
UPDATE v2 SET c=3;
ERROR HY000: CHECK OPTION failed 'test.v2'
PREPARE t FROM 'UPDATE v2 SET c=3';
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v2'
EXECUTE t;
ERROR HY000: CHECK OPTION failed 'test.v2'
INSERT INTO v2(a1, c) VALUES (3, 3);
ERROR HY000: CHECK OPTION failed 'test.v2'
UPDATE v2 SET c=2 WHERE a1=1;
SELECT * FROM v2;
a1	c
1	2
2	0
SELECT * FROM t1;
a1	c
1	2
2	0
DROP VIEW v1,v2;
DROP TABLE t1,t2,t3,t4;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 VALUES (1,2), (2,2), (1,3), (1,2);
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT a, b+1 as b FROM t1;
SELECT b, SUM(a) FROM v1 WHERE b=3 GROUP BY b;
b	SUM(a)
3	4
EXPLAIN SELECT b, SUM(a) FROM v1 WHERE b=3 GROUP BY b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select (`test`.`t1`.`b` + 1) AS `b`,sum(`test`.`t1`.`a`) AS `SUM(a)` from `test`.`t1` where ((`test`.`t1`.`b` + 1) = 3) group by `b`
SELECT a, SUM(b) FROM v1 WHERE b=3 GROUP BY a;
a	SUM(b)
1	6
2	3
EXPLAIN SELECT a, SUM(b) FROM v1 WHERE b=3 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,sum((`test`.`t1`.`b` + 1)) AS `SUM(b)` from `test`.`t1` where ((`test`.`t1`.`b` + 1) = 3) group by `test`.`t1`.`a`
SELECT a, SUM(b) FROM v1 WHERE a=1 GROUP BY a;
a	SUM(b)
1	10
EXPLAIN SELECT a, SUM(b) FROM v1 WHERE a=1 GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	4	25.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,sum((`test`.`t1`.`b` + 1)) AS `SUM(b)` from `test`.`t1` where (`test`.`t1`.`a` = 1) group by `test`.`t1`.`a`
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (
person_id int NOT NULL PRIMARY KEY,
username varchar(40) default NULL,
status_flg char(1) NOT NULL default 'A'
);
CREATE TABLE t2 (
person_role_id int NOT NULL auto_increment PRIMARY KEY,
role_id int NOT NULL,
person_id int NOT NULL,
INDEX idx_person_id (person_id),
INDEX idx_role_id (role_id)
);
CREATE TABLE t3 (
role_id int NOT NULL auto_increment PRIMARY KEY,
role_name varchar(100) default NULL,
app_name varchar(40) NOT NULL,
INDEX idx_app_name(app_name)
);
CREATE VIEW v1 AS
SELECT profile.person_id AS person_id
FROM t1 profile, t2 userrole, t3 `role`
    WHERE userrole.person_id = profile.person_id AND
role.role_id = userrole.role_id AND
profile.status_flg = 'A'
  ORDER BY profile.person_id,role.app_name,role.role_name;
INSERT INTO  t1 VALUES
(6,'Sw','A'), (-1136332546,'ols','e'), (0,'    *\n','0'),
(-717462680,'ENTS Ta','0'), (-904346964,'ndard SQL\n','0');
INSERT INTO t2 VALUES
(1,3,6),(2,4,7),(3,5,8),(4,6,9),(5,1,6),(6,1,7),(7,1,8),(8,1,9),(9,1,10);
INSERT INTO t3 VALUES
(1,'NUCANS_APP_USER','NUCANSAPP'),(2,'NUCANS_TRGAPP_USER','NUCANSAPP'),
(3,'IA_INTAKE_COORDINATOR','IACANS'),(4,'IA_SCREENER','IACANS'),
(5,'IA_SUPERVISOR','IACANS'),(6,'IA_READONLY','IACANS'),
(7,'SOC_USER','SOCCANS'),(8,'CAYIT_USER','CAYITCANS'),
(9,'RTOS_DCFSPOS_SUPERVISOR','RTOS');
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
EXPLAIN SELECT t.person_id AS a, t.person_id AS b FROM v1 t WHERE t.person_id=6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	profile	NULL	const	PRIMARY	PRIMARY	4	const	#	#	Using temporary; Using filesort
1	SIMPLE	userrole	NULL	ref	idx_person_id,idx_role_id	idx_person_id	4	const	#	#	NULL
1	SIMPLE	role	NULL	eq_ref	PRIMARY	PRIMARY	4	test.userrole.role_id	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select '6' AS `a`,'6' AS `b` from `test`.`t1` `profile` join `test`.`t2` `userrole` join `test`.`t3` `role` where ((`test`.`role`.`role_id` = `test`.`userrole`.`role_id`) and (`test`.`userrole`.`person_id` = 6)) order by '6',`test`.`role`.`app_name`,`test`.`role`.`role_name`
SELECT t.person_id AS a, t.person_id AS b FROM v1 t WHERE t.person_id=6;
a	b
6	6
6	6
DROP VIEW v1;
DROP TABLE t1,t2,t3;
create table t1 (i int);
insert into t1 values (1), (2), (1), (3), (2), (4);
create view v1 as select distinct i from t1;
select * from v1;
i
1
2
3
4
select table_name, is_updatable from information_schema.views
where table_name = 'v1';
TABLE_NAME	IS_UPDATABLE
v1	NO
drop view v1;
drop table t1;
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2);
CREATE VIEW v1 AS SELECT * FROM t1;
SELECT * FROM v1 USE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE KEY(non_existant);
ERROR 42000: Key 'non_existant' doesn't exist in table 'v1'
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a INT NOT NULL AUTO_INCREMENT, b INT NOT NULL DEFAULT 0,
PRIMARY KEY(a), KEY (b));
INSERT INTO t1 VALUES (),(),(),(),(),(),(),(),(),(),(),(),(),(),();
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE VIEW v1 AS SELECT * FROM t1 FORCE KEY (PRIMARY,b) ORDER BY a;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` FORCE INDEX (PRIMARY) FORCE INDEX (`b`) order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` FORCE INDEX (PRIMARY) FORCE INDEX (`b`) order by `test`.`t1`.`a`
CREATE VIEW v2 AS SELECT * FROM t1 USE KEY () ORDER BY a;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` USE INDEX () order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` USE INDEX () order by `test`.`t1`.`a`
CREATE VIEW v3 AS SELECT * FROM t1 IGNORE KEY (b) ORDER BY a;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1` IGNORE INDEX (`b`) order by `t1`.`a`	utf8mb4	utf8mb4_0900_ai_ci
EXPLAIN SELECT * FROM v3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	NULL	PRIMARY	4	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` IGNORE INDEX (`b`) order by `test`.`t1`.`a`
DROP VIEW v1;
DROP VIEW v2;
DROP VIEW v3;
DROP TABLE t1;
#
# Bug#29477 Not all fields of the target table were checked to have
#           a default value when inserting into a view.
#
create table t1(f1 int, f2 int not null);
create view v1 as select f1 from t1;
insert into v1 values(1);
Warnings:
Warning	1423	Field of view 'test.v1' underlying table doesn't have a default value
set @old_mode=@@sql_mode;
set @@sql_mode=traditional;
insert into v1 values(1);
ERROR HY000: Field of view 'test.v1' underlying table doesn't have a default value
set @@sql_mode=@old_mode;
drop view v1;
drop table t1;
create table t1 (a int, key(a));
create table t2 (c int);
create view v1 as select a b from t1;
create view v2 as select 1 a from t2, v1 where c in
(select 1 from t1 where b = a);
insert into t1 values (1), (1);
insert into t2 values (1), (1);
prepare stmt from "select * from v2 where a = 1";
execute stmt;
a
1
1
1
1
drop view v1, v2;
drop table t1, t2;
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT p.a AS a FROM t1 p, t1 q;
INSERT INTO t1 VALUES (1), (1);
SELECT MAX(a), COUNT(DISTINCT a) FROM v1 GROUP BY a;
MAX(a)	COUNT(DISTINCT a)
1	1
DROP VIEW v1;
DROP TABLE t1;
# -----------------------------------------------------------------
# -- Bug#34337 Server crash when Altering a view using a table name.
# -----------------------------------------------------------------

DROP TABLE IF EXISTS t1;

CREATE TABLE t1(c1 INT);

SELECT * FROM t1;
c1
ALTER ALGORITHM=TEMPTABLE SQL SECURITY INVOKER VIEW t1 (c2) AS SELECT (1);
ERROR HY000: 'test.t1' is not VIEW

DROP TABLE t1;

# -- End of test case for Bug#34337.

# -----------------------------------------------------------------
# -- Bug#35193 VIEW query is rewritten without "FROM DUAL",
# --           causing syntax error
# -----------------------------------------------------------------

CREATE VIEW v1 AS SELECT 1 FROM DUAL WHERE 1;

SELECT * FROM v1;
1
1
SHOW CREATE TABLE v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1` from DUAL  where 1	utf8mb4	utf8mb4_0900_ai_ci

DROP VIEW v1;

# -- End of test case for Bug#35193.

CREATE VIEW v1 AS SELECT 1;
DROP VIEW v1;
CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 INT, INDEX (c2));
INSERT INTO t1 VALUES (1,1), (2,2), (3,3);
SELECT * FROM t1 USE INDEX (PRIMARY) WHERE c1=2;
c1	c2
2	2
SELECT * FROM t1 USE INDEX (c2) WHERE c2=2;
c1	c2
2	2
CREATE VIEW v1 AS SELECT c1, c2 FROM t1;
SHOW INDEX FROM v1;
Table	Non_unique	Key_name	Seq_in_index	Column_name	Collation	Cardinality	Sub_part	Packed	Null	Index_type	Comment	Index_comment	Visible	Expression
SELECT * FROM v1 USE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE INDEX (PRIMARY) WHERE c1=2;
ERROR 42000: Key 'PRIMARY' doesn't exist in table 'v1'
SELECT * FROM v1 USE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
SELECT * FROM v1 FORCE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
SELECT * FROM v1 IGNORE INDEX (c2) WHERE c2=2;
ERROR 42000: Key 'c2' doesn't exist in table 'v1'
DROP VIEW v1;
DROP TABLE t1;
# 
# Bug #45806 crash when replacing into a view with a join!
# 
CREATE TABLE t1(a INT UNIQUE);
CREATE VIEW v1 AS SELECT t1.a FROM t1, t1 AS a;
INSERT INTO t1 VALUES (1), (2);
REPLACE INTO v1(a) SELECT 1 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v1'
SELECT * FROM v1;
a
1
2
1
2
REPLACE INTO v1(a) SELECT 3 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v1'
SELECT * FROM v1;
a
1
2
1
2
DELETE FROM t1 WHERE a=3;
INSERT INTO v1(a) SELECT 1 FROM t1,t1 AS c
ON DUPLICATE KEY UPDATE `v1`.`a`= 1;
SELECT * FROM v1;
a
1
2
1
2
CREATE VIEW v2 AS SELECT t1.a FROM t1, v1 AS a;
REPLACE INTO v2(a) SELECT 1 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v2'
SELECT * FROM v2;
a
1
2
1
2
1
2
1
2
REPLACE INTO v2(a) SELECT 3 FROM t1,t1 AS c;
ERROR HY000: Can not delete from join view 'test.v2'
SELECT * FROM v2;
a
1
2
1
2
1
2
1
2
INSERT INTO v2(a) SELECT 1 FROM t1,t1 AS c
ON DUPLICATE KEY UPDATE `v2`.`a`= 1;
SELECT * FROM v2;
a
1
2
1
2
1
2
1
2
DROP VIEW v1;
DROP VIEW v2;
DROP TABLE t1;
# -- End of test case for Bug#45806
# -----------------------------------------------------------------
# -- Bug#40825: Error 1356 while selecting from a view 
# --            with a "HAVING" clause though query works
# -----------------------------------------------------------------

CREATE TABLE t1 (c INT);

CREATE VIEW v1 (view_column) AS SELECT c AS alias FROM t1 HAVING alias;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`view_column`) AS select `t1`.`c` AS `alias` from `t1` having `alias`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM v1;
view_column

DROP VIEW v1;
DROP TABLE t1;

# -- End of test case for Bug#40825

# -----------------------------------------------------------------
# -- End of 5.0 tests.
# -----------------------------------------------------------------
DROP DATABASE IF EXISTS `d-1`;
CREATE DATABASE `d-1`;
USE `d-1`;
CREATE TABLE `t-1` (c1 INT);
CREATE VIEW  `v-1` AS SELECT c1 FROM `t-1`;
SHOW TABLES;
Tables_in_d-1
t-1
v-1
RENAME TABLE `t-1` TO `t-2`;
RENAME TABLE `v-1` TO `v-2`;
SHOW TABLES;
Tables_in_d-1
t-2
v-2
DROP TABLE `t-2`;
DROP VIEW  `v-2`;
DROP DATABASE `d-1`;
USE test;

#
# Bug#26676 VIEW using old table schema in a session.
#

DROP VIEW IF EXISTS v1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(c1 INT, c2 INT);
INSERT INTO t1 VALUES (1, 2), (3, 4);

SELECT * FROM t1;
c1	c2
1	2
3	4

CREATE VIEW v1 AS SELECT * FROM t1;

SELECT * FROM v1;
c1	c2
1	2
3	4

ALTER TABLE t1 ADD COLUMN c3 INT AFTER c2;

SELECT * FROM t1;
c1	c2	c3
1	2	NULL
3	4	NULL

SELECT * FROM v1;
c1	c2
1	2
3	4

SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1`,`t1`.`c2` AS `c2` from `t1`	utf8mb4	utf8mb4_0900_ai_ci

DROP VIEW v1;
DROP TABLE t1;

# End of test case for Bug#26676.

# -----------------------------------------------------------------
# -- Bug#32538 View definition picks up character set, but not collation
# -----------------------------------------------------------------

DROP VIEW IF EXISTS v1;

SET collation_connection = latin1_general_ci;
CREATE VIEW v1 AS SELECT _latin1 'text1' AS c1, 'text2' AS c2;

SELECT COLLATION(c1), COLLATION(c2) FROM v1;
COLLATION(c1)	COLLATION(c2)
latin1_swedish_ci	latin1_general_ci

SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select _latin1'text1' AS `c1`,'text2' AS `c2`	utf8mb4	latin1_general_ci

SELECT * FROM v1 WHERE c1 = 'text1';
ERROR HY000: Illegal mix of collations (latin1_swedish_ci,COERCIBLE) and (latin1_general_ci,COERCIBLE) for operation '='

SELECT * FROM v1 WHERE c2 = 'text2';
c1	c2
text1	text2

use test;
SET names latin1;

SELECT COLLATION(c1), COLLATION(c2) FROM v1;
COLLATION(c1)	COLLATION(c2)
latin1_swedish_ci	latin1_general_ci

SELECT * FROM v1 WHERE c1 = 'text1';
c1	c2
text1	text2

SELECT * FROM v1 WHERE c2 = 'text2';
ERROR HY000: Illegal mix of collations (latin1_general_ci,COERCIBLE) and (latin1_swedish_ci,COERCIBLE) for operation '='

DROP VIEW v1;
SET NAMES DEFAULT;

# -- End of test case for Bug#32538.

drop view if exists a;
drop procedure if exists p;
create procedure p()
begin
declare continue handler for sqlexception begin end;
create view a as select 1;
end|
call p();
call p();
drop view a;
drop procedure p;
#
# Bug #44860: ALTER TABLE on view crashes server
#
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT a FROM t1;
ALTER TABLE v1;
ERROR HY000: 'test.v1' is not BASE TABLE
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1(f1 INT);
INSERT INTO t1 VALUES ();
CREATE VIEW v1 AS SELECT 1 FROM t1 WHERE
ROW(1,1) >= ROW(1, (SELECT 1 FROM t1 WHERE  f1 >= ANY ( SELECT '1' )));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#52120 create view cause Assertion failed: 0, file .\item_subselect.cc, line 817
#
CREATE TABLE t1 (a CHAR(1) CHARSET latin1, b CHAR(1) CHARSET utf8);
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
CREATE VIEW v1 AS SELECT 1 from t1
WHERE t1.b <=> (SELECT a FROM t1 WHERE a < SOME(SELECT '1'));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#57703 create view cause Assertion failed: 0, file .\item_subselect.cc, line 846
#
CREATE TABLE t1(a int);
CREATE VIEW v1 AS SELECT 1 FROM t1 GROUP BY
SUBSTRING(1 FROM (SELECT 3 FROM t1 WHERE a >= ANY(SELECT 1)));
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#57352 valgrind warnings when creating view
#
CREATE VIEW v1 AS SELECT 1 IN (1 LIKE 2,0) AS f;
DROP VIEW v1;
#
# Bug 11829681 - 60295: ERROR 1356 ON VIEW THAT EXECUTES FINE AS A QUERY
#
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT s.* FROM t1 s, t1 b HAVING a;
SELECT * FROM v1;
a
DROP VIEW v1;
DROP TABLE t1;
# -----------------------------------------------------------------
# -- End of 5.1 tests.
# -----------------------------------------------------------------
drop table if exists t_9801;
drop view if exists v_9801;
create table t_9801 (s1 int);
create view v_9801 as
select sum(s1) from t_9801 with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
create view v_9801 as
select sum(s1) from t_9801 group by s1 with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
create view v_9801 as
select sum(s1) from t_9801 group by s1 with rollup with check option;
ERROR HY000: CHECK OPTION on non-updatable view 'test.v_9801'
drop table t_9801;
#
# Bug #47335 assert in get_table_share
#
DROP TABLE IF EXISTS t1;
DROP VIEW IF EXISTS v1;
CREATE TEMPORARY TABLE t1 (id INT);
ALTER VIEW t1 AS SELECT 1 AS f1;
ERROR 42S02: Table 'test.t1' doesn't exist
DROP TABLE t1;
CREATE VIEW v1 AS SELECT 1 AS f1;
CREATE TEMPORARY TABLE v1 (id INT);
ALTER VIEW v1 AS SELECT 2 AS f1;
DROP TABLE v1;
SELECT * FROM v1;
f1
2
DROP VIEW v1;
#
# Bug #47635 assert in start_waiting_global_read_lock 
#            during CREATE VIEW
#
DROP TABLE IF EXISTS t1, t2;
DROP VIEW IF EXISTS t2;
CREATE TABLE t1 (f1 integer);
CREATE TEMPORARY TABLE IF NOT EXISTS t1 (f1 integer);
CREATE TEMPORARY TABLE t2 (f1 integer);
DROP TABLE t1;
FLUSH TABLES WITH READ LOCK;
CREATE VIEW t2 AS SELECT * FROM t1;
ERROR HY000: Can't execute the query because you have a conflicting read lock
UNLOCK TABLES;
DROP TABLE t1, t2;
#
# Bug#48315 Metadata lock is not taken for merged views that
#           use an INFORMATION_SCHEMA table
#
DROP VIEW IF EXISTS v1;
DROP PROCEDURE IF EXISTS p1;
# Connection default
CREATE VIEW v1 AS SELECT schema_name FROM information_schema.schemata;
CREATE PROCEDURE p1() SELECT COUNT(*), GET_LOCK('blocker', 100) FROM v1;
# CALL p1() so the view is merged.
CALL p1();
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection 3
SELECT GET_LOCK('blocker', 100);
GET_LOCK('blocker', 100)
1
# Connection default
# Try to CALL p1() again, this time it should block for t1.
# Sending:
CALL p1();
# Connection 2
# ... then try to drop the view. This should block.
# Sending:
DROP VIEW v1;
# Connection 3
# Now allow CALL p1() to complete
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection default
# Reaping: CALL p1()
SELECT RELEASE_LOCK('blocker');
RELEASE_LOCK('blocker')
1
# Connection 2
# Reaping: DROP VIEW v1
# Connection default
DROP PROCEDURE p1;
#
# Bug#11757397 49437: CANNOT DO SHOW FIELDS FOR BIG VIEW 
#
DROP TABLE IF EXISTS t1, t2, t3, table_broken;
DROP VIEW IF EXISTS view_broken;
CREATE TABLE t1 (a1 int, a2 int, a3 int, a4 int, a5 int, a6 int, a7 int, a8 int, a9 int, a10 int, a11 int, a12 int, a13 int, a14 int, a15 int, a16 int, a17 int, a18 int, a19 int, a20 int, a21 int, a22 int, a23 int, a24 int, a25 int, a26 int, a27 int, a28 int, a29 int, a30 int, a31 int, a32 int, a33 int, a34 int, a35 int, a36 int, a37 int, a38 int, a39 int, a40 int, a41 int, a42 int, a43 int, a44 int, a45 int, a46 int, a47 int, a48 int, a49 int, a50 int, a51 int, a52 int, a53 int, a54 int, a55 int, a56 int, a57 int, a58 int, a59 int, a60 int, a61 int, a62 int, a63 int, a64 int, a65 int, a66 int, a67 int, a68 int, a69 int, a70 int, a71 int, a72 int, a73 int, a74 int, a75 int, a76 int, a77 int, a78 int, a79 int, a80 int, a81 int, a82 int, a83 int, a84 int, a85 int, a86 int, a87 int, a88 int, a89 int, a90 int, a91 int, a92 int, a93 int, a94 int, a95 int, a96 int, a97 int, a98 int, a99 int, a100 int, a101 int, a102 int, a103 int, a104 int, a105 int, a106 int, a107 int, a108 int, a109 int, a110 int, a111 int, a112 int, a113 int, a114 int, a115 int, a116 int, a117 int, a118 int, a119 int, a120 int, a121 int, a122 int, a123 int, a124 int, a125 int, a126 int, a127 int, a128 int, a129 int, a130 int, a131 int, a132 int, a133 int, a134 int, a135 int, a136 int, a137 int, a138 int, a139 int, a140 int, a141 int, a142 int, a143 int, a144 int, a145 int, a146 int, a147 int, a148 int, a149 int, a150 int, a151 int, a152 int, a153 int, a154 int, a155 int, a156 int, a157 int, a158 int, a159 int, a160 int, a161 int, a162 int, a163 int, a164 int, a165 int, a166 int, a167 int, a168 int, a169 int, a170 int, a171 int, a172 int, a173 int, a174 int, a175 int, a176 int, a177 int, a178 int, a179 int, a180 int, a181 int, a182 int, a183 int, a184 int, a185 int, a186 int, a187 int, a188 int, a189 int, a190 int, a191 int, a192 int, a193 int, a194 int, a195 int, a196 int, a197 int, a198 int, a199 int, a200 int, a201 int, a202 int, a203 int, a204 int, a205 int, a206 int, a207 int, a208 int, a209 int, a210 int, a211 int, a212 int, a213 int, a214 int, a215 int, a216 int, a217 int, a218 int, a219 int, a220 int, a221 int, a222 int, a223 int, a224 int, a225 int, a226 int, a227 int, a228 int, a229 int, a230 int, a231 int, a232 int, a233 int, a234 int, a235 int, a236 int, a237 int, a238 int, a239 int, a240 int, a241 int, a242 int, a243 int, a244 int, a245 int, a246 int, a247 int, a248 int, a249 int, a250 int, a251 int, a252 int, a253 int, a254 int, a255 int, a256 int, a257 int, a258 int, a259 int, a260 int, a261 int, a262 int, a263 int, a264 int, a265 int, a266 int, a267 int, a268 int, a269 int, a270 int, a271 int, a272 int, a273 int, a274 int, a275 int, a276 int, a277 int, a278 int, a279 int, a280 int, a281 int, a282 int, a283 int, a284 int, a285 int, a286 int, a287 int, a288 int, a289 int, a290 int, a291 int, a292 int, a293 int, a294 int, a295 int, a296 int, a297 int, a298 int, a299 int, a300 int, a301 int, a302 int, a303 int, a304 int, a305 int, a306 int, a307 int, a308 int, a309 int, a310 int, a311 int, a312 int, a313 int, a314 int, a315 int, a316 int, a317 int, a318 int, a319 int, a320 int, a321 int, a322 int, a323 int, a324 int, a325 int, a326 int, a327 int, a328 int, a329 int, a330 int, a331 int, a332 int, a333 int, a334 int, a335 int, a336 int, a337 int, a338 int, a339 int, a340 int, a341 int, a342 int, a343 int, a344 int, a345 int, a346 int, a347 int, a348 int, a349 int, a350 int, a351 int, a352 int, a353 int, a354 int, a355 int, a356 int, a357 int, a358 int, a359 int, a360 int, a361 int, a362 int, a363 int, a364 int, a365 int, a366 int, a367 int, a368 int, a369 int, a370 int, a371 int, a372 int, a373 int, a374 int, a375 int, a376 int, a377 int, a378 int, a379 int, a380 int, a381 int, a382 int, a383 int, a384 int, a385 int, a386 int, a387 int, a388 int, a389 int, a390 int, a391 int, a392 int, a393 int, a394 int, a395 int, a396 int, a397 int, a398 int, a399 int, a400 int, a401 int, a402 int, a403 int, a404 int, a405 int, a406 int, a407 int, a408 int, a409 int, a410 int, a411 int, a412 int, a413 int, a414 int, a415 int, a416 int, a417 int, a418 int, a419 int, a420 int, a421 int, a422 int, a423 int, a424 int, a425 int, a426 int, a427 int, a428 int, a429 int, a430 int, a431 int, a432 int, a433 int, a434 int, a435 int, a436 int, a437 int, a438 int, a439 int, a440 int, a441 int, a442 int, a443 int, a444 int, a445 int, a446 int, a447 int, a448 int, a449 int, a450 int, a451 int, a452 int, a453 int, a454 int, a455 int, a456 int, a457 int, a458 int, a459 int, a460 int, a461 int, a462 int, a463 int, a464 int, a465 int, a466 int, a467 int, a468 int, a469 int, a470 int, a471 int, a472 int, a473 int, a474 int, a475 int, a476 int, a477 int, a478 int, a479 int, a480 int, a481 int, a482 int, a483 int, a484 int, a485 int, a486 int, a487 int, a488 int, a489 int, a490 int, a491 int, a492 int, a493 int, a494 int, a495 int, a496 int, a497 int, a498 int, a499 int, a500 int, a501 int, a502 int, a503 int, a504 int, a505 int, a506 int, a507 int, a508 int, a509 int, a510 int, a511 int, a512 int, a513 int, a514 int, a515 int, a516 int, a517 int, a518 int, a519 int, a520 int, a521 int, a522 int, a523 int, a524 int, a525 int, a526 int, a527 int, a528 int, a529 int, a530 int, a531 int, a532 int, a533 int, a534 int, a535 int, a536 int, a537 int, a538 int, a539 int, a540 int, a541 int, a542 int, a543 int, a544 int, a545 int, a546 int, a547 int, a548 int, a549 int, a550 int, a551 int, a552 int, a553 int, a554 int, a555 int, a556 int, a557 int, a558 int, a559 int, a560 int, a561 int, a562 int, a563 int, a564 int, a565 int, a566 int, a567 int, a568 int, a569 int, a570 int, a571 int, a572 int, a573 int, a574 int, a575 int, a576 int, a577 int, a578 int, a579 int, a580 int, a581 int, a582 int, a583 int, a584 int, a585 int, a586 int, a587 int, a588 int, a589 int, a590 int, a591 int, a592 int, a593 int, a594 int, a595 int, a596 int, a597 int, a598 int, a599 int, a600 int, a601 int, a602 int, a603 int, a604 int, a605 int, a606 int, a607 int, a608 int, a609 int, a610 int, a611 int, a612 int, a613 int, a614 int, a615 int, a616 int, a617 int, a618 int, a619 int, a620 int, a621 int, a622 int, a623 int, a624 int, a625 int, a626 int, a627 int, a628 int, a629 int, a630 int, a631 int, a632 int, a633 int, a634 int, a635 int, a636 int, a637 int, a638 int, a639 int, a640 int, a641 int, a642 int, a643 int, a644 int, a645 int, a646 int, a647 int, a648 int, a649 int, a650 int, a651 int, a652 int, a653 int, a654 int, a655 int, a656 int, a657 int, a658 int, a659 int, a660 int, a661 int, a662 int, a663 int, a664 int, a665 int, a666 int, a667 int, a668 int, a669 int, a670 int, a671 int, a672 int, a673 int, a674 int, a675 int, a676 int, a677 int, a678 int, a679 int, a680 int, a681 int, a682 int, a683 int, a684 int, a685 int, a686 int, a687 int, a688 int, a689 int, a690 int, a691 int, a692 int, a693 int, a694 int, a695 int, a696 int, a697 int, a698 int, a699 int, a700 int, a701 int, a702 int, a703 int, a704 int, a705 int, a706 int, a707 int, a708 int, a709 int, a710 int, a711 int, a712 int, a713 int, a714 int, a715 int, a716 int, a717 int, a718 int, a719 int, a720 int, a721 int, a722 int, a723 int, a724 int, a725 int, a726 int, a727 int, a728 int, a729 int, a730 int, a731 int, a732 int, a733 int, a734 int, a735 int, a736 int, a737 int, a738 int, a739 int, a740 int, a741 int, a742 int, a743 int, a744 int, a745 int, a746 int, a747 int, a748 int, a749 int, a750 int, a751 int, a752 int, a753 int, a754 int, a755 int, a756 int, a757 int, a758 int, a759 int, a760 int, a761 int, a762 int, a763 int, a764 int, a765 int, a766 int, a767 int, a768 int, a769 int, a770 int, a771 int, a772 int, a773 int, a774 int, a775 int, a776 int, a777 int, a778 int, a779 int, a780 int, a781 int, a782 int, a783 int, a784 int, a785 int, a786 int, a787 int, a788 int, a789 int, a790 int, a791 int, a792 int, a793 int, a794 int, a795 int, a796 int, a797 int, a798 int, a799 int, a800 int, a801 int, a802 int, a803 int, a804 int, a805 int, a806 int, a807 int, a808 int, a809 int, a810 int, a811 int, a812 int, a813 int, a814 int, a815 int, a816 int, a817 int, a818 int, a819 int, a820 int, a821 int, a822 int, a823 int, a824 int, a825 int, a826 int, a827 int, a828 int, a829 int, a830 int, a831 int, a832 int, a833 int, a834 int, a835 int, a836 int, a837 int, a838 int, a839 int, a840 int, a841 int, a842 int, a843 int, a844 int, a845 int, a846 int, a847 int, a848 int, a849 int, a850 int, a851 int, a852 int, a853 int, a854 int, a855 int, a856 int, a857 int, a858 int, a859 int, a860 int, a861 int, a862 int, a863 int, a864 int, a865 int, a866 int, a867 int, a868 int, a869 int, a870 int, a871 int, a872 int, a873 int, a874 int, a875 int, a876 int, a877 int, a878 int, a879 int, a880 int, a881 int, a882 int, a883 int, a884 int, a885 int, a886 int, a887 int, a888 int, a889 int, a890 int, a891 int, a892 int, a893 int, a894 int, a895 int, a896 int, a897 int, a898 int, a899 int, a900 int, a901 int, a902 int, a903 int, a904 int, a905 int, a906 int, a907 int, a908 int, a909 int, a910 int, a911 int, a912 int, a913 int, a914 int, a915 int, a916 int, a917 int, a918 int, a919 int, a920 int, a921 int, a922 int, a923 int, a924 int, a925 int, a926 int, a927 int, a928 int, a929 int, a930 int, a931 int, a932 int, a933 int, a934 int, a935 int, a936 int, a937 int, a938 int, a939 int, a940 int, a941 int, a942 int, a943 int, a944 int, a945 int, a946 int, a947 int, a948 int, a949 int, a950 int, a951 int, a952 int, a953 int, a954 int, a955 int, a956 int, a957 int, a958 int, a959 int, a960 int, a961 int, a962 int, a963 int, a964 int, a965 int, a966 int, a967 int, a968 int, a969 int, a970 int, a971 int, a972 int, a973 int, a974 int, a975 int, a976 int, a977 int, a978 int, a979 int, a980 int, a981 int, a982 int, a983 int, a984 int, a985 int, a986 int, a987 int, a988 int, a989 int, a990 int, a991 int, a992 int, a993 int, a994 int, a995 int, a996 int, a997 int, a998 int, a999 int, a1000 int, a1001 int, a1002 int, a1003 int, a1004 int, a1005 int, a1006 int, a1007 int, a1008 int, a1009 int, a1010 int, a1011 int, a1012 int, a1013 int, a1014 int, a1015 int, a1016 int, a1017 int, a1018 int, a1019 int, a1020 int, a1021 int, a1022 int, a1023 int, a1024 int, a1025 int, a1026 int, a1027 int, a1028 int, a1029 int, a1030 int, a1031 int, a1032 int, a1033 int, a1034 int, a1035 int, a1036 int, a1037 int, a1038 int, a1039 int, a1040 int, a1041 int, a1042 int, a1043 int, a1044 int, a1045 int, a1046 int, a1047 int, a1048 int, a1049 int, a1050 int, a1051 int, a1052 int, a1053 int, a1054 int, a1055 int, a1056 int, a1057 int, a1058 int, a1059 int, a1060 int, a1061 int, a1062 int, a1063 int, a1064 int, a1065 int, a1066 int, a1067 int, a1068 int, a1069 int, a1070 int, a1071 int, a1072 int, a1073 int, a1074 int, a1075 int, a1076 int, a1077 int, a1078 int, a1079 int, a1080 int, a1081 int, a1082 int, a1083 int, a1084 int, a1085 int, a1086 int, a1087 int, a1088 int, a1089 int, a1090 int, a1091 int, a1092 int, a1093 int, a1094 int, a1095 int, a1096 int, a1097 int, a1098 int, a1099 int, a1100 int, a1101 int, a1102 int, a1103 int, a1104 int, a1105 int, a1106 int, a1107 int, a1108 int, a1109 int, a1110 int, a1111 int, a1112 int, a1113 int, a1114 int, a1115 int, a1116 int, a1117 int, a1118 int, a1119 int, a1120 int, a1121 int, a1122 int, a1123 int, a1124 int, a1125 int, a1126 int, a1127 int, a1128 int, a1129 int, a1130 int, a1131 int, a1132 int, a1133 int, a1134 int, a1135 int, a1136 int, a1137 int, a1138 int, a1139 int, a1140 int, a1141 int, a1142 int, a1143 int, a1144 int, a1145 int, a1146 int, a1147 int, a1148 int, a1149 int, a1150 int, a1151 int, a1152 int, a1153 int, a1154 int, a1155 int, a1156 int, a1157 int, a1158 int, a1159 int, a1160 int, a1161 int, a1162 int, a1163 int, a1164 int, a1165 int, a1166 int, a1167 int, a1168 int, a1169 int, a1170 int, a1171 int, a1172 int, a1173 int, a1174 int, a1175 int, a1176 int, a1177 int, a1178 int, a1179 int, a1180 int, a1181 int, a1182 int, a1183 int, a1184 int, a1185 int, a1186 int, a1187 int, a1188 int, a1189 int, a1190 int, a1191 int, a1192 int, a1193 int, a1194 int, a1195 int, a1196 int, a1197 int, a1198 int, a1199 int, a1200 int, a1201 int, a1202 int, a1203 int, a1204 int, a1205 int, a1206 int, a1207 int, a1208 int, a1209 int, a1210 int, a1211 int, a1212 int, a1213 int, a1214 int, a1215 int, a1216 int, a1217 int, a1218 int, a1219 int, a1220 int, a1221 int, a1222 int, a1223 int, a1224 int, a1225 int, a1226 int, a1227 int, a1228 int, a1229 int, a1230 int, a1231 int, a1232 int, a1233 int, a1234 int, a1235 int, a1236 int, a1237 int, a1238 int, a1239 int, a1240 int, a1241 int, a1242 int, a1243 int, a1244 int, a1245 int, a1246 int, a1247 int, a1248 int, a1249 int, a1250 int, a1251 int, a1252 int, a1253 int, a1254 int, a1255 int, a1256 int, a1257 int, a1258 int, a1259 int, a1260 int, a1261 int, a1262 int, a1263 int, a1264 int, a1265 int, a1266 int, a1267 int, a1268 int, a1269 int, a1270 int, a1271 int, a1272 int, a1273 int, a1274 int, a1275 int, a1276 int, a1277 int, a1278 int, a1279 int, a1280 int, a1281 int, a1282 int, a1283 int, a1284 int, a1285 int, a1286 int, a1287 int, a1288 int, a1289 int, a1290 int, a1291 int, a1292 int, a1293 int, a1294 int, a1295 int, a1296 int, a1297 int, a1298 int, a1299 int, a1300 int, a1301 int, a1302 int, a1303 int, a1304 int, a1305 int, a1306 int, a1307 int, a1308 int, a1309 int, a1310 int, a1311 int, a1312 int, a1313 int, a1314 int, a1315 int, a1316 int, a1317 int, a1318 int, a1319 int, a1320 int, a1321 int, a1322 int, a1323 int, a1324 int, a1325 int, a1326 int, a1327 int, a1328 int, a1329 int, a1330 int, a1331 int, a1332 int, a1333 int, a1334 int, a1335 int, a1336 int, a1337 int, a1338 int, a1339 int, a1340 int, a1341 int, a1342 int, a1343 int, a1344 int, a1345 int, a1346 int, a1347 int, a1348 int, a1349 int, a1350 int, a1351 int, a1352 int, a1353 int, a1354 int, a1355 int, a1356 int, a1357 int, a1358 int, a1359 int, a1360 int, a1361 int, a1362 int, a1363 int, a1364 int, a1365 int, a1366 int, a1367 int, a1368 int, a1369 int, a1370 int, a1371 int, a1372 int, a1373 int, a1374 int, a1375 int, a1376 int, a1377 int, a1378 int, a1379 int, a1380 int, a1381 int, a1382 int, a1383 int, a1384 int, a1385 int, a1386 int, a1387 int, a1388 int, a1389 int, a1390 int, a1391 int, a1392 int, a1393 int, a1394 int, a1395 int, a1396 int, a1397 int, a1398 int, a1399 int, a1400 int, a1401 int, a1402 int, a1403 int, a1404 int, a1405 int, a1406 int, a1407 int, a1408 int, a1409 int, a1410 int, a1411 int, a1412 int, a1413 int, a1414 int, a1415 int, a1416 int, a1417 int, a1418 int, a1419 int, a1420 int, a1421 int, a1422 int, a1423 int, a1424 int, a1425 int, a1426 int, a1427 int, a1428 int, a1429 int, a1430 int, a1431 int, a1432 int, a1433 int, a1434 int, a1435 int, a1436 int, a1437 int, a1438 int, a1439 int, a1440 int, a1441 int, a1442 int, a1443 int, a1444 int, a1445 int, a1446 int, a1447 int, a1448 int, a1449 int, a1450 int, a1451 int, a1452 int, a1453 int, a1454 int, a1455 int, a1456 int, a1457 int, a1458 int, a1459 int, a1460 int, a1461 int, a1462 int, a1463 int, a1464 int, a1465 int, a1466 int, a1467 int, a1468 int, a1469 int, a1470 int, a1471 int, a1472 int, a1473 int, a1474 int, a1475 int, a1476 int, a1477 int, a1478 int, a1479 int, a1480 int, a1481 int, a1482 int, a1483 int, a1484 int, a1485 int, a1486 int, a1487 int, a1488 int, a1489 int, a1490 int, a1491 int, a1492 int, a1493 int, a1494 int, a1495 int, a1496 int, a1497 int, a1498 int, a1499 int, a1500 int, a text) ENGINE=MyiSAM;
CREATE TABLE t2 (b1 int, b2 int, b3 int, b4 int, b5 int, b6 int, b7 int, b8 int, b9 int, b10 int, b11 int, b12 int, b13 int, b14 int, b15 int, b16 int, b17 int, b18 int, b19 int, b20 int, b21 int, b22 int, b23 int, b24 int, b25 int, b26 int, b27 int, b28 int, b29 int, b30 int, b31 int, b32 int, b33 int, b34 int, b35 int, b36 int, b37 int, b38 int, b39 int, b40 int, b41 int, b42 int, b43 int, b44 int, b45 int, b46 int, b47 int, b48 int, b49 int, b50 int, b51 int, b52 int, b53 int, b54 int, b55 int, b56 int, b57 int, b58 int, b59 int, b60 int, b61 int, b62 int, b63 int, b64 int, b65 int, b66 int, b67 int, b68 int, b69 int, b70 int, b71 int, b72 int, b73 int, b74 int, b75 int, b76 int, b77 int, b78 int, b79 int, b80 int, b81 int, b82 int, b83 int, b84 int, b85 int, b86 int, b87 int, b88 int, b89 int, b90 int, b91 int, b92 int, b93 int, b94 int, b95 int, b96 int, b97 int, b98 int, b99 int, b100 int, b101 int, b102 int, b103 int, b104 int, b105 int, b106 int, b107 int, b108 int, b109 int, b110 int, b111 int, b112 int, b113 int, b114 int, b115 int, b116 int, b117 int, b118 int, b119 int, b120 int, b121 int, b122 int, b123 int, b124 int, b125 int, b126 int, b127 int, b128 int, b129 int, b130 int, b131 int, b132 int, b133 int, b134 int, b135 int, b136 int, b137 int, b138 int, b139 int, b140 int, b141 int, b142 int, b143 int, b144 int, b145 int, b146 int, b147 int, b148 int, b149 int, b150 int, b151 int, b152 int, b153 int, b154 int, b155 int, b156 int, b157 int, b158 int, b159 int, b160 int, b161 int, b162 int, b163 int, b164 int, b165 int, b166 int, b167 int, b168 int, b169 int, b170 int, b171 int, b172 int, b173 int, b174 int, b175 int, b176 int, b177 int, b178 int, b179 int, b180 int, b181 int, b182 int, b183 int, b184 int, b185 int, b186 int, b187 int, b188 int, b189 int, b190 int, b191 int, b192 int, b193 int, b194 int, b195 int, b196 int, b197 int, b198 int, b199 int, b200 int, b201 int, b202 int, b203 int, b204 int, b205 int, b206 int, b207 int, b208 int, b209 int, b210 int, b211 int, b212 int, b213 int, b214 int, b215 int, b216 int, b217 int, b218 int, b219 int, b220 int, b221 int, b222 int, b223 int, b224 int, b225 int, b226 int, b227 int, b228 int, b229 int, b230 int, b231 int, b232 int, b233 int, b234 int, b235 int, b236 int, b237 int, b238 int, b239 int, b240 int, b241 int, b242 int, b243 int, b244 int, b245 int, b246 int, b247 int, b248 int, b249 int, b250 int, b251 int, b252 int, b253 int, b254 int, b255 int, b256 int, b257 int, b258 int, b259 int, b260 int, b261 int, b262 int, b263 int, b264 int, b265 int, b266 int, b267 int, b268 int, b269 int, b270 int, b271 int, b272 int, b273 int, b274 int, b275 int, b276 int, b277 int, b278 int, b279 int, b280 int, b281 int, b282 int, b283 int, b284 int, b285 int, b286 int, b287 int, b288 int, b289 int, b290 int, b291 int, b292 int, b293 int, b294 int, b295 int, b296 int, b297 int, b298 int, b299 int, b300 int, b301 int, b302 int, b303 int, b304 int, b305 int, b306 int, b307 int, b308 int, b309 int, b310 int, b311 int, b312 int, b313 int, b314 int, b315 int, b316 int, b317 int, b318 int, b319 int, b320 int, b321 int, b322 int, b323 int, b324 int, b325 int, b326 int, b327 int, b328 int, b329 int, b330 int, b331 int, b332 int, b333 int, b334 int, b335 int, b336 int, b337 int, b338 int, b339 int, b340 int, b341 int, b342 int, b343 int, b344 int, b345 int, b346 int, b347 int, b348 int, b349 int, b350 int, b351 int, b352 int, b353 int, b354 int, b355 int, b356 int, b357 int, b358 int, b359 int, b360 int, b361 int, b362 int, b363 int, b364 int, b365 int, b366 int, b367 int, b368 int, b369 int, b370 int, b371 int, b372 int, b373 int, b374 int, b375 int, b376 int, b377 int, b378 int, b379 int, b380 int, b381 int, b382 int, b383 int, b384 int, b385 int, b386 int, b387 int, b388 int, b389 int, b390 int, b391 int, b392 int, b393 int, b394 int, b395 int, b396 int, b397 int, b398 int, b399 int, b400 int, b401 int, b402 int, b403 int, b404 int, b405 int, b406 int, b407 int, b408 int, b409 int, b410 int, b411 int, b412 int, b413 int, b414 int, b415 int, b416 int, b417 int, b418 int, b419 int, b420 int, b421 int, b422 int, b423 int, b424 int, b425 int, b426 int, b427 int, b428 int, b429 int, b430 int, b431 int, b432 int, b433 int, b434 int, b435 int, b436 int, b437 int, b438 int, b439 int, b440 int, b441 int, b442 int, b443 int, b444 int, b445 int, b446 int, b447 int, b448 int, b449 int, b450 int, b451 int, b452 int, b453 int, b454 int, b455 int, b456 int, b457 int, b458 int, b459 int, b460 int, b461 int, b462 int, b463 int, b464 int, b465 int, b466 int, b467 int, b468 int, b469 int, b470 int, b471 int, b472 int, b473 int, b474 int, b475 int, b476 int, b477 int, b478 int, b479 int, b480 int, b481 int, b482 int, b483 int, b484 int, b485 int, b486 int, b487 int, b488 int, b489 int, b490 int, b491 int, b492 int, b493 int, b494 int, b495 int, b496 int, b497 int, b498 int, b499 int, b500 int, b501 int, b502 int, b503 int, b504 int, b505 int, b506 int, b507 int, b508 int, b509 int, b510 int, b511 int, b512 int, b513 int, b514 int, b515 int, b516 int, b517 int, b518 int, b519 int, b520 int, b521 int, b522 int, b523 int, b524 int, b525 int, b526 int, b527 int, b528 int, b529 int, b530 int, b531 int, b532 int, b533 int, b534 int, b535 int, b536 int, b537 int, b538 int, b539 int, b540 int, b541 int, b542 int, b543 int, b544 int, b545 int, b546 int, b547 int, b548 int, b549 int, b550 int, b551 int, b552 int, b553 int, b554 int, b555 int, b556 int, b557 int, b558 int, b559 int, b560 int, b561 int, b562 int, b563 int, b564 int, b565 int, b566 int, b567 int, b568 int, b569 int, b570 int, b571 int, b572 int, b573 int, b574 int, b575 int, b576 int, b577 int, b578 int, b579 int, b580 int, b581 int, b582 int, b583 int, b584 int, b585 int, b586 int, b587 int, b588 int, b589 int, b590 int, b591 int, b592 int, b593 int, b594 int, b595 int, b596 int, b597 int, b598 int, b599 int, b600 int, b601 int, b602 int, b603 int, b604 int, b605 int, b606 int, b607 int, b608 int, b609 int, b610 int, b611 int, b612 int, b613 int, b614 int, b615 int, b616 int, b617 int, b618 int, b619 int, b620 int, b621 int, b622 int, b623 int, b624 int, b625 int, b626 int, b627 int, b628 int, b629 int, b630 int, b631 int, b632 int, b633 int, b634 int, b635 int, b636 int, b637 int, b638 int, b639 int, b640 int, b641 int, b642 int, b643 int, b644 int, b645 int, b646 int, b647 int, b648 int, b649 int, b650 int, b651 int, b652 int, b653 int, b654 int, b655 int, b656 int, b657 int, b658 int, b659 int, b660 int, b661 int, b662 int, b663 int, b664 int, b665 int, b666 int, b667 int, b668 int, b669 int, b670 int, b671 int, b672 int, b673 int, b674 int, b675 int, b676 int, b677 int, b678 int, b679 int, b680 int, b681 int, b682 int, b683 int, b684 int, b685 int, b686 int, b687 int, b688 int, b689 int, b690 int, b691 int, b692 int, b693 int, b694 int, b695 int, b696 int, b697 int, b698 int, b699 int, b700 int, b701 int, b702 int, b703 int, b704 int, b705 int, b706 int, b707 int, b708 int, b709 int, b710 int, b711 int, b712 int, b713 int, b714 int, b715 int, b716 int, b717 int, b718 int, b719 int, b720 int, b721 int, b722 int, b723 int, b724 int, b725 int, b726 int, b727 int, b728 int, b729 int, b730 int, b731 int, b732 int, b733 int, b734 int, b735 int, b736 int, b737 int, b738 int, b739 int, b740 int, b741 int, b742 int, b743 int, b744 int, b745 int, b746 int, b747 int, b748 int, b749 int, b750 int, b751 int, b752 int, b753 int, b754 int, b755 int, b756 int, b757 int, b758 int, b759 int, b760 int, b761 int, b762 int, b763 int, b764 int, b765 int, b766 int, b767 int, b768 int, b769 int, b770 int, b771 int, b772 int, b773 int, b774 int, b775 int, b776 int, b777 int, b778 int, b779 int, b780 int, b781 int, b782 int, b783 int, b784 int, b785 int, b786 int, b787 int, b788 int, b789 int, b790 int, b791 int, b792 int, b793 int, b794 int, b795 int, b796 int, b797 int, b798 int, b799 int, b800 int, b801 int, b802 int, b803 int, b804 int, b805 int, b806 int, b807 int, b808 int, b809 int, b810 int, b811 int, b812 int, b813 int, b814 int, b815 int, b816 int, b817 int, b818 int, b819 int, b820 int, b821 int, b822 int, b823 int, b824 int, b825 int, b826 int, b827 int, b828 int, b829 int, b830 int, b831 int, b832 int, b833 int, b834 int, b835 int, b836 int, b837 int, b838 int, b839 int, b840 int, b841 int, b842 int, b843 int, b844 int, b845 int, b846 int, b847 int, b848 int, b849 int, b850 int, b851 int, b852 int, b853 int, b854 int, b855 int, b856 int, b857 int, b858 int, b859 int, b860 int, b861 int, b862 int, b863 int, b864 int, b865 int, b866 int, b867 int, b868 int, b869 int, b870 int, b871 int, b872 int, b873 int, b874 int, b875 int, b876 int, b877 int, b878 int, b879 int, b880 int, b881 int, b882 int, b883 int, b884 int, b885 int, b886 int, b887 int, b888 int, b889 int, b890 int, b891 int, b892 int, b893 int, b894 int, b895 int, b896 int, b897 int, b898 int, b899 int, b900 int, b901 int, b902 int, b903 int, b904 int, b905 int, b906 int, b907 int, b908 int, b909 int, b910 int, b911 int, b912 int, b913 int, b914 int, b915 int, b916 int, b917 int, b918 int, b919 int, b920 int, b921 int, b922 int, b923 int, b924 int, b925 int, b926 int, b927 int, b928 int, b929 int, b930 int, b931 int, b932 int, b933 int, b934 int, b935 int, b936 int, b937 int, b938 int, b939 int, b940 int, b941 int, b942 int, b943 int, b944 int, b945 int, b946 int, b947 int, b948 int, b949 int, b950 int, b951 int, b952 int, b953 int, b954 int, b955 int, b956 int, b957 int, b958 int, b959 int, b960 int, b961 int, b962 int, b963 int, b964 int, b965 int, b966 int, b967 int, b968 int, b969 int, b970 int, b971 int, b972 int, b973 int, b974 int, b975 int, b976 int, b977 int, b978 int, b979 int, b980 int, b981 int, b982 int, b983 int, b984 int, b985 int, b986 int, b987 int, b988 int, b989 int, b990 int, b991 int, b992 int, b993 int, b994 int, b995 int, b996 int, b997 int, b998 int, b999 int, b1000 int, b1001 int, b1002 int, b1003 int, b1004 int, b1005 int, b1006 int, b1007 int, b1008 int, b1009 int, b1010 int, b1011 int, b1012 int, b1013 int, b1014 int, b1015 int, b1016 int, b1017 int, b1018 int, b1019 int, b1020 int, b1021 int, b1022 int, b1023 int, b1024 int, b1025 int, b1026 int, b1027 int, b1028 int, b1029 int, b1030 int, b1031 int, b1032 int, b1033 int, b1034 int, b1035 int, b1036 int, b1037 int, b1038 int, b1039 int, b1040 int, b1041 int, b1042 int, b1043 int, b1044 int, b1045 int, b1046 int, b1047 int, b1048 int, b1049 int, b1050 int, b1051 int, b1052 int, b1053 int, b1054 int, b1055 int, b1056 int, b1057 int, b1058 int, b1059 int, b1060 int, b1061 int, b1062 int, b1063 int, b1064 int, b1065 int, b1066 int, b1067 int, b1068 int, b1069 int, b1070 int, b1071 int, b1072 int, b1073 int, b1074 int, b1075 int, b1076 int, b1077 int, b1078 int, b1079 int, b1080 int, b1081 int, b1082 int, b1083 int, b1084 int, b1085 int, b1086 int, b1087 int, b1088 int, b1089 int, b1090 int, b1091 int, b1092 int, b1093 int, b1094 int, b1095 int, b1096 int, b1097 int, b1098 int, b1099 int, b1100 int, b1101 int, b1102 int, b1103 int, b1104 int, b1105 int, b1106 int, b1107 int, b1108 int, b1109 int, b1110 int, b1111 int, b1112 int, b1113 int, b1114 int, b1115 int, b1116 int, b1117 int, b1118 int, b1119 int, b1120 int, b1121 int, b1122 int, b1123 int, b1124 int, b1125 int, b1126 int, b1127 int, b1128 int, b1129 int, b1130 int, b1131 int, b1132 int, b1133 int, b1134 int, b1135 int, b1136 int, b1137 int, b1138 int, b1139 int, b1140 int, b1141 int, b1142 int, b1143 int, b1144 int, b1145 int, b1146 int, b1147 int, b1148 int, b1149 int, b1150 int, b1151 int, b1152 int, b1153 int, b1154 int, b1155 int, b1156 int, b1157 int, b1158 int, b1159 int, b1160 int, b1161 int, b1162 int, b1163 int, b1164 int, b1165 int, b1166 int, b1167 int, b1168 int, b1169 int, b1170 int, b1171 int, b1172 int, b1173 int, b1174 int, b1175 int, b1176 int, b1177 int, b1178 int, b1179 int, b1180 int, b1181 int, b1182 int, b1183 int, b1184 int, b1185 int, b1186 int, b1187 int, b1188 int, b1189 int, b1190 int, b1191 int, b1192 int, b1193 int, b1194 int, b1195 int, b1196 int, b1197 int, b1198 int, b1199 int, b1200 int, b1201 int, b1202 int, b1203 int, b1204 int, b1205 int, b1206 int, b1207 int, b1208 int, b1209 int, b1210 int, b1211 int, b1212 int, b1213 int, b1214 int, b1215 int, b1216 int, b1217 int, b1218 int, b1219 int, b1220 int, b1221 int, b1222 int, b1223 int, b1224 int, b1225 int, b1226 int, b1227 int, b1228 int, b1229 int, b1230 int, b1231 int, b1232 int, b1233 int, b1234 int, b1235 int, b1236 int, b1237 int, b1238 int, b1239 int, b1240 int, b1241 int, b1242 int, b1243 int, b1244 int, b1245 int, b1246 int, b1247 int, b1248 int, b1249 int, b1250 int, b1251 int, b1252 int, b1253 int, b1254 int, b1255 int, b1256 int, b1257 int, b1258 int, b1259 int, b1260 int, b1261 int, b1262 int, b1263 int, b1264 int, b1265 int, b1266 int, b1267 int, b1268 int, b1269 int, b1270 int, b1271 int, b1272 int, b1273 int, b1274 int, b1275 int, b1276 int, b1277 int, b1278 int, b1279 int, b1280 int, b1281 int, b1282 int, b1283 int, b1284 int, b1285 int, b1286 int, b1287 int, b1288 int, b1289 int, b1290 int, b1291 int, b1292 int, b1293 int, b1294 int, b1295 int, b1296 int, b1297 int, b1298 int, b1299 int, b1300 int, b1301 int, b1302 int, b1303 int, b1304 int, b1305 int, b1306 int, b1307 int, b1308 int, b1309 int, b1310 int, b1311 int, b1312 int, b1313 int, b1314 int, b1315 int, b1316 int, b1317 int, b1318 int, b1319 int, b1320 int, b1321 int, b1322 int, b1323 int, b1324 int, b1325 int, b1326 int, b1327 int, b1328 int, b1329 int, b1330 int, b1331 int, b1332 int, b1333 int, b1334 int, b1335 int, b1336 int, b1337 int, b1338 int, b1339 int, b1340 int, b1341 int, b1342 int, b1343 int, b1344 int, b1345 int, b1346 int, b1347 int, b1348 int, b1349 int, b1350 int, b1351 int, b1352 int, b1353 int, b1354 int, b1355 int, b1356 int, b1357 int, b1358 int, b1359 int, b1360 int, b1361 int, b1362 int, b1363 int, b1364 int, b1365 int, b1366 int, b1367 int, b1368 int, b1369 int, b1370 int, b1371 int, b1372 int, b1373 int, b1374 int, b1375 int, b1376 int, b1377 int, b1378 int, b1379 int, b1380 int, b1381 int, b1382 int, b1383 int, b1384 int, b1385 int, b1386 int, b1387 int, b1388 int, b1389 int, b1390 int, b1391 int, b1392 int, b1393 int, b1394 int, b1395 int, b1396 int, b1397 int, b1398 int, b1399 int, b1400 int, b1401 int, b1402 int, b1403 int, b1404 int, b1405 int, b1406 int, b1407 int, b1408 int, b1409 int, b1410 int, b1411 int, b1412 int, b1413 int, b1414 int, b1415 int, b1416 int, b1417 int, b1418 int, b1419 int, b1420 int, b1421 int, b1422 int, b1423 int, b1424 int, b1425 int, b1426 int, b1427 int, b1428 int, b1429 int, b1430 int, b1431 int, b1432 int, b1433 int, b1434 int, b1435 int, b1436 int, b1437 int, b1438 int, b1439 int, b1440 int, b1441 int, b1442 int, b1443 int, b1444 int, b1445 int, b1446 int, b1447 int, b1448 int, b1449 int, b1450 int, b1451 int, b1452 int, b1453 int, b1454 int, b1455 int, b1456 int, b1457 int, b1458 int, b1459 int, b1460 int, b1461 int, b1462 int, b1463 int, b1464 int, b1465 int, b1466 int, b1467 int, b1468 int, b1469 int, b1470 int, b1471 int, b1472 int, b1473 int, b1474 int, b1475 int, b1476 int, b1477 int, b1478 int, b1479 int, b1480 int, b1481 int, b1482 int, b1483 int, b1484 int, b1485 int, b1486 int, b1487 int, b1488 int, b1489 int, b1490 int, b1491 int, b1492 int, b1493 int, b1494 int, b1495 int, b1496 int, b1497 int, b1498 int, b1499 int, b1500 int, b text) ENGINE=MyiSAM;
CREATE TABLE t3 (c1 int, c2 int, c3 int, c4 int, c5 int, c6 int, c7 int, c8 int, c9 int, c10 int, c11 int, c12 int, c13 int, c14 int, c15 int, c16 int, c17 int, c18 int, c19 int, c20 int, c21 int, c22 int, c23 int, c24 int, c25 int, c26 int, c27 int, c28 int, c29 int, c30 int, c31 int, c32 int, c33 int, c34 int, c35 int, c36 int, c37 int, c38 int, c39 int, c40 int, c41 int, c42 int, c43 int, c44 int, c45 int, c46 int, c47 int, c48 int, c49 int, c50 int, c51 int, c52 int, c53 int, c54 int, c55 int, c56 int, c57 int, c58 int, c59 int, c60 int, c61 int, c62 int, c63 int, c64 int, c65 int, c66 int, c67 int, c68 int, c69 int, c70 int, c71 int, c72 int, c73 int, c74 int, c75 int, c76 int, c77 int, c78 int, c79 int, c80 int, c81 int, c82 int, c83 int, c84 int, c85 int, c86 int, c87 int, c88 int, c89 int, c90 int, c91 int, c92 int, c93 int, c94 int, c95 int, c96 int, c97 int, c98 int, c99 int, c100 int, c101 int, c102 int, c103 int, c104 int, c105 int, c106 int, c107 int, c108 int, c109 int, c110 int, c111 int, c112 int, c113 int, c114 int, c115 int, c116 int, c117 int, c118 int, c119 int, c120 int, c121 int, c122 int, c123 int, c124 int, c125 int, c126 int, c127 int, c128 int, c129 int, c130 int, c131 int, c132 int, c133 int, c134 int, c135 int, c136 int, c137 int, c138 int, c139 int, c140 int, c141 int, c142 int, c143 int, c144 int, c145 int, c146 int, c147 int, c148 int, c149 int, c150 int, c151 int, c152 int, c153 int, c154 int, c155 int, c156 int, c157 int, c158 int, c159 int, c160 int, c161 int, c162 int, c163 int, c164 int, c165 int, c166 int, c167 int, c168 int, c169 int, c170 int, c171 int, c172 int, c173 int, c174 int, c175 int, c176 int, c177 int, c178 int, c179 int, c180 int, c181 int, c182 int, c183 int, c184 int, c185 int, c186 int, c187 int, c188 int, c189 int, c190 int, c191 int, c192 int, c193 int, c194 int, c195 int, c196 int, c197 int, c198 int, c199 int, c200 int, c201 int, c202 int, c203 int, c204 int, c205 int, c206 int, c207 int, c208 int, c209 int, c210 int, c211 int, c212 int, c213 int, c214 int, c215 int, c216 int, c217 int, c218 int, c219 int, c220 int, c221 int, c222 int, c223 int, c224 int, c225 int, c226 int, c227 int, c228 int, c229 int, c230 int, c231 int, c232 int, c233 int, c234 int, c235 int, c236 int, c237 int, c238 int, c239 int, c240 int, c241 int, c242 int, c243 int, c244 int, c245 int, c246 int, c247 int, c248 int, c249 int, c250 int, c251 int, c252 int, c253 int, c254 int, c255 int, c256 int, c257 int, c258 int, c259 int, c260 int, c261 int, c262 int, c263 int, c264 int, c265 int, c266 int, c267 int, c268 int, c269 int, c270 int, c271 int, c272 int, c273 int, c274 int, c275 int, c276 int, c277 int, c278 int, c279 int, c280 int, c281 int, c282 int, c283 int, c284 int, c285 int, c286 int, c287 int, c288 int, c289 int, c290 int, c291 int, c292 int, c293 int, c294 int, c295 int, c296 int, c297 int, c298 int, c299 int, c300 int, c301 int, c302 int, c303 int, c304 int, c305 int, c306 int, c307 int, c308 int, c309 int, c310 int, c311 int, c312 int, c313 int, c314 int, c315 int, c316 int, c317 int, c318 int, c319 int, c320 int, c321 int, c322 int, c323 int, c324 int, c325 int, c326 int, c327 int, c328 int, c329 int, c330 int, c331 int, c332 int, c333 int, c334 int, c335 int, c336 int, c337 int, c338 int, c339 int, c340 int, c341 int, c342 int, c343 int, c344 int, c345 int, c346 int, c347 int, c348 int, c349 int, c350 int, c351 int, c352 int, c353 int, c354 int, c355 int, c356 int, c357 int, c358 int, c359 int, c360 int, c361 int, c362 int, c363 int, c364 int, c365 int, c366 int, c367 int, c368 int, c369 int, c370 int, c371 int, c372 int, c373 int, c374 int, c375 int, c376 int, c377 int, c378 int, c379 int, c380 int, c381 int, c382 int, c383 int, c384 int, c385 int, c386 int, c387 int, c388 int, c389 int, c390 int, c391 int, c392 int, c393 int, c394 int, c395 int, c396 int, c397 int, c398 int, c399 int, c400 int, c401 int, c402 int, c403 int, c404 int, c405 int, c406 int, c407 int, c408 int, c409 int, c410 int, c411 int, c412 int, c413 int, c414 int, c415 int, c416 int, c417 int, c418 int, c419 int, c420 int, c421 int, c422 int, c423 int, c424 int, c425 int, c426 int, c427 int, c428 int, c429 int, c430 int, c431 int, c432 int, c433 int, c434 int, c435 int, c436 int, c437 int, c438 int, c439 int, c440 int, c441 int, c442 int, c443 int, c444 int, c445 int, c446 int, c447 int, c448 int, c449 int, c450 int, c451 int, c452 int, c453 int, c454 int, c455 int, c456 int, c457 int, c458 int, c459 int, c460 int, c461 int, c462 int, c463 int, c464 int, c465 int, c466 int, c467 int, c468 int, c469 int, c470 int, c471 int, c472 int, c473 int, c474 int, c475 int, c476 int, c477 int, c478 int, c479 int, c480 int, c481 int, c482 int, c483 int, c484 int, c485 int, c486 int, c487 int, c488 int, c489 int, c490 int, c491 int, c492 int, c493 int, c494 int, c495 int, c496 int, c497 int, c498 int, c499 int, c500 int, c501 int, c502 int, c503 int, c504 int, c505 int, c506 int, c507 int, c508 int, c509 int, c510 int, c511 int, c512 int, c513 int, c514 int, c515 int, c516 int, c517 int, c518 int, c519 int, c520 int, c521 int, c522 int, c523 int, c524 int, c525 int, c526 int, c527 int, c528 int, c529 int, c530 int, c531 int, c532 int, c533 int, c534 int, c535 int, c536 int, c537 int, c538 int, c539 int, c540 int, c541 int, c542 int, c543 int, c544 int, c545 int, c546 int, c547 int, c548 int, c549 int, c550 int, c551 int, c552 int, c553 int, c554 int, c555 int, c556 int, c557 int, c558 int, c559 int, c560 int, c561 int, c562 int, c563 int, c564 int, c565 int, c566 int, c567 int, c568 int, c569 int, c570 int, c571 int, c572 int, c573 int, c574 int, c575 int, c576 int, c577 int, c578 int, c579 int, c580 int, c581 int, c582 int, c583 int, c584 int, c585 int, c586 int, c587 int, c588 int, c589 int, c590 int, c591 int, c592 int, c593 int, c594 int, c595 int, c596 int, c597 int, c598 int, c599 int, c600 int, c601 int, c602 int, c603 int, c604 int, c605 int, c606 int, c607 int, c608 int, c609 int, c610 int, c611 int, c612 int, c613 int, c614 int, c615 int, c616 int, c617 int, c618 int, c619 int, c620 int, c621 int, c622 int, c623 int, c624 int, c625 int, c626 int, c627 int, c628 int, c629 int, c630 int, c631 int, c632 int, c633 int, c634 int, c635 int, c636 int, c637 int, c638 int, c639 int, c640 int, c641 int, c642 int, c643 int, c644 int, c645 int, c646 int, c647 int, c648 int, c649 int, c650 int, c651 int, c652 int, c653 int, c654 int, c655 int, c656 int, c657 int, c658 int, c659 int, c660 int, c661 int, c662 int, c663 int, c664 int, c665 int, c666 int, c667 int, c668 int, c669 int, c670 int, c671 int, c672 int, c673 int, c674 int, c675 int, c676 int, c677 int, c678 int, c679 int, c680 int, c681 int, c682 int, c683 int, c684 int, c685 int, c686 int, c687 int, c688 int, c689 int, c690 int, c691 int, c692 int, c693 int, c694 int, c695 int, c696 int, c697 int, c698 int, c699 int, c700 int, c701 int, c702 int, c703 int, c704 int, c705 int, c706 int, c707 int, c708 int, c709 int, c710 int, c711 int, c712 int, c713 int, c714 int, c715 int, c716 int, c717 int, c718 int, c719 int, c720 int, c721 int, c722 int, c723 int, c724 int, c725 int, c726 int, c727 int, c728 int, c729 int, c730 int, c731 int, c732 int, c733 int, c734 int, c735 int, c736 int, c737 int, c738 int, c739 int, c740 int, c741 int, c742 int, c743 int, c744 int, c745 int, c746 int, c747 int, c748 int, c749 int, c750 int, c751 int, c752 int, c753 int, c754 int, c755 int, c756 int, c757 int, c758 int, c759 int, c760 int, c761 int, c762 int, c763 int, c764 int, c765 int, c766 int, c767 int, c768 int, c769 int, c770 int, c771 int, c772 int, c773 int, c774 int, c775 int, c776 int, c777 int, c778 int, c779 int, c780 int, c781 int, c782 int, c783 int, c784 int, c785 int, c786 int, c787 int, c788 int, c789 int, c790 int, c791 int, c792 int, c793 int, c794 int, c795 int, c796 int, c797 int, c798 int, c799 int, c800 int, c801 int, c802 int, c803 int, c804 int, c805 int, c806 int, c807 int, c808 int, c809 int, c810 int, c811 int, c812 int, c813 int, c814 int, c815 int, c816 int, c817 int, c818 int, c819 int, c820 int, c821 int, c822 int, c823 int, c824 int, c825 int, c826 int, c827 int, c828 int, c829 int, c830 int, c831 int, c832 int, c833 int, c834 int, c835 int, c836 int, c837 int, c838 int, c839 int, c840 int, c841 int, c842 int, c843 int, c844 int, c845 int, c846 int, c847 int, c848 int, c849 int, c850 int, c851 int, c852 int, c853 int, c854 int, c855 int, c856 int, c857 int, c858 int, c859 int, c860 int, c861 int, c862 int, c863 int, c864 int, c865 int, c866 int, c867 int, c868 int, c869 int, c870 int, c871 int, c872 int, c873 int, c874 int, c875 int, c876 int, c877 int, c878 int, c879 int, c880 int, c881 int, c882 int, c883 int, c884 int, c885 int, c886 int, c887 int, c888 int, c889 int, c890 int, c891 int, c892 int, c893 int, c894 int, c895 int, c896 int, c897 int, c898 int, c899 int, c900 int, c901 int, c902 int, c903 int, c904 int, c905 int, c906 int, c907 int, c908 int, c909 int, c910 int, c911 int, c912 int, c913 int, c914 int, c915 int, c916 int, c917 int, c918 int, c919 int, c920 int, c921 int, c922 int, c923 int, c924 int, c925 int, c926 int, c927 int, c928 int, c929 int, c930 int, c931 int, c932 int, c933 int, c934 int, c935 int, c936 int, c937 int, c938 int, c939 int, c940 int, c941 int, c942 int, c943 int, c944 int, c945 int, c946 int, c947 int, c948 int, c949 int, c950 int, c951 int, c952 int, c953 int, c954 int, c955 int, c956 int, c957 int, c958 int, c959 int, c960 int, c961 int, c962 int, c963 int, c964 int, c965 int, c966 int, c967 int, c968 int, c969 int, c970 int, c971 int, c972 int, c973 int, c974 int, c975 int, c976 int, c977 int, c978 int, c979 int, c980 int, c981 int, c982 int, c983 int, c984 int, c985 int, c986 int, c987 int, c988 int, c989 int, c990 int, c991 int, c992 int, c993 int, c994 int, c995 int, c996 int, c997 int, c998 int, c999 int, c1000 int, c1001 int, c1002 int, c1003 int, c1004 int, c1005 int, c1006 int, c1007 int, c1008 int, c1009 int, c1010 int, c1011 int, c1012 int, c1013 int, c1014 int, c1015 int, c1016 int, c1017 int, c1018 int, c1019 int, c1020 int, c1021 int, c1022 int, c1023 int, c1024 int, c1025 int, c1026 int, c1027 int, c1028 int, c1029 int, c1030 int, c1031 int, c1032 int, c1033 int, c1034 int, c1035 int, c1036 int, c1037 int, c1038 int, c1039 int, c1040 int, c1041 int, c1042 int, c1043 int, c1044 int, c1045 int, c1046 int, c1047 int, c1048 int, c1049 int, c1050 int, c1051 int, c1052 int, c1053 int, c1054 int, c1055 int, c1056 int, c1057 int, c1058 int, c1059 int, c1060 int, c1061 int, c1062 int, c1063 int, c1064 int, c1065 int, c1066 int, c1067 int, c1068 int, c1069 int, c1070 int, c1071 int, c1072 int, c1073 int, c1074 int, c1075 int, c1076 int, c1077 int, c1078 int, c1079 int, c1080 int, c1081 int, c1082 int, c1083 int, c1084 int, c1085 int, c1086 int, c1087 int, c1088 int, c1089 int, c1090 int, c1091 int, c1092 int, c1093 int, c1094 int, c1095 int, c1096 int, c1097 int, c1098 int, c1099 int, c1100 int, c1101 int, c1102 int, c1103 int, c1104 int, c1105 int, c1106 int, c1107 int, c1108 int, c1109 int, c1110 int, c1111 int, c1112 int, c1113 int, c1114 int, c1115 int, c1116 int, c1117 int, c1118 int, c1119 int, c1120 int, c1121 int, c1122 int, c1123 int, c1124 int, c1125 int, c1126 int, c1127 int, c1128 int, c1129 int, c1130 int, c1131 int, c1132 int, c1133 int, c1134 int, c1135 int, c1136 int, c1137 int, c1138 int, c1139 int, c1140 int, c1141 int, c1142 int, c1143 int, c1144 int, c1145 int, c1146 int, c1147 int, c1148 int, c1149 int, c1150 int, c1151 int, c1152 int, c1153 int, c1154 int, c1155 int, c1156 int, c1157 int, c1158 int, c1159 int, c1160 int, c1161 int, c1162 int, c1163 int, c1164 int, c1165 int, c1166 int, c1167 int, c1168 int, c1169 int, c1170 int, c1171 int, c1172 int, c1173 int, c1174 int, c1175 int, c1176 int, c1177 int, c1178 int, c1179 int, c1180 int, c1181 int, c1182 int, c1183 int, c1184 int, c1185 int, c1186 int, c1187 int, c1188 int, c1189 int, c1190 int, c1191 int, c1192 int, c1193 int, c1194 int, c1195 int, c1196 int, c1197 int, c1198 int, c1199 int, c1200 int, c1201 int, c1202 int, c1203 int, c1204 int, c1205 int, c1206 int, c1207 int, c1208 int, c1209 int, c1210 int, c1211 int, c1212 int, c1213 int, c1214 int, c1215 int, c1216 int, c1217 int, c1218 int, c1219 int, c1220 int, c1221 int, c1222 int, c1223 int, c1224 int, c1225 int, c1226 int, c1227 int, c1228 int, c1229 int, c1230 int, c1231 int, c1232 int, c1233 int, c1234 int, c1235 int, c1236 int, c1237 int, c1238 int, c1239 int, c1240 int, c1241 int, c1242 int, c1243 int, c1244 int, c1245 int, c1246 int, c1247 int, c1248 int, c1249 int, c1250 int, c1251 int, c1252 int, c1253 int, c1254 int, c1255 int, c1256 int, c1257 int, c1258 int, c1259 int, c1260 int, c1261 int, c1262 int, c1263 int, c1264 int, c1265 int, c1266 int, c1267 int, c1268 int, c1269 int, c1270 int, c1271 int, c1272 int, c1273 int, c1274 int, c1275 int, c1276 int, c1277 int, c1278 int, c1279 int, c1280 int, c1281 int, c1282 int, c1283 int, c1284 int, c1285 int, c1286 int, c1287 int, c1288 int, c1289 int, c1290 int, c1291 int, c1292 int, c1293 int, c1294 int, c1295 int, c1296 int, c1297 int, c1298 int, c1299 int, c1300 int, c1301 int, c1302 int, c1303 int, c1304 int, c1305 int, c1306 int, c1307 int, c1308 int, c1309 int, c1310 int, c1311 int, c1312 int, c1313 int, c1314 int, c1315 int, c1316 int, c1317 int, c1318 int, c1319 int, c1320 int, c1321 int, c1322 int, c1323 int, c1324 int, c1325 int, c1326 int, c1327 int, c1328 int, c1329 int, c1330 int, c1331 int, c1332 int, c1333 int, c1334 int, c1335 int, c1336 int, c1337 int, c1338 int, c1339 int, c1340 int, c1341 int, c1342 int, c1343 int, c1344 int, c1345 int, c1346 int, c1347 int, c1348 int, c1349 int, c1350 int, c1351 int, c1352 int, c1353 int, c1354 int, c1355 int, c1356 int, c1357 int, c1358 int, c1359 int, c1360 int, c1361 int, c1362 int, c1363 int, c1364 int, c1365 int, c1366 int, c1367 int, c1368 int, c1369 int, c1370 int, c1371 int, c1372 int, c1373 int, c1374 int, c1375 int, c1376 int, c1377 int, c1378 int, c1379 int, c1380 int, c1381 int, c1382 int, c1383 int, c1384 int, c1385 int, c1386 int, c1387 int, c1388 int, c1389 int, c1390 int, c1391 int, c1392 int, c1393 int, c1394 int, c1395 int, c1396 int, c1397 int, c1398 int, c1399 int, c1400 int, c1401 int, c1402 int, c1403 int, c1404 int, c1405 int, c1406 int, c1407 int, c1408 int, c1409 int, c1410 int, c1411 int, c1412 int, c1413 int, c1414 int, c1415 int, c1416 int, c1417 int, c1418 int, c1419 int, c1420 int, c1421 int, c1422 int, c1423 int, c1424 int, c1425 int, c1426 int, c1427 int, c1428 int, c1429 int, c1430 int, c1431 int, c1432 int, c1433 int, c1434 int, c1435 int, c1436 int, c1437 int, c1438 int, c1439 int, c1440 int, c1441 int, c1442 int, c1443 int, c1444 int, c1445 int, c1446 int, c1447 int, c1448 int, c1449 int, c1450 int, c1451 int, c1452 int, c1453 int, c1454 int, c1455 int, c1456 int, c1457 int, c1458 int, c1459 int, c1460 int, c1461 int, c1462 int, c1463 int, c1464 int, c1465 int, c1466 int, c1467 int, c1468 int, c1469 int, c1470 int, c1471 int, c1472 int, c1473 int, c1474 int, c1475 int, c1476 int, c1477 int, c1478 int, c1479 int, c1480 int, c1481 int, c1482 int, c1483 int, c1484 int, c1485 int, c1486 int, c1487 int, c1488 int, c1489 int, c1490 int, c1491 int, c1492 int, c1493 int, c1494 int, c1495 int, c1496 int, c1497 int, c1498 int, c1499 int, c1500 int, c text) ENGINE=MyiSAM;
CREATE VIEW view_broken AS SELECT * FROM t1, t2, t3;
ERROR HY000: Too many columns
CREATE TABLE table_broken AS SELECT * FROM t1, t2, t3;
ERROR HY000: Too many columns
DROP TABLE t1, t2, t3;
#
# Bug#11766440 59546: Assertion m_sp == __null fails in
# Item_func_sp::init_result_field with functions
#
CREATE TABLE t1 (a INT);
CREATE FUNCTION f1 () RETURNS INTEGER RETURN 1;
CREATE FUNCTION f2 (i INTEGER) RETURNS INTEGER RETURN 1;
CREATE VIEW v1 AS SELECT f1() AS a FROM t1;
CREATE VIEW v2 AS SELECT f2(a) AS a FROM v1;
DROP FUNCTION f1;
SELECT f2(a) FROM v2;
ERROR HY000: View 'test.v2' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP VIEW v2;
DROP VIEW v1;
DROP FUNCTION f2;
DROP TABLE t1;
#
# Bug#13418197: ASSERTION `(*TABLES)->REGINFO.LOCK_TYPE >=
#               TL_READ' FAILED | MYSQL_LOCK_TABLES
#
DROP TABLE IF EXISTS t1;
CREATE TEMPORARY TABLE t1 (a INT) engine=InnoDB;
CREATE VIEW t1 AS SELECT 1;
DROP VIEW t1;
DROP TEMPORARY TABLE t1;
#
# Bug#13601606: FAILED VIEW CREATION ERROR MESSAGE (FOR DB NOT PRESENT) 
#               NEEDS BIG IMPROVEMENT 
#
DROP DATABASE IF EXISTS nodb;
CREATE VIEW nodb.a AS SELECT 1;
ERROR 42000: Unknown database 'nodb'
#
# Bug#13633549 HANDLE_FATAL_SIGNAL IN 
#              TEST_IF_SKIP_SORT_ORDER/CREATE_SORT_INDEX
#
CREATE TABLE t1 (
pk        INT AUTO_INCREMENT,
c_int_key INT,
PRIMARY KEY (pk),
KEY (c_int_key)
) 
ENGINE=innodb;
CREATE VIEW v_t1 AS SELECT * FROM t1;
CREATE TABLE t2 (
pk              INT auto_increment,
c_varchar_600_x VARCHAR(600),
c_int_key       INT,
c_varchar_600_y VARCHAR(600),
c_varchar_600_z VARCHAR(600),
PRIMARY KEY (pk),
KEY (c_int_key)
) 
ENGINE=innodb;
CREATE VIEW v_t2 AS SELECT * FROM t2;
INSERT INTO t2 VALUES
(
NULL,
repeat('x', 600),
3,
repeat('y', 600),
repeat('z', 600)
);
SELECT a1.pk AS f1
FROM v_t1 AS a1 LEFT JOIN v_t2 AS a2 ON a1.pk=a2.c_int_key
WHERE 
a1.pk > 8
OR ((a1.pk BETWEEN 9 AND 13) AND a1.pk = 90)
ORDER BY f1 ;
f1
DROP TABLE t1, t2;
DROP VIEW v_t1, v_t2;
#
# Bug#13783777 CONSTANT PROPAGATION IS WRONG FOR
#              DISJUNCTIVE PREDICATES IN VIEWS
#
CREATE TABLE t1 (
pk INTEGER,
PRIMARY KEY (pk)
);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v_t1 AS SELECT * FROM t1;
SELECT pk
FROM t1
WHERE
pk > 8
OR ((pk BETWEEN 9 AND 13) AND pk = 90)
;
pk
SELECT pk
FROM v_t1
WHERE
pk > 8
OR ((pk BETWEEN 9 AND 13) AND pk = 90)
;
pk
DROP VIEW v_t1;
DROP TABLE t1;
#
# WL#5275 Process subqueries in FROM clause in the same way as view
#
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER, b INTEGER);
INSERT INTO t1 VALUES(1, 10), (2, 20);
INSERT INTO t2 VALUES(1, 100), (2, 200);
CREATE VIEW v2 AS SELECT * FROM t2;
CREATE VIEW v2_sj AS SELECT * FROM t2
WHERE a IN (SELECT a FROM t1);
CREATE VIEW v12_1 AS SELECT t2.a, t2.b FROM t1 JOIN t2 USING (a);
CREATE VIEW v12_2 AS SELECT t1.a, t2.b FROM t1 JOIN t2 USING (a);
CREATE VIEW v12_3 AS SELECT t2.a, t2.b FROM t1 JOIN t2 USING (a)
WHERE t1.b > 15;
CREATE VIEW vu_1 AS SELECT * FROM t2 UNION SELECT * FROM t2;
CREATE VIEW vu_2 AS SELECT * FROM t2 UNION ALL SELECT * FROM t2;
CREATE VIEW vd_1 AS SELECT DISTINCT a, b FROM t2;
CREATE VIEW va_1 AS SELECT SUM(a) AS a, SUM(b) AS b FROM t2;
CREATE VIEW vg_1 AS SELECT a, SUM(b) AS b FROM t2 GROUP BY a;
CREATE VIEW vh_1 AS SELECT 1 AS a FROM t2 HAVING COUNT(*) > 1;
CREATE VIEW vl_1 AS SELECT * FROM t2 LIMIT 1;
CREATE VIEW vlo_1 AS SELECT * FROM t2 LIMIT 2 OFFSET 1;
CREATE VIEW vrow AS SELECT 1 AS a;
CREATE VIEW vo_1 AS SELECT * FROM t2 ORDER BY a;
CREATE VIEW vo_2 AS SELECT * FROM t2 ORDER BY a DESC;
CREATE VIEW vx AS SELECT a, (SELECT b) AS b FROM t2;
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
SELECT *
FROM t1 JOIN v2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1, v2 AS dt WHERE t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1, v2 AS dt WHERE t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM (t1 JOIN t2 ON t1.a=t2.a) JOIN v2 AS dt ON t1.a=dt.a;
a	b	a	b	a	b
1	10	1	100	1	100
2	20	2	200	2	200
explain SELECT *
FROM (t1 JOIN t2 ON t1.a=t2.a) JOIN v2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN v12_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v12_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_2 AS dt1
ON t1.a=dt1.a AND t2.b=dt1.b
JOIN v12_1 AS dt2
ON dt1.a=dt2.a;
a	b	b	a	b	a	b
1	10	100	1	100	1	100
2	20	200	2	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_2 AS dt1
ON t1.a=dt1.a AND t2.b=dt1.b
JOIN v12_1 AS dt2
ON dt1.a=dt2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t1`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`b` = `test`.`t2`.`b`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN v12_3 AS dt ON t1.a=dt.a;
a	b	a	b
2	20	2	200
explain SELECT *
FROM t1 JOIN v12_3 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` > 15))
SELECT *
FROM t1 JOIN v2_sj AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN v2_sj AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; FirstMatch(t2); Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` semi join (`test`.`t1`) join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`))
SELECT *
FROM t1 JOIN vu_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vu_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
NULL	UNION RESULT	<union2,3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vu_1` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vu_2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
1	10	1	100
2	20	2	200
2	20	2	200
explain SELECT *
FROM t1 JOIN vu_2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vu_2` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vd_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vd_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vd_1` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN va_1 AS dt ON t1.a=dt.a;
a	b	a	b
explain SELECT *
FROM t1 JOIN va_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'3' AS `a`,'300' AS `b` from `test`.`t1` where (`test`.`t1`.`a` = '3')
SELECT *
FROM t1 JOIN vg_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vg_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vg_1` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vh_1 AS dt ON t1.a=dt.a;
a	b	a
1	10	1
explain SELECT *
FROM t1 JOIN vh_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM t1 JOIN vl_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
explain SELECT *
FROM t1 JOIN vl_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a`,'100' AS `b` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM t1 JOIN vlo_1 AS dt ON t1.a=dt.a;
a	b	a	b
2	20	2	200
explain SELECT *
FROM t1 JOIN vlo_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vlo_1` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vrow AS dt ON t1.a=dt.a;
a	b	a
1	10	1
explain SELECT *
FROM t1 JOIN vrow AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	#	No tables used
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,'1' AS `a` from `test`.`t1` where (`test`.`t1`.`a` = '1')
SELECT *
FROM vo_1 AS dt;
a	b
1	100
2	200
explain SELECT *
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` order by `test`.`t2`.`a`
SELECT *
FROM vo_2 AS dt;
a	b
2	200
1	100
explain SELECT *
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` order by `test`.`t2`.`a` desc
SELECT *
FROM vo_1 AS dt
WHERE dt.a > 0;
a	b
1	100
2	200
explain SELECT *
FROM vo_1 AS dt
WHERE dt.a > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` where (`test`.`t2`.`a` > 0) order by `test`.`t2`.`a`
SELECT *
FROM vo_2 AS dt
WHERE dt.a > 0;
a	b
2	200
1	100
explain SELECT *
FROM vo_2 AS dt
WHERE dt.a > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2` where (`test`.`t2`.`a` > 0) order by `test`.`t2`.`a` desc
SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
SELECT dt.a, COUNT(*)
FROM vo_1 AS dt
GROUP BY dt.a;
a	COUNT(*)
1	1
2	1
explain SELECT dt.a, COUNT(*)
FROM vo_1 AS dt
GROUP BY dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,count(0) AS `COUNT(*)` from `test`.`t2` group by `test`.`t2`.`a`
SELECT dt.a, COUNT(*)
FROM vo_2 AS dt
GROUP BY dt.a;
a	COUNT(*)
1	1
2	1
explain SELECT dt.a, COUNT(*)
FROM vo_2 AS dt
GROUP BY dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a`,count(0) AS `COUNT(*)` from `test`.`t2` group by `test`.`t2`.`a`
SELECT COUNT(*)
FROM vo_1 AS dt;
COUNT(*)
2
explain SELECT COUNT(*)
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t2`
SELECT COUNT(*)
FROM vo_2 AS dt;
COUNT(*)
2
explain SELECT COUNT(*)
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t2`
SELECT DISTINCT *
FROM vo_1 AS dt;
a	b
1	100
2	200
explain SELECT DISTINCT *
FROM vo_1 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2`
SELECT DISTINCT *
FROM vo_2 AS dt;
a	b
1	100
2	200
explain SELECT DISTINCT *
FROM vo_2 AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t2`
SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a
ORDER BY t1.b;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_1 AS dt ON t1.a=dt.a
ORDER BY t1.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`) order by `test`.`t1`.`b`
SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a
ORDER BY t1.b;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vo_2 AS dt ON t1.a=dt.a
ORDER BY t1.b;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`) order by `test`.`t1`.`b`
SELECT *
FROM t1 JOIN vx AS dt ON t1.a=dt.a;
a	b	a	b
1	10	1	100
2	20	2	200
explain SELECT *
FROM t1 JOIN vx AS dt ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	#	#	No tables used
Warnings:
Note	1276	Field or reference 'test.t2.b' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`vx` `dt` where (`dt`.`a` = `test`.`t1`.`a`)
SET @optimizer_switch_saved= @@optimizer_switch;
SET @@optimizer_switch="derived_merge=off";
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
1	PRIMARY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
1	PRIMARY	<derived2>	NULL	ref	<auto_key0>	<auto_key0>	5	test.t1.a	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`dt`.`a` AS `a`,`dt`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`v12_1` `dt` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`dt`.`a` = `test`.`t1`.`a`))
SET @@optimizer_switch="derived_merge=on";
SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
a	b	b	a	b
1	10	100	1	100
2	20	200	2	200
explain SELECT *
FROM (t1 JOIN t2 USING (a))
JOIN v12_1 AS dt
ON t1.a=dt.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`b` AS `b`,`test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b` from `test`.`t1` join `test`.`t2` join `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`a` = `test`.`t1`.`a`) and (`test`.`t2`.`a` = `test`.`t1`.`a`))
SET @@optimizer_switch= @optimizer_switch_saved;
DROP VIEW v2, v2_sj, v12_1, v12_2, v12_3;
DROP VIEW vu_1, vu_2, vd_1, va_1, vg_1, vh_1, vl_1;
DROP VIEW vlo_1, vrow, vo_1, vo_2, vx;
DROP TABLE t1, t2;
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER);
INSERT INTO t1 VALUES
(1, 10),
(2, 20), (2, 21),
(3, NULL),
(4, 40), (4, 41), (4, 42), (4, 43), (4, 44);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (NULL);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t2) AS dt;
SELECT * FROM v1;
a
1
2
3
4
5
NULL
SELECT * FROM (SELECT * FROM t2) AS dt;
a
1
2
3
4
5
NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`
explain SELECT * FROM (SELECT * FROM t2) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
SELECT * FROM v1;
a	b
1	10
2	20
4	40
SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
a	b
1	10
2	20
4	40
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = (`test`.`t1`.`a` * 10))
explain SELECT * FROM (SELECT * FROM t1 WHERE b=a*10) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`b` = (`test`.`t1`.`a` * 10))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
SELECT * FROM v1;
a	s	c
1	10	1
2	41	2
3	NULL	1
4	210	5
SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
a	s	c
1	10	1
2	41	2
3	NULL	1
4	210	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`s` AS `s`,`dt`.`c` AS `c` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,sum(`test`.`t1`.`b`) AS `s`,count(0) AS `c` from `test`.`t1` group by `test`.`t1`.`a` order by `test`.`t1`.`a`) `dt`
explain SELECT * FROM (SELECT a, SUM(b) AS s, COUNT(*) AS c FROM t1 GROUP BY a ORDER BY a) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary; Using filesort
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`s` AS `s`,`dt`.`c` AS `c` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,sum(`test`.`t1`.`b`) AS `s`,count(0) AS `c` from `test`.`t1` group by `test`.`t1`.`a` order by `test`.`t1`.`a`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
SELECT * FROM v1;
a
1
2
3
4
SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
a
1
2
3
4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#3 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`) `dt`
explain SELECT * FROM (SELECT DISTINCT a FROM t1) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#2 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
SELECT * FROM v1;
a	b
3	NULL
4	40
4	41
SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
a	b
3	NULL
4	40
4	41
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`b` AS `b` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` limit 3,3) `dt`
explain SELECT * FROM (SELECT * FROM t1 LIMIT 3 OFFSET 3) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`b` AS `b` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` limit 3,3) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
SELECT * FROM v1;
a
1
2
3
4
1
2
3
4
5
NULL
SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
a
1
2
3
4
1
2
3
4
5
NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
4	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#3 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` union all /* select#4 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`) `dt`
explain SELECT * FROM (SELECT DISTINCT a FROM t1 UNION ALL SELECT a FROM t2) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	UNION	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `dt`.`a` AS `a` from (/* select#2 */ select distinct `test`.`t1`.`a` AS `a` from `test`.`t1` union all /* select#3 */ select `test`.`t2`.`a` AS `a` from `test`.`t2`) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
SELECT * FROM v1;
a	b
1	10
SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
a	b
1	10
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
4	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((/* select#4 */ select `test`.`t1`.`a` from `test`.`t1` limit 1) = (`test`.`t1`.`b` / 10))
explain SELECT * FROM (SELECT * FROM t1 WHERE (SELECT a FROM t1 LIMIT 1) = b/10) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
3	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((/* select#3 */ select `test`.`t1`.`a` from `test`.`t1` limit 1) = (`test`.`t1`.`b` / 10))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
SELECT * FROM v1;
a	b
2	20
2	21
4	40
4	41
4	42
4	43
4	44
SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
a	b
2	20
2	21
4	40
4	41
4	42
4	43
4	44
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` semi join (`test`.`t2`) where ((`test`.`t1`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`a` % 2) = 0))
explain SELECT * FROM (SELECT * FROM t1 WHERE a IN (SELECT a FROM t2 WHERE a % 2 = 0)) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` semi join (`test`.`t2`) where ((`test`.`t1`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`a` % 2) = 0))
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
SELECT * FROM v1;
a	(SELECT a FROM t2 WHERE a=t1.a)
1	1
2	2
4	4
SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
a	(SELECT a FROM t2 WHERE a=t1.a)
1	1
2	2
4	4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
3	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
5	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #5 was resolved in SELECT #3
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`(SELECT a FROM t2 WHERE a=t1.a)` AS `(SELECT a FROM t2 WHERE a=t1.a)` from (/* select#3 */ select `test`.`t1`.`a` AS `a`,(/* select#5 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `(SELECT a FROM t2 WHERE a=t1.a)` from `test`.`t1` semi join (`test`.`t2`) where (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10))) `dt`
explain SELECT * FROM (SELECT a, (SELECT a FROM t2 WHERE a=t1.a)
FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `dt`.`a` AS `a`,`dt`.`(SELECT a FROM t2 WHERE a=t1.a)` AS `(SELECT a FROM t2 WHERE a=t1.a)` from (/* select#2 */ select `test`.`t1`.`a` AS `a`,(/* select#3 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `(SELECT a FROM t2 WHERE a=t1.a)` from `test`.`t1` semi join (`test`.`t2`) where (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10))) `dt`
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, (SELECT a FROM t2) FROM t1 WHERE b=a*10) AS dt;
SELECT * FROM v1;
ERROR 21000: Subquery returns more than 1 row
SELECT * FROM (SELECT a, (SELECT a FROM t2) FROM t1 WHERE b=a*10) AS dt;
ERROR 21000: Subquery returns more than 1 row
DROP VIEW v1;
CREATE VIEW v1 AS
SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt;
SELECT * FROM v1 JOIN t2 ON v1.a=t2.a;
a	b	a
1	10	1
2	20	2
4	40	4
SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt JOIN t2 ON dt.a=t2.a;
a	b	a
1	10	1
2	20	2
4	40	4
explain SELECT * FROM v1 JOIN t2 ON v1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a` from `test`.`t1` semi join (`test`.`t2`) join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10)))
explain SELECT * FROM (SELECT a, b FROM t1 WHERE b IN (SELECT a*10 FROM t2)) AS dt JOIN t2 ON dt.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Start temporary
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`a` AS `a` from `test`.`t1` semi join (`test`.`t2`) join `test`.`t2` where ((`test`.`t2`.`a` = `test`.`t1`.`a`) and (`test`.`t1`.`b` = (`test`.`t2`.`a` * 10)))
DROP VIEW v1;
DROP TABLE t1, t2;
CREATE TABLE t1(a INTEGER, b INTEGER);
CREATE TABLE t2(a INTEGER);
INSERT INTO t1 VALUES
(1, 10),
(2, 20), (2, 21),
(3, NULL),
(4, 40), (4, 41), (4, 42), (4, 43), (4, 44);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (NULL);
ANALYZE TABLE t1,t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 3)) AS `s` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT 1 FROM t2 WHERE a=3) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 3)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	NULL
2	20	NULL
2	21	NULL
3	NULL	NULL
4	40	NULL
4	41	NULL
4	42	NULL
4	43	NULL
4	44	NULL
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
a	b	s
1	10	NULL
2	20	NULL
2	21	NULL
3	NULL	NULL
4	40	NULL
4	41	NULL
4	42	NULL
4	43	NULL
4	44	NULL
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6)) AS `s` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT 1 FROM t2 WHERE a>=3) AS s
FROM t1;
SELECT * FROM v1;
ERROR 21000: Subquery returns more than 1 row
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT 1 FROM t2 WHERE a>=3) AS s
FROM t1;
ERROR 21000: Subquery returns more than 1 row
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
a	b	s
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, a IN (SELECT 1 FROM t2 WHERE a=6) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,<in_optimizer>(`test`.`t1`.`a`,`test`.`t1`.`a` in ( <materialize> (/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = 6) ), <primary_index_lookup>(`test`.`t1`.`a` in <temporary table> on <auto_key> where ((`test`.`t1`.`a` = `materialized-subquery`.`1`))))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
SELECT * FROM v1;
a	b	c
1	10	6
2	20	6
2	21	6
3	NULL	6
4	40	6
4	41	6
4	42	6
4	43	6
4	44	6
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
a	b	c
1	10	6
2	20	6
2	21	6
3	NULL	6
4	40	6
4	41	6
4	42	6
4	43	6
4	44	6
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#3 */ select count(0) from `test`.`t2`) AS `c` from `test`.`t1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1`
explain SELECT a, b, (SELECT COUNT(*) FROM t2) AS c
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select count(0) from `test`.`t2`) AS `c` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
SELECT * FROM v1;
a	b	c
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
a	b	c
1	10	0
2	20	0
2	21	0
3	NULL	0
4	40	0
4	41	0
4	42	0
4	43	0
4	44	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`c` AS `c` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, a IN (SELECT COUNT(*) FROM t2) AS c
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,<in_optimizer>(`test`.`t1`.`a`,`test`.`t1`.`a` in ( <materialize> (/* select#2 */ select count(0) from `test`.`t2` having 1 ), <primary_index_lookup>(`test`.`t1`.`a` in <temporary table> on <auto_key> where ((`test`.`t1`.`a` = `materialized-subquery`.`COUNT(*)`))))) AS `c` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	2
2	20	4
2	21	4
3	NULL	6
4	40	8
4	41	8
4	42	8
4	43	8
4	44	8
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	2
2	20	4
2	21	4
3	NULL	6
4	40	8
4	41	8
4	42	8
4	43	8
4	44	8
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select (`test`.`t2`.`a` * 2) from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, EXISTS (SELECT a*2 FROM t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,exists(/* select#2 */ select (`test`.`t2`.`a` * 2) from `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	2
2	21	2
3	NULL	1
4	40	5
4	41	5
4	42	5
4	43	5
4	44	5
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	2
2	21	2
3	NULL	1
4	40	5
4	41	5
4	42	5
4	43	5
4	44	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,(/* select#2 */ select count(0) from `test`.`t1` `t2` where (`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
SELECT * FROM v1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
SELECT a FROM v1;
a
1
2
2
3
4
4
4
4
4
SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
a	b	s
1	10	1
2	20	1
2	21	1
3	NULL	1
4	40	1
4	41	1
4	42	1
4	43	1
4	44	1
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`b` AS `b`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, b, EXISTS (SELECT COUNT(*) FROM t1 AS t2 WHERE a=t1.a) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,exists(/* select#2 */ select count(0) from `test`.`t1` `t2` where (`t2`.`a` = `test`.`t1`.`a`)) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
s
4
SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
s
4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '4' AS `s` from dual
explain SELECT (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2)))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
a	s
9	4
SELECT a FROM v1;
a
9
SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
a	s
9	4
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a`,'4' AS `s` from dual
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a` from dual
explain SELECT COUNT(*) AS a, (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select count(0) AS `a`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2)))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
s
0
SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
s
0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '0' AS `s` from dual
explain SELECT a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select <in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2))) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
SELECT * FROM v1;
a	s
9	0
SELECT a FROM v1;
a
9
SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
a	s
9	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a`,'0' AS `s` from dual
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	system	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select '9' AS `a` from dual
explain SELECT COUNT(*) AS a, a IN (SELECT a FROM t2 WHERE a=FLOOR(COUNT(t1.a)/2)) AS s
FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select count(0) AS `a`,<in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = floor((count(`test`.`t1`.`a`) / 2))) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
SELECT * FROM v1;
a	c	s
1	1	1
2	2	2
3	1	1
4	5	5
SELECT a FROM v1;
a
1
2
3
4
SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
a	c	s
1	1	1
2	2	2
3	1	1
4	5	5
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`c` AS `c`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, COUNT(*) AS c, (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,count(0) AS `c`,(/* select#2 */ select `test`.`t2`.`a` from `test`.`t2` where (`test`.`t2`.`a` = count(`test`.`t1`.`a`))) AS `s` from `test`.`t1` group by `test`.`t1`.`a`
DROP VIEW v1;
CREATE VIEW v1 AS SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
SELECT * FROM v1;
a	c	s
1	1	1
2	2	1
3	1	0
4	5	0
SELECT a FROM v1;
a
1
2
3
4
SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
a	c	s
1	1	1
2	2	1
3	1	0
4	5	0
explain SELECT * FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a`,`v1`.`c` AS `c`,`v1`.`s` AS `s` from `test`.`v1`
explain SELECT a FROM v1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
3	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #3 was resolved in SELECT #2
Note	1003	/* select#1 */ select `v1`.`a` AS `a` from `test`.`v1`
explain SELECT a, COUNT(*) AS c, a IN (SELECT a FROM t2 WHERE a=COUNT(t1.a)) AS s
FROM t1
GROUP BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using temporary
2	DEPENDENT SUBQUERY	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
Warnings:
Note	1276	Field or reference 'test.t1.a' of SELECT #2 was resolved in SELECT #1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,count(0) AS `c`,<in_optimizer>(`test`.`t1`.`a`,<exists>(/* select#2 */ select 1 from `test`.`t2` where (`test`.`t2`.`a` = count(`test`.`t1`.`a`)) having <if>(outer_field_is_not_null, (<cache>(`test`.`t1`.`a`) = <ref_null_helper>(`test`.`t2`.`a`)), true))) AS `s` from `test`.`t1` group by `test`.`t1`.`a`
DROP VIEW v1;
DROP TABLE t1, t2;
#
# Bug#19789450 Assert fail in add_key_field
#
CREATE TABLE t1 (
pk int NOT NULL,
col_date_key date DEFAULT NULL,
PRIMARY KEY (pk),
KEY col_date_key (col_date_key)
) ;
CREATE TABLE t2 (
pk int NOT NULL,
col_time_key time DEFAULT NULL,
col_datetime_key datetime DEFAULT NULL,
PRIMARY KEY (pk),
KEY col_time_key (col_time_key),
KEY col_datetime_key (col_datetime_key)
);
CREATE ALGORITHM=MERGE VIEW v1 AS 
SELECT col_date_key
FROM t1 WHERE (pk, pk, col_date_key) IN
(SELECT col_datetime_key,
col_time_key,
col_time_key
FROM t2
WHERE pk <= 7);
SELECT * FROM v1;
col_date_key
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#14117018 - MYSQL SERVER CREATES INVALID VIEW DEFINITION 
# BUG#18405221 - SHOW CREATE VIEW OUTPUT INCCORRECT 
#
CREATE VIEW v1 AS (SELECT '' FROM DUAL);
CREATE VIEW v2 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
CREATE VIEW v3 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
CREATE VIEW v4 AS (SELECT 'BUG#14117018' AS col1 FROM DUAL) UNION ALL
(SELECT '' AS col2 FROM DUAL) UNION ALL
(SELECT '' FROM DUAL);
# Name for the column in select1 is set properly with or
# without this fix.
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select '' AS `Name_exp_1`	utf8mb4	utf8mb4_0900_ai_ci
# Name for the column in select2 is set with this fix.
# Without this fix, name would not have set for the
# columns in select2.
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS (select 'BUG#14117018' AS `col1`) union all (select '' AS `Name_exp_2`)	utf8mb4	utf8mb4_0900_ai_ci
# Name for the field item in select2 & select3 is set with this fix.
# Without this fix, name would not have set for the
# columns in select2 & select3.
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS (select 'BUG#14117018' AS `col1`) union all (select '' AS `Name_exp_2`) union all (select '' AS `Name_exp_3`)	utf8mb4	utf8mb4_0900_ai_ci
# Name for the field item in select3 is set with this fix.
# Without this fix, name would not have set for the
# columns in select3.
SHOW CREATE VIEW v4;
View	Create View	character_set_client	collation_connection
v4	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v4` AS (select 'BUG#14117018' AS `col1`) union all (select '' AS `col2`) union all (select '' AS `Name_exp_3`)	utf8mb4	utf8mb4_0900_ai_ci
DROP VIEW v1, v2, v3, v4;
# Bug#20087932 Assert fail in Join_tab_compare_straight::operator()
CREATE TABLE t1 (
pk int NOT NULL,
col_varchar_key varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE TABLE t2 (
pk int NOT NULL,
col_varchar_key varchar(1) NOT NULL,
col_varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE TABLE t3 (
pk int NOT NULL,
col_int_key int NOT NULL,
col_varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk)
);
CREATE VIEW v2 AS SELECT * FROM t2;
ANALYZE TABLE t1,t2,t3;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
test.t3	analyze	status	OK
explain SELECT STRAIGHT_JOIN alias1.pk
FROM t2 AS alias1
RIGHT JOIN
(SELECT sq1_alias2.*
FROM t1 AS sq1_alias1
RIGHT OUTER JOIN
v2 AS sq1_alias2
ON sq1_alias2.col_varchar_key = sq1_alias1.col_varchar_key AND
sq1_alias2.col_varchar_nokey IN
(SELECT c_sq1_alias1.col_varchar_nokey AS c_sq1_field1
FROM t3 AS c_sq1_alias1
WHERE c_sq1_alias1.col_int_key <> c_sq1_alias1.col_int_key
)
) AS alias2
ON alias2.col_varchar_key = alias1.col_varchar_key;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
1	PRIMARY	alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; Using join buffer (Block Nested Loop)
2	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	#	#	NULL
2	DERIVED	sq1_alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where
2	DERIVED	c_sq1_alias1	NULL	ALL	NULL	NULL	NULL	NULL	#	#	Using where; FirstMatch(sq1_alias1)
Warnings:
Note	1003	/* select#1 */ select straight_join `test`.`alias1`.`pk` AS `pk` from (/* select#2 */ select `test`.`t2`.`pk` AS `pk`,`test`.`t2`.`col_varchar_key` AS `col_varchar_key`,`test`.`t2`.`col_varchar_nokey` AS `col_varchar_nokey` from `test`.`t2` left join (`test`.`t1` `sq1_alias1` semi join (`test`.`t3` `c_sq1_alias1`)) on(((`test`.`c_sq1_alias1`.`col_varchar_nokey` = `test`.`t2`.`col_varchar_nokey`) and (`test`.`sq1_alias1`.`col_varchar_key` = `test`.`t2`.`col_varchar_key`) and 1 and (`test`.`c_sq1_alias1`.`col_int_key` <> `test`.`c_sq1_alias1`.`col_int_key`))) where 1) `alias2` left join `test`.`t2` `alias1` on((`test`.`alias1`.`col_varchar_key` = `alias2`.`col_varchar_key`)) where 1
SELECT STRAIGHT_JOIN alias1.pk
FROM t2 AS alias1
RIGHT JOIN
(SELECT sq1_alias2.*
FROM t1 AS sq1_alias1
RIGHT OUTER JOIN
v2 AS sq1_alias2
ON sq1_alias2.col_varchar_key = sq1_alias1.col_varchar_key AND
sq1_alias2.col_varchar_nokey IN
(SELECT c_sq1_alias1.col_varchar_nokey AS c_sq1_field1
FROM t3 AS c_sq1_alias1
WHERE c_sq1_alias1.col_int_key <> c_sq1_alias1.col_int_key
)
) AS alias2
ON alias2.col_varchar_key = alias1.col_varchar_key;
pk
DROP VIEW v2;
DROP TABLE t1, t2, t3;
CREATE TABLE t0(x INTEGER);
INSERT INTO t0 VALUES(0);
CREATE TABLE t1(a1 INTEGER PRIMARY KEY, b1 INTEGER);
CREATE TABLE t2(a2 INTEGER PRIMARY KEY, b2 INTEGER);
CREATE VIEW v0 AS SELECT DISTINCT x FROM t0;
CREATE VIEW vmat1 AS SELECT DISTINCT * FROM t1;
CREATE VIEW vmat2 AS SELECT DISTINCT * FROM t2;
CREATE VIEW vtt AS
SELECT * FROM t1 JOIN t2 ON t1.a1=t2.a2;
CREATE VIEW vtr AS
SELECT * FROM t1 JOIN vmat2 AS dt2 ON t1.a1=dt2.a2;
CREATE VIEW vtrd AS
SELECT * FROM t1 JOIN (SELECT DISTINCT * FROM t2) AS dt2 ON t1.a1=dt2.a2;
CREATE VIEW vrt AS
SELECT * FROM vmat1 AS dt1 JOIN t2 ON dt1.a1=t2.a2;
CREATE VIEW vrtd AS
SELECT * FROM (SELECT DISTINCT * FROM t1) AS dt1 JOIN t2 ON dt1.a1=t2.a2;
CREATE VIEW vrr AS
SELECT * FROM vmat1 AS dt1 JOIN vmat2 AS dt2 ON dt1.a1=dt2.a2;
CREATE VIEW vrrd AS
SELECT * FROM (SELECT DISTINCT * FROM t1) AS dt1 JOIN
(SELECT DISTINCT * FROM t2) AS dt2 ON dt1.a1=dt2.a2;
INSERT INTO vtt(a1,b1) VALUES (1,100);
INSERT INTO vtt(a2,b2) VALUES (1,100);
INSERT INTO vtr(a1,b1) VALUES (2,100);
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a1,b1) VALUES (3,100);
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vtr(a2,b2) VALUES (2,100);
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a2,b2) VALUES (3,100);
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vrt(a1,b1) VALUES (4,100);
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a1,b1) VALUES (5,100);
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrt(a2,b2) VALUES (4,100);
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a2,b2) VALUES (5,100);
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrr(a1,b1) VALUES (6,100);
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a1,b1) VALUES (7,100);
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
INSERT INTO vrr(a2,b2) VALUES (6,100);
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a2,b2) VALUES (7,100);
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO vtt(a1,b1) SELECT 1,100;
INSERT INTO vtt(a2,b2) SELECT 1,100;
INSERT INTO vtr(a1,b1) SELECT 2,100;
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a1,b1) SELECT 3,100;
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vtr(a2,b2) SELECT 2,100;
ERROR HY000: The target table vtr of the INSERT is not insertable-into
INSERT INTO vtrd(a2,b2) SELECT 3,100;
ERROR HY000: The target table vtrd of the INSERT is not insertable-into
INSERT INTO vrt(a1,b1) SELECT 4,100;
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a1,b1) SELECT 5,100;
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrt(a2,b2) SELECT 4,100;
ERROR HY000: The target table vrt of the INSERT is not insertable-into
INSERT INTO vrtd(a2,b2) SELECT 5,100;
ERROR HY000: The target table vrtd of the INSERT is not insertable-into
INSERT INTO vrr(a1,b1) SELECT 6,100;
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a1,b1) SELECT 7,100;
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
INSERT INTO vrr(a2,b2) SELECT 6,100;
ERROR HY000: The target table vrr of the INSERT is not insertable-into
INSERT INTO vrrd(a2,b2) SELECT 7,100;
ERROR HY000: The target table vrrd of the INSERT is not insertable-into
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES
(1,100), (2,100), (3,100), (4,100), (5,100),
(6,100), (7,100), (8,100), (9,100), (10,100),
(11,100), (12,100), (13,100), (14,100);
INSERT INTO t2 VALUES
(1,100), (2,100), (3,100), (4,100), (5,100),
(6,100), (7,100), (8,100), (9,100), (10,100),
(11,100), (12,100), (13,100), (14,100);
DELETE FROM vtt WHERE a1=1;
ERROR HY000: Can not delete from join view 'test.vtt'
DELETE FROM vtr WHERE a1=2;
ERROR HY000: Can not delete from join view 'test.vtr'
DELETE FROM vtrd WHERE a1=3;
ERROR HY000: Can not delete from join view 'test.vtrd'
DELETE FROM vrt WHERE a1=4;
ERROR HY000: Can not delete from join view 'test.vrt'
DELETE FROM vrtd WHERE a1=5;
ERROR HY000: Can not delete from join view 'test.vrtd'
DELETE FROM vrr WHERE a1=6;
ERROR HY000: The target table vrr of the DELETE is not updatable
DELETE FROM vrrd WHERE a1=7;
ERROR HY000: The target table vrrd of the DELETE is not updatable
DELETE vtt FROM vtt WHERE a1=8;
ERROR HY000: Can not delete from join view 'test.vtt'
DELETE vtr FROM vtr WHERE a1=9;
ERROR HY000: Can not delete from join view 'test.vtr'
DELETE vtrd FROM vtrd WHERE a1=10;
ERROR HY000: Can not delete from join view 'test.vtrd'
DELETE vrt FROM vrt WHERE a1=11;
ERROR HY000: Can not delete from join view 'test.vrt'
DELETE vrtd FROM vrtd WHERE a1=12;
ERROR HY000: Can not delete from join view 'test.vrtd'
DELETE vrr FROM vrr WHERE a1=13;
ERROR HY000: The target table vrr of the DELETE is not updatable
DELETE vrrd FROM vrrd WHERE a1=14;
ERROR HY000: The target table vrrd of the DELETE is not updatable
SELECT * FROM vtt;
a1	b1	a2	b2
1	100	1	100
2	100	2	100
3	100	3	100
4	100	4	100
5	100	5	100
6	100	6	100
7	100	7	100
8	100	8	100
9	100	9	100
10	100	10	100
11	100	11	100
12	100	12	100
13	100	13	100
14	100	14	100
DELETE FROM t1;
DELETE FROM t2;
INSERT INTO t1 VALUES (1,100);
INSERT INTO t2 VALUES (1,100);
UPDATE vtt SET b1=b1+1 WHERE a1=1;
UPDATE vtt SET b2=b2+1 WHERE a2=1;
UPDATE vtr SET b1=b1+1 WHERE a1=1;
UPDATE vtrd SET b1=b1+1 WHERE a1=1;
UPDATE vtr SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtr of the UPDATE is not updatable
UPDATE vtrd SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtrd of the UPDATE is not updatable
UPDATE vrt SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrt of the UPDATE is not updatable
UPDATE vrtd SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrtd of the UPDATE is not updatable
UPDATE vrt SET b2=b2+1 WHERE a2=1;
UPDATE vrtd SET b2=b2+1 WHERE a2=1;
UPDATE vrr SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vrr SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vtt, v0 AS dt SET b1=b1+1 WHERE a1=1;
UPDATE vtt, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vtr, v0 SET b1=b1+1 WHERE a1=1;
UPDATE vtrd, v0 SET b1=b1+1 WHERE a1=1;
UPDATE vtr, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtr of the UPDATE is not updatable
UPDATE vtrd, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vtrd of the UPDATE is not updatable
UPDATE vrt, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrt of the UPDATE is not updatable
UPDATE vrtd, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrtd of the UPDATE is not updatable
UPDATE vrt, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vrtd, v0 SET b2=b2+1 WHERE a2=1;
UPDATE vrr, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd, v0 SET b1=b1+1 WHERE a1=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
UPDATE vrr, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrr of the UPDATE is not updatable
UPDATE vrrd, v0 SET b2=b2+1 WHERE a2=1;
ERROR HY000: The target table vrrd of the UPDATE is not updatable
SELECT * FROM vtt;
a1	b1	a2	b2
1	106	1	106
DROP VIEW v0, vtt, vtr, vrt, vrr, vmat1, vmat2;
DROP VIEW vtrd, vrtd, vrrd;
DROP TABLE t0, t1, t2;
#
# Bug#20407961 VIEW'S CHECK OPTION SOMETIMES NOT HONOURED IF INCLUDED IN A TOP VIEW
#
create table t1 (a varchar(100));
# n/c/l letter suffix means: no/cascaded/local check option
create view v1n as select * from t1 where a like '%v1n%';
create view v2c as select * from t1 where a like '%v2c%'
 with check option;
show create view v2c;
View	Create View	character_set_client	collation_connection
v2c	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2c` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` like '%v2c%') WITH CASCADED CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
create view v3l as select * from t1 where a like '%v3l%'
 with local check option;
show create view v3l;
View	Create View	character_set_client	collation_connection
v3l	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3l` AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` like '%v3l%') WITH LOCAL CHECK OPTION	utf8mb4	utf8mb4_0900_ai_ci
# The basic, single-view feature works:
insert into t1 values('');
insert into v1n values('');
insert into v2c values('');
ERROR HY000: CHECK OPTION failed 'test.v2c'
insert into v2c values('v2c');
insert into v3l values('');
ERROR HY000: CHECK OPTION failed 'test.v3l'
insert into v3l values('v3l');
# We also test UPDATE of the successfully inserted row
update v1n set a='_';
# if this update to v2c was allowed, it would be produce a row in t1
# not matching v2c's filter, which is against the goal of CHECK
# OPTION.
update v2c set a='';
ERROR HY000: CHECK OPTION failed 'test.v2c'
update v3l set a='';
ERROR HY000: CHECK OPTION failed 'test.v3l'
# Top view without no CHECK OPTION, still CHECK OPTION conditions
# of underlying views are checked.
create view v4n as select * from v2c where a like '%v4n%';
create view v5n as select * from v3l where a like '%v5n%';
# The view's nesting structure is:
# v4n -> v2c -> t1
# We present the query with needed tags, verify that it passes,
# then we take each tag away and verify that it fails.
insert into v4n values('v2c');
insert into v4n values('');
ERROR HY000: CHECK OPTION failed 'test.v4n'
# To check UPDATE on v4n, we need to update a row originally
# visible in v4n, so we create it:
insert into v4n values('v4n v2c');
# This row can legally disappear from v4n:
update v4n set a='v2c';
insert into v4n values('v4n v2c');
# But this row cannot disappear from v2c:
update v4n set a='v4n';
ERROR HY000: CHECK OPTION failed 'test.v4n'
# Lest we delete it:
delete from v4n;
# v5n -> v3l -> t1
insert into v5n values('v3l');
insert into v5n values('');
ERROR HY000: CHECK OPTION failed 'test.v5n'
# Top view with LOCAL CHECK OPTION, still CHECK OPTION conditions
# of underlying views are checked.
create view v4l as select * from v2c where a like '%v4l%'
 with local check option;
create view v5l as select * from v3l where a like '%v5l%'
 with local check option;
# v4l -> v2c -> t1
insert into v4l values('v4l v2c');
insert into v4l values('v2c');
ERROR HY000: CHECK OPTION failed 'test.v4l'
update v4l set a='v2c';
ERROR HY000: CHECK OPTION failed 'test.v4l'
insert into v4l values('v4l');
ERROR HY000: CHECK OPTION failed 'test.v4l'
update v4l set a='v4l';
ERROR HY000: CHECK OPTION failed 'test.v4l'
# v5l -> v3l -> t1
insert into v5l values('v5l v3l');
insert into v5l values('v3l');
ERROR HY000: CHECK OPTION failed 'test.v5l'
update v5l set a='v3l';
ERROR HY000: CHECK OPTION failed 'test.v5l'
insert into v5l values('v5l');
ERROR HY000: CHECK OPTION failed 'test.v5l'
update v5l set a='v5l';
ERROR HY000: CHECK OPTION failed 'test.v5l'
# CASCADED makes all filtering conditions a requirement
create view v6c as select * from v5n where a like '%v6c%'
 with cascaded check option;
# v6c -> v5n -> v3l -> t1
insert into v6c values('v6c v5n v3l');
insert into v6c values('v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v6c'
insert into v6c values('v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v6c'
insert into v6c values('v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v6c'
update v6c set a='v6c v5n';
ERROR HY000: CHECK OPTION failed 'test.v6c'
# Also true if top view has no check option:
create view v7n as select * from v6c where a like '%v7n%';
# v7n -> v6c -> v5n -> v3l -> t1
insert into v7n values('v6c v5n v3l');
insert into v7n values('v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v7n'
insert into v7n values('v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v7n'
insert into v7n values('v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v7n'
# Make a visible row to update:
insert into v7n values('v7n v6c v5n v3l');
update v7n set a='v7n v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v7n'
update v7n set a='v7n v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v7n'
update v7n set a='v7n v6c v5nà';
ERROR HY000: CHECK OPTION failed 'test.v7n'
# Also true if top view has LOCAL:
create view v8l as select * from v7n where a like '%v8l%'
 with local check option;
# v8l -> v7n -> v6c -> v5n -> v3l -> t1
insert into v8l values('v8l v6c v5n v3l');
insert into v8l values('v6c v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v5n v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v6c v3l');
ERROR HY000: CHECK OPTION failed 'test.v8l'
insert into v8l values('v8l v6c v5n');
ERROR HY000: CHECK OPTION failed 'test.v8l'
# Make a visible row (=> satisfy v7n's WHERE clause):
insert into v8l values('v8l v7n v6c v5n v3l');
update v8l set a='v7n v6c v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v5n v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v6c v3l';
ERROR HY000: CHECK OPTION failed 'test.v8l'
update v8l set a='v8l v7n v6c v5n';
ERROR HY000: CHECK OPTION failed 'test.v8l'
drop view v1n,v2c,v3l,v4n,v5n,v4l,v5l,v6c,v7n,v8l;
drop table t1;
# Bug#20982756 Crash in Table_list::fetch_number_of_rows
CREATE TABLE t1(a INTEGER) engine=innodb;
CREATE VIEW v3 AS SELECT 1 FROM t1;
CREATE VIEW v2 AS SELECT 1 FROM v3 LEFT JOIN t1 ON 1;
PREPARE s FROM "set @a:=(SELECT 1 FROM t1,v2);";
EXECUTE s;
EXECUTE s;
DROP VIEW  v2,v3;
DROP TABLE t1;
# Bug#21097485 *insert_table_ref && (*insert_table_ref)->is_insertable
CREATE TABLE t1 (r INTEGER) engine=innodb;
CREATE VIEW v1 AS
SELECT 1 AS z from t1;
INSERT INTO v1(z) VALUES(1);
ERROR HY000: Column 'z' is not updatable
DROP VIEW  v1;
DROP TABLE t1;
# Bug#21277074: crash (segfault) in THD::change_item_tree on exec of prep
CREATE TABLE t (i INTEGER);
PREPARE s1 FROM
"SELECT (SELECT MAX(i)) AS field1
   FROM (SELECT * FROM t) AS table1"
;
EXECUTE s1;
field1
NULL
CREATE VIEW v AS SELECT * FROM t;
PREPARE s2 FROM
"SELECT (SELECT MAX(i)) AS field1
   FROM v AS table1"
;
EXECUTE s2;
field1
NULL
DEALLOCATE PREPARE s1;
DEALLOCATE PREPARE s2;
DROP VIEW v;
DROP TABLE t;
#
# BUG#19886430: VIEW CREATION WITH NAMED COLUMNS, OVER UNION,
#               IS REJECTED
# Without the patch, reports an error.
CREATE VIEW v1 (fld1, fld2) AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
# The column names are explicitly specified and not duplicates, hence
# succeeds.
CREATE VIEW v2 (fld1, fld2) AS
SELECT 1 AS a, 2 AS a
UNION ALL
SELECT 1 AS a, 1 AS a;
# The column name in the first SELECT are not duplicates, hence succeeds.
CREATE VIEW v3 AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
# Should report an error, since the explicitly specified column names are
# duplicates.
CREATE VIEW v4 (fld1, fld1) AS
SELECT 1 AS a, 2 AS b
UNION ALL
SELECT 1 AS a, 1 AS a;
ERROR 42S21: Duplicate column name 'fld1'
# Should report an error, since duplicate column name is specified in the
# First SELECT.
CREATE VIEW v4 AS
SELECT 1 AS a, 2 AS a
UNION ALL
SELECT 1 AS a, 1 AS a;
ERROR 42S21: Duplicate column name 'a'
# Cleanup
DROP VIEW v1, v2, v3;
#
# Bug #22108567 ASSERTION `TABLE != 0' FAILED
#
PREPARE X FROM 'CREATE VIEW bug22108567_v1 AS SELECT 1 FROM (SELECT 1) AS D1';
EXECUTE X;
DROP VIEW bug22108567_v1;
#
# BUG#21877062: MIN/MAX IN VIEW ON TIMESTAMDIFF IN VIEW CONFUSES
#               OPTIMIZER TO THROW SYNTAX ERROR
#
CREATE TABLE t(ts1 DATETIME(6), ts2 DATETIME(6));
INSERT INTO t VALUES('2016-01-11 09:15:25','2016-01-11 21:15:25');
CREATE VIEW v1 AS
SELECT TIMESTAMPDIFF(MICROSECOND, ts1, ts2) duration FROM t;
# Without the patch, a syntax error is reported.
SELECT * FROM v1;
duration
43200000000
CREATE VIEW v2 AS
SELECT MIN(duration) AS dmin, MAX(duration) AS dmax FROM v1;
DROP VIEW v1, v2;
DROP TABLE t;
#
# Bug24786327 SIG 11 IN __STPCPY_SSE2_UNALIGNED FROM MY_STPCPY() IN SQL/AUTH/SQL_AUTH_CACHE.CC
#
CREATE TABLE t1_base_N3 (pk INT, col_int INT);
CREATE VIEW t1_view_N3 AS SELECT * FROM t1_base_N3 WHERE `pk` BETWEEN 1 AND
2;
CREATE VIEW t1_view_N4 AS SELECT * FROM ( SELECT * FROM t1_view_N3 ) AS A;
UPDATE t1_view_N3 AS A JOIN t1_view_N4 B SET A. col_int = 1 , B. col_int = 2;
ERROR HY000: The target table B of the UPDATE is not updatable
DROP VIEW t1_view_N3, t1_view_N4;
DROP TABLE t1_base_N3;
#
# WL#7743: New data dictionary: changes to DDL-related parts of SE API
#
CREATE TABLE t1(a INT);
CREATE VIEW v1 AS SELECT * FROM t1;
RENAME TABLE t1 TO t2, v1 TO v2;
SELECT * FROM information_schema.views WHERE table_schema='test';
TABLE_CATALOG	TABLE_SCHEMA	TABLE_NAME	VIEW_DEFINITION	CHECK_OPTION	IS_UPDATABLE	DEFINER	SECURITY_TYPE	CHARACTER_SET_CLIENT	COLLATION_CONNECTION
def	test	v2	select `test`.`t1`.`a` AS `a` from `test`.`t1`	NONE	YES	root@localhost	DEFINER	utf8mb4	utf8mb4_0900_ai_ci
Warnings:
Warning	1356	View 'test.v2' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP VIEW v2;
DROP TABLE t2;
CREATE TABLE t1(a INT);
CREATE TABLE t2(b INT);
CREATE TABLE t3(a INT);
CREATE TABLE t4(b INT);
CREATE VIEW v1 AS SELECT * FROM t1, t2;
DROP TABLE t1, t2;
RENAME TABLE t3 TO t1, t4 TO t2;
DROP VIEW v1;
DROP TABLE t1, t2;
CREATE TABLE t1(a INT) ENGINE=MyISAM;
CREATE TABLE t2(b INT);
CREATE TABLE t3(c INT);
CREATE TABLE t4(d INT);
CREATE VIEW v1 AS SELECT * FROM t2;
RENAME TABLES t1 TO t5, v1 TO v2;
SELECT * FROM v2;
b
RENAME TABLES t5 TO t1, v2 TO v1, t3 TO t4;
ERROR 42S01: Table 't4' already exists
SELECT * FROM v2;
b
DROP VIEW v2;
DROP TABLES t2, t3, t4, t5;
#
# BUG#25634576: DATABASE NAME IN SHOW CREATE VIEW
#
CREATE DATABASE db;
CREATE TABLE db.t1(fld1 INT);
CREATE TABLE db.t2(fld2 INT);
CREATE TABLE t1(fld1 INT);
CREATE TABLE t2(fld2 INT);
# With patch, db name is appended only to those tables
# which are not present in the current database.
# Test cases with reference to table within current
# db and outside current db.
CREATE VIEW v1 AS SELECT * FROM t1 UNION SELECT * FROM t2;
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`fld1` AS `fld1` from `t1` union select `t2`.`fld2` AS `fld2` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v2 AS SELECT * FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v3 AS SELECT fld1 FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v4 AS SELECT t1.fld1 FROM t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v4;
View	Create View	character_set_client	collation_connection
v4	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v4` AS select `t1`.`fld1` AS `fld1` from `t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v5 AS SELECT * FROM db.t1 UNION SELECT * FROM db.t2;
SHOW CREATE VIEW v5;
View	Create View	character_set_client	collation_connection
v5	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v5` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` union select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`	utf8mb4	utf8mb4_0900_ai_ci
# Test cases with subquery.
CREATE VIEW v6 AS SELECT * FROM t2 WHERE fld2 IN (SELECT fld1 FROM t1);
SHOW CREATE VIEW v6;
View	Create View	character_set_client	collation_connection
v6	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v6` AS select `t2`.`fld2` AS `fld2` from `t2` where `t2`.`fld2` in (select `t1`.`fld1` from `t1`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v7 AS SELECT * FROM db.t2 WHERE fld2 IN (SELECT fld1 FROM t1);
SHOW CREATE VIEW v7;
View	Create View	character_set_client	collation_connection
v7	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v7` AS select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2` where `db`.`t2`.`fld2` in (select `t1`.`fld1` from `t1`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v8 AS SELECT * FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v8;
View	Create View	character_set_client	collation_connection
v8	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v8` AS select `t1`.`fld1` AS `fld1` from `t1` where (not(`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`)))	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v9 AS SELECT fld1 FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v9;
View	Create View	character_set_client	collation_connection
v9	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v9` AS select `t1`.`fld1` AS `fld1` from `t1` where (not(`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`)))	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v10 AS SELECT t1.fld1 FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v10;
View	Create View	character_set_client	collation_connection
v10	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v10` AS select `t1`.`fld1` AS `fld1` from `t1` where (not(`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`)))	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v11 AS SELECT * FROM db.t1 WHERE fld1 NOT IN
(SELECT fld2 FROM db.t2);
SHOW CREATE VIEW v11;
View	Create View	character_set_client	collation_connection
v11	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v11` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` where (not(`db`.`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`)))	utf8mb4	utf8mb4_0900_ai_ci
# Test cases which uses derived table in sub query.
CREATE VIEW v12 AS SELECT * FROM (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW v12;
View	Create View	character_set_client	collation_connection
v12	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v12` AS select `dummy`.`fld1` AS `fld1` from (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v13 AS SELECT * FROM (SELECT fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v13;
View	Create View	character_set_client	collation_connection
v13	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v13` AS select `dummy`.`fld1` AS `fld1` from (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v14 AS SELECT * FROM db.t2, (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW v14;
View	Create View	character_set_client	collation_connection
v14	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v14` AS select `db`.`t2`.`fld2` AS `fld2`,`dummy`.`fld1` AS `fld1` from (`db`.`t2` join (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v15 AS SELECT * FROM db.t2, (SELECT fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v15;
View	Create View	character_set_client	collation_connection
v15	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v15` AS select `db`.`t2`.`fld2` AS `fld2`,`dummy`.`fld1` AS `fld1` from (`db`.`t2` join (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v16 AS SELECT db.t2.fld2 FROM db.t2, (SELECT t1.fld1 FROM db.t1) dummy;
SHOW CREATE VIEW v16;
View	Create View	character_set_client	collation_connection
v16	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v16` AS select `db`.`t2`.`fld2` AS `fld2` from (`db`.`t2` join (select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1`) `dummy`)	utf8mb4	utf8mb4_0900_ai_ci
# Test cases using CTE.
CREATE VIEW v17 AS WITH cte AS (SELECT * FROM t1) SELECT * FROM cte;
SHOW CREATE VIEW v17;
View	Create View	character_set_client	collation_connection
v17	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v17` AS with `cte` as (select `t1`.`fld1` AS `fld1` from `t1`) select `cte`.`fld1` AS `fld1` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v18 AS WITH cte AS (SELECT fld1 FROM t1) SELECT * FROM cte;
SHOW CREATE VIEW v18;
View	Create View	character_set_client	collation_connection
v18	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v18` AS with `cte` as (select `t1`.`fld1` AS `fld1` from `t1`) select `cte`.`fld1` AS `fld1` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW v19 AS WITH cte AS (SELECT db.t2.fld2 FROM db.t2) SELECT * FROM cte;
SHOW CREATE VIEW v19;
View	Create View	character_set_client	collation_connection
v19	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v19` AS with `cte` as (select `db`.`t2`.`fld2` AS `fld2` from `db`.`t2`) select `cte`.`fld2` AS `fld2` from `cte`	utf8mb4	utf8mb4_0900_ai_ci
# Test case added for coverage where view is created in different db.
CREATE VIEW db.v1 AS SELECT * FROM db.t1 UNION SELECT * FROM t2;
SHOW CREATE VIEW db.v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v1` AS select `db`.`t1`.`fld1` AS `fld1` from `db`.`t1` union select `t2`.`fld2` AS `fld2` from `t2`	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW db.v2 AS SELECT * FROM t1 where fld1 NOT IN (SELECT fld2 FROM db.t2);
SHOW CREATE VIEW db.v2;
View	Create View	character_set_client	collation_connection
v2	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v2` AS select `t1`.`fld1` AS `fld1` from `t1` where (not(`t1`.`fld1` in (select `db`.`t2`.`fld2` from `db`.`t2`)))	utf8mb4	utf8mb4_0900_ai_ci
CREATE VIEW db.v3 AS SELECT * FROM (SELECT fld1 FROM t1) dummy;
SHOW CREATE VIEW db.v3;
View	Create View	character_set_client	collation_connection
v3	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `db`.`v3` AS select `dummy`.`fld1` AS `fld1` from (select `t1`.`fld1` AS `fld1` from `t1`) `dummy`	utf8mb4	utf8mb4_0900_ai_ci
# Cleanup.
DROP VIEW v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
v16, v17, v18, v19;
DROP TABLE t1, t2;
DROP DATABASE db;
#
# Bug#25832861: TABLE_SHARE->TMP_TABLE != NO_TMP_TABLE || M_LOCK_TYPE == 1' AT HANDLER::HA_UPDAT
#
CREATE TABLE t1 (a INTEGER);
INSERT INTO t1 VALUES (1), (2);
CREATE VIEW v1 AS SELECT a FROM t1;
CREATE VIEW v2 AS SELECT 1;
CREATE VIEW v3 AS SELECT a FROM (SELECT a FROM v1) AS dt;
CREATE VIEW v4 AS SELECT a FROM (SELECT a FROM t1) AS dt;
CREATE VIEW v5 AS SELECT a FROM (SELECT a FROM v3) AS dt2;
UPDATE v3 SET v3.a=3;
ERROR HY000: The target table v3 of the UPDATE is not updatable
UPDATE v3, v2 SET v3.a=3;
ERROR HY000: The target table v3 of the UPDATE is not updatable
UPDATE v3, v1 SET v1.a=3;
SELECT * FROM t1;
a
3
3
UPDATE v3, t1 SET t1.a=4;
SELECT * FROM t1;
a
4
4
UPDATE v4 SET v4.a=6;
ERROR HY000: The target table v4 of the UPDATE is not updatable
SELECT * FROM t1;
a
4
4
UPDATE v4, v2 SET v4.a=6;
ERROR HY000: The target table v4 of the UPDATE is not updatable
UPDATE v4, v1 SET v1.a=6;
SELECT * FROM t1;
a
6
6
UPDATE v4, t1 SET t1.a=7;
SELECT * FROM t1;
a
7
7
UPDATE v5 SET v5.a=9;
ERROR HY000: The target table v5 of the UPDATE is not updatable
UPDATE v5, v2 SET v5.a=9;
ERROR HY000: The target table v5 of the UPDATE is not updatable
UPDATE v5, v1 SET v1.a=9;
SELECT * FROM t1;
a
9
9
UPDATE v5, t1 SET t1.a=10;
SELECT * FROM t1;
a
10
10
DROP TABLE t1;
DROP VIEW v1, v2, v3, v4, v5;
# Bug#26659699 Assertion !(thd->lex->context_analysis_only & 2) failed
CREATE TABLE t1(pk INTEGER, cik INTEGER, UNIQUE KEY(cik))
PARTITION BY KEY(cik) PARTITIONS 10;
CREATE TABLE t2(pk INTEGER, cvk VARCHAR(20), cik INTEGER, UNIQUE KEY(cik))
PARTITION BY KEY(cik) PARTITIONS 10;
CREATE VIEW v1 AS
SELECT MAX(t2.pk) AS field1
FROM t1, t2
WHERE (SELECT 7 FROM DUAL) IS NOT NULL AND
t1.pk BETWEEN 123 AND (123 + 128) AND
t2.cvk <= 'p'
ORDER BY t1.pk DESC;
DROP VIEW v1;
DROP TABLE t1, t2;
#
# BUG#26266789: ON SERVER 8.0 CREATE OR REPLACE VIEW FAILS FOR COLUMN SIZE > 64
#
CREATE TABLE t1(fld1 INT, fld2 INT);
INSERT INTO t1 VALUES(1, 1);
# Without patch, a dictionary store error is triggered on release
# build and an assert on debug build.
CREATE OR REPLACE VIEW v1
(`x12345678901234567890123456789012345678901234567890123456789012322`) AS
SELECT fld1 FROM t1;
ERROR 42000: Incorrect column name 'x12345678901234567890123456789012345678901234567890123456789012322'
# Clean up.
DROP TABLE t1;
#
# Bug#26360114 WRONG RESULT WITH AGGREGATE AND HAVING CLAUSE IN VIEW
#
CREATE TABLE t1 (
col_date_key DATE,
KEY col_date_key (col_date_key)
);
INSERT INTO t1 VALUES ('2007-02-08');
INSERT INTO t1 VALUES ('2007-02-08');
INSERT INTO t1 VALUES ('2008-11-04');
INSERT INTO t1 VALUES ('2008-11-04');
INSERT INTO t1 VALUES ('2009-01-14');
INSERT INTO t1 VALUES ('2009-01-14');
SELECT MAX(col_date_key) AS x
FROM t1
HAVING x >= CAST('2009-01-01' AS DATE)
;
x
2009-01-14
CREATE VIEW v1 AS
SELECT MAX(col_date_key) AS x
FROM t1
HAVING x >= CAST('2009-01-01' AS DATE)
;
SELECT * FROM v1;
x
2009-01-14
DROP VIEW v1;
DROP TABLE t1;
#
# Bug#27121663: SIG 11 IN FILL_DD_VIEW_TABLES | SQL/DD/DD_VIEW.CC
#
CREATE TABLE t1 (pk INT);
CREATE VIEW v1 AS SELECT COUNT(*) FROM t1
ORDER BY (SELECT 1 FROM t1 WHERE 1 IN (SELECT * FROM (SELECT 1 as field) AS dt));
DROP TABLE t1;
DROP VIEW v1;
