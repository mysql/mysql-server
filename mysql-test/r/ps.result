call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');
SET @old_log_output=@@global.log_output;
SET GLOBAL log_output="FILE,TABLE";
drop table if exists t1,t2,t3,t4;
drop database if exists client_test_db;
create table t1
(
a int primary key,
b char(10)
);
insert into t1 values (1,'one');
insert into t1 values (2,'two');
insert into t1 values (3,'three');
insert into t1 values (4,'four');
set @a=2;
prepare stmt1 from 'select * from t1 where a <= ?';
execute stmt1 using @a;
a	b
1	one
2	two
set @a=3;
execute stmt1 using @a;
a	b
1	one
2	two
3	three
deallocate prepare no_such_statement;
ERROR HY000: Unknown prepared statement handler (no_such_statement) given to DEALLOCATE PREPARE
execute stmt1;
ERROR HY000: Incorrect arguments to EXECUTE
prepare stmt2 from 'prepare nested_stmt from "select 1"';
ERROR HY000: This command is not supported in the prepared statement protocol yet
prepare stmt2 from 'execute stmt1';
ERROR HY000: This command is not supported in the prepared statement protocol yet
prepare stmt2 from 'deallocate prepare z';
ERROR HY000: This command is not supported in the prepared statement protocol yet
prepare stmt3 from 'insert into t1 values (?,?)';
set @arg1=5, @arg2='five';
execute stmt3 using @arg1, @arg2;
select * from t1 where a>3;
a	b
4	four
5	five
prepare stmt4 from 'update t1 set a=? where b=?';
set @arg1=55, @arg2='five';
execute stmt4 using @arg1, @arg2;
select * from t1 where a>3;
a	b
4	four
55	five
prepare stmt4 from 'create table t2 (a int)';
execute stmt4;
prepare stmt4 from 'drop table t2';
execute stmt4;
execute stmt4;
ERROR 42S02: Unknown table 'test.t2'
prepare stmt5 from 'select ? + a from t1';
set @a=1;
execute stmt5 using @a;
? + a
2
3
4
5
56
execute stmt5 using @no_such_var;
? + a
NULL
NULL
NULL
NULL
NULL
set @nullvar=1;
set @nullvar=NULL;
execute stmt5 using @nullvar;
? + a
NULL
NULL
NULL
NULL
NULL
set @nullvar2=NULL;
execute stmt5 using @nullvar2;
? + a
NULL
NULL
NULL
NULL
NULL
prepare stmt6 from 'select 1; select2';
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'select2' at line 1
prepare stmt6 from 'insert into t1 values (5,"five"); select2';
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'select2' at line 1
explain prepare stmt6 from 'insert into t1 values (5,"five"); select2';
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'from 'insert into t1 values (5,"five"); select2'' at line 1
create table t2
(
a int
);
insert into t2 values (0);
set @arg00=NULL ;
prepare stmt1 from 'select 1 FROM t2 where a=?' ;
execute stmt1 using @arg00 ;
1
prepare stmt1 from @nosuchvar;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'NULL' at line 1
set @ivar= 1234;
prepare stmt1 from @ivar;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '1234' at line 1
set @fvar= 123.4567;
prepare stmt1 from @fvar;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '123.4567' at line 1
drop table t1,t2;
deallocate prepare stmt3;
deallocate prepare stmt4;
deallocate prepare stmt5;
PREPARE stmt1 FROM "select _utf8mb3 'A' COLLATE utf8mb3_bin = ?";
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
set @var='A';
EXECUTE stmt1 USING @var;
_utf8mb3 'A' COLLATE utf8mb3_bin = ?
1
DEALLOCATE PREPARE stmt1;
create table t1 (id int);
prepare stmt1 from "select FOUND_ROWS()";
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
select SQL_CALC_FOUND_ROWS * from t1;
id
Warnings:
Warning	1287	SQL_CALC_FOUND_ROWS is deprecated and will be removed in a future release. Consider using two separate queries instead.
execute stmt1;
FOUND_ROWS()
0
insert into t1 values (1);
select SQL_CALC_FOUND_ROWS * from t1;
id
1
Warnings:
Warning	1287	SQL_CALC_FOUND_ROWS is deprecated and will be removed in a future release. Consider using two separate queries instead.
execute stmt1;
FOUND_ROWS()
1
execute stmt1;
FOUND_ROWS()
1
deallocate prepare stmt1;
drop table t1;
create table t1 
(
c1  tinyint, c2  smallint, c3  mediumint, c4  int,
c5  integer, c6  bigint, c7  float, c8  double,
c9  double precision, c10 real, c11 decimal(7, 4), c12 numeric(8, 4),
c13 date, c14 datetime, c15 timestamp, c16 time,
c17 year, c18 bit, c19 bool, c20 char,
c21 char(10), c22 varchar(30), c23 tinyblob, c24 tinytext,
c25 blob, c26 text, c27 mediumblob, c28 mediumtext,
c29 longblob, c30 longtext, c31 enum('one', 'two', 'three'),
c32 set('monday', 'tuesday', 'wednesday')
) engine = MYISAM ;
create table t2 like t1;
set @stmt= ' explain SELECT (SELECT SUM(c1 + c12 + 0.0) FROM t2 where (t1.c2 - 0e-3) = t2.c2 GROUP BY t1.c15 LIMIT 1) as scalar_s, exists (select 1.0e+0 from t2 where t2.c3 * 9.0000000000 = t1.c4) as exists_s, c5 * 4 in (select c6 + 0.3e+1 from t2) as in_s, (c7 - 4, c8 - 4) in (select c9 + 4.0, c10 + 40e-1 from t2) as in_row_s FROM t1, (select c25 x, c32 y from t2) tt WHERE x * 1 = c25 ' ;
prepare stmt1 from @stmt ;
Warnings:
Note	1276	Field or reference 'test.t1.c2' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.c15' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.c4' of SELECT #3 was resolved in SELECT #1
execute stmt1 ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
5	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
4	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
3	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
2	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select sum(((`test`.`t2`.`c1` + `test`.`t2`.`c12`) + 0.0)) from `test`.`t2` where ((NULL - 0e-3) = `test`.`t2`.`c2`) group by NULL limit 1) AS `scalar_s`,exists(/* select#3 */ select 1.0e+0 from `test`.`t2` where ((`test`.`t2`.`c3` * 9.0000000000) = NULL)) AS `exists_s`,<in_optimizer>((NULL * 4),<exists>(/* select#4 */ select (`test`.`t2`.`c6` + 0.3e+1) from `test`.`t2` where <if>(outer_field_is_not_null, ((<cache>((NULL * 4)) = (`test`.`t2`.`c6` + 0.3e+1)) or ((`test`.`t2`.`c6` + 0.3e+1) is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c6` + 0.3e+1)), true))) AS `in_s`,<in_optimizer>(((NULL - 4),(NULL - 4)),<exists>(/* select#5 */ select (`test`.`t2`.`c9` + 4.0),(`test`.`t2`.`c10` + 40e-1) from `test`.`t2` where (<if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c9` + 4.0)) or ((`test`.`t2`.`c9` + 4.0) is null)), true) and <if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c10` + 40e-1)) or ((`test`.`t2`.`c10` + 40e-1) is null)), true)) having (<if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c9` + 4.0)), true) and <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c10` + 40e-1)), true)))) AS `in_row_s` from `test`.`t1` join `test`.`t2` where ((NULL * 1) = NULL)
execute stmt1 ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
5	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
4	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
3	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
2	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
Warnings:
Note	1003	/* select#1 */ select (/* select#2 */ select sum(((`test`.`t2`.`c1` + `test`.`t2`.`c12`) + 0.0)) from `test`.`t2` where ((NULL - 0e-3) = `test`.`t2`.`c2`) group by NULL limit 1) AS `scalar_s`,exists(/* select#3 */ select 1.0e+0 from `test`.`t2` where ((`test`.`t2`.`c3` * 9.0000000000) = NULL)) AS `exists_s`,<in_optimizer>((NULL * 4),<exists>(/* select#4 */ select (`test`.`t2`.`c6` + 0.3e+1) from `test`.`t2` where <if>(outer_field_is_not_null, ((<cache>((NULL * 4)) = (`test`.`t2`.`c6` + 0.3e+1)) or ((`test`.`t2`.`c6` + 0.3e+1) is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c6` + 0.3e+1)), true))) AS `in_s`,<in_optimizer>(((NULL - 4),(NULL - 4)),<exists>(/* select#5 */ select (`test`.`t2`.`c9` + 4.0),(`test`.`t2`.`c10` + 40e-1) from `test`.`t2` where (<if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c9` + 4.0)) or ((`test`.`t2`.`c9` + 4.0) is null)), true) and <if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c10` + 40e-1)) or ((`test`.`t2`.`c10` + 40e-1) is null)), true)) having (<if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c9` + 4.0)), true) and <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c10` + 40e-1)), true)))) AS `in_row_s` from `test`.`t1` join `test`.`t2` where ((NULL * 1) = NULL)
explain SELECT (SELECT SUM(c1 + c12 + 0.0) FROM t2 where (t1.c2 - 0e-3) = t2.c2 GROUP BY t1.c15 LIMIT 1) as scalar_s, exists (select 1.0e+0 from t2 where t2.c3 * 9.0000000000 = t1.c4) as exists_s, c5 * 4 in (select c6 + 0.3e+1 from t2) as in_s, (c7 - 4, c8 - 4) in (select c9 + 4.0, c10 + 40e-1 from t2) as in_row_s FROM t1, (select c25 x, c32 y from t2) tt WHERE x * 1 = c25;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
5	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
4	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
3	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
2	SUBQUERY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Not optimized, outer query is empty
Warnings:
Note	1276	Field or reference 'test.t1.c2' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.c15' of SELECT #2 was resolved in SELECT #1
Note	1276	Field or reference 'test.t1.c4' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select (/* select#2 */ select sum(((`test`.`t2`.`c1` + `test`.`t2`.`c12`) + 0.0)) from `test`.`t2` where ((NULL - 0e-3) = `test`.`t2`.`c2`) group by NULL limit 1) AS `scalar_s`,exists(/* select#3 */ select 1.0e+0 from `test`.`t2` where ((`test`.`t2`.`c3` * 9.0000000000) = NULL)) AS `exists_s`,<in_optimizer>((NULL * 4),<exists>(/* select#4 */ select (`test`.`t2`.`c6` + 0.3e+1) from `test`.`t2` where <if>(outer_field_is_not_null, ((<cache>((NULL * 4)) = (`test`.`t2`.`c6` + 0.3e+1)) or ((`test`.`t2`.`c6` + 0.3e+1) is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c6` + 0.3e+1)), true))) AS `in_s`,<in_optimizer>(((NULL - 4),(NULL - 4)),<exists>(/* select#5 */ select (`test`.`t2`.`c9` + 4.0),(`test`.`t2`.`c10` + 40e-1) from `test`.`t2` where (<if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c9` + 4.0)) or ((`test`.`t2`.`c9` + 4.0) is null)), true) and <if>(outer_field_is_not_null, ((<cache>((NULL - 4)) = (`test`.`t2`.`c10` + 40e-1)) or ((`test`.`t2`.`c10` + 40e-1) is null)), true)) having (<if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c9` + 4.0)), true) and <if>(outer_field_is_not_null, <is_not_null_test>((`test`.`t2`.`c10` + 40e-1)), true)))) AS `in_row_s` from `test`.`t1` join `test`.`t2` where ((NULL * 1) = NULL)
deallocate prepare stmt1;
drop tables t1,t2;
set @arg00=1;
prepare stmt1 from ' create table t1 (m int) as select 1 as m ' ;
execute stmt1 ;
select m from t1;
m
1
drop table t1;
prepare stmt1 from ' create table t1 (m int) as select ? as m ' ;
execute stmt1 using @arg00;
select m from t1;
m
1
deallocate prepare stmt1;
drop table t1;
create table t1 (id int(10) unsigned NOT NULL default '0',
name varchar(64) NOT NULL default '',
PRIMARY KEY  (id), UNIQUE KEY `name` (`name`));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (1,'1'),(2,'2'),(3,'3'),(4,'4'),(5,'5'),(6,'6'),(7,'7');
prepare stmt1 from 'select name from t1 where id=? or id=?';
set @id1=1,@id2=6;
execute stmt1 using @id1, @id2;
name
1
6
select name from t1 where id=1 or id=6;
name
1
6
deallocate prepare stmt1;
drop table t1;
create table t1 ( a int primary key, b varchar(30)) engine = MYISAM ;
analyze table t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
prepare stmt1 from ' show table status from test like ''t1%'' ';
execute stmt1;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	MyISAM	10	Dynamic	0	0	0	4294967295	1024	0	NULL	#	#	#	utf8mb4_0900_ai_ci	NULL		
show table status from test like 't1%' ;
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	MyISAM	10	Dynamic	0	0	0	4294967295	1024	0	NULL	#	#	#	utf8mb4_0900_ai_ci	NULL		
deallocate prepare stmt1 ;
drop table t1;
create table t1(a varchar(2), b varchar(3));
prepare stmt1 from "select a, b from t1 where (not (a='aa' and b < 'zzz'))";
execute stmt1;
a	b
execute stmt1;
a	b
deallocate prepare stmt1;
drop table t1;
prepare stmt1 from "select 1 into @var";
execute stmt1;
execute stmt1;
prepare stmt1 from "create table t1 select 1 as i";
execute stmt1;
drop table t1;
execute stmt1;
prepare stmt1 from "insert into t1 select i from t1";
execute stmt1;
execute stmt1;
prepare stmt1 from "select * from t1 into outfile '<MYSQLTEST_VARDIR>/tmp/f1.txt'";
execute stmt1;
deallocate prepare stmt1;
drop table t1;
prepare stmt1 from 'select 1';
prepare STMT1 from 'select 2';
execute sTmT1;
2
2
deallocate prepare StMt1;
deallocate prepare Stmt1;
ERROR HY000: Unknown prepared statement handler (Stmt1) given to DEALLOCATE PREPARE
set names utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
prepare `Ã¼` from 'select 1234';
execute `Ã¼` ;
1234
1234
set names latin1;
execute `ü`;
1234
1234
deallocate prepare `ü`;
set names default;
create table t1 (a varchar(10)) charset=utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
insert into t1 (a) values ('yahoo');
set character_set_connection=latin1;
prepare stmt from 'select a from t1 where a like ?';
set @var='google';
execute stmt using @var;
a
execute stmt using @var;
a
deallocate prepare stmt;
drop table t1;
create table t1 (a bigint(20) not null primary key auto_increment);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 (a) values (null);
select * from t1;
a
1
prepare stmt from "insert into t1 (a) values (?)";
set @var=null;
execute stmt using @var;
select * from t1;
a
1
2
drop table t1;
create table t1 (a timestamp not null);
prepare stmt from "insert into t1 (a) values (CURRENT_TIMESTAMP)";
execute stmt;
select * from t1;
deallocate prepare stmt;
drop table t1;
prepare stmt from "select 'abc' like convert('abc' using utf8mb3)";
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
execute stmt;
'abc' like convert('abc' using utf8mb3)
1
execute stmt;
'abc' like convert('abc' using utf8mb3)
1
deallocate prepare stmt;
create table t1 ( a bigint );
prepare stmt from 'select a from t1 where a between ? and ?';
set @a=1;
execute stmt using @a, @a;
a
execute stmt using @a, @a;
a
execute stmt using @a, @a;
a
drop table t1;
deallocate prepare stmt;
create table t1 (a int);
prepare stmt from "select * from t1 where 1 > (1 in (SELECT * FROM t1))";
execute stmt;
a
execute stmt;
a
execute stmt;
a
drop table t1;
deallocate prepare stmt;
create table t1 (a int, b int) engine = myisam;
insert into t1 (a, b) values (1,1), (1,2), (2,1), (2,2);
prepare stmt from
"explain select * from t1 where t1.a=2 and t1.a=t1.b and t1.b > 1 + ?";
set @v=5;
execute stmt using @v;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
-	-	-	-	-	-	-	-	NULL	NULL	NULL	Impossible WHERE
Warnings:
-	-	-
set @v=0;
execute stmt using @v;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
-	-	-	-	-	-	-	-	NULL	4	25.00	Using where
Warnings:
-	-	-
set @v=5;
execute stmt using @v;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
-	-	-	-	-	-	-	-	NULL	NULL	NULL	Impossible WHERE
Warnings:
-	-	-
drop table t1;
deallocate prepare stmt;
create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4);
set @precision=10000000000;
select rand(), 
cast(rand(10)*@precision as unsigned integer) from t1;
rand()	cast(rand(10)*@precision as unsigned integer)
-	6570515220
-	1282061302
-	6698761160
-	9647622201
prepare stmt from
"select rand(), 
        cast(rand(10)*@precision as unsigned integer),
        cast(rand(?)*@precision as unsigned integer) from t1";
set @var=1;
execute stmt using @var;
rand()	cast(rand(10)*@precision as unsigned integer)	cast(rand(?)*@precision as unsigned integer)
-	6570515220	-
-	1282061302	-
-	6698761160	-
-	9647622201	-
set @var=2;
execute stmt using @var;
rand()	cast(rand(10)*@precision as unsigned integer)	cast(rand(?)*@precision as unsigned integer)
-	6570515220	6555866465
-	1282061302	1223466193
-	6698761160	6449731874
-	9647622201	8578261098
set @var=3;
execute stmt using @var;
rand()	cast(rand(10)*@precision as unsigned integer)	cast(rand(?)*@precision as unsigned integer)
-	6570515220	9057697560
-	1282061302	3730790581
-	6698761160	1480860535
-	9647622201	6211931236
drop table t1;
deallocate prepare stmt;
create database mysqltest1;
create table t1 (a int);
create table mysqltest1.t1 (a int);
select * from t1, mysqltest1.t1;
a	a
prepare stmt from "select * from t1, mysqltest1.t1";
execute stmt;
a	a
execute stmt;
a	a
execute stmt;
a	a
drop table t1;
drop table mysqltest1.t1;
drop database mysqltest1;
deallocate prepare stmt;
select '1.1' as a, '1.2' as a UNION SELECT '2.1', '2.2';
a	a
1.1	1.2
2.1	2.2
prepare stmt from
"select '1.1' as a, '1.2' as a UNION SELECT '2.1', '2.2'";
execute stmt;
a	a
1.1	1.2
2.1	2.2
execute stmt;
a	a
1.1	1.2
2.1	2.2
execute stmt;
a	a
1.1	1.2
2.1	2.2
deallocate prepare stmt;
create table t1 (a int);
insert into t1 values (1),(2),(3);
create table t2 select * from t1;
prepare stmt FROM 'create table t2 select * from t1';
drop table t2;
execute stmt;
drop table t2;
execute stmt;
execute stmt;
ERROR 42S01: Table 't2' already exists
drop table t2;
execute stmt;
drop table t1,t2;
deallocate prepare stmt;
create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
prepare stmt from "select sql_calc_found_rows * from t1 limit 2";
Warnings:
Warning	1287	SQL_CALC_FOUND_ROWS is deprecated and will be removed in a future release. Consider using two separate queries instead.
execute stmt;
a
1
2
select found_rows();
found_rows()
10
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
execute stmt;
a
1
2
select found_rows();
found_rows()
10
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
execute stmt;
a
1
2
select found_rows();
found_rows()
10
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
deallocate prepare stmt;
drop table t1;
CREATE TABLE t1 (N int, M tinyint);
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
prepare stmt from "select ? is null, ? is not null, ?";
select @no_such_var is null, @no_such_var is not null, @no_such_var;
@no_such_var is null	@no_such_var is not null	@no_such_var
1	0	NULL
execute stmt using @no_such_var, @no_such_var, @no_such_var;
? is null	? is not null	?
1	0	NULL
set @var='abc';
select @var is null, @var is not null, @var;
@var is null	@var is not null	@var
0	1	abc
execute stmt using @var, @var, @var;
? is null	? is not null	?
0	1	abc
set @var=null;
select @var is null, @var is not null, @var;
@var is null	@var is not null	@var
1	0	NULL
execute stmt using @var, @var, @var;
? is null	? is not null	?
1	0	NULL
create table t1 (pnum char(3));
create table t2 (pnum char(3));
prepare stmt from "select pnum from t2 having pnum in (select 'p1' from t1)";
execute stmt;
pnum
execute stmt;
pnum
execute stmt;
pnum
deallocate prepare stmt;
drop table t1, t2;
drop table if exists t1;
create temporary table if not exists t1 (a1 int);
prepare stmt from "delete t1 from t1 where (cast(a1/3 as unsigned) * 3) = a1";
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
deallocate prepare stmt;
create table t1 (a varchar(20));
insert into t1 values ('foo');
prepare stmt FROM 'SELECT char_length (a) FROM t1';
prepare stmt2 FROM 'SELECT not_a_function (a) FROM t1';
ERROR 42000: FUNCTION test.not_a_function does not exist
drop table t1;
prepare stmt from "SELECT SQL_CALC_FOUND_ROWS 'foo' UNION SELECT 'bar' LIMIT 0";
Warnings:
Warning	1287	SQL_CALC_FOUND_ROWS is deprecated and will be removed in a future release. Consider using two separate queries instead.
execute stmt;
foo
SELECT FOUND_ROWS();
FOUND_ROWS()
2
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
execute stmt;
foo
SELECT FOUND_ROWS();
FOUND_ROWS()
2
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
deallocate prepare stmt;
drop table if exists t1;
Warnings:
Note	1051	Unknown table 'test.t1'
create table t1 (c1 int(11) not null, c2 int(11) not null,
primary key  (c1,c2), key c2 (c2), key c1 (c1));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (200887, 860);
insert into t1 values (200887, 200887);
select * from t1 where (c1=200887 and c2=200887) or c2=860;
c1	c2
200887	860
200887	200887
prepare stmt from
"select * from t1 where (c1=200887 and c2=200887) or c2=860";
execute stmt;
c1	c2
200887	860
200887	200887
prepare stmt from
"select * from t1 where (c1=200887 and c2=?) or c2=?";
set @a=200887, @b=860;
execute stmt using @a, @b;
c1	c2
200887	860
200887	200887
deallocate prepare stmt;
drop table t1;
create table t1 (
id bigint(20) not null auto_increment,
code varchar(20) character set utf8mb3 COLLATE utf8mb3_bin not null default '',
company_name varchar(250) character set utf8mb3 COLLATE utf8mb3_bin default null,
setup_mode tinyint(4) default null,
start_date datetime default null,
primary key  (id), unique key code (code)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
Warning	3778	'utf8mb3_bin' is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead.
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
Warning	3778	'utf8mb3_bin' is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t2 (
id bigint(20) not null auto_increment,
email varchar(250) character set utf8mb3 COLLATE utf8mb3_bin default null,
name varchar(250) character set utf8mb3 COLLATE utf8mb3_bin default null,
t1_id bigint(20) default null,
password varchar(250) character set utf8mb3 COLLATE utf8mb3_bin default null,
primary_contact tinyint(4) not null default '0',
email_opt_in tinyint(4) not null default '1',
primary key  (id), unique key email (email), key t1_id (t1_id),
constraint t2_fk1 foreign key (t1_id) references t1 (id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
Warning	3778	'utf8mb3_bin' is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead.
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
Warning	3778	'utf8mb3_bin' is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
Warning	3778	'utf8mb3_bin' is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values
(1, 'demo', 'demo s', 0, current_date()),
(2, 'code2', 'name 2', 0, current_date()),
(3, 'code3', 'name 3', 0, current_date());
insert into t2 values
(2, 'email1', 'name1', 3, 'password1', 0, 0),
(3, 'email2', 'name1', 1, 'password2', 1, 0),
(5, 'email3', 'name3', 2, 'password3', 0, 0);
prepare stmt from 'select t2.id from t2, t1 where (t1.id=? and t2.t1_id=t1.id)';
set @a=1;
execute stmt using @a;
id
3
select t2.id from t2, t1 where (t1.id=1 and t2.t1_id=t1.id);
id
3
deallocate prepare stmt;
drop table t2, t1;
create table t1 (id int);
prepare stmt from "insert into t1 (id) select id from t1 union select id from t1";
execute stmt;
execute stmt;
deallocate prepare stmt;
drop table t1;
create table t1 (
id int(11) unsigned not null primary key auto_increment,
partner_id varchar(35) not null,
t1_status_id int(10) unsigned
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values ("1", "partner1", "10"), ("2", "partner2", "10"),
("3", "partner3", "10"), ("4", "partner4", "10");
create table t2 (
id int(11) unsigned not null default '0',
t1_line_id int(11) unsigned not null default '0',
article_id varchar(20),
sequence int(11) not null default '0',
primary key  (id,t1_line_id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t2 values ("1", "1", "sup", "0"), ("2", "1", "sup", "1"),
("2", "2", "sup", "2"), ("2", "3", "sup", "3"),
("2", "4", "imp", "4"), ("3", "1", "sup", "0"),
("4", "1", "sup", "0");
create table t3 (
id int(11) not null default '0',
preceding_id int(11) not null default '0',
primary key  (id,preceding_id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t4 (
user_id varchar(50) not null,
article_id varchar(20) not null,
primary key  (user_id,article_id)
);
insert into t4 values("nicke", "imp");
prepare stmt from
'select distinct t1.partner_id
from t1 left join t3 on t1.id = t3.id
     left join t1 pp on pp.id = t3.preceding_id
where
  exists (
    select *
    from t2 as pl_inner
    where pl_inner.id = t1.id
    and pl_inner.sequence <= (
      select min(sequence) from t2 pl_seqnr
      where pl_seqnr.id = t1.id
    )
    and exists (
      select * from t4
      where t4.article_id = pl_inner.article_id
      and t4.user_id = ?
    )
  )
  and t1.id = ?
group by t1.id
having count(pp.id) = 0';
set @user_id = 'nicke';
set @id = '2';
execute stmt using @user_id, @id;
partner_id
execute stmt using @user_id, @id;
partner_id
deallocate prepare stmt;
drop table t1, t2, t3, t4;
prepare stmt from 'select ?=?';
set @a='CHRISTINE           ';
set @b='CHRISTINE';
execute stmt using @a, @b;
?=?
1
execute stmt using @a, @b;
?=?
1
set @a=1, @b=2;
execute stmt using @a, @b;
?=?
0
set @a='CHRISTINE           ';
set @b='CHRISTINE';
execute stmt using @a, @b;
?=?
1
Warnings:
Warning	1292	Truncated incorrect INTEGER value: 'CHRISTINE           '
Warning	1292	Truncated incorrect INTEGER value: 'CHRISTINE'
deallocate prepare stmt;
create table t1 (a int);
prepare stmt from "select ??";
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?' at line 1
prepare stmt from "select ?FROM t1";
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?FROM t1' at line 1
prepare stmt from "select FROM t1 WHERE?=1";
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FROM t1 WHERE?=1' at line 1
prepare stmt from "update t1 set a=a+?WHERE 1";
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?WHERE 1' at line 1
select ?;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?' at line 1
select ??;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '??' at line 1
select ? from t1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '? from t1' at line 1
drop table t1;
prepare stmt from "select @@time_zone";
execute stmt;
@@time_zone
SYSTEM
set @@time_zone:='Japan';
execute stmt;
@@time_zone
Japan
prepare stmt from "select @@transaction_isolation";
execute stmt;
@@transaction_isolation
REPEATABLE-READ
set transaction isolation level read committed;
execute stmt;
@@transaction_isolation
REPEATABLE-READ
set transaction isolation level serializable;
execute stmt;
@@transaction_isolation
REPEATABLE-READ
set @@transaction_isolation=default;
execute stmt;
@@transaction_isolation
REPEATABLE-READ
deallocate prepare stmt;
prepare stmt from "create temporary table t1 (letter enum('','a','b','c')
not null)";
execute stmt;
drop table t1;
execute stmt;
drop table t1;
execute stmt;
drop table t1;
set names latin1;
prepare stmt from "create table t1 (a enum('test') default 'test')
 character set utf8mb3";
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
execute stmt;
drop table t1;
execute stmt;
drop table t1;
execute stmt;
drop table t1;
set names default;
deallocate prepare stmt;
create table t1 (
word_id mediumint(8) unsigned not null default '0',
formatted varchar(20) not null default ''
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values
(80,'pendant'), (475,'pretendants'), (989,'tendances'),
(1019,'cependant'),(1022,'abondance'),(1205,'independants'),
(13,'lessiver'),(25,'lambiner'),(46,'situer'),(71,'terminer'),
(82,'decrocher');
select count(*) from t1 where formatted like '%NDAN%';
count(*)
6
select count(*) from t1 where formatted like '%ER';
count(*)
5
prepare stmt from "select count(*) from t1 where formatted like ?";
set @like="%NDAN%";
execute stmt using @like;
count(*)
6
set @like="%ER";
execute stmt using @like;
count(*)
5
set @like="%NDAN%";
execute stmt using @like;
count(*)
6
set @like="%ER";
execute stmt using @like;
count(*)
5
deallocate prepare stmt;
drop table t1;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
prepare stmt from 'create table t1 (a varchar(10) character set utf8mb3)';
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
execute stmt;
insert into t1 (a) values (repeat('a', 20));
select length(a) from t1;
length(a)
10
drop table t1;
execute stmt;
insert into t1 (a) values (repeat('a', 20));
select length(a) from t1;
length(a)
10
drop table t1;
deallocate prepare stmt;
SET sql_mode = default;
create table t1 (col1 integer, col2 integer);
insert into t1 values(100,100),(101,101),(102,102),(103,103);
prepare stmt from 'select col1, col2 from t1 where (col1, col2) in ((?,?))';
set @a=100, @b=100;
execute stmt using @a,@b;
col1	col2
100	100
set @a=101, @b=101;
execute stmt using @a,@b;
col1	col2
101	101
set @a=102, @b=102;
execute stmt using @a,@b;
col1	col2
102	102
set @a=102, @b=103;
execute stmt using @a,@b;
col1	col2
deallocate prepare stmt;
drop table t1;
set @old_max_prepared_stmt_count= @@max_prepared_stmt_count;
show variables like 'max_prepared_stmt_count';
Variable_name	Value
max_prepared_stmt_count	16382
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
16382
set global max_prepared_stmt_count=-1;
Warnings:
Warning	1292	Truncated incorrect max_prepared_stmt_count value: '-1'
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
0
set global max_prepared_stmt_count=10000000000000000;
Warnings:
Warning	1292	Truncated incorrect max_prepared_stmt_count value: '10000000000000000'
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
4194304
set global max_prepared_stmt_count=default;
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
16382
set @@max_prepared_stmt_count=1;
ERROR HY000: Variable 'max_prepared_stmt_count' is a GLOBAL variable and should be set with SET GLOBAL
set max_prepared_stmt_count=1;
ERROR HY000: Variable 'max_prepared_stmt_count' is a GLOBAL variable and should be set with SET GLOBAL
set local max_prepared_stmt_count=1;
ERROR HY000: Variable 'max_prepared_stmt_count' is a GLOBAL variable and should be set with SET GLOBAL
set global max_prepared_stmt_count=1;
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
1
set global max_prepared_stmt_count=0;
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
0
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
prepare stmt from "select 1";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 0)
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
set global max_prepared_stmt_count=1;
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	1
prepare stmt1 from "select 1";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 1)
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	1
deallocate prepare stmt;
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
prepare stmt from "select 1";
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	1
prepare stmt from "select 2";
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	1
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	1
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
1
set global max_prepared_stmt_count=0;
prepare stmt from "select 1";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 0)
execute stmt;
ERROR HY000: Unknown prepared statement handler (stmt) given to EXECUTE
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
prepare stmt from "select 1";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 0)
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
set global max_prepared_stmt_count=3;
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
3
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
prepare stmt from "select 1";
prepare stmt from "select 2";
prepare stmt1 from "select 3";
prepare stmt2 from "select 4";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 3)
prepare stmt2 from "select 4";
ERROR 42000: Can't create more than max_prepared_stmt_count statements (current value: 3)
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
3
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	3
deallocate prepare stmt;
select @@max_prepared_stmt_count;
@@max_prepared_stmt_count
3
show status like 'prepared_stmt_count';
Variable_name	Value
Prepared_stmt_count	0
set global max_prepared_stmt_count= @old_max_prepared_stmt_count;
drop table if exists t1;
create temporary table if not exists t1 (a1 int);
prepare stmt from "delete t1 from t1 where (cast(a1/3 as unsigned) * 3) = a1";
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
create temporary table if not exists t1 (a1 int);
execute stmt;
drop temporary table t1;
deallocate prepare stmt;
CREATE TABLE t1(
ID int(10) unsigned NOT NULL auto_increment,
Member_ID varchar(15) NOT NULL default '',
Action varchar(12) NOT NULL,
Action_Date datetime NOT NULL,
Track varchar(15) default NULL,
User varchar(12) default NULL,
Date_Updated timestamp NOT NULL default CURRENT_TIMESTAMP on update
CURRENT_TIMESTAMP,
PRIMARY KEY (ID),
KEY Action (Action),
KEY Action_Date (Action_Date)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1(Member_ID, Action, Action_Date, Track) VALUES
('111111', 'Disenrolled', '2006-03-01', 'CAD' ),
('111111', 'Enrolled', '2006-03-01', 'CAD' ),
('111111', 'Disenrolled', '2006-07-03', 'CAD' ),
('222222', 'Enrolled', '2006-03-07', 'CAD' ),
('222222', 'Enrolled', '2006-03-07', 'CHF' ),
('222222', 'Disenrolled', '2006-08-02', 'CHF' ),
('333333', 'Enrolled', '2006-03-01', 'CAD' ),
('333333', 'Disenrolled', '2006-03-01', 'CAD' ),
('444444', 'Enrolled', '2006-03-01', 'CAD' ),
('555555', 'Disenrolled', '2006-03-01', 'CAD' ),
('555555', 'Enrolled', '2006-07-21', 'CAD' ),
('555555', 'Disenrolled', '2006-03-01', 'CHF' ),
('666666', 'Enrolled', '2006-02-09', 'CAD' ),
('666666', 'Enrolled', '2006-05-12', 'CHF' ),
('666666', 'Disenrolled', '2006-06-01', 'CAD' );
PREPARE STMT FROM
"SELECT GROUP_CONCAT(Track SEPARATOR ', ') FROM t1
  WHERE Member_ID=? AND Action='Enrolled' AND
        (Track,Action_Date) IN (SELECT Track, MAX(Action_Date) FROM t1
                                  WHERE Member_ID=?
                                    GROUP BY Track 
                                      HAVING Track>='CAD' AND
                                             MAX(Action_Date)>'2006-03-01')";
SET @id='111111';
EXECUTE STMT USING @id,@id;
GROUP_CONCAT(Track SEPARATOR ', ')
NULL
SET @id='222222';
EXECUTE STMT USING @id,@id;
GROUP_CONCAT(Track SEPARATOR ', ')
CAD
DEALLOCATE PREPARE STMT;
DROP TABLE t1;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (i INT, INDEX(i));
INSERT INTO t1 VALUES (1);
PREPARE stmt FROM "SELECT (COUNT(i) = 1), COUNT(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(COUNT(i) = 1)	COUNT(i)
0	0
SET @a = 1;
EXECUTE stmt USING @a;
(COUNT(i) = 1)	COUNT(i)
1	1
SET @a = 0;
EXECUTE stmt USING @a;
(COUNT(i) = 1)	COUNT(i)
0	0
PREPARE stmt FROM "SELECT (AVG(i) = 1), AVG(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(AVG(i) = 1)	AVG(i)
NULL	NULL
SET @a = 1;
EXECUTE stmt USING @a;
(AVG(i) = 1)	AVG(i)
1	1.0000
SET @a = 0;
EXECUTE stmt USING @a;
(AVG(i) = 1)	AVG(i)
NULL	NULL
PREPARE stmt FROM "SELECT (VARIANCE(i) = 1), VARIANCE(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(VARIANCE(i) = 1)	VARIANCE(i)
NULL	NULL
SET @a = 1;
EXECUTE stmt USING @a;
(VARIANCE(i) = 1)	VARIANCE(i)
0	0
SET @a = 0;
EXECUTE stmt USING @a;
(VARIANCE(i) = 1)	VARIANCE(i)
NULL	NULL
PREPARE stmt FROM "SELECT (STDDEV(i) = 1), STDDEV(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(STDDEV(i) = 1)	STDDEV(i)
NULL	NULL
SET @a = 1;
EXECUTE stmt USING @a;
(STDDEV(i) = 1)	STDDEV(i)
0	0
SET @a = 0;
EXECUTE stmt USING @a;
(STDDEV(i) = 1)	STDDEV(i)
NULL	NULL
PREPARE stmt FROM "SELECT (BIT_OR(i) = 1), BIT_OR(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_OR(i) = 1)	BIT_OR(i)
0	0
SET @a = 1;
EXECUTE stmt USING @a;
(BIT_OR(i) = 1)	BIT_OR(i)
1	1
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_OR(i) = 1)	BIT_OR(i)
0	0
PREPARE stmt FROM "SELECT (BIT_AND(i) = 1), BIT_AND(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_AND(i) = 1)	BIT_AND(i)
0	18446744073709551615
SET @a = 1;
EXECUTE stmt USING @a;
(BIT_AND(i) = 1)	BIT_AND(i)
1	1
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_AND(i) = 1)	BIT_AND(i)
0	18446744073709551615
PREPARE stmt FROM "SELECT (BIT_XOR(i) = 1), BIT_XOR(i) FROM t1 WHERE i = ?";
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_XOR(i) = 1)	BIT_XOR(i)
0	0
SET @a = 1;
EXECUTE stmt USING @a;
(BIT_XOR(i) = 1)	BIT_XOR(i)
1	1
SET @a = 0;
EXECUTE stmt USING @a;
(BIT_XOR(i) = 1)	BIT_XOR(i)
0	0
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
CREATE TABLE t1 (i INT);
PREPARE st_19182
FROM "CREATE TABLE t2 (i INT, j INT, KEY (i), KEY(j)) SELECT i FROM t1";
EXECUTE st_19182;
DESC t2;
Field	Type	Null	Key	Default	Extra
j	int	YES	MUL	NULL	
i	int	YES	MUL	NULL	
DROP TABLE t2;
EXECUTE st_19182;
DESC t2;
Field	Type	Null	Key	Default	Extra
j	int	YES	MUL	NULL	
i	int	YES	MUL	NULL	
DEALLOCATE PREPARE st_19182;
DROP TABLE t2, t1;
drop database if exists mysqltest;
drop table if exists t1, t2;
create database mysqltest character set utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
prepare stmt1 from "create table mysqltest.t1 (c char(10))";
prepare stmt2 from "create table mysqltest.t2 select 'test'";
execute stmt1;
execute stmt2;
show create table mysqltest.t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `c` char(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3
show create table mysqltest.t2;
Table	Create Table
t2	CREATE TABLE `t2` (
  `test` varchar(4) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3
drop table mysqltest.t1;
drop table mysqltest.t2;
alter database mysqltest character set latin1;
execute stmt1;
execute stmt2;
show create table mysqltest.t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `c` char(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
show create table mysqltest.t2;
Table	Create Table
t2	CREATE TABLE `t2` (
  `test` varchar(4) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=latin1
drop database mysqltest;
deallocate prepare stmt1;
deallocate prepare stmt2;
execute stmt;
show create table t1;
drop table t1;
execute stmt;
show create table t1;
drop table t1;
deallocate prepare stmt;
CREATE TABLE t1(a int);
INSERT INTO t1 VALUES (2), (3), (1);
PREPARE st1 FROM
'(SELECT a FROM t1) UNION (SELECT a+10 FROM t1) ORDER BY RAND()*0+a';
EXECUTE st1;
a
1
2
3
11
12
13
EXECUTE st1;
a
1
2
3
11
12
13
DEALLOCATE PREPARE st1;
DROP TABLE t1;
create table t1 (a int, b tinyint);
prepare st1 from 'update t1 set b= (str_to_date(a, a))';
execute st1;
deallocate prepare st1;
drop table t1;
End of 4.1 tests.
create table t1 (a varchar(20));
insert into t1 values ('foo');
prepare stmt FROM 'SELECT char_length (a) FROM t1';
prepare stmt2 FROM 'SELECT not_a_function (a) FROM t1';
ERROR 42000: FUNCTION test.not_a_function does not exist
drop table t1;
create table t1 (a char(3) not null, b char(3) not null,
c char(3) not null, primary key  (a, b, c));
create table t2 like t1;
prepare stmt from
"select t1.a from (t1 left outer join t2 on t2.a=1 and t1.b=t2.b)
  where t1.a=1";
execute stmt;
a
execute stmt;
a
execute stmt;
a
prepare stmt from
"select t1.a, t1.b, t1.c, t2.a, t2.b, t2.c from
(t1 left outer join t2 on t2.a=? and t1.b=t2.b)
left outer join t2 t3 on t3.a=? where t1.a=?";
set @a:=1, @b:=1, @c:=1;
execute stmt using @a, @b, @c;
a	b	c	a	b	c
execute stmt using @a, @b, @c;
a	b	c	a	b	c
execute stmt using @a, @b, @c;
a	b	c	a	b	c
deallocate prepare stmt;
drop table t1,t2;
SET @aux= "SELECT COUNT(*)
                FROM INFORMATION_SCHEMA.COLUMNS A,
                INFORMATION_SCHEMA.COLUMNS B
                WHERE A.TABLE_SCHEMA = B.TABLE_SCHEMA
                AND A.TABLE_NAME = B.TABLE_NAME
                AND A.COLUMN_NAME = B.COLUMN_NAME AND
                A.TABLE_NAME = 'user'";
prepare my_stmt from @aux;
execute my_stmt;
COUNT(*)
51
execute my_stmt;
COUNT(*)
51
execute my_stmt;
COUNT(*)
51
deallocate prepare my_stmt;
drop procedure if exists p1|
drop table if exists t1|
create table t1 (id int)|
insert into t1 values(1)|
create procedure p1(a int, b int)
begin
declare c int;
select max(id)+1 into c from t1;
insert into t1 select a+b;
insert into t1 select a-b;
insert into t1 select a-c;
end|
set @a= 3, @b= 4|
prepare stmt from "call p1(?, ?)"|
execute stmt using @a, @b|
execute stmt using @a, @b|
select * from t1|
id
1
7
-1
1
7
-1
-5
deallocate prepare stmt|
drop procedure p1|
drop table t1|
create table t1 (a int);
insert into t1 (a) values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
prepare stmt from "select * from t1 limit ?, ?";
set @offset=0, @limit=1;
execute stmt using @offset, @limit;
a
1
select * from t1 limit 0, 1;
a
1
set @offset=3, @limit=2;
execute stmt using @offset, @limit;
a
4
5
select * from t1 limit 3, 2;
a
4
5
prepare stmt from "select * from t1 limit ?";
execute stmt using @limit;
a
1
2
prepare stmt from "select * from t1 where a in (select a from t1 limit ?)";
ERROR 42000: This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
prepare stmt from "select * from t1 union all select * from t1 limit ?, ?";
set @offset=9;
set @limit=2;
execute stmt using @offset, @limit;
a
10
1
prepare stmt from "(select * from t1 limit ?, ?) union all
                   (select * from t1 limit ?, ?) order by a limit ?";
execute stmt using @offset, @limit, @offset, @limit, @limit;
a
10
10
drop table t1;
deallocate prepare stmt;
CREATE TABLE b12651_T1(a int) ENGINE=MYISAM;
CREATE TABLE b12651_T2(b int) ENGINE=MYISAM;
CREATE VIEW  b12651_V1 as SELECT b FROM b12651_T2;
PREPARE b12651 FROM 'SELECT 1 FROM b12651_T1 WHERE a IN (SELECT b FROM b12651_V1)';
EXECUTE b12651;
1
DROP VIEW b12651_V1;
DROP TABLE b12651_T1, b12651_T2;
DEALLOCATE PREPARE b12651;
create table t1 (id int);
prepare ins_call from "insert into t1 (id) values (1)";
execute ins_call;
select row_count();
row_count()
1
drop table t1;
create table t1 (a int, b int);
insert into t1 (a,b) values (2,8),(1,9),(3,7);
prepare stmt from "select * from t1 order by ?";
set @a=NULL;
execute stmt using @a;
a	b
2	8
1	9
3	7
set @a=1;
execute stmt using @a;
a	b
2	8
1	9
3	7
set @a=2;
execute stmt using @a;
a	b
2	8
1	9
3	7
deallocate prepare stmt;
select * from t1 order by 1;
a	b
1	9
2	8
3	7
prepare stmt from "select * from t1 order by ?+1";
set @a=0;
execute stmt using @a;
a	b
2	8
1	9
3	7
set @a=1;
execute stmt using @a;
a	b
2	8
1	9
3	7
deallocate prepare stmt;
select * from t1 order by 1+1;
a	b
2	8
1	9
3	7
drop table t1;
create table t1 (a int) engine=myisam;
create table t2 like t1;
create table t3 like t2;
prepare stmt from "repair table t1";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
prepare stmt from "optimize table t1";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	OK
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	Table is already up to date
prepare stmt from "analyze table t1";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
prepare stmt from "repair table t1, t2, t3";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
test.t2	repair	status	OK
test.t3	repair	status	OK
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
test.t2	repair	status	OK
test.t3	repair	status	OK
prepare stmt from "optimize table t1, t2, t3";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	OK
test.t2	optimize	status	OK
test.t3	optimize	status	OK
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	Table is already up to date
test.t2	optimize	status	Table is already up to date
test.t3	optimize	status	Table is already up to date
prepare stmt from "analyze table t1, t2, t3";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
test.t2	analyze	status	Table is already up to date
test.t3	analyze	status	Table is already up to date
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Table is already up to date
test.t2	analyze	status	Table is already up to date
test.t3	analyze	status	Table is already up to date
prepare stmt from "repair table t1, t4, t3";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
test.t4	repair	Error	Table 'test.t4' doesn't exist
test.t4	repair	status	Operation failed
test.t3	repair	status	OK
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	repair	status	OK
test.t4	repair	Error	Table 'test.t4' doesn't exist
test.t4	repair	status	Operation failed
test.t3	repair	status	OK
prepare stmt from "optimize table t1, t3, t4";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	OK
test.t3	optimize	status	OK
test.t4	optimize	Error	Table 'test.t4' doesn't exist
test.t4	optimize	status	Operation failed
execute stmt;
Table	Op	Msg_type	Msg_text
test.t1	optimize	status	Table is already up to date
test.t3	optimize	status	Table is already up to date
test.t4	optimize	Error	Table 'test.t4' doesn't exist
test.t4	optimize	status	Operation failed
prepare stmt from "analyze table t4, t1";
execute stmt;
Table	Op	Msg_type	Msg_text
test.t4	analyze	Error	Table 'test.t4' doesn't exist
test.t4	analyze	status	Operation failed
test.t1	analyze	status	Table is already up to date
execute stmt;
Table	Op	Msg_type	Msg_text
test.t4	analyze	Error	Table 'test.t4' doesn't exist
test.t4	analyze	status	Operation failed
test.t1	analyze	status	Table is already up to date
deallocate prepare stmt;
drop table t1, t2, t3;
create database mysqltest_long_database_name_to_thrash_heap;
use test;
create table t1 (i int);
prepare stmt from "alter table test.t1 rename t1";
use mysqltest_long_database_name_to_thrash_heap;
execute stmt;
show tables like 't1';
Tables_in_mysqltest_long_database_name_to_thrash_heap (t1)
prepare stmt from "alter table test.t1 rename t1";
use test;
execute stmt;
show tables like 't1';
Tables_in_test (t1)
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
Tables_in_mysqltest_long_database_name_to_thrash_heap (t1)
t1
deallocate prepare stmt;
use mysqltest_long_database_name_to_thrash_heap;
prepare stmt_create from "create table t1 (i int)";
prepare stmt_insert from "insert into t1 (i) values (1)";
prepare stmt_update from "update t1 set i=2";
prepare stmt_delete from "delete from t1 where i=2";
prepare stmt_select from "select * from t1";
prepare stmt_alter from "alter table t1 add column (b int)";
prepare stmt_alter1 from "alter table t1 drop column b";
prepare stmt_analyze from "analyze table t1";
prepare stmt_optimize from "optimize table t1";
prepare stmt_show from "show tables like 't1'";
prepare stmt_truncate from "truncate table t1";
prepare stmt_drop from "drop table t1";
drop table t1;
use test;
execute stmt_create;
show tables like 't1';
Tables_in_test (t1)
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
Tables_in_mysqltest_long_database_name_to_thrash_heap (t1)
t1
use test;
execute stmt_insert;
select * from mysqltest_long_database_name_to_thrash_heap.t1;
i
1
execute stmt_update;
select * from mysqltest_long_database_name_to_thrash_heap.t1;
i
2
execute stmt_delete;
execute stmt_select;
i
execute stmt_alter;
show columns from mysqltest_long_database_name_to_thrash_heap.t1;
Field	Type	Null	Key	Default	Extra
i	int	YES		NULL	
b	int	YES		NULL	
execute stmt_alter1;
show columns from mysqltest_long_database_name_to_thrash_heap.t1;
Field	Type	Null	Key	Default	Extra
i	int	YES		NULL	
execute stmt_analyze;
Table	Op	Msg_type	Msg_text
mysqltest_long_database_name_to_thrash_heap.t1	analyze	status	OK
execute stmt_optimize;
Table	Op	Msg_type	Msg_text
mysqltest_long_database_name_to_thrash_heap.t1	optimize	note	Table does not support optimize, doing recreate + analyze instead
mysqltest_long_database_name_to_thrash_heap.t1	optimize	status	OK
execute stmt_show;
Tables_in_mysqltest_long_database_name_to_thrash_heap (t1)
t1
execute stmt_truncate;
execute stmt_drop;
show tables like 't1';
Tables_in_test (t1)
use mysqltest_long_database_name_to_thrash_heap;
show tables like 't1';
Tables_in_mysqltest_long_database_name_to_thrash_heap (t1)
drop database mysqltest_long_database_name_to_thrash_heap;
prepare stmt_create from "create table t1 (i int)";
ERROR 3D000: No database selected
prepare stmt_insert from "insert into t1 (i) values (1)";
ERROR 3D000: No database selected
prepare stmt_update from "update t1 set i=2";
ERROR 3D000: No database selected
prepare stmt_delete from "delete from t1 where i=2";
ERROR 3D000: No database selected
prepare stmt_select from "select * from t1";
ERROR 3D000: No database selected
prepare stmt_alter from "alter table t1 add column (b int)";
ERROR 3D000: No database selected
prepare stmt_alter1 from "alter table t1 drop column b";
ERROR 3D000: No database selected
prepare stmt_analyze from "analyze table t1";
ERROR 3D000: No database selected
prepare stmt_optimize from "optimize table t1";
ERROR 3D000: No database selected
prepare stmt_show from "show tables like 't1'";
ERROR 3D000: No database selected
prepare stmt_truncate from "truncate table t1";
ERROR 3D000: No database selected
prepare stmt_drop from "drop table t1";
ERROR 3D000: No database selected
create temporary table t1 (i int);
ERROR 3D000: No database selected
use test;
CREATE TABLE t1 (i BIGINT, j BIGINT);
CREATE TABLE t2 (i BIGINT);
CREATE TABLE t3 (i BIGINT, j BIGINT);
PREPARE stmt FROM "SELECT * FROM t1 JOIN t2 ON (t2.i = t1.i)
                   LEFT JOIN t3 ON ((t3.i, t3.j) = (t1.i, t1.j))
                   WHERE t1.i = ?";
SET @a= 1;
EXECUTE stmt USING @a;
i	j	i	i	j
EXECUTE stmt USING @a;
i	j	i	i	j
DEALLOCATE PREPARE stmt;
DROP TABLE IF EXISTS t1, t2, t3;
CREATE TABLE t1 (i INT KEY);
CREATE TABLE t2 (i INT);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (1);
PREPARE stmt FROM "SELECT t2.i FROM t1 LEFT JOIN t2 ON t2.i = t1.i
                   WHERE t1.i = ?";
SET @arg= 1;
EXECUTE stmt USING @arg;
i
1
SET @arg= 2;
EXECUTE stmt USING @arg;
i
NULL
SET @arg= 1;
EXECUTE stmt USING @arg;
i
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
CREATE TABLE t1 (i INT);
CREATE VIEW v1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES (1), (2);
SELECT t1.i FROM t1 JOIN v1 ON t1.i = v1.i
WHERE EXISTS (SELECT * FROM t1 WHERE v1.i = 1);
i
1
PREPARE stmt FROM "SELECT t1.i FROM t1 JOIN v1 ON t1.i = v1.i
WHERE EXISTS (SELECT * FROM t1 WHERE v1.i = 1)";
EXECUTE stmt;
i
1
EXECUTE stmt;
i
1
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (a int);
INSERT INTO t1 VALUES (1), (2);
CREATE TABLE t2 (b int);
INSERT INTO t2 VALUES (NULL);
SELECT a FROM t1 WHERE (SELECT b FROM t2) IS NULL;
a
1
2
PREPARE stmt FROM 'SELECT a FROM t1 WHERE (SELECT b FROM t2) IS NULL';
EXECUTE stmt;
a
1
2
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT a FROM t1 WHERE (SELECT b FROM t2 limit ?) IS NULL';
SET @arg=1;
EXECUTE stmt USING @arg;
a
1
2
DEALLOCATE PREPARE stmt;
DROP TABLE t1,t2;
create table t1 (s1 char(20));
prepare stmt from "alter table t1 modify s1 int";
execute stmt;
execute stmt;
drop table t1;
deallocate prepare stmt;
create table t1 (a int, b int);
prepare s_6895 from "alter table t1 drop column b";
execute s_6895;
show columns from t1;
Field	Type	Null	Key	Default	Extra
a	int	YES		NULL	
drop table t1;
create table t1 (a int, b int);
execute s_6895;
show columns from t1;
Field	Type	Null	Key	Default	Extra
a	int	YES		NULL	
drop table t1;
create table t1 (a int, b int);
execute s_6895;
show columns from t1;
Field	Type	Null	Key	Default	Extra
a	int	YES		NULL	
deallocate prepare s_6895;
drop table t1;
create table t1 (i int primary key auto_increment) comment='comment for table t1';
create table t2 (i int, j int, k int);
prepare stmt from "alter table t1 auto_increment=100";
execute stmt;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `i` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`i`)
) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='comment for table t1'
flush tables;
select * from t2;
i	j	k
execute stmt;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `i` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`i`)
) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='comment for table t1'
deallocate prepare stmt;
drop table t1, t2;
set @old_character_set_server= @@character_set_server;
set @@character_set_server= latin1;
prepare stmt from "create database mysqltest_1";
execute stmt;
show create database mysqltest_1;
Database	Create Database
mysqltest_1	CREATE DATABASE `mysqltest_1` /*!40100 DEFAULT CHARACTER SET latin1 */ /*!80016 DEFAULT ENCRYPTION='N' */
drop database mysqltest_1;
set @@character_set_server= utf8mb3;
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
execute stmt;
show create database mysqltest_1;
Database	Create Database
mysqltest_1	CREATE DATABASE `mysqltest_1` /*!40100 DEFAULT CHARACTER SET utf8mb3 */ /*!80016 DEFAULT ENCRYPTION='N' */
drop database mysqltest_1;
deallocate prepare stmt;
set @@character_set_server= @old_character_set_server;
create table t1 (id int primary key auto_increment, value varchar(10));
insert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');
prepare stmt from "insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP'";
ERROR 42S22: Unknown column 'v' in 'field list'
prepare stmt from "insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP'";
ERROR 42S22: Unknown column 'y.value' in 'field list'
drop tables t1;
prepare stmt from "create table t1 select ?";
set @a=1.0;
execute stmt using @a;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `?` decimal(65,30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
drop table t1;
create table t1 (a bigint unsigned, b bigint(20) unsigned);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
prepare stmt from "insert into t1 values (?,?)";
set @a= 9999999999999999;
set @b= 14632475938453979136;
insert into t1 values (@a, @b);
select * from t1 where a = @a and b = @b;
a	b
9999999999999999	14632475938453979136
execute stmt using @a, @b;
select * from t1 where a = @a and b = @b;
a	b
9999999999999999	14632475938453979136
9999999999999999	14632475938453979136
deallocate prepare stmt;
drop table t1;
drop view if exists v1;
drop table if exists t1;
create table t1 (a int, b int);
insert into t1 values (1,1), (2,2), (3,3);
insert into t1 values (3,1), (1,2), (2,3);
prepare stmt from "create view v1 as select * from t1";
execute stmt;
drop table t1;
create table t1 (a int, b int);
drop view v1;
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
drop view v1;
prepare stmt from "create view v1 (c,d) as select a,b from t1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`,`d`) AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c	d
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`,`d`) AS select `t1`.`a` AS `a`,`t1`.`b` AS `b` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c	d
drop view v1;
prepare stmt from "create view v1 (c) as select b+1 from t1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`) AS select (`t1`.`b` + 1) AS `b+1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c
drop view v1;
prepare stmt from "create view v1 (c,d,e,f) as select a,b,a in (select a+2 from t1), a = all (select a from t1) from t1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`,`d`,`e`,`f`) AS select `t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`a` in (select (`t1`.`a` + 2) from `t1`) AS `a in (select a+2 from t1)`,`t1`.`a` = all (select `t1`.`a` from `t1`) AS `a = all (select a from t1)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c	d	e	f
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`c`,`d`,`e`,`f`) AS select `t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`a` in (select (`t1`.`a` + 2) from `t1`) AS `a in (select a+2 from t1)`,`t1`.`a` = all (select `t1`.`a` from `t1`) AS `a = all (select a from t1)` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
c	d	e	f
drop view v1;
prepare stmt from "create or replace view v1 as select 1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
1
1
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
1
1
drop view v1;
prepare stmt from "create view v1 as select 1, 1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`,1 AS `Name_exp_1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
1	Name_exp_1
1	1
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select 1 AS `1`,1 AS `Name_exp_1`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
1	Name_exp_1
1	1
drop view v1;
prepare stmt from "create view v1 (x) as select a from t1 where a > 1";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`x`) AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` > 1)	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
x
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` (`x`) AS select `t1`.`a` AS `a` from `t1` where (`t1`.`a` > 1)	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
x
drop view v1;
prepare stmt from "create view v1 as select * from `t1` `b`";
execute stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `b`.`a` AS `a`,`b`.`b` AS `b` from `t1` `b`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
a	b
drop view v1;
execute stmt;
deallocate prepare stmt;
show create view v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `b`.`a` AS `a`,`b`.`b` AS `b` from `t1` `b`	utf8mb4	utf8mb4_0900_ai_ci
select * from v1;
a	b
drop view v1;
prepare stmt from "create view v1 (a,b,c) as select * from t1";
ERROR HY000: In definition of view, derived table or common table expression, SELECT list and column names list have different column counts
drop table t1;
create temporary table t1 (a int, b int);
prepare stmt from "create view v1 as select * from t1";
execute stmt;
ERROR HY000: View's SELECT refers to a temporary table 't1'
execute stmt;
ERROR HY000: View's SELECT refers to a temporary table 't1'
deallocate prepare stmt;
drop table t1;
prepare stmt from "create view v1 as select * from t1";
ERROR 42S02: Table 'test.t1' doesn't exist
prepare stmt from "create view v1 as select * from `t1` `b`";
ERROR 42S02: Table 'test.t1' doesn't exist
prepare stmt from "select ?";
set @arg= 123456789.987654321;
select @arg;
@arg
123456789.987654321
execute stmt using @arg;
?
123456789.987654321
set @arg= "string";
select @arg;
@arg
string
execute stmt using @arg;
?
string
set @arg= 123456;
select @arg;
@arg
123456
execute stmt using @arg;
?
123456
set @arg= cast(-12345.54321 as decimal(20, 10));
select @arg;
@arg
-12345.5432100000
execute stmt using @arg;
?
-12345.5432100000
deallocate prepare stmt;
#
# Bug#48508: Crash on prepared statement re-execution.
#
create table t1(b int);
insert into t1 values (0);
create view v1 AS select 1 as a from t1 where b;
prepare stmt from "select * from v1 where a";
execute stmt;
a
execute stmt;
a
deallocate prepare stmt;
drop table t1;
drop view v1;
create table t1(a bigint);
create table t2(b tinyint);
insert into t2 values (null);
prepare stmt from "select 1 from t1 join  t2 on a xor b where b > 1  and a =1";
execute stmt;
1
execute stmt;
1
deallocate prepare stmt;
drop table t1,t2;
#
#
# Bug #49570: Assertion failed: !(order->used & map)
# on re-execution of prepared statement
#
CREATE TABLE t1(a INT PRIMARY KEY);
INSERT INTO t1 VALUES(0), (1);
PREPARE stmt FROM 
"SELECT 1 FROM t1 JOIN t1 t2 USING(a) GROUP BY t2.a, t1.a";
EXECUTE stmt;
1
1
1
EXECUTE stmt;
1
1
1
EXECUTE stmt;
1
1
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
End of 5.0 tests.
create procedure proc_1() reset binary logs and gtids;
create function func_1() returns int begin reset binary logs and gtids; return 1; end|
ERROR 0A000: RESET is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: RESET is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "reset binary logs and gtids";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() RESET REPLICA;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin RESET REPLICA; return 1; end|
ERROR 0A000: RESET is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: RESET is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "RESET REPLICA";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1(a integer) kill a;
call proc_1(0);
ERROR HY000: Unknown thread id: 0
call proc_1(0);
ERROR HY000: Unknown thread id: 0
call proc_1(0);
ERROR HY000: Unknown thread id: 0
drop procedure proc_1;
create function func_1() returns int begin kill 0; return 1; end|
select func_1() from dual;
ERROR HY000: Unknown thread id: 0
select func_1() from dual;
ERROR HY000: Unknown thread id: 0
select func_1() from dual;
ERROR HY000: Unknown thread id: 0
drop function func_1;
prepare abc from "kill 0";
execute abc;
ERROR HY000: Unknown thread id: 0
execute abc;
ERROR HY000: Unknown thread id: 0
execute abc;
ERROR HY000: Unknown thread id: 0
deallocate prepare abc;
prepare abc from "TRUNCATE TABLE performance_schema.host_cache";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush privileges;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin flush privileges; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush privileges";
deallocate prepare abc;
create procedure proc_1() flush tables with read lock;
call proc_1();
unlock tables;
call proc_1();
unlock tables;
call proc_1();
unlock tables;
create function func_1() returns int begin flush tables with read lock; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush tables with read lock";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
unlock tables;
create procedure proc_1() flush tables;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin flush tables; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush tables";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush tables;
flush tables;
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
call proc_1();
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
call proc_1();
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
call proc_1();
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
flush tables;
create function func_1() returns int begin flush tables; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
flush tables;
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
prepare abc from "flush tables";
execute abc;
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
execute abc;
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
execute abc;
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	general_log	0	0
select Host, User from mysql.user limit 0;
Host	User
select Host, Db from mysql.db limit 0;
Host	Db
show open tables from mysql;
Database	Table	In_use	Name_locked
mysql	db	0	0
mysql	general_log	0	0
mysql	user	0	0
flush tables;
deallocate prepare abc;
create procedure proc_1() flush logs;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin flush logs; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush logs";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush status;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin flush status; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush status";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() flush user_resources;
call proc_1();
call proc_1();
call proc_1();
create function func_1() returns int begin flush user_resources; return 1; end|
ERROR 0A000: FLUSH is not allowed in stored function or trigger
create function func_1() returns int begin call proc_1(); return 1; end|
select func_1(), func_1(), func_1() from dual;
ERROR 0A000: FLUSH is not allowed in stored function or trigger
drop function func_1;
drop procedure proc_1;
prepare abc from "flush user_resources";
execute abc;
execute abc;
execute abc;
deallocate prepare abc;
create procedure proc_1() START REPLICA;
drop procedure proc_1;
create function func_1() returns int begin START REPLICA; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
prepare abc from "START REPLICA";
deallocate prepare abc;
create procedure proc_1() STOP REPLICA;
drop procedure proc_1;
create function func_1() returns int begin STOP REPLICA; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
prepare abc from "STOP REPLICA";
deallocate prepare abc;
create procedure proc_1() show binlog events;
drop procedure proc_1;
create function func_1() returns int begin show binlog events; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show binlog events";
deallocate prepare abc;
create procedure proc_1() SHOW REPLICA STATUS;
drop procedure proc_1;
create function func_1() returns int begin SHOW REPLICA STATUS; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "SHOW REPLICA STATUS";
deallocate prepare abc;
create procedure proc_1() show binary log status;
drop procedure proc_1;
create function func_1() returns int begin show binary log status; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show binary log status";
deallocate prepare abc;
create procedure proc_1() show binary logs;
drop procedure proc_1;
create function func_1() returns int begin show binary logs; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show binary logs";
deallocate prepare abc;
create procedure proc_1() show events;
call proc_1();
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
call proc_1();
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
call proc_1();
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
drop procedure proc_1;
create function func_1() returns int begin show events; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show events";
execute abc;
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
execute abc;
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
execute abc;
Db	Name	Definer	Time zone	Type	Execute at	Interval value	Interval field	Starts	Ends	Status	Originator	character_set_client	collation_connection	Database Collation
deallocate prepare abc;
create procedure a() select 42;
create procedure proc_1(a char(2)) show create procedure a;
call proc_1("bb");
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
call proc_1("bb");
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
call proc_1("bb");
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
drop procedure proc_1;
create function func_1() returns int begin show create procedure a; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show create procedure a";
execute abc;
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
execute abc;
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
execute abc;
Procedure	sql_mode	Create Procedure	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` PROCEDURE `a`()
select 42	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
deallocate prepare abc;
drop procedure a;
create function a() returns int return 42+13;
create procedure proc_1(a char(2)) show create function a;
call proc_1("bb");
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
call proc_1("bb");
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
call proc_1("bb");
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
drop procedure proc_1;
create function func_1() returns int begin show create function a; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show create function a";
execute abc;
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
execute abc;
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
execute abc;
Function	sql_mode	Create Function	character_set_client	collation_connection	Database Collation
a	ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION	CREATE DEFINER=`root`@`localhost` FUNCTION `a`() RETURNS int
return 42+13	utf8mb4	utf8mb4_0900_ai_ci	utf8mb4_0900_ai_ci
deallocate prepare abc;
drop function a;
create table tab1(a int, b char(1), primary key(a,b));
create procedure proc_1() show create table tab1;
call proc_1();
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
call proc_1();
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
call proc_1();
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
drop procedure proc_1;
create function func_1() returns int begin show create table tab1; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show create table tab1";
execute abc;
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
execute abc;
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
execute abc;
Table	Create Table
tab1	CREATE TABLE `tab1` (
  `a` int NOT NULL,
  `b` char(1) NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
deallocate prepare abc;
drop table tab1;
drop view if exists v1;
drop table if exists t1;
create table t1(a int, b char(5));
insert into t1 values (1, "one"), (1, "edno"), (2, "two"), (2, "dve");
create view v1 as
(select a, count(*) from t1 group by a)
union all
(select b, count(*) from t1 group by b);
create procedure proc_1() show create view v1;
call proc_1();
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
call proc_1();
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
call proc_1();
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
drop procedure proc_1;
create function func_1() returns int begin show create view v1; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "show create view v1";
execute abc;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
execute abc;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
execute abc;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`a` AS `a`,count(0) AS `count(*)` from `t1` group by `t1`.`a` union all select `t1`.`b` AS `b`,count(0) AS `count(*)` from `t1` group by `t1`.`b`	utf8mb4	utf8mb4_0900_ai_ci
deallocate prepare abc;
drop view v1;
drop table t1;
create procedure proc_1() install plugin my_plug soname 'some_plugin.so';
call proc_1();
Got one of the listed errors
call proc_1();
Got one of the listed errors
call proc_1();
Got one of the listed errors
drop procedure proc_1;
create function func_1() returns int begin install plugin my_plug soname '/tmp/plugin'; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "install plugin my_plug soname 'some_plugin.so'";
deallocate prepare abc;
create procedure proc_1() uninstall plugin my_plug;
call proc_1();
ERROR 42000: PLUGIN my_plug does not exist
call proc_1();
ERROR 42000: PLUGIN my_plug does not exist
call proc_1();
ERROR 42000: PLUGIN my_plug does not exist
drop procedure proc_1;
create function func_1() returns int begin uninstall plugin my_plug; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "uninstall plugin my_plug";
execute abc;
ERROR 42000: PLUGIN my_plug does not exist
execute abc;
ERROR 42000: PLUGIN my_plug does not exist
execute abc;
ERROR 42000: PLUGIN my_plug does not exist
deallocate prepare abc;
create procedure proc_1() create database mysqltest_xyz;
call proc_1();
drop database if exists mysqltest_xyz;
call proc_1();
call proc_1();
ERROR HY000: Can't create database 'mysqltest_xyz'; database exists
drop database if exists mysqltest_xyz;
call proc_1();
drop database if exists mysqltest_xyz;
drop procedure proc_1;
create function func_1() returns int begin create database mysqltest_xyz; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "create database mysqltest_xyz";
execute abc;
drop database if exists mysqltest_xyz;
execute abc;
execute abc;
ERROR HY000: Can't create database 'mysqltest_xyz'; database exists
drop database if exists mysqltest_xyz;
execute abc;
drop database if exists mysqltest_xyz;
deallocate prepare abc;
create table t1 (a int, b char(5));
insert into t1 values (1, "one"), (2, "two"), (3, "three");
create procedure proc_1() checksum table xyz;
call proc_1();
Table	Checksum
test.xyz	NULL
Warnings:
Error	1146	Table 'test.xyz' doesn't exist
call proc_1();
Table	Checksum
test.xyz	NULL
Warnings:
Error	1146	Table 'test.xyz' doesn't exist
call proc_1();
Table	Checksum
test.xyz	NULL
Warnings:
Error	1146	Table 'test.xyz' doesn't exist
drop procedure proc_1;
create function func_1() returns int begin checksum table t1; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "checksum table t1";
execute abc;
Table	Checksum
test.t1	4164812274
execute abc;
Table	Checksum
test.t1	4164812274
execute abc;
Table	Checksum
test.t1	4164812274
deallocate prepare abc;
create procedure proc_1() create user pstest_xyz@localhost;
call proc_1();
drop user pstest_xyz@localhost;
call proc_1();
call proc_1();
ERROR HY000: Operation CREATE USER failed for 'pstest_xyz'@'localhost'
drop user pstest_xyz@localhost;
call proc_1();
drop user pstest_xyz@localhost;
drop procedure proc_1;
create function func_1() returns int begin create user pstest_xyz@localhost; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "create user pstest_xyz@localhost";
execute abc;
drop user pstest_xyz@localhost;
execute abc;
execute abc;
ERROR HY000: Operation CREATE USER failed for 'pstest_xyz'@'localhost'
drop user pstest_xyz@localhost;
execute abc;
drop user pstest_xyz@localhost;
deallocate prepare abc;
create function func_1() returns int begin create event xyz on schedule at now() do select 123; return 1; end|
ERROR HY000: Recursion of EVENT DDL statements is forbidden when body is present
select func_1(), func_1(), func_1() from dual;
ERROR 42000: FUNCTION test.func_1 does not exist
drop function func_1;
ERROR 42000: FUNCTION test.func_1 does not exist
prepare abc from "create event xyz on schedule at now() do select 123";
deallocate prepare abc;
drop event if exists xyz;
create event xyz on schedule every 5 minute disable do select 123;
create procedure proc_1() alter event xyz comment 'xyz';
call proc_1();
drop event xyz;
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
drop event xyz;
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
drop event xyz;
drop procedure proc_1;
create function func_1() returns int begin alter event xyz comment 'xyz'; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
prepare abc from "alter event xyz comment 'xyz'";
deallocate prepare abc;
drop event if exists xyz;
create event xyz on schedule every 5 minute disable do select 123;
create procedure proc_1() drop event xyz;
call proc_1();
create event xyz on schedule every 5 minute disable do select 123;
call proc_1();
call proc_1();
ERROR HY000: Unknown event 'xyz'
drop procedure proc_1;
create function func_1() returns int begin drop event xyz; return 1; end|
ERROR HY000: Explicit or implicit commit is not allowed in stored function or trigger.
prepare abc from "drop event xyz";
deallocate prepare abc;
drop table if exists t1;
create table t1 (a int, b char(5)) engine=myisam;
insert into t1 values (1, "one"), (2, "two"), (3, "three");
SET GLOBAL new_cache.key_buffer_size=128*1024;
Warnings:
Warning	1287	new_cache.key_buffer_size syntax is deprecated and will be removed in a future release
create procedure proc_1() cache index t1 in new_cache;
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
drop procedure proc_1;
SET GLOBAL second_cache.key_buffer_size=128*1024;
Warnings:
Warning	1287	second_cache.key_buffer_size syntax is deprecated and will be removed in a future release
prepare abc from "cache index t1 in second_cache";
execute abc;
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
execute abc;
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
execute abc;
Table	Op	Msg_type	Msg_text
test.t1	assign_to_keycache	status	OK
deallocate prepare abc;
drop table t1;
drop table if exists t1;
drop table if exists t2;
create table t1 (a int, b char(5)) engine=myisam;
insert into t1 values (1, "one"), (2, "two"), (3, "three");
create table t2 (a int, b char(5)) engine=myisam;
insert into t2 values (1, "one"), (2, "two"), (3, "three");
create procedure proc_1() load index into cache t1 ignore leaves;
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	preload_keys	status	OK
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	preload_keys	status	OK
call proc_1();
Table	Op	Msg_type	Msg_text
test.t1	preload_keys	status	OK
drop procedure proc_1;
create function func_1() returns int begin load index into cache t1 ignore leaves; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
prepare abc from "load index into cache t2 ignore leaves";
execute abc;
Table	Op	Msg_type	Msg_text
test.t2	preload_keys	status	OK
execute abc;
Table	Op	Msg_type	Msg_text
test.t2	preload_keys	status	OK
execute abc;
Table	Op	Msg_type	Msg_text
test.t2	preload_keys	status	OK
deallocate prepare abc;
drop table t1, t2;
create procedure proc_1() show errors;
call proc_1();
Level	Code	Message
call proc_1();
Level	Code	Message
call proc_1();
Level	Code	Message
drop procedure proc_1;
create function func_1() returns int begin show errors; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
prepare abc from "show errors";
ERROR HY000: This command is not supported in the prepared statement protocol yet
drop table if exists t1;
drop table if exists t2;
create procedure proc_1() show warnings;
drop table if exists t1;
Warnings:
Note	1051	Unknown table 'test.t1'
call proc_1();
Level	Code	Message
drop table if exists t2;
Warnings:
Note	1051	Unknown table 'test.t2'
call proc_1();
Level	Code	Message
drop table if exists t1, t2;
Warnings:
Note	1051	Unknown table 'test.t1'
Note	1051	Unknown table 'test.t2'
call proc_1();
Level	Code	Message
drop procedure proc_1;
create function func_1() returns int begin show warnings; return 1; end|
ERROR 0A000: Not allowed to return a result set from a function
prepare abc from "show warnings";
ERROR HY000: This command is not supported in the prepared statement protocol yet
set @to_format="123456789.123456789";
set @dec=0;
prepare stmt2 from 'select format(?, ?)';
execute stmt2 using @to_format, @dec;
format(?, ?)
123,456,789
set @dec=4;
execute stmt2 using @to_format, @dec;
format(?, ?)
123,456,789.1235
set @dec=6;
execute stmt2 using @to_format, @dec;
format(?, ?)
123,456,789.123457
set @dec=2;
execute stmt2 using @to_format, @dec;
format(?, ?)
123,456,789.12
set @to_format="100";
execute stmt2 using @to_format, @dec;
format(?, ?)
100.00
set @to_format="1000000";
execute stmt2 using @to_format, @dec;
format(?, ?)
1,000,000.00
set @to_format="10000";
execute stmt2 using @to_format, @dec;
format(?, ?)
10,000.00
deallocate prepare stmt2;
CREATE TABLE t1 (i INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (i INT);
INSERT INTO t2 VALUES (2);
LOCK TABLE t1 READ, t2 WRITE;
PREPARE stmt1 FROM "SELECT i FROM t1";
PREPARE stmt2 FROM "INSERT INTO t2 (i) VALUES (3)";
EXECUTE stmt1;
i
1
EXECUTE stmt2;
SELECT * FROM t2;
i
2
UNLOCK TABLES;
SELECT * FROM t2;
i
2
3
ALTER TABLE t1 ADD COLUMN j INT;
ALTER TABLE t2 ADD COLUMN j INT;
INSERT INTO t1 VALUES (4, 5);
INSERT INTO t2 VALUES (4, 5);
EXECUTE stmt1;
i
1
4
EXECUTE stmt2;
SELECT * FROM t2;
i	j
2	NULL
3	NULL
4	5
3	NULL
DROP TABLE t1, t2;
drop table if exists t1;
Warnings:
Note	1051	Unknown table 'test.t1'
prepare stmt
from "create table t1 (c char(100) character set utf8mb3, key (c(10)))";
Warnings:
Warning	1287	'utf8mb3' is deprecated and will be removed in a future release. Please use utf8mb4 instead
execute stmt;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `c` char(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  KEY `c` (`c`(10))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
drop table t1;
execute stmt;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `c` char(100) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci DEFAULT NULL,
  KEY `c` (`c`(10))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
drop table t1;
create table t1 (a int, b int);
create table t2 like t1;
insert into t1 (a, b) values (1,1), (1,2), (1,3), (1,4), (1,5),
(2,2), (2,3), (2,1), (3,1), (4,1), (4,2), (4,3), (4,4), (4,5), (4,6);
insert into t2 select a, max(b) from t1 group by a;
prepare stmt from "delete from t2 where (select (select max(b) from t1 group
by a having a < 2) x from t1) > 10000";
delete from t2 where (select (select max(b) from t1 group
by a having a < 2) x from t1) > 10000;
ERROR 21000: Subquery returns more than 1 row
execute stmt;
ERROR 21000: Subquery returns more than 1 row
execute stmt;
ERROR 21000: Subquery returns more than 1 row
deallocate prepare stmt;
drop table t1, t2;
#
# Bug#52124 memory leaks like a sieve in datetime, timestamp, time, date fields + warnings
#
CREATE TABLE t1 (a TIME NOT NULL, b TINYINT);
INSERT IGNORE INTO t1 VALUES (0, 0),(0, 0);
PREPARE stmt FROM "SELECT 1 FROM t1 WHERE
ROW(a, b) >= ROW('1', (SELECT 1 FROM t1 WHERE a > '1234abc'))";
Warnings:
Warning	1292	Incorrect time value: '1234abc' for column 'a' at row 1
EXECUTE stmt;
1
EXECUTE stmt;
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
#
# Bug#54494 crash with explain and prepared statements
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (1),(2);
PREPARE stmt FROM 'EXPLAIN SELECT 1 FROM t1 RIGHT JOIN t1 t2 ON 1';
EXECUTE stmt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` `t2` left join `test`.`t1` on(true) where true
EXECUTE stmt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (hash join)
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` `t2` left join `test`.`t1` on(true) where true
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
#
# Bug#54488 crash when using explain and prepared statements with subqueries
#
CREATE TABLE t1(f1 INT);
INSERT INTO t1 VALUES (1),(1);
PREPARE stmt FROM 'EXPLAIN SELECT 1 FROM t1 WHERE (SELECT (SELECT 1 FROM t1 GROUP BY f1))';
Warnings:
Note	1249	Select 2 was reduced during optimization
EXECUTE stmt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` where true
EXECUTE stmt;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	SUBQUERY	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using temporary
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` where true
DEALLOCATE PREPARE stmt;
DROP TABLE t1;

End of 5.1 tests.

#
# WL#4435: Support OUT-parameters in prepared statements.
#

DROP PROCEDURE IF EXISTS p_string;
DROP PROCEDURE IF EXISTS p_double;
DROP PROCEDURE IF EXISTS p_int;
DROP PROCEDURE IF EXISTS p_decimal;

CREATE PROCEDURE p_string(
IN v0 INT,
OUT v1 CHAR(32),
IN v2 CHAR(32),
INOUT v3 CHAR(32))
BEGIN
SET v0 = -1;
SET v1 = 'test_v1';
SET v2 = 'n/a';
SET v3 = 'test_v3';
END|

CREATE PROCEDURE p_double(
IN v0 INT,
OUT v1 DOUBLE(4, 2),
IN v2 DOUBLE(4, 2),
INOUT v3 DOUBLE(4, 2))
BEGIN
SET v0 = -1;
SET v1 = 12.34;
SET v2 = 98.67;
SET v3 = 56.78;
END|
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.

CREATE PROCEDURE p_int(
IN v0 CHAR(10),
OUT v1 INT,
IN v2 INT,
INOUT v3 INT)
BEGIN
SET v0 = 'n/a';
SET v1 = 1234;
SET v2 = 9876;
SET v3 = 5678;
END|

CREATE PROCEDURE p_decimal(
IN v0 INT,
OUT v1 DECIMAL(4, 2),
IN v2 DECIMAL(4, 2),
INOUT v3 DECIMAL(4, 2))
BEGIN
SET v0 = -1;
SET v1 = 12.34;
SET v2 = 98.67;
SET v3 = 56.78;
END|

PREPARE stmt_str FROM 'CALL p_string(?, ?, ?, ?)';
PREPARE stmt_dbl FROM 'CALL p_double(?, ?, ?, ?)';
PREPARE stmt_int FROM 'CALL p_int(?, ?, ?, ?)';
PREPARE stmt_dec FROM 'CALL p_decimal(?, ?, ?, ?)';

SET @x_str_1 = NULL;
SET @x_str_2 = NULL;
SET @x_str_3 = NULL;
SET @x_dbl_1 = NULL;
SET @x_dbl_2 = NULL;
SET @x_dbl_3 = NULL;
SET @x_int_1 = NULL;
SET @x_int_2 = NULL;
SET @x_int_3 = NULL;
SET @x_dec_1 = NULL;
SET @x_dec_2 = NULL;
SET @x_dec_3 = NULL;

-- Testing strings...

EXECUTE stmt_str USING @x_int_1, @x_str_1, @x_str_2, @x_str_3;
SELECT @x_int_1, @x_str_1, @x_str_2, @x_str_3;
@x_int_1	@x_str_1	@x_str_2	@x_str_3
NULL	test_v1	NULL	test_v3

EXECUTE stmt_str USING @x_int_1, @x_str_1, @x_str_2, @x_str_3;
SELECT @x_int_1, @x_str_1, @x_str_2, @x_str_3;
@x_int_1	@x_str_1	@x_str_2	@x_str_3
NULL	test_v1	NULL	test_v3

-- Testing doubles...

EXECUTE stmt_dbl USING @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
SELECT @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
@x_int_1	@x_dbl_1	@x_dbl_2	@x_dbl_3
NULL	12.34	NULL	56.78

EXECUTE stmt_dbl USING @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
SELECT @x_int_1, @x_dbl_1, @x_dbl_2, @x_dbl_3;
@x_int_1	@x_dbl_1	@x_dbl_2	@x_dbl_3
NULL	12.34	NULL	56.78

-- Testing ints...

EXECUTE stmt_int USING @x_str_1, @x_int_1, @x_int_2, @x_int_3;
SELECT @x_str_1, @x_int_1, @x_int_2, @x_int_3;
@x_str_1	@x_int_1	@x_int_2	@x_int_3
test_v1	1234	NULL	5678

EXECUTE stmt_int USING @x_str_1, @x_int_1, @x_int_2, @x_int_3;
SELECT @x_str_1, @x_int_1, @x_int_2, @x_int_3;
@x_str_1	@x_int_1	@x_int_2	@x_int_3
test_v1	1234	NULL	5678

-- Testing decs...

EXECUTE stmt_dec USING @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
SELECT @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
@x_int_1	@x_dec_1	@x_dec_2	@x_dec_3
1234	12.34	NULL	56.78

EXECUTE stmt_dec USING @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
SELECT @x_int_1, @x_dec_1, @x_dec_2, @x_dec_3;
@x_int_1	@x_dec_1	@x_dec_2	@x_dec_3
1234	12.34	NULL	56.78

DEALLOCATE PREPARE stmt_str;
DEALLOCATE PREPARE stmt_dbl;
DEALLOCATE PREPARE stmt_int;
DEALLOCATE PREPARE stmt_dec;

DROP PROCEDURE p_string;
DROP PROCEDURE p_double;
DROP PROCEDURE p_int;
DROP PROCEDURE p_decimal;

DROP PROCEDURE IF EXISTS p1;
DROP PROCEDURE IF EXISTS p2;

CREATE PROCEDURE p1(OUT v1 CHAR(10))
SET v1 = 'test1';

CREATE PROCEDURE p2(OUT v2 CHAR(10))
BEGIN
SET @query = 'CALL p1(?)';
PREPARE stmt1 FROM @query;
EXECUTE stmt1 USING @u1;
DEALLOCATE PREPARE stmt1;
SET v2 = @u1;
END|

CALL p2(@a);
SELECT @a;
@a
test1

DROP PROCEDURE p1;
DROP PROCEDURE p2;

TINYINT

CREATE PROCEDURE p1(OUT v TINYINT)
SET v = 127;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 127;
@a	@a = 127
127	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

SMALLINT

CREATE PROCEDURE p1(OUT v SMALLINT)
SET v = 32767;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 32767;
@a	@a = 32767
32767	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

MEDIUMINT

CREATE PROCEDURE p1(OUT v MEDIUMINT)
SET v = 8388607;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 8388607;
@a	@a = 8388607
8388607	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

INT

CREATE PROCEDURE p1(OUT v INT)
SET v = 2147483647;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 2147483647;
@a	@a = 2147483647
2147483647	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

BIGINT

CREATE PROCEDURE p1(OUT v BIGINT)
SET v = 9223372036854775807;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 9223372036854775807;
@a	@a = 9223372036854775807
9223372036854775807	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

BIT(11)

CREATE PROCEDURE p1(OUT v BIT(11))
SET v = b'10100100101';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = b'10100100101';
@a	@a = b'10100100101'
1317	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

TIMESTAMP

CREATE PROCEDURE p1(OUT v TIMESTAMP)
SET v = '2007-11-18 15:01:02';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = '2007-11-18 15:01:02';
@a	@a = '2007-11-18 15:01:02'
2007-11-18 15:01:02	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

DATETIME

CREATE PROCEDURE p1(OUT v DATETIME)
SET v = '1234-11-12 12:34:59';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = '1234-11-12 12:34:59';
@a	@a = '1234-11-12 12:34:59'
1234-11-12 12:34:59	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

TIME

CREATE PROCEDURE p1(OUT v TIME)
SET v = '123:45:01';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = '123:45:01';
@a	@a = '123:45:01'
123:45:01	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

DATE

CREATE PROCEDURE p1(OUT v DATE)
SET v = '1234-11-12';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = '1234-11-12';
@a	@a = '1234-11-12'
1234-11-12	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

YEAR

CREATE PROCEDURE p1(OUT v YEAR)
SET v = 2010;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` bigint unsigned DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 2010;
@a	@a = 2010
2010	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

FLOAT(7, 4)

CREATE PROCEDURE p1(OUT v FLOAT(7, 4))
SET v = 123.4567;
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` double DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a - 123.4567 < 0.00001;
@a	@a - 123.4567 < 0.00001
123.45670318603516	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

DOUBLE(8, 5)

CREATE PROCEDURE p1(OUT v DOUBLE(8, 5))
SET v = 123.45678;
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` double DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a - 123.45678 < 0.000001;
@a	@a - 123.45678 < 0.000001
123.45678	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

DECIMAL(9, 6)

CREATE PROCEDURE p1(OUT v DECIMAL(9, 6))
SET v = 123.456789;
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` decimal(65,30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 123.456789;
@a	@a = 123.456789
123.456789	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

CHAR(32)

CREATE PROCEDURE p1(OUT v CHAR(32))
SET v = REPEAT('a', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('a', 16);
@a	@a = REPEAT('a', 16)
aaaaaaaaaaaaaaaa	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

VARCHAR(32)

CREATE PROCEDURE p1(OUT v VARCHAR(32))
SET v = REPEAT('b', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('b', 16);
@a	@a = REPEAT('b', 16)
bbbbbbbbbbbbbbbb	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

TINYTEXT

CREATE PROCEDURE p1(OUT v TINYTEXT)
SET v = REPEAT('c', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('c', 16);
@a	@a = REPEAT('c', 16)
cccccccccccccccc	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

TEXT

CREATE PROCEDURE p1(OUT v TEXT)
SET v = REPEAT('d', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('d', 16);
@a	@a = REPEAT('d', 16)
dddddddddddddddd	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

MEDIUMTEXT

CREATE PROCEDURE p1(OUT v MEDIUMTEXT)
SET v = REPEAT('e', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('e', 16);
@a	@a = REPEAT('e', 16)
eeeeeeeeeeeeeeee	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

LONGTEXT

CREATE PROCEDURE p1(OUT v LONGTEXT)
SET v = REPEAT('f', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('f', 16);
@a	@a = REPEAT('f', 16)
ffffffffffffffff	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

BINARY(32)

CREATE PROCEDURE p1(OUT v BINARY(32))
SET v = REPEAT('g', 32);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('g', 32);
@a	@a = REPEAT('g', 32)
gggggggggggggggggggggggggggggggg	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

VARBINARY(32)

CREATE PROCEDURE p1(OUT v VARBINARY(32))
SET v = REPEAT('h', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('h', 16);
@a	@a = REPEAT('h', 16)
hhhhhhhhhhhhhhhh	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

TINYBLOB

CREATE PROCEDURE p1(OUT v TINYBLOB)
SET v = REPEAT('i', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('i', 16);
@a	@a = REPEAT('i', 16)
iiiiiiiiiiiiiiii	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

BLOB

CREATE PROCEDURE p1(OUT v BLOB)
SET v = REPEAT('j', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('j', 16);
@a	@a = REPEAT('j', 16)
jjjjjjjjjjjjjjjj	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

MEDIUMBLOB

CREATE PROCEDURE p1(OUT v MEDIUMBLOB)
SET v = REPEAT('k', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('k', 16);
@a	@a = REPEAT('k', 16)
kkkkkkkkkkkkkkkk	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

LONGBLOB

CREATE PROCEDURE p1(OUT v LONGBLOB)
SET v = REPEAT('l', 16);
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = REPEAT('l', 16);
@a	@a = REPEAT('l', 16)
llllllllllllllll	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

SET('aaa', 'bbb')

CREATE PROCEDURE p1(OUT v SET('aaa', 'bbb'))
SET v = 'aaa';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 'aaa';
@a	@a = 'aaa'
aaa	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

ENUM('aaa', 'bbb')

CREATE PROCEDURE p1(OUT v ENUM('aaa', 'bbb'))
SET v = 'aaa';
PREPARE stmt1 FROM 'CALL p1(?)';
EXECUTE stmt1 USING @a;
CREATE TEMPORARY TABLE tmp1 AS SELECT @a AS c1;
SHOW CREATE TABLE tmp1;
Table	Create Table
tmp1	CREATE TEMPORARY TABLE `tmp1` (
  `c1` longblob
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
SELECT @a, @a = 'aaa';
@a	@a = 'aaa'
aaa	1
DROP TEMPORARY TABLE tmp1;
DROP PROCEDURE p1;

# End of WL#4435.
#
# WL#4284: Transactional DDL locking
#
CREATE TABLE t1 (a INT);
BEGIN;
SELECT * FROM t1;
a
# Test that preparing a CREATE TABLE does not take a exclusive metdata lock.
PREPARE stmt1 FROM "CREATE TABLE t1 AS SELECT 1";
EXECUTE stmt1;
ERROR 42S01: Table 't1' already exists
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
#
# WL#4284: Transactional DDL locking
#
# Test that metadata locks taken during prepare are released.
#
CREATE TABLE t1 (a INT);
BEGIN;
PREPARE stmt1 FROM "SELECT * FROM t1";
DROP TABLE t1;

#
# Bug#56115: invalid memory reads when PS selecting from
#            information_schema tables
# Bug#58701: crash in Field::make_field, cursor-protocol
#
# NOTE: MTR should be run both with --ps-protocol and --cursor-protocol.
#

SELECT *
FROM (SELECT 1 UNION SELECT 2) t;
1
1
2

# Bug#13805127: Stored program cache produces wrong result in same THD

PREPARE s1 FROM 
"
SELECT c1, t2.c2, count(c3)
FROM
  (
  SELECT 3 as c2 FROM dual WHERE @x = 1
  UNION
  SELECT 2       FROM dual WHERE @x = 1 OR @x = 2
  ) AS t1,
  (
  SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual
  UNION
  SELECT '2012-03-01 02:00:00',       3,       2       FROM dual
  UNION
  SELECT '2012-03-01 01:00:00',       2,       1       FROM dual
  ) AS t2
WHERE t2.c2 = t1.c2
GROUP BY c1,c2
ORDER BY c1,c2
";

SET @x = 1;
SELECT c1, t2.c2, count(c3)
FROM
(
SELECT 3 as c2 FROM dual WHERE @x = 1
UNION
SELECT 2       FROM dual WHERE @x = 1 OR @x = 2
) AS t1,
(
SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual
UNION
SELECT '2012-03-01 02:00:00',       3,       2       FROM dual
UNION
SELECT '2012-03-01 01:00:00',       2,       1       FROM dual
) AS t2
WHERE t2.c2 = t1.c2
GROUP BY c1, c2
ORDER BY c1, c2;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1
2012-03-01 01:00:00	3	1
2012-03-01 02:00:00	3	1

EXECUTE s1;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1
2012-03-01 01:00:00	3	1
2012-03-01 02:00:00	3	1

SET @x = 2;
SELECT c1, t2.c2, count(c3)
FROM
(
SELECT 3 as c2 FROM dual WHERE @x = 1
UNION
SELECT 2       FROM dual WHERE @x = 1 OR @x = 2
) AS t1,
(
SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual
UNION
SELECT '2012-03-01 02:00:00',       3,       2       FROM dual
UNION
SELECT '2012-03-01 01:00:00',       2,       1       FROM dual
) AS t2
WHERE t2.c2 = t1.c2
GROUP BY c1, c2
ORDER BY c1, c2;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1

EXECUTE s1;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1

SET @x = 1;
SELECT c1, t2.c2, count(c3)
FROM
(
SELECT 3 as c2 FROM dual WHERE @x = 1
UNION
SELECT 2       FROM dual WHERE @x = 1 OR @x = 2
) AS t1,
(
SELECT '2012-03-01 01:00:00' AS c1, 3 as c2, 1 as c3 FROM dual
UNION
SELECT '2012-03-01 02:00:00',       3,       2       FROM dual
UNION
SELECT '2012-03-01 01:00:00',       2,       1       FROM dual
) AS t2
WHERE t2.c2 = t1.c2
GROUP BY c1, c2
ORDER BY c1, c2;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1
2012-03-01 01:00:00	3	1
2012-03-01 02:00:00	3	1

EXECUTE s1;
c1	c2	count(c3)
2012-03-01 01:00:00	2	1
2012-03-01 01:00:00	3	1
2012-03-01 02:00:00	3	1
DEALLOCATE PREPARE s1;
#
# End of 5.5 tests.
#
# Bug#12603141: JOIN::flatten_subqueries asrt/simplify_joins sig11/...
# Bug#12603457: SEGFAULT IN REINIT_STMT_BEFORE_USE
#
CREATE TABLE t1(a INTEGER);
CREATE TABLE t2(a INTEGER);
PREPARE stmt FROM '
SELECT (SELECT 1 FROM t2 WHERE ot.a) AS d
FROM t1 AS ot
GROUP BY d';
EXECUTE stmt;
d
EXECUTE stmt;
d
INSERT INTO t1 VALUES (0),(1),(2);
INSERT INTO t2 VALUES (1);
EXECUTE stmt;
d
NULL
1
EXECUTE stmt;
d
NULL
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
#
# Bug#12582849
# ASSERTION FAILURE IN __CXA_PURE_VIRTUAL/ITEM_COND::FIX_FIELDS
#
CREATE TABLE t1 (
pk INTEGER AUTO_INCREMENT,
col_int_nokey INTEGER,
col_int_key INTEGER,
col_varchar_key VARCHAR(1),
col_varchar_nokey VARCHAR(1),
PRIMARY KEY (pk),
KEY (col_int_key),
KEY (col_varchar_key, col_int_key)
);
INSERT INTO t1 (
col_int_key, col_int_nokey,
col_varchar_key, col_varchar_nokey
) VALUES 
(4,    2, 'v', 'v'),
(62, 150, 'v', 'v');
CREATE TABLE t2 (
pk INTEGER AUTO_INCREMENT,
col_int_nokey INTEGER,
col_int_key INTEGER,
col_varchar_key VARCHAR(1),
col_varchar_nokey VARCHAR(1),
PRIMARY KEY (pk),
KEY (col_int_key),
KEY (col_varchar_key, col_int_key)
);
INSERT INTO t2 (
col_int_key, col_int_nokey,
col_varchar_key, col_varchar_nokey
) VALUES 
(8, NULL, 'x', 'x'),
(7, 8,    'd', 'd');
PREPARE stmt FROM ' 
SELECT
  ( SELECT MAX( SQ1_alias2 .col_int_nokey ) AS SQ1_field1
    FROM ( t2 AS SQ1_alias1 RIGHT JOIN t1 AS SQ1_alias2
           ON ( SQ1_alias2.col_varchar_key = SQ1_alias1.col_varchar_nokey )
         )
    WHERE SQ1_alias2.pk < alias1.col_int_nokey OR alias1.pk
  ) AS field1
FROM ( t1 AS alias1 JOIN t2 AS alias2 ON alias2.pk )
GROUP BY field1
';
EXECUTE stmt;
field1
150
EXECUTE stmt;
field1
150
DEALLOCATE PREPARE stmt;
DROP TABLE t1, t2;
#
# Bug#16820562: Bad column names are not rejected at 'prepare'
#
Resolver errors should be given at prepare time in insert select
CREATE TABLE t1 (a INTEGER);
CREATE TABLE t2 (b INTEGER);
PREPARE s FROM "INSERT INTO t1 VALUES(1) ON DUPLICATE KEY UPDATE absent=2";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "INSERT INTO t1 VALUES(1) ON DUPLICATE KEY UPDATE a=absent";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "INSERT INTO t1 SELECT 1 ON DUPLICATE KEY UPDATE absent=2";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "INSERT INTO t1 SELECT 1 ON DUPLICATE KEY UPDATE a=absent";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "INSERT INTO t1(absent) VALUES(1) ON DUPLICATE KEY UPDATE a=1";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "INSERT INTO t1(absent) SELECT 1 ON DUPLICATE KEY UPDATE a=1";
ERROR 42S22: Unknown column 'absent' in 'field list'
Resolver errors should be given at prepare time in multi-table update
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=absent";
ERROR 42S22: Unknown column 'absent' in 'field list'
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=t1.absent";
ERROR 42S22: Unknown column 't1.absent' in 'field list'
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=t2.absent";
ERROR 42S22: Unknown column 't2.absent' in 'field list'
PREPARE s FROM "UPDATE t1 JOIN t2 ON t1.a=t2.b SET t1.a=absent.absent";
ERROR 42S22: Unknown column 'absent.absent' in 'field list'
DROP TABLE t1, t2;
#
# Bug#19894382 - SERVER SIDE PREPARED STATEMENTS LEADS TO POTENTIAL OFF-BY-SECOND
#                TIMESTAMP ON SLAVE.
#
CREATE TABLE bug19894382(f1 CHAR(64) DEFAULT 'slave',
f2 TIME, f3 TIMESTAMP NULL, f4 DATETIME,
f5 TIME(3), f6 TIMESTAMP(3) NULL, f7 DATETIME(3));
# Execute prepared statements from mysql_client_test.
# Insert tuples from the client_test_db.bug19894382 to the test.bug19894382.
# Tuples in the client_test_db.bug19894382 are inserted from the mysql_client_test.
INSERT INTO bug19894382 SELECT * FROM client_test_db.bug19894382;
# Replay binlog events
# Insert tuples from the client_test_db.bug19894382 to the test.bug19894382.
# Tuples in the client_test_db.bug19894382 are inserted from the binlog.
INSERT INTO bug19894382(f2, f3, f4, f5, f6, f7)
SELECT f2, f3, f4, f5, f6, f7 FROM client_test_db.bug19894382;
# With fix, tuples of "master" and "slave" will be same. There will not be any difference
# in values inserted for time, timestamp and datetime type columns.
SELECT * FROM bug19894382 ORDER BY f2;
f1	f2	f3	f4	f5	f6	f7
master	07:30:30	2015-04-24 13:30:30	2015-04-24 07:30:30	07:30:30.005	2015-04-24 13:30:30.005	2015-04-24 07:30:30.005
slave	07:30:30	2015-04-24 13:30:30	2015-04-24 07:30:30	07:30:30.005	2015-04-24 13:30:30.005	2015-04-24 07:30:30.005
master	07:30:31	2015-04-24 13:30:31	2015-04-24 07:30:31	07:30:30.502	2015-04-24 13:30:30.502	2015-04-24 07:30:30.502
slave	07:30:31	2015-04-24 13:30:31	2015-04-24 07:30:31	07:30:30.502	2015-04-24 13:30:30.502	2015-04-24 07:30:30.502
# Cleanup
DROP TABLE bug19894382;
# Test parameter string longer than 65k
SET @a=repeat('a', 100000);
prepare s from "select length(?)";
execute s using @a;
length(?)
100000
DROP DATABASE client_test_db;
# Bug#28929657: Assertion !is_temporal() at Item::get_time_from_int()
CREATE TABLE t1 (t time DEFAULT NULL);
INSERT INTO t1 VALUES ('16:07:44');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE t = ?";
EXECUTE s USING @var1;
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t1 (dt datetime DEFAULT NULL);
INSERT INTO t1 VALUES ('2018-11-11 16:07:44');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE dt = ?";
EXECUTE s USING @var1;
ERROR 22007: Incorrect datetime value: '5'
DEALLOCATE PREPARE s;
DROP TABLE t1;
CREATE TABLE t1 (d date DEFAULT NULL);
INSERT INTO t1 VALUES ('2018-11-11');
SET @var1 = 5;
PREPARE s FROM "DELETE FROM t1 WHERE d = ?";
EXECUTE s USING @var1;
ERROR 22007: Incorrect datetime value: '5'
DEALLOCATE PREPARE s;
DROP TABLE t1;
#
# Bug#30438038: MAIN.LOCK_MULTI_BUG38499 FAILS ON PB2
#
CREATE TABLE t(a INT, b INT);
INSERT INTO t VALUES (1, 1), (2, 2), (3, 3), (4, 4);
PREPARE ps FROM
'UPDATE t, (SELECT 1 FROM t UNION SELECT 2 FROM t) e SET a = 0 WHERE FALSE';
EXECUTE ps;
EXECUTE ps;
DROP PREPARE ps;
DROP TABLE t;
# Bug#31437028: SIG11 AT FIELD::HIDDEN() IN SQL/FIELD.H WITH PREPARED SHOW CREATE VIEW
CREATE TABLE t1(c1 int);
INSERT INTO t1 VALUES(1),(2);
CREATE FUNCTION f1() returns INT deterministic return 1;
CREATE VIEW v1 AS SELECT c1 FROM t1 WHERE c1 = f1();
DROP FUNCTION f1;
PREPARE stmt FROM "SHOW CREATE VIEW v1";
EXECUTE stmt;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1` from `t1` where (`t1`.`c1` = `f1`())	utf8mb4	utf8mb4_0900_ai_ci
Warnings:
Warning	1356	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
EXECUTE stmt;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select `t1`.`c1` AS `c1` from `t1` where (`t1`.`c1` = `f1`())	utf8mb4	utf8mb4_0900_ai_ci
Warnings:
Warning	1356	View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DEALLOCATE PREPARE stmt;
DROP VIEW v1;
DROP TABLE t1;
# Bug#32077842: "Illegal mix of collations" errors when matching ASCII field and UNICODE
CREATE TABLE t1 (a char (64) character set latin1, b int unsigned);
PREPARE s FROM 'SELECT a FROM t1 WHERE a=? AND b=?';
SET @a = 'test';
SET @b = 2;
EXECUTE s USING @a, @b;
a
DEALLOCATE PREPARE s;
DROP TABLE t1;
#
# Bug #32751973: REGRESSION: HEAP-USE-AFTER-FREE IN ITEM_FIELD::BIND_FIELDS
#
CREATE TABLE t1 (a INTEGER);
PREPARE s FROM 'SELECT 1 FROM t1 WHERE TRUE OR ( SELECT 1 FROM (SELECT a) q ) = 1';
EXECUTE s;
1
DROP TABLE t1;
#
# Bug #32808790: DON'T ADD CACHES AROUND PREPARED STATEMENT PARAMETERS
#
CREATE TABLE t1 ( pk INTEGER NOT NULL, a INTEGER );
PREPARE q FROM 'EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE pk = ?';
SET @v = 2;
EXECUTE q USING @v;
EXPLAIN
-> Filter: (t1.pk = 2)
    -> Table scan on t1

DROP TABLE t1;
# Bug#32213576: MySQL tries to parse string-bound float as integer
#               and returns wrong error
CREATE TABLE t (f INT NOT NULL) ENGINE=InnoDB;
INSERT INTO t (f) VALUES (0);
PREPARE stmt FROM 'UPDATE t SET f = 100 * ?';
SET @a = '0.3';
EXECUTE stmt USING @a;
DEALLOCATE PREPARE stmt;
SELECT * FROM t;
f
30
DROP TABLE t;
# Bug#32787037: Passed string type binding for integer column
#               incorrectly cast to integer
CREATE TABLE t1 (int_column INT NOT NULL);
INSERT INTO t1 VALUES (1), (2), (3), (4);
SELECT * from t1 where int_column < '1.9';
int_column
1
PREPARE stmt FROM 'SELECT * from t1 where int_column < ?';
SET @a = '1.9';
EXECUTE stmt USING @a;
int_column
1
DEALLOCATE PREPARE stmt;
DROP TABLE t1;
SET GLOBAL log_output=@old_log_output;
TRUNCATE TABLE mysql.general_log;
TRUNCATE TABLE mysql.slow_log;
# Bug#34213338: Broken integer value empty string validation with
#               bind vars (8.0.27 to 8.0.28)
CREATE TABLE ints(i INTEGER);
CREATE TABLE deci(d DECIMAL(12,4));
CREATE TABLE dbls(r DOUBLE);
CREATE TABLE flts(f FLOAT);
SET @empty = '';
SET @spaces = '   ';
SET @intval = '666';
SET @decval = '777.777';
SET @dblval = '888.888e100';
SET @fltval = '1e38';
SET @intvalx = '  666  ';
SET @decvalx = '  777.777  ';
SET @dblvalx = '  888.888e100  ';
SET @fltvalx = '  1e38  ';
INSERT INTO ints VALUES ('');
ERROR HY000: Incorrect integer value: '' for column 'i' at row 1
INSERT INTO deci VALUES ('');
ERROR HY000: Incorrect decimal value: '' for column 'd' at row 1
INSERT INTO dbls VALUES ('');
ERROR HY000: Incorrect DOUBLE value: '' for column 'r' at row 1
INSERT INTO flts VALUES ('');
ERROR HY000: Incorrect FLOAT value: '' for column 'f' at row 1
INSERT INTO ints VALUES ('   ');
ERROR HY000: Incorrect integer value: '   ' for column 'i' at row 1
INSERT INTO deci VALUES ('   ');
ERROR HY000: Incorrect decimal value: '   ' for column 'd' at row 1
INSERT INTO dbls VALUES ('   ');
ERROR HY000: Incorrect DOUBLE value: '   ' for column 'r' at row 1
INSERT INTO flts VALUES ('   ');
ERROR HY000: Incorrect FLOAT value: '   ' for column 'f' at row 1
INSERT INTO ints VALUES (@empty);
ERROR HY000: Incorrect integer value: '' for column 'i' at row 1
INSERT INTO deci VALUES (@empty);
ERROR HY000: Incorrect decimal value: '' for column 'd' at row 1
INSERT INTO dbls VALUES (@empty);
ERROR HY000: Incorrect DOUBLE value: '' for column 'r' at row 1
INSERT INTO flts VALUES (@empty);
ERROR HY000: Incorrect FLOAT value: '' for column 'f' at row 1
INSERT INTO ints VALUES (@spaces);
ERROR HY000: Incorrect integer value: '   ' for column 'i' at row 1
INSERT INTO deci VALUES (@spaces);
ERROR HY000: Incorrect decimal value: '   ' for column 'd' at row 1
INSERT INTO dbls VALUES (@spaces);
ERROR HY000: Incorrect DOUBLE value: '   ' for column 'r' at row 1
INSERT INTO flts VALUES (@spaces);
ERROR HY000: Incorrect FLOAT value: '   ' for column 'f' at row 1
INSERT INTO ints VALUES ('666');
INSERT INTO deci VALUES ('777.777');
INSERT INTO dbls VALUES ('888.888e100');
INSERT INTO flts VALUES ('1e38');
INSERT INTO ints VALUES ('  666  ');
INSERT INTO deci VALUES ('  777.777  ');
INSERT INTO dbls VALUES ('  888.888e100  ');
INSERT INTO flts VALUES ('  1e38  ');
INSERT INTO ints VALUES (@intval);
INSERT INTO deci VALUES (@decval);
INSERT INTO dbls VALUES (@dblval);
INSERT INTO flts VALUES (@fltval);
INSERT INTO ints VALUES (@intvalx);
INSERT INTO deci VALUES (@decvalx);
INSERT INTO dbls VALUES (@dblvalx);
INSERT INTO flts VALUES (@fltvalx);
PREPARE ps1 FROM 'INSERT INTO ints VALUES (?)';
PREPARE ps2 FROM 'INSERT INTO deci VALUES (?)';
PREPARE ps3 FROM 'INSERT INTO dbls VALUES (?)';
PREPARE ps4 FROM 'INSERT INTO flts VALUES (?)';
EXECUTE ps1 USING @empty;
ERROR HY000: Incorrect integer value: '' for column 'i' at row 1
EXECUTE ps2 USING @empty;
ERROR HY000: Incorrect decimal value: '' for column 'd' at row 1
EXECUTE ps3 USING @empty;
ERROR HY000: Incorrect DOUBLE value: '' for column 'r' at row 1
EXECUTE ps4 USING @empty;
ERROR HY000: Incorrect FLOAT value: '' for column 'f' at row 1
EXECUTE ps1 USING @spaces;
ERROR HY000: Incorrect integer value: '   ' for column 'i' at row 1
EXECUTE ps2 USING @spaces;
ERROR HY000: Incorrect decimal value: '   ' for column 'd' at row 1
EXECUTE ps3 USING @spaces;
ERROR HY000: Incorrect DOUBLE value: '   ' for column 'r' at row 1
EXECUTE ps4 USING @spaces;
ERROR HY000: Incorrect FLOAT value: '   ' for column 'f' at row 1
EXECUTE ps1 USING @intval;
EXECUTE ps1 USING @intvalx;
EXECUTE ps2 USING @decval;
EXECUTE ps2 USING @decvalx;
EXECUTE ps3 USING @dblval;
EXECUTE ps3 USING @dblvalx;
EXECUTE ps4 USING @fltval;
EXECUTE ps4 USING @fltvalx;
DEALLOCATE PREPARE ps1;
DEALLOCATE PREPARE ps2;
DEALLOCATE PREPARE ps3;
DEALLOCATE PREPARE ps4;
SELECT * FROM ints;
i
666
666
666
666
666
666
SELECT * FROM deci;
d
777.7770
777.7770
777.7770
777.7770
777.7770
777.7770
SELECT * FROM dbls;
r
8.88888e102
8.88888e102
8.88888e102
8.88888e102
8.88888e102
8.88888e102
SELECT * FROM flts;
f
1e38
1e38
1e38
1e38
1e38
1e38
DROP TABLE ints, deci, dbls, flts;
# Bug#33521861: Server fails to update row via PS but works via query
CREATE TABLE t1 (
id INT NOT NULL,
value VARCHAR(100) NULL
);
INSERT INTO t1 VALUES ROW(1,'A');
flush status;
set @a=1;
set @b='B';
prepare ps from "
UPDATE t1 AS ut
       INNER JOIN (VALUES ROW(?, ?)) AS vt (id, value)
       ON ut.id = vt.id
SET ut.value = vt.value";
execute ps using @a, @b;
SELECT * FROM t1;
id	value
1	B
SHOW STATUS LIKE 'Com_stmt_reprepare';
Variable_name	Value
Com_stmt_reprepare	1
UPDATE t1 SET id = 1, value = 'A';
Notice the above statement is implicitly reprepared, as there
is no context available to guess the desired types.
Using explicit CAST avoids the reprepare.
prepare ps from "
UPDATE t1 AS ut
       INNER JOIN (VALUES ROW(CAST(? AS SIGNED), CAST(? AS CHAR))
                  ) AS vt (id, value)
       ON ut.id = vt.id
SET ut.value = vt.value";
execute ps using @a, @b;
SELECT * FROM t1;
id	value
1	B
SHOW STATUS LIKE 'Com_stmt_reprepare';
Variable_name	Value
Com_stmt_reprepare	1
deallocate prepare ps;
DROP TABLE t1;
