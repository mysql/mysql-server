set optimizer_switch='batched_key_access=on,block_nested_loop=off,mrr_cost_based=off';
set optimizer_switch='semijoin=on,materialization=on,firstmatch=on,loosescan=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=off';
drop table if exists t1,t2,t3,t4,t11;
drop table if exists t1_1,t1_2,t9_1,t9_2,t1aa,t2aa;
drop view if exists v1;
CREATE TABLE t1 (
Period smallint(4) unsigned zerofill DEFAULT '0000' NOT NULL,
Varor_period smallint(4) unsigned DEFAULT '0' NOT NULL
);
Warnings:
Warning	1681	The ZEROFILL attribute is deprecated and will be removed in a future release. Use the LPAD function to zero-pad numbers, or store the formatted numbers in a CHAR column.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (9410,9412);
select period from t1;
period
9410
select * from t1;
Period	Varor_period
9410	9412
select t1.* from t1;
Period	Varor_period
9410	9412
CREATE TABLE t2 (
auto int not null auto_increment,
fld1 int(6) unsigned zerofill DEFAULT '000000' NOT NULL,
companynr tinyint(2) unsigned zerofill DEFAULT '00' NOT NULL,
fld3 char(30) DEFAULT '' NOT NULL,
fld4 char(35) DEFAULT '' NOT NULL,
fld5 char(35) DEFAULT '' NOT NULL,
fld6 char(4) DEFAULT '' NOT NULL,
UNIQUE fld1 (fld1),
KEY fld3 (fld3),
PRIMARY KEY (auto)
) charset utf8mb4;
Warnings:
Warning	1681	The ZEROFILL attribute is deprecated and will be removed in a future release. Use the LPAD function to zero-pad numbers, or store the formatted numbers in a CHAR column.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	The ZEROFILL attribute is deprecated and will be removed in a future release. Use the LPAD function to zero-pad numbers, or store the formatted numbers in a CHAR column.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
select t2.fld3 from t2 where companynr = 58 and fld3 like "%imaginable%";
fld3
imaginable
select fld3 from t2 where fld3 like "%cultivation" ;
fld3
cultivation
select t2.fld3,companynr from t2 where companynr = 57+1 order by fld3;
fld3	companynr
concoct	58
druggists	58
engrossing	58
Eurydice	58
exclaimers	58
ferociousness	58
hopelessness	58
Huey	58
imaginable	58
judges	58
merging	58
ostrich	58
peering	58
Phelps	58
presumes	58
Ruth	58
sentences	58
Shylock	58
straggled	58
synergy	58
thanking	58
tying	58
unlocks	58
select fld3,companynr from t2 where companynr = 58 order by fld3;
fld3	companynr
concoct	58
druggists	58
engrossing	58
Eurydice	58
exclaimers	58
ferociousness	58
hopelessness	58
Huey	58
imaginable	58
judges	58
merging	58
ostrich	58
peering	58
Phelps	58
presumes	58
Ruth	58
sentences	58
Shylock	58
straggled	58
synergy	58
thanking	58
tying	58
unlocks	58
select fld3 from t2 order by fld3 desc limit 10;
fld3
youthfulness
yelped
Wotan
workers
Witt
witchcraft
Winsett
Willy
willed
wildcats
select fld3 from t2 order by fld3 desc limit 5;
fld3
youthfulness
yelped
Wotan
workers
Witt
select fld3 from t2 order by fld3 desc limit 5,5;
fld3
witchcraft
Winsett
Willy
willed
wildcats
select t2.fld3 from t2 where fld3 = 'honeysuckle';
fld3
honeysuckle
select t2.fld3 from t2 where fld3 LIKE 'honeysuckl_';
fld3
honeysuckle
select t2.fld3 from t2 where fld3 LIKE 'hon_ysuckl_';
fld3
honeysuckle
select t2.fld3 from t2 where fld3 LIKE 'honeysuckle%';
fld3
honeysuckle
select t2.fld3 from t2 where fld3 LIKE 'h%le';
fld3
honeysuckle
select t2.fld3 from t2 where fld3 LIKE 'honeysuckle_';
fld3
select t2.fld3 from t2 where fld3 LIKE 'don_t_find_me_please%';
fld3
explain select t2.fld3 from t2 where fld3 = 'honeysuckle';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	fld3	fld3	120	const	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` where (`test`.`t2`.`fld3` = 'honeysuckle')
explain select fld3 from t2 ignore index (fld3) where fld3 = 'honeysuckle';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` IGNORE INDEX (`fld3`) where (`test`.`t2`.`fld3` = 'honeysuckle')
explain select fld3 from t2 use index (fld1) where fld3 = 'honeysuckle';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` USE INDEX (`fld1`) where (`test`.`t2`.`fld3` = 'honeysuckle')
explain select fld3 from t2 use index (fld3) where fld3 = 'honeysuckle';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	fld3	fld3	120	const	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` USE INDEX (`fld3`) where (`test`.`t2`.`fld3` = 'honeysuckle')
explain select fld3 from t2 use index (fld1,fld3) where fld3 = 'honeysuckle';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	fld3	fld3	120	const	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` USE INDEX (`fld3`) USE INDEX (`fld1`) where (`test`.`t2`.`fld3` = 'honeysuckle')
explain select fld3 from t2 ignore index (fld3,not_used);
ERROR 42000: Key 'not_used' doesn't exist in table 't2'
explain select fld3 from t2 use index (not_used);
ERROR 42000: Key 'not_used' doesn't exist in table 't2'
select t2.fld3 from t2 where fld3 >= 'honeysuckle' and fld3 <= 'honoring' order by fld3;
fld3
honeysuckle
honoring
explain select t2.fld3 from t2 where fld3 >= 'honeysuckle' and fld3 <= 'honoring' order by fld3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	fld3	fld3	120	NULL	2	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` where ((`test`.`t2`.`fld3` >= 'honeysuckle') and (`test`.`t2`.`fld3` <= 'honoring')) order by `test`.`t2`.`fld3`
select fld1,fld3 from t2 where fld3="Colombo" or fld3 = "nondecreasing" order by fld3;
fld1	fld3
148504	Colombo
068305	Colombo
000000	nondecreasing
select fld1,fld3 from t2 where companynr = 37 and fld3 = 'appendixes';
fld1	fld3
232605	appendixes
1232605	appendixes
1232606	appendixes
1232607	appendixes
1232608	appendixes
1232609	appendixes
select fld1 from t2 where fld1=250501 or fld1="250502";
fld1
250501
250502
explain select fld1 from t2 where fld1=250501 or fld1="250502";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	fld1	fld1	4	NULL	2	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld1` AS `fld1` from `test`.`t2` where ((`test`.`t2`.`fld1` = 250501) or (`test`.`t2`.`fld1` = 250502))
select fld1 from t2 where fld1=250501 or fld1=250502 or fld1 >= 250505 and fld1 <= 250601 or fld1 between 250501 and 250502;
fld1
250501
250502
250505
250601
explain select fld1 from t2 where fld1=250501 or fld1=250502 or fld1 >= 250505 and fld1 <= 250601 or fld1 between 250501 and 250502;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	fld1	fld1	4	NULL	4	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld1` AS `fld1` from `test`.`t2` where ((`test`.`t2`.`fld1` = 250501) or (`test`.`t2`.`fld1` = 250502) or ((`test`.`t2`.`fld1` >= 250505) and (`test`.`t2`.`fld1` <= 250601)) or (`test`.`t2`.`fld1` between 250501 and 250502))
select fld1,fld3 from t2 where companynr = 37 and fld3 like 'f%';
fld1	fld3
012001	flanking
013602	foldout
013606	fingerings
018007	fanatic
018017	featherweight
018054	fetters
018103	flint
018104	flopping
036002	funereal
038017	fetched
038205	firearm
058004	Fenton
088303	feminine
186002	freakish
188007	flurried
188505	fitting
198006	furthermore
202301	Fitzpatrick
208101	fiftieth
208113	freest
218008	finishers
218022	feed
218401	faithful
226205	foothill
226209	furnishings
228306	forthcoming
228311	fated
231315	freezes
232102	forgivably
238007	filial
238008	fixedly
select fld3 from t2 where fld3 like "L%" and fld3 = "ok";
fld3
select fld3 from t2 where (fld3 like "C%" and fld3 = "Chantilly");
fld3
Chantilly
select fld1,fld3 from t2 where fld1 like "25050%";
fld1	fld3
250501	poisoning
250502	Iraqis
250503	heaving
250504	population
250505	bomb
select fld1,fld3 from t2 where fld1 like "25050_";
fld1	fld3
250501	poisoning
250502	Iraqis
250503	heaving
250504	population
250505	bomb
select distinct companynr from t2;
companynr
00
37
36
50
58
29
40
53
65
41
34
68
select distinct companynr from t2 order by companynr;
companynr
00
29
34
36
37
40
41
50
53
58
65
68
select distinct companynr from t2 order by companynr desc;
companynr
68
65
58
53
50
41
40
37
36
34
29
00
select distinct t2.fld3,period from t2,t1 where companynr=37 and fld3 like "O%";
fld3	period
obliterates	9410
offload	9410
opaquely	9410
organizer	9410
overestimating	9410
overlay	9410
select distinct fld3 from t2 where companynr = 34 order by fld3;
fld3
absentee
accessed
ahead
alphabetic
Asiaticizations
attitude
aye
bankruptcies
belays
Blythe
bomb
boulevard
bulldozes
cannot
caressing
charcoal
checksumming
chess
clubroom
colorful
cosy
creator
crying
Darius
diffusing
duality
Eiffel
Epiphany
Ernestine
explorers
exterminated
famine
forked
Gershwins
heaving
Hodges
Iraqis
Italianization
Lagos
landslide
libretto
Majorca
mastering
narrowed
occurred
offerers
Palestine
Peruvianizes
pharmaceutic
poisoning
population
Pygmalion
rats
realest
recording
regimented
retransmitting
reviver
rouses
scars
sicker
sleepwalk
stopped
sugars
translatable
uncles
unexpected
uprisings
versatility
vest
select distinct fld3 from t2 limit 10;
fld3
abates
abiding
Abraham
abrogating
absentee
abut
accessed
accruing
accumulating
accuracies
select distinct fld3 from t2 having fld3 like "A%" limit 10;
fld3
abates
abiding
Abraham
abrogating
absentee
abut
accessed
accruing
accumulating
accuracies
select distinct substring(fld3,1,3) from t2 where fld3 like "A%";
substring(fld3,1,3)
aba
abi
Abr
abs
abu
acc
acq
acu
Ade
adj
Adl
adm
Ado
ads
adv
aer
aff
afi
afl
afo
agi
ahe
aim
air
Ald
alg
ali
all
alp
alr
ama
ame
amm
ana
and
ane
Ang
ani
Ann
Ant
api
app
aqu
Ara
arc
Arm
arr
Art
Asi
ask
asp
ass
ast
att
aud
Aug
aut
ave
avo
awe
aye
Azt
select distinct substring(fld3,1,3) as a from t2 having a like "A%" order by a limit 10;
a
aba
abi
Abr
abs
abu
acc
acq
acu
Ade
adj
select distinct substring(fld3,1,3) from t2 where fld3 like "A%" limit 10;
substring(fld3,1,3)
aba
abi
Abr
abs
abu
acc
acq
acu
Ade
adj
select distinct substring(fld3,1,3) as a from t2 having a like "A%" limit 10;
a
aba
abi
Abr
abs
abu
acc
acq
acu
Ade
adj
create table t3 (
period    int not null,
name      char(32) not null,
companynr int not null,
price     double(11,0),
price2     double(11,0),
key (period),
key (name)
);
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
create temporary table tmp engine = myisam select * from t3;
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
insert into tmp select * from t3;
insert into t3 select * from tmp;
alter table t3 add t2nr int not null auto_increment primary key first;
drop table tmp;
SET BIG_TABLES=1;
select distinct concat(fld3," ",fld3) as namn from t2,t3 where t2.fld1=t3.t2nr order by namn limit 10;
namn
Abraham Abraham
abrogating abrogating
admonishing admonishing
Adolph Adolph
afield afield
aging aging
ammonium ammonium
analyzable analyzable
animals animals
animized animized
SET BIG_TABLES=0;
select distinct concat(fld3," ",fld3) from t2,t3 where t2.fld1=t3.t2nr order by fld3 limit 10;
concat(fld3," ",fld3)
Abraham Abraham
abrogating abrogating
admonishing admonishing
Adolph Adolph
afield afield
aging aging
ammonium ammonium
analyzable analyzable
animals animals
animized animized
select distinct fld5 from t2 limit 10;
fld5
neat
Steinberg
jarring
tinily
balled
persist
attainments
fanatic
measures
rightfulness
select distinct companynr, fld3,count(*) from t2 group by companynr, fld3 order by companynr, fld3 limit 10;
companynr	fld3	count(*)
00	affixed	1
00	and	1
00	annoyers	1
00	Anthony	1
00	assayed	1
00	assurers	1
00	attendants	1
00	bedlam	1
00	bedpost	1
00	boasted	1
SET BIG_TABLES=1;
select distinct companynr, fld3,count(*) from t2 group by companynr, fld3 order by companynr, fld3 limit 10;
companynr	fld3	count(*)
00	affixed	1
00	and	1
00	annoyers	1
00	Anthony	1
00	assayed	1
00	assurers	1
00	attendants	1
00	bedlam	1
00	bedpost	1
00	boasted	1
SET BIG_TABLES=0;
select distinct companynr, fld3,repeat("a",length(fld3)),count(*) from t2 group by companynr ,fld3 order by companynr, fld3 limit 100,10;
companynr	fld3	repeat("a",length(fld3))	count(*)
29	chancellor	aaaaaaaaaa	1
29	Chippewa	aaaaaaaa	1
29	circumference	aaaaaaaaaaaaa	1
29	circus	aaaaaa	1
29	cited	aaaaa	1
29	Colombo	aaaaaaa	1
29	congresswoman	aaaaaaaaaaaaa	1
29	contrition	aaaaaaaaaa	1
29	corny	aaaaa	1
29	cultivation	aaaaaaaaaaa	1
select distinct companynr,rtrim(space(512+companynr)) from t3 order by 1,2;
companynr	rtrim(space(512+companynr))
37	
78	
101	
154	
311	
447	
512	
select distinct fld3 from t2,t3 where t2.companynr = 34 and t2.fld1=t3.t2nr order by fld3;
fld3
explain select t3.t2nr,fld3 from t2,t3 where t2.companynr = 34 and t2.fld1=t3.t2nr order by t3.t2nr,fld3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	fld1	NULL	NULL	NULL	1199	10.00	Using where; Using temporary; Using filesort
1	SIMPLE	t3	NULL	eq_ref	PRIMARY	PRIMARY	4	test.t2.fld1	1	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`t2nr` AS `t2nr`,`test`.`t2`.`fld3` AS `fld3` from `test`.`t2` join `test`.`t3` where ((`test`.`t2`.`companynr` = 34) and (`test`.`t2`.`fld1` = `test`.`t3`.`t2nr`)) order by `test`.`t3`.`t2nr`,`test`.`t2`.`fld3`
explain select * from t3 as t1,t3 where t1.period=t3.period order by t3.period;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	period	NULL	NULL	NULL	41810	100.00	Using temporary; Using filesort
1	SIMPLE	t3	NULL	ref	period	period	4	test.t1.period	4181	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`t2nr` AS `t2nr`,`test`.`t1`.`period` AS `period`,`test`.`t1`.`name` AS `name`,`test`.`t1`.`companynr` AS `companynr`,`test`.`t1`.`price` AS `price`,`test`.`t1`.`price2` AS `price2`,`test`.`t3`.`t2nr` AS `t2nr`,`test`.`t3`.`period` AS `period`,`test`.`t3`.`name` AS `name`,`test`.`t3`.`companynr` AS `companynr`,`test`.`t3`.`price` AS `price`,`test`.`t3`.`price2` AS `price2` from `test`.`t3` `t1` join `test`.`t3` where (`test`.`t3`.`period` = `test`.`t1`.`period`) order by `test`.`t3`.`period`
explain select * from t3 as t1,t3 where t1.period=t3.period order by t3.period limit 10;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	ALL	period	NULL	NULL	NULL	41810	100.00	Using temporary; Using filesort
1	SIMPLE	t1	NULL	ref	period	period	4	test.t3.period	4181	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`t2nr` AS `t2nr`,`test`.`t1`.`period` AS `period`,`test`.`t1`.`name` AS `name`,`test`.`t1`.`companynr` AS `companynr`,`test`.`t1`.`price` AS `price`,`test`.`t1`.`price2` AS `price2`,`test`.`t3`.`t2nr` AS `t2nr`,`test`.`t3`.`period` AS `period`,`test`.`t3`.`name` AS `name`,`test`.`t3`.`companynr` AS `companynr`,`test`.`t3`.`price` AS `price`,`test`.`t3`.`price2` AS `price2` from `test`.`t3` `t1` join `test`.`t3` where (`test`.`t1`.`period` = `test`.`t3`.`period`) order by `test`.`t3`.`period` limit 10
explain select * from t3 as t1,t3 where t1.period=t3.period order by t1.period limit 10;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	period	NULL	NULL	NULL	41810	100.00	Using temporary; Using filesort
1	SIMPLE	t3	NULL	ref	period	period	4	test.t1.period	4181	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`t2nr` AS `t2nr`,`test`.`t1`.`period` AS `period`,`test`.`t1`.`name` AS `name`,`test`.`t1`.`companynr` AS `companynr`,`test`.`t1`.`price` AS `price`,`test`.`t1`.`price2` AS `price2`,`test`.`t3`.`t2nr` AS `t2nr`,`test`.`t3`.`period` AS `period`,`test`.`t3`.`name` AS `name`,`test`.`t3`.`companynr` AS `companynr`,`test`.`t3`.`price` AS `price`,`test`.`t3`.`price2` AS `price2` from `test`.`t3` `t1` join `test`.`t3` where (`test`.`t3`.`period` = `test`.`t1`.`period`) order by `test`.`t1`.`period` limit 10
select period from t1;
period
9410
select period from t1 where period=1900;
period
select fld3,period from t1,t2 where fld1 = 011401 order by period;
fld3	period
breaking	9410
select fld3,period from t2,t3 where t2.fld1 = 011401 and t2.fld1=t3.t2nr and t3.period=1001;
fld3	period
breaking	1001
explain select fld3,period from t2,t3 where t2.fld1 = 011401 and t3.t2nr=t2.fld1 and 1001 = t3.period;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	const	fld1	fld1	4	const	1	100.00	NULL
1	SIMPLE	t3	NULL	const	PRIMARY,period	PRIMARY	4	const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select 'breaking' AS `fld3`,'1001' AS `period` from `test`.`t2` join `test`.`t3` where true
select fld3,period from t2,t1 where companynr*10 = 37*10;
fld3	period
breaking	9410
Romans	9410
intercepted	9410
bewilderingly	9410
astound	9410
admonishing	9410
sumac	9410
flanking	9410
combed	9410
subjective	9410
scatterbrain	9410
Eulerian	9410
Kane	9410
overlay	9410
perturb	9410
goblins	9410
annihilates	9410
Wotan	9410
snatching	9410
concludes	9410
laterally	9410
yelped	9410
grazing	9410
Baird	9410
celery	9410
misunderstander	9410
handgun	9410
foldout	9410
mystic	9410
succumbed	9410
Nabisco	9410
fingerings	9410
aging	9410
afield	9410
ammonium	9410
boat	9410
intelligibility	9410
Augustine	9410
teethe	9410
dreaded	9410
scholastics	9410
audiology	9410
wallet	9410
parters	9410
eschew	9410
quitter	9410
neat	9410
Steinberg	9410
jarring	9410
tinily	9410
balled	9410
persist	9410
attainments	9410
fanatic	9410
measures	9410
rightfulness	9410
capably	9410
impulsive	9410
starlet	9410
terminators	9410
untying	9410
announces	9410
featherweight	9410
pessimist	9410
daughter	9410
decliner	9410
lawgiver	9410
stated	9410
readable	9410
attrition	9410
cascade	9410
motors	9410
interrogate	9410
pests	9410
stairway	9410
dopers	9410
testicle	9410
Parsifal	9410
leavings	9410
postulation	9410
squeaking	9410
contrasted	9410
leftover	9410
whiteners	9410
erases	9410
Punjab	9410
Merritt	9410
Quixotism	9410
sweetish	9410
dogging	9410
scornfully	9410
bellow	9410
bills	9410
cupboard	9410
sureties	9410
puddings	9410
fetters	9410
bivalves	9410
incurring	9410
Adolph	9410
pithed	9410
Miles	9410
trimmings	9410
tragedies	9410
skulking	9410
flint	9410
flopping	9410
relaxing	9410
offload	9410
suites	9410
lists	9410
animized	9410
multilayer	9410
standardizes	9410
Judas	9410
vacuuming	9410
dentally	9410
humanness	9410
inch	9410
Weissmuller	9410
irresponsibly	9410
luckily	9410
culled	9410
medical	9410
bloodbath	9410
subschema	9410
animals	9410
Micronesia	9410
repetitions	9410
Antares	9410
ventilate	9410
pityingly	9410
interdependent	9410
Graves	9410
neonatal	9410
chafe	9410
honoring	9410
realtor	9410
elite	9410
funereal	9410
abrogating	9410
sorters	9410
Conley	9410
lectured	9410
Abraham	9410
Hawaii	9410
cage	9410
hushes	9410
Simla	9410
reporters	9410
Dutchman	9410
descendants	9410
groupings	9410
dissociate	9410
coexist	9410
Beebe	9410
Taoism	9410
Connally	9410
fetched	9410
checkpoints	9410
rusting	9410
galling	9410
obliterates	9410
traitor	9410
resumes	9410
analyzable	9410
terminator	9410
gritty	9410
firearm	9410
minima	9410
Selfridge	9410
disable	9410
witchcraft	9410
betroth	9410
Manhattanize	9410
imprint	9410
peeked	9410
swelling	9410
interrelationships	9410
riser	9410
Gandhian	9410
peacock	9410
bee	9410
kanji	9410
dental	9410
scarf	9410
chasm	9410
insolence	9410
syndicate	9410
alike	9410
imperial	9410
convulsion	9410
railway	9410
validate	9410
normalizes	9410
comprehensive	9410
chewing	9410
denizen	9410
schemer	9410
chronicle	9410
Kline	9410
Anatole	9410
partridges	9410
brunch	9410
recruited	9410
dimensions	9410
Chicana	9410
announced	9410
praised	9410
employing	9410
linear	9410
quagmire	9410
western	9410
relishing	9410
serving	9410
scheduling	9410
lore	9410
eventful	9410
arteriole	9410
disentangle	9410
cured	9410
Fenton	9410
avoidable	9410
drains	9410
detectably	9410
husky	9410
impelling	9410
undoes	9410
evened	9410
squeezes	9410
destroyer	9410
rudeness	9410
beaner	9410
boorish	9410
Everhart	9410
encompass	9410
mushrooms	9410
Alison	9410
externally	9410
pellagra	9410
cult	9410
creek	9410
Huffman	9410
Majorca	9410
governing	9410
gadfly	9410
reassigned	9410
intentness	9410
craziness	9410
psychic	9410
squabbled	9410
burlesque	9410
capped	9410
extracted	9410
DiMaggio	9410
exclamation	9410
subdirectory	9410
Gothicism	9410
feminine	9410
metaphysically	9410
sanding	9410
Miltonism	9410
freakish	9410
index	9410
straight	9410
flurried	9410
denotative	9410
coming	9410
commencements	9410
gentleman	9410
gifted	9410
Shanghais	9410
sportswriting	9410
sloping	9410
navies	9410
leaflet	9410
shooter	9410
Joplin	9410
babies	9410
assails	9410
admiring	9410
swaying	9410
Goldstine	9410
fitting	9410
Norwalk	9410
analogy	9410
deludes	9410
cokes	9410
Clayton	9410
exhausts	9410
causality	9410
sating	9410
icon	9410
throttles	9410
communicants	9410
dehydrate	9410
priceless	9410
publicly	9410
incidentals	9410
commonplace	9410
mumbles	9410
furthermore	9410
cautioned	9410
parametrized	9410
registration	9410
sadly	9410
positioning	9410
babysitting	9410
eternal	9410
hoarder	9410
congregates	9410
rains	9410
workers	9410
sags	9410
unplug	9410
garage	9410
boulder	9410
specifics	9410
Teresa	9410
Winsett	9410
convenient	9410
buckboards	9410
amenities	9410
resplendent	9410
sews	9410
participated	9410
Simon	9410
certificates	9410
Fitzpatrick	9410
Evanston	9410
misted	9410
textures	9410
save	9410
count	9410
rightful	9410
chaperone	9410
Lizzy	9410
clenched	9410
effortlessly	9410
accessed	9410
beaters	9410
Hornblower	9410
vests	9410
indulgences	9410
infallibly	9410
unwilling	9410
excrete	9410
spools	9410
crunches	9410
overestimating	9410
ineffective	9410
humiliation	9410
sophomore	9410
star	9410
rifles	9410
dialysis	9410
arriving	9410
indulge	9410
clockers	9410
languages	9410
Antarctica	9410
percentage	9410
ceiling	9410
specification	9410
regimented	9410
ciphers	9410
pictures	9410
serpents	9410
allot	9410
realized	9410
mayoral	9410
opaquely	9410
hostess	9410
fiftieth	9410
incorrectly	9410
decomposition	9410
stranglings	9410
mixture	9410
electroencephalography	9410
similarities	9410
charges	9410
freest	9410
Greenberg	9410
tinting	9410
expelled	9410
warm	9410
smoothed	9410
deductions	9410
Romano	9410
bitterroot	9410
corset	9410
securing	9410
environing	9410
cute	9410
Crays	9410
heiress	9410
inform	9410
avenge	9410
universals	9410
Kinsey	9410
ravines	9410
bestseller	9410
equilibrium	9410
extents	9410
relatively	9410
pressure	9410
critiques	9410
befouled	9410
rightfully	9410
mechanizing	9410
Latinizes	9410
timesharing	9410
Aden	9410
embassies	9410
males	9410
shapelessly	9410
mastering	9410
Newtonian	9410
finishers	9410
abates	9410
teem	9410
kiting	9410
stodgy	9410
feed	9410
guitars	9410
airships	9410
store	9410
denounces	9410
Pyle	9410
Saxony	9410
serializations	9410
Peruvian	9410
taxonomically	9410
kingdom	9410
stint	9410
Sault	9410
faithful	9410
Ganymede	9410
tidiness	9410
gainful	9410
contrary	9410
Tipperary	9410
tropics	9410
theorizers	9410
renew	9410
already	9410
terminal	9410
Hegelian	9410
hypothesizer	9410
warningly	9410
journalizing	9410
nested	9410
Lars	9410
saplings	9410
foothill	9410
labeled	9410
imperiously	9410
reporters	9410
furnishings	9410
precipitable	9410
discounts	9410
excises	9410
Stalin	9410
despot	9410
ripeness	9410
Arabia	9410
unruly	9410
mournfulness	9410
boom	9410
slaughter	9410
Sabine	9410
handy	9410
rural	9410
organizer	9410
shipyard	9410
civics	9410
inaccuracy	9410
rules	9410
juveniles	9410
comprised	9410
investigations	9410
stabilizes	9410
seminaries	9410
Hunter	9410
sporty	9410
test	9410
weasels	9410
CERN	9410
tempering	9410
afore	9410
Galatean	9410
techniques	9410
error	9410
veranda	9410
severely	9410
Cassites	9410
forthcoming	9410
guides	9410
vanish	9410
lied	9410
sawtooth	9410
fated	9410
gradually	9410
widens	9410
preclude	9410
evenhandedly	9410
percentage	9410
disobedience	9410
humility	9410
gleaning	9410
petted	9410
bloater	9410
minion	9410
marginal	9410
apiary	9410
measures	9410
precaution	9410
repelled	9410
primary	9410
coverings	9410
Artemia	9410
navigate	9410
spatial	9410
Gurkha	9410
meanwhile	9410
Melinda	9410
Butterfield	9410
Aldrich	9410
previewing	9410
glut	9410
unaffected	9410
inmate	9410
mineral	9410
impending	9410
meditation	9410
ideas	9410
miniaturizes	9410
lewdly	9410
title	9410
youthfulness	9410
creak	9410
Chippewa	9410
clamored	9410
freezes	9410
forgivably	9410
reduce	9410
McGovern	9410
Nazis	9410
epistle	9410
socializes	9410
conceptions	9410
Kevin	9410
uncovering	9410
chews	9410
appendixes	9410
appendixes	9410
appendixes	9410
appendixes	9410
appendixes	9410
appendixes	9410
raining	9410
infest	9410
compartment	9410
minting	9410
ducks	9410
roped	9410
waltz	9410
Lillian	9410
repressions	9410
chillingly	9410
noncritical	9410
lithograph	9410
spongers	9410
parenthood	9410
posed	9410
instruments	9410
filial	9410
fixedly	9410
relives	9410
Pandora	9410
watering	9410
ungrateful	9410
secures	9410
poison	9410
dusted	9410
encompasses	9410
presentation	9410
Kantian	9410
select fld3,period,price,price2 from t2,t3 where t2.fld1=t3.t2nr and period >= 1001 and period <= 1002 and t2.companynr = 37 order by fld3,period, price;
fld3	period	price	price2
admonishing	1002	28357832	8723648
analyzable	1002	28357832	8723648
annihilates	1001	5987435	234724
Antares	1002	28357832	8723648
astound	1001	5987435	234724
audiology	1001	5987435	234724
Augustine	1002	28357832	8723648
Baird	1002	28357832	8723648
bewilderingly	1001	5987435	234724
breaking	1001	5987435	234724
Conley	1001	5987435	234724
dentally	1002	28357832	8723648
dissociate	1002	28357832	8723648
elite	1001	5987435	234724
eschew	1001	5987435	234724
Eulerian	1001	5987435	234724
flanking	1001	5987435	234724
foldout	1002	28357832	8723648
funereal	1002	28357832	8723648
galling	1002	28357832	8723648
Graves	1001	5987435	234724
grazing	1001	5987435	234724
groupings	1001	5987435	234724
handgun	1001	5987435	234724
humility	1002	28357832	8723648
impulsive	1002	28357832	8723648
inch	1001	5987435	234724
intelligibility	1001	5987435	234724
jarring	1001	5987435	234724
lawgiver	1001	5987435	234724
lectured	1002	28357832	8723648
Merritt	1002	28357832	8723648
neonatal	1001	5987435	234724
offload	1002	28357832	8723648
parters	1002	28357832	8723648
pityingly	1002	28357832	8723648
puddings	1002	28357832	8723648
Punjab	1001	5987435	234724
quitter	1002	28357832	8723648
realtor	1001	5987435	234724
relaxing	1001	5987435	234724
repetitions	1001	5987435	234724
resumes	1001	5987435	234724
Romans	1002	28357832	8723648
rusting	1001	5987435	234724
scholastics	1001	5987435	234724
skulking	1002	28357832	8723648
stated	1002	28357832	8723648
suites	1002	28357832	8723648
sureties	1001	5987435	234724
testicle	1002	28357832	8723648
tinily	1002	28357832	8723648
tragedies	1001	5987435	234724
trimmings	1001	5987435	234724
vacuuming	1001	5987435	234724
ventilate	1001	5987435	234724
wallet	1001	5987435	234724
Weissmuller	1002	28357832	8723648
Wotan	1002	28357832	8723648
select t2.fld1,fld3,period,price,price2 from t2,t3 where t2.fld1>= 18201 and t2.fld1 <= 18811 and t2.fld1=t3.t2nr and period = 1001 and t2.companynr = 37;
fld1	fld3	period	price	price2
018201	relaxing	1001	5987435	234724
018601	vacuuming	1001	5987435	234724
018801	inch	1001	5987435	234724
018811	repetitions	1001	5987435	234724
create table t4 (
companynr tinyint(2) unsigned zerofill NOT NULL default '00',
companyname char(30) NOT NULL default '',
PRIMARY KEY (companynr),
UNIQUE KEY companyname(companyname)
) ENGINE=MyISAM MAX_ROWS=50 PACK_KEYS=1 COMMENT='companynames';
Warnings:
Warning	1681	The ZEROFILL attribute is deprecated and will be removed in a future release. Use the LPAD function to zero-pad numbers, or store the formatted numbers in a CHAR column.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
select STRAIGHT_JOIN t2.companynr,companyname from t4,t2 where t2.companynr=t4.companynr group by t2.companynr;
companynr	companyname
00	Unknown
29	company 1
34	company 2
36	company 3
37	company 4
40	company 5
41	company 6
50	company 11
53	company 7
58	company 8
65	company 9
68	company 10
select SQL_SMALL_RESULT t2.companynr,companyname from t4,t2 where t2.companynr=t4.companynr group by t2.companynr;
companynr	companyname
29	company 1
34	company 2
36	company 3
37	company 4
40	company 5
41	company 6
53	company 7
58	company 8
65	company 9
68	company 10
50	company 11
00	Unknown
select * from t1,t1 t12;
Period	Varor_period	Period	Varor_period
9410	9412	9410	9412
select t2.fld1,t22.fld1 from t2,t2 t22 where t2.fld1 >= 250501 and t2.fld1 <= 250505 and t22.fld1 >= 250501 and t22.fld1 <= 250505;
fld1	fld1
250501	250501
250501	250502
250501	250503
250501	250504
250501	250505
250502	250501
250502	250502
250502	250503
250502	250504
250502	250505
250503	250501
250503	250502
250503	250503
250503	250504
250503	250505
250504	250501
250504	250502
250504	250503
250504	250504
250504	250505
250505	250501
250505	250502
250505	250503
250505	250504
250505	250505
insert into t2 (fld1, companynr) values (999999,99);
select t2.companynr,companyname from t2 left join t4 using (companynr) where t4.companynr is null;
companynr	companyname
99	NULL
select count(*) from t2 left join t4 using (companynr) where t4.companynr is not null;
count(*)
1199
explain select t2.companynr,companyname from t2 left join t4 using (companynr) where t4.companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1200	100.00	NULL
1	SIMPLE	t4	NULL	eq_ref	PRIMARY	PRIMARY	1	test.t2.companynr	1	100.00	Using where; Not exists; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t2` left join `test`.`t4` on((`test`.`t4`.`companynr` = `test`.`t2`.`companynr`)) where (`test`.`t4`.`companynr` is null)
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	ALL	NULL	NULL	NULL	NULL	12	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1200	10.00	Using where; Not exists
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (`test`.`t2`.`companynr` is null)
select companynr,companyname from t2 left join t4 using (companynr) where companynr is null;
companynr	companyname
select count(*) from t2 left join t4 using (companynr) where companynr is not null;
count(*)
1200
explain select companynr,companyname from t2 left join t4 using (companynr) where companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t2` left join `test`.`t4` on(multiple equal(`test`.`t2`.`companynr`, `test`.`t4`.`companynr`)) where false
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on(multiple equal(`test`.`t4`.`companynr`, `test`.`t2`.`companynr`)) where false
delete from t2 where fld1=999999;
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	33.33	Using where
1	SIMPLE	t4	NULL	eq_ref	PRIMARY	PRIMARY	1	test.t2.companynr	1	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` join `test`.`t2` where ((`test`.`t4`.`companynr` = `test`.`t2`.`companynr`) and (`test`.`t2`.`companynr` > 0))
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr > 0 or t2.companynr < 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	33.33	Using where
1	SIMPLE	t4	NULL	eq_ref	PRIMARY	PRIMARY	1	test.t2.companynr	1	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` join `test`.`t2` where ((`test`.`t4`.`companynr` = `test`.`t2`.`companynr`) and (`test`.`t2`.`companynr` > 0))
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr > 0 and t4.companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	33.33	Using where
1	SIMPLE	t4	NULL	eq_ref	PRIMARY	PRIMARY	1	test.t2.companynr	1	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` join `test`.`t2` where ((`test`.`t4`.`companynr` = `test`.`t2`.`companynr`) and (`test`.`t2`.`companynr` > 0) and (`test`.`t2`.`companynr` > 0))
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	range	PRIMARY	PRIMARY	1	NULL	11	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (`test`.`t4`.`companynr` > 0)
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr > 0 or companynr < 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	range	PRIMARY	PRIMARY	1	NULL	11	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (`test`.`t4`.`companynr` > 0)
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr > 0 and companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	range	PRIMARY	PRIMARY	1	NULL	11	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where ((`test`.`t4`.`companynr` > 0) and (`test`.`t4`.`companynr` > 0))
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr > 0 or t2.companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	ALL	NULL	NULL	NULL	NULL	12	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	40.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where ((`test`.`t2`.`companynr` > 0) or (`test`.`t2`.`companynr` is null))
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where t2.companynr > 0 or t2.companynr < 0 or t4.companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	ALL	PRIMARY	NULL	NULL	NULL	12	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where ((`test`.`t2`.`companynr` > 0) or (`test`.`t4`.`companynr` > 0))
explain select t2.companynr,companyname from t4 left join t2 using (companynr) where ifnull(t2.companynr,1)>0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	ALL	NULL	NULL	NULL	NULL	12	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (ifnull(`test`.`t2`.`companynr`,1) > 0)
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr > 0 or companynr is null;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	range	PRIMARY	PRIMARY	1	NULL	11	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (`test`.`t4`.`companynr` > 0)
explain select companynr,companyname from t4 left join t2 using (companynr) where companynr > 0 or companynr < 0 or companynr > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	range	PRIMARY	PRIMARY	1	NULL	11	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where ((`test`.`t4`.`companynr` > 0) or (`test`.`t4`.`companynr` > 0))
explain select companynr,companyname from t4 left join t2 using (companynr) where ifnull(companynr,1)>0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	ALL	NULL	NULL	NULL	NULL	12	100.00	Using where
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t4`.`companynr` AS `companynr`,`test`.`t4`.`companyname` AS `companyname` from `test`.`t4` left join `test`.`t2` on((`test`.`t2`.`companynr` = `test`.`t4`.`companynr`)) where (ifnull(`test`.`t4`.`companynr`,1) > 0)
select distinct t2.companynr,t4.companynr from t2,t4 where t2.companynr=t4.companynr+1;
companynr	companynr
37	36
41	40
explain select distinct t2.companynr,t4.companynr from t2,t4 where t2.companynr=t4.companynr+1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t4	NULL	index	NULL	PRIMARY	1	NULL	12	100.00	Using index; Using temporary
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select distinct `test`.`t2`.`companynr` AS `companynr`,`test`.`t4`.`companynr` AS `companynr` from `test`.`t2` join `test`.`t4` where (`test`.`t2`.`companynr` = (`test`.`t4`.`companynr` + 1))
select t2.fld1,t2.companynr,fld3,period from t3,t2 where t2.fld1 = 38208 and t2.fld1=t3.t2nr and period = 1008 or t2.fld1 = 38008 and t2.fld1 =t3.t2nr and period = 1008;
fld1	companynr	fld3	period
038008	37	reporters	1008
038208	37	Selfridge	1008
select t2.fld1,t2.companynr,fld3,period from t3,t2 where (t2.fld1 = 38208 or t2.fld1 = 38008) and t2.fld1=t3.t2nr and period>=1008 and period<=1009;
fld1	companynr	fld3	period
038008	37	reporters	1008
038208	37	Selfridge	1008
select t2.fld1,t2.companynr,fld3,period from t3,t2 where (t3.t2nr = 38208 or t3.t2nr = 38008) and t2.fld1=t3.t2nr and period>=1008 and period<=1009;
fld1	companynr	fld3	period
038008	37	reporters	1008
038208	37	Selfridge	1008
select period from t1 where (((period > 0) or period < 10000 or (period = 1900)) and (period=1900 and period <= 1901) or (period=1903 and (period=1903)) and period>=1902) or ((period=1904 or period=1905) or (period=1906 or period>1907)) or (period=1908 and period = 1909);
period
9410
select period from t1 where ((period > 0 and period < 1) or (((period > 0 and period < 100) and (period > 10)) or (period > 10)) or (period > 0 and (period > 5 or period > 6)));
period
9410
select a.fld1 from t2 as a,t2 b where ((a.fld1 = 250501 and a.fld1=b.fld1) or a.fld1=250502 or a.fld1=250503 or (a.fld1=250505 and a.fld1<=b.fld1 and b.fld1>=a.fld1)) and a.fld1=b.fld1;
fld1
250501
250502
250503
250505
select fld1 from t2 where fld1 in (250502,98005,98006,250503,250605,250606) and fld1 >=250502 and fld1 not in (250605,250606);
fld1
250502
250503
select fld1 from t2 where fld1 between 250502 and 250504;
fld1
250502
250503
250504
select fld3 from t2 where (((fld3 like "_%L%" ) or (fld3 like "%ok%")) and ( fld3 like "L%" or fld3 like "G%")) and fld3 like "L%" ;
fld3
label
labeled
labeled
landslide
laterally
leaflet
lewdly
Lillian
luckily
select count(*) from t1;
count(*)
1
select companynr,count(*),sum(fld1) from t2 group by companynr;
companynr	count(*)	sum(fld1)
00	82	10355753
37	588	83602098
36	215	22786296
50	11	1595438
58	23	2254293
29	95	14473298
40	37	6618386
53	4	793210
65	10	2284055
41	52	12816335
34	70	17788966
68	12	3097288
select companynr,count(*) from t2 group by companynr order by companynr desc limit 5;
companynr	count(*)
68	12
65	10
58	23
53	4
50	11
select count(*),min(fld4),max(fld4),sum(fld1),avg(fld1),std(fld1),variance(fld1) from t2 where companynr = 34 and fld4<>"";
count(*)	min(fld4)	max(fld4)	sum(fld1)	avg(fld1)	std(fld1)	variance(fld1)
70	absentee	vest	17788966	254128.0857	3272.5939722090234	10709871.306938833
explain select count(*),min(fld4),max(fld4),sum(fld1),avg(fld1),std(fld1),variance(fld1) from t2 where companynr = 34 and fld4<>"";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	9.00	Using where
Warnings:
Note	1003	/* select#1 */ select count(0) AS `count(*)`,min(`test`.`t2`.`fld4`) AS `min(fld4)`,max(`test`.`t2`.`fld4`) AS `max(fld4)`,sum(`test`.`t2`.`fld1`) AS `sum(fld1)`,avg(`test`.`t2`.`fld1`) AS `avg(fld1)`,std(`test`.`t2`.`fld1`) AS `std(fld1)`,variance(`test`.`t2`.`fld1`) AS `variance(fld1)` from `test`.`t2` where ((`test`.`t2`.`companynr` = 34) and (`test`.`t2`.`fld4` <> ''))
select companynr,count(*),min(fld4),max(fld4),sum(fld1),avg(fld1),std(fld1),variance(fld1) from t2 group by companynr order by companynr limit 3;
companynr	count(*)	min(fld4)	max(fld4)	sum(fld1)	avg(fld1)	std(fld1)	variance(fld1)
00	82	Anthony	windmills	10355753	126289.6707	115550.97568479746	13352027981.708656
29	95	abut	wetness	14473298	152350.5053	8368.547956641249	70032594.90260443
34	70	absentee	vest	17788966	254128.0857	3272.5939722090234	10709871.306938833
select
companynr,t2nr,count(price),sum(price),min(price),max(price),avg(price) from
t3 where companynr = 37 group by companynr,t2nr order by companynr, t2nr limit 10;
companynr	t2nr	count(price)	sum(price)	min(price)	max(price)	avg(price)
37	1	1	5987435	5987435	5987435	5987435.0000
37	2	1	28357832	28357832	28357832	28357832.0000
37	3	1	39654943	39654943	39654943	39654943.0000
37	11	1	5987435	5987435	5987435	5987435.0000
37	12	1	28357832	28357832	28357832	28357832.0000
37	13	1	39654943	39654943	39654943	39654943.0000
37	21	1	5987435	5987435	5987435	5987435.0000
37	22	1	28357832	28357832	28357832	28357832.0000
37	23	1	39654943	39654943	39654943	39654943.0000
37	31	1	5987435	5987435	5987435	5987435.0000
select /*! SQL_SMALL_RESULT */
companynr,t2nr,count(price),sum(price),min(price),max(price),avg(price) from
t3 where companynr = 37 group by companynr,t2nr order by companynr, t2nr limit 10;
companynr	t2nr	count(price)	sum(price)	min(price)	max(price)	avg(price)
37	1	1	5987435	5987435	5987435	5987435.0000
37	2	1	28357832	28357832	28357832	28357832.0000
37	3	1	39654943	39654943	39654943	39654943.0000
37	11	1	5987435	5987435	5987435	5987435.0000
37	12	1	28357832	28357832	28357832	28357832.0000
37	13	1	39654943	39654943	39654943	39654943.0000
37	21	1	5987435	5987435	5987435	5987435.0000
37	22	1	28357832	28357832	28357832	28357832.0000
37	23	1	39654943	39654943	39654943	39654943.0000
37	31	1	5987435	5987435	5987435	5987435.0000
select companynr,count(price),sum(price),min(price),max(price),avg(price) from t3 group by companynr ;
companynr	count(price)	sum(price)	min(price)	max(price)	avg(price)
37	12543	309394878010	5987435	39654943	24666736.6667
78	8362	414611089292	726498	98439034	49582766.0000
101	4181	3489454238	834598	834598	834598.0000
154	4181	4112197254950	983543950	983543950	983543950.0000
311	4181	979599938	234298	234298	234298.0000
447	4181	9929180954	2374834	2374834	2374834.0000
512	4181	3288532102	786542	786542	786542.0000
select distinct mod(companynr,10) from t4 group by companynr;
mod(companynr,10)
0
9
4
6
7
1
3
8
5
select distinct 1 from t4 group by companynr;
1
1
select count(distinct fld1) from t2;
count(distinct fld1)
1199
select companynr,count(distinct fld1) from t2 group by companynr;
companynr	count(distinct fld1)
00	82
29	95
34	70
36	215
37	588
40	37
41	52
50	11
53	4
58	23
65	10
68	12
select companynr,count(*) from t2 group by companynr;
companynr	count(*)
00	82
37	588
36	215
50	11
58	23
29	95
40	37
53	4
65	10
41	52
34	70
68	12
select companynr,count(distinct concat(fld1,repeat(65,1000))) from t2 group by companynr;
companynr	count(distinct concat(fld1,repeat(65,1000)))
00	82
29	95
34	70
36	215
37	588
40	37
41	52
50	11
53	4
58	23
65	10
68	12
select companynr,count(distinct concat(fld1,repeat(65,200))) from t2 group by companynr;
companynr	count(distinct concat(fld1,repeat(65,200)))
00	82
29	95
34	70
36	215
37	588
40	37
41	52
50	11
53	4
58	23
65	10
68	12
select companynr,count(distinct floor(fld1/100)) from t2 group by companynr;
companynr	count(distinct floor(fld1/100))
00	47
29	35
34	14
36	69
37	108
40	16
41	11
50	9
53	1
58	1
65	1
68	1
select companynr,count(distinct concat(repeat(65,1000),floor(fld1/100))) from t2 group by companynr;
companynr	count(distinct concat(repeat(65,1000),floor(fld1/100)))
00	47
29	35
34	14
36	69
37	108
40	16
41	11
50	9
53	1
58	1
65	1
68	1
select sum(fld1),fld3 from t2 where fld3="Romans" group by fld1 limit 10;
sum(fld1)	fld3
11402	Romans
select name,count(*) from t3 where name='cloakroom' group by name;
name	count(*)
cloakroom	4181
select name,count(*) from t3 where name='cloakroom' and price>10 group by name;
name	count(*)
cloakroom	4181
select count(*) from t3 where name='cloakroom' and price2=823742;
count(*)
4181
select name,count(*) from t3 where name='cloakroom' and price2=823742 group by name;
name	count(*)
cloakroom	4181
select name,count(*) from t3 where name >= "extramarital" and price <= 39654943 group by name;
name	count(*)
extramarital	4181
gazer	4181
gems	4181
Iranizes	4181
spates	4181
tucked	4181
violinist	4181
select t2.fld3,count(*) from t2,t3 where t2.fld1=158402 and t3.name=t2.fld3 group by t3.name;
fld3	count(*)
spates	4181
select companynr|0,companyname from t4 group by 1;
companynr|0	companyname
29	company 1
34	company 2
36	company 3
37	company 4
40	company 5
41	company 6
53	company 7
58	company 8
65	company 9
68	company 10
50	company 11
0	Unknown
select t2.companynr,companyname,count(*) from t2,t4 where t2.companynr=t4.companynr group by t2.companynr order by companyname;
companynr	companyname	count(*)
29	company 1	95
68	company 10	12
50	company 11	11
34	company 2	70
36	company 3	215
37	company 4	588
40	company 5	37
41	company 6	52
53	company 7	4
58	company 8	23
65	company 9	10
00	Unknown	82
select t2.fld1,count(*) from t2,t3 where t2.fld1=158402 and t3.name=t2.fld3 group by t3.name;
fld1	count(*)
158402	4181
select sum(Period)/count(*) from t1;
sum(Period)/count(*)
9410.0000
select companynr,count(price) as "count",sum(price) as "sum" ,abs(sum(price)/count(price)-avg(price)) as "diff",(0+count(price))*companynr as func from t3 group by companynr;
companynr	count	sum	diff	func
37	12543	309394878010	0.0000	464091
78	8362	414611089292	0.0000	652236
101	4181	3489454238	0.0000	422281
154	4181	4112197254950	0.0000	643874
311	4181	979599938	0.0000	1300291
447	4181	9929180954	0.0000	1868907
512	4181	3288532102	0.0000	2140672
select companynr,sum(price)/count(price) as avg from t3 group by companynr having avg > 70000000 order by avg;
companynr	avg
154	983543950.0000
select companynr,count(*) from t2 group by companynr order by 2 desc;
companynr	count(*)
37	588
36	215
29	95
00	82
34	70
41	52
40	37
58	23
68	12
50	11
65	10
53	4
select companynr,count(*) from t2 where companynr > 40 group by companynr order by 2 desc;
companynr	count(*)
41	52
58	23
68	12
50	11
65	10
53	4
select t2.fld4,t2.fld1,count(price),sum(price),min(price),max(price),avg(price) from t3,t2 where t3.companynr = 37 and t2.fld1 = t3.t2nr group by fld1,t2.fld4;
fld4	fld1	count(price)	sum(price)	min(price)	max(price)	avg(price)
teethe	000001	1	5987435	5987435	5987435	5987435.0000
dreaded	011401	1	5987435	5987435	5987435	5987435.0000
scholastics	011402	1	28357832	28357832	28357832	28357832.0000
audiology	011403	1	39654943	39654943	39654943	39654943.0000
wallet	011501	1	5987435	5987435	5987435	5987435.0000
parters	011701	1	5987435	5987435	5987435	5987435.0000
eschew	011702	1	28357832	28357832	28357832	28357832.0000
quitter	011703	1	39654943	39654943	39654943	39654943.0000
neat	012001	1	5987435	5987435	5987435	5987435.0000
Steinberg	012003	1	39654943	39654943	39654943	39654943.0000
balled	012301	1	5987435	5987435	5987435	5987435.0000
persist	012302	1	28357832	28357832	28357832	28357832.0000
attainments	012303	1	39654943	39654943	39654943	39654943.0000
capably	012501	1	5987435	5987435	5987435	5987435.0000
impulsive	012602	1	28357832	28357832	28357832	28357832.0000
starlet	012603	1	39654943	39654943	39654943	39654943.0000
featherweight	012701	1	5987435	5987435	5987435	5987435.0000
pessimist	012702	1	28357832	28357832	28357832	28357832.0000
daughter	012703	1	39654943	39654943	39654943	39654943.0000
lawgiver	013601	1	5987435	5987435	5987435	5987435.0000
stated	013602	1	28357832	28357832	28357832	28357832.0000
readable	013603	1	39654943	39654943	39654943	39654943.0000
testicle	013801	1	5987435	5987435	5987435	5987435.0000
Parsifal	013802	1	28357832	28357832	28357832	28357832.0000
leavings	013803	1	39654943	39654943	39654943	39654943.0000
squeaking	013901	1	5987435	5987435	5987435	5987435.0000
contrasted	016001	1	5987435	5987435	5987435	5987435.0000
leftover	016201	1	5987435	5987435	5987435	5987435.0000
whiteners	016202	1	28357832	28357832	28357832	28357832.0000
erases	016301	1	5987435	5987435	5987435	5987435.0000
Punjab	016302	1	28357832	28357832	28357832	28357832.0000
Merritt	016303	1	39654943	39654943	39654943	39654943.0000
sweetish	018001	1	5987435	5987435	5987435	5987435.0000
dogging	018002	1	28357832	28357832	28357832	28357832.0000
scornfully	018003	1	39654943	39654943	39654943	39654943.0000
fetters	018012	1	28357832	28357832	28357832	28357832.0000
bivalves	018013	1	39654943	39654943	39654943	39654943.0000
skulking	018021	1	5987435	5987435	5987435	5987435.0000
flint	018022	1	28357832	28357832	28357832	28357832.0000
flopping	018023	1	39654943	39654943	39654943	39654943.0000
Judas	018032	1	28357832	28357832	28357832	28357832.0000
vacuuming	018033	1	39654943	39654943	39654943	39654943.0000
medical	018041	1	5987435	5987435	5987435	5987435.0000
bloodbath	018042	1	28357832	28357832	28357832	28357832.0000
subschema	018043	1	39654943	39654943	39654943	39654943.0000
interdependent	018051	1	5987435	5987435	5987435	5987435.0000
Graves	018052	1	28357832	28357832	28357832	28357832.0000
neonatal	018053	1	39654943	39654943	39654943	39654943.0000
sorters	018061	1	5987435	5987435	5987435	5987435.0000
epistle	018062	1	28357832	28357832	28357832	28357832.0000
Conley	018101	1	5987435	5987435	5987435	5987435.0000
lectured	018102	1	28357832	28357832	28357832	28357832.0000
Abraham	018103	1	39654943	39654943	39654943	39654943.0000
cage	018201	1	5987435	5987435	5987435	5987435.0000
hushes	018202	1	28357832	28357832	28357832	28357832.0000
Simla	018402	1	28357832	28357832	28357832	28357832.0000
reporters	018403	1	39654943	39654943	39654943	39654943.0000
coexist	018601	1	5987435	5987435	5987435	5987435.0000
Beebe	018602	1	28357832	28357832	28357832	28357832.0000
Taoism	018603	1	39654943	39654943	39654943	39654943.0000
Connally	018801	1	5987435	5987435	5987435	5987435.0000
fetched	018802	1	28357832	28357832	28357832	28357832.0000
checkpoints	018803	1	39654943	39654943	39654943	39654943.0000
gritty	018811	1	5987435	5987435	5987435	5987435.0000
firearm	018812	1	28357832	28357832	28357832	28357832.0000
minima	019101	1	5987435	5987435	5987435	5987435.0000
Selfridge	019102	1	28357832	28357832	28357832	28357832.0000
disable	019103	1	39654943	39654943	39654943	39654943.0000
witchcraft	019201	1	5987435	5987435	5987435	5987435.0000
betroth	030501	1	5987435	5987435	5987435	5987435.0000
Manhattanize	030502	1	28357832	28357832	28357832	28357832.0000
imprint	030503	1	39654943	39654943	39654943	39654943.0000
swelling	031901	1	5987435	5987435	5987435	5987435.0000
interrelationships	036001	1	5987435	5987435	5987435	5987435.0000
riser	036002	1	28357832	28357832	28357832	28357832.0000
bee	038001	1	5987435	5987435	5987435	5987435.0000
kanji	038002	1	28357832	28357832	28357832	28357832.0000
dental	038003	1	39654943	39654943	39654943	39654943.0000
railway	038011	1	5987435	5987435	5987435	5987435.0000
validate	038012	1	28357832	28357832	28357832	28357832.0000
normalizes	038013	1	39654943	39654943	39654943	39654943.0000
Kline	038101	1	5987435	5987435	5987435	5987435.0000
Anatole	038102	1	28357832	28357832	28357832	28357832.0000
partridges	038103	1	39654943	39654943	39654943	39654943.0000
recruited	038201	1	5987435	5987435	5987435	5987435.0000
dimensions	038202	1	28357832	28357832	28357832	28357832.0000
Chicana	038203	1	39654943	39654943	39654943	39654943.0000
select t3.companynr,fld3,sum(price) from t3,t2 where t2.fld1 = t3.t2nr and t3.companynr = 512 group by companynr,fld3;
companynr	fld3	sum(price)
512	boat	786542
512	capably	786542
512	decliner	786542
512	dopers	786542
512	erases	786542
512	cupboard	786542
512	Miles	786542
512	skies	786542
512	Micronesia	786542
512	descendants	786542
select t2.companynr,count(*),min(fld3),max(fld3),sum(price),avg(price) from t2,t3 where t3.companynr >= 30 and t3.companynr <= 58 and t3.t2nr = t2.fld1 and 1+1=2 group by t2.companynr;
companynr	count(*)	min(fld3)	max(fld3)	sum(price)	avg(price)
00	1	Omaha	Omaha	5987435	5987435.0000
37	83	Abraham	Wotan	1908978016	22999735.1325
36	1	dubbed	dubbed	28357832	28357832.0000
50	2	scribbled	tapestry	68012775	34006387.5000
select t3.companynr+0,t3.t2nr,fld3,sum(price) from t3,t2 where t2.fld1 = t3.t2nr and t3.companynr = 37 group by 1,t3.t2nr,fld3,fld3,fld3,fld3,fld3 order by fld1;
t3.companynr+0	t2nr	fld3	sum(price)
37	1	Omaha	5987435
37	11401	breaking	5987435
37	11402	Romans	28357832
37	11403	intercepted	39654943
37	11501	bewilderingly	5987435
37	11701	astound	5987435
37	11702	admonishing	28357832
37	11703	sumac	39654943
37	12001	flanking	5987435
37	12003	combed	39654943
37	12301	Eulerian	5987435
37	12302	dubbed	28357832
37	12303	Kane	39654943
37	12501	annihilates	5987435
37	12602	Wotan	28357832
37	12603	snatching	39654943
37	12701	grazing	5987435
37	12702	Baird	28357832
37	12703	celery	39654943
37	13601	handgun	5987435
37	13602	foldout	28357832
37	13603	mystic	39654943
37	13801	intelligibility	5987435
37	13802	Augustine	28357832
37	13803	teethe	39654943
37	13901	scholastics	5987435
37	16001	audiology	5987435
37	16201	wallet	5987435
37	16202	parters	28357832
37	16301	eschew	5987435
37	16302	quitter	28357832
37	16303	neat	39654943
37	18001	jarring	5987435
37	18002	tinily	28357832
37	18003	balled	39654943
37	18012	impulsive	28357832
37	18013	starlet	39654943
37	18021	lawgiver	5987435
37	18022	stated	28357832
37	18023	readable	39654943
37	18032	testicle	28357832
37	18033	Parsifal	39654943
37	18041	Punjab	5987435
37	18042	Merritt	28357832
37	18043	Quixotism	39654943
37	18051	sureties	5987435
37	18052	puddings	28357832
37	18053	tapestry	39654943
37	18061	trimmings	5987435
37	18062	humility	28357832
37	18101	tragedies	5987435
37	18102	skulking	28357832
37	18103	flint	39654943
37	18201	relaxing	5987435
37	18202	offload	28357832
37	18402	suites	28357832
37	18403	lists	39654943
37	18601	vacuuming	5987435
37	18602	dentally	28357832
37	18603	humanness	39654943
37	18801	inch	5987435
37	18802	Weissmuller	28357832
37	18803	irresponsibly	39654943
37	18811	repetitions	5987435
37	18812	Antares	28357832
37	19101	ventilate	5987435
37	19102	pityingly	28357832
37	19103	interdependent	39654943
37	19201	Graves	5987435
37	30501	neonatal	5987435
37	30502	scribbled	28357832
37	30503	chafe	39654943
37	31901	realtor	5987435
37	36001	elite	5987435
37	36002	funereal	28357832
37	38001	Conley	5987435
37	38002	lectured	28357832
37	38003	Abraham	39654943
37	38011	groupings	5987435
37	38012	dissociate	28357832
37	38013	coexist	39654943
37	38101	rusting	5987435
37	38102	galling	28357832
37	38103	obliterates	39654943
37	38201	resumes	5987435
37	38202	analyzable	28357832
37	38203	terminator	39654943
select sum(price) from t3,t2 where t2.fld1 = t3.t2nr and t3.companynr = 512 and t3.t2nr = 38008 and t2.fld1 = 38008 or t2.fld1= t3.t2nr and t3.t2nr = 38008 and t2.fld1 = 38008;
sum(price)
234298
select t2.fld1,sum(price) from t3,t2 where t2.fld1 = t3.t2nr and t3.companynr = 512 and t3.t2nr = 38008 and t2.fld1 = 38008 or t2.fld1 = t3.t2nr and t3.t2nr = 38008 and t2.fld1 = 38008 or t3.t2nr = t2.fld1 and t2.fld1 = 38008 group by t2.fld1;
fld1	sum(price)
038008	234298
explain select fld3 from t2 where 1>2 or 2>3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` where false
explain select fld3 from t2 where fld1=fld1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1199	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`fld3` AS `fld3` from `test`.`t2` where true
select companynr,fld1 from t2 HAVING fld1=250501 or fld1=250502;
companynr	fld1
34	250501
34	250502
select companynr,fld1 from t2 WHERE fld1>=250501 HAVING fld1<=250502;
companynr	fld1
34	250501
34	250502
select companynr,count(*) as count,sum(fld1) as sum from t2 group by companynr having count > 40 and sum/count >= 120000;
companynr	count	sum
00	82	10355753
37	588	83602098
29	95	14473298
41	52	12816335
34	70	17788966
select companynr from t2 group by companynr having count(*) > 40 and sum(fld1)/count(*) >= 120000 ;
companynr
00
37
29
41
34
select t2.companynr,companyname,count(*) from t2,t4 where t2.companynr=t4.companynr group by companyname having t2.companynr >= 40;
companynr	companyname	count(*)
40	company 5	37
41	company 6	52
53	company 7	4
58	company 8	23
65	company 9	10
68	company 10	12
50	company 11	11
select count(*) from t2;
count(*)
1199
select count(*) from t2 where fld1 < 098024;
count(*)
387
select min(fld1) from t2 where fld1>= 098024;
min(fld1)
98024
select max(fld1) from t2 where fld1>= 098024;
max(fld1)
1232609
select count(*) from t3 where price2=76234234;
count(*)
4181
select count(*) from t3 where companynr=512 and price2=76234234;
count(*)
4181
explain select min(fld1),max(fld1),count(*) from t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t2`.`fld1`) AS `min(fld1)`,max(`test`.`t2`.`fld1`) AS `max(fld1)`,count(0) AS `count(*)` from `test`.`t2`
explain format=tree select min(fld1),max(fld1),count(*) from t2;
EXPLAIN
-> Rows fetched before execution

explain format=tree select min(fld1),max(fld1),count(*) from t2 where rand() > 0.5;
EXPLAIN
-> Aggregate: min(t2.fld1), max(t2.fld1), count(0)
    -> Filter: (rand() > 0.5)  (cost=151.60 rows=1199)
        -> Index scan on t2 using fld1  (cost=151.60 rows=1199)

select min(fld1),max(fld1),count(*) from t2;
min(fld1)	max(fld1)	count(*)
0	1232609	1199
select min(t2nr),max(t2nr) from t3 where t2nr=2115 and price2=823742;
min(t2nr)	max(t2nr)
2115	2115
select count(*),min(t2nr),max(t2nr) from t3 where name='spates' and companynr=78;
count(*)	min(t2nr)	max(t2nr)
4181	4	41804
select t2nr,count(*) from t3 where name='gems' group by t2nr limit 20;
t2nr	count(*)
9	1
19	1
29	1
39	1
49	1
59	1
69	1
79	1
89	1
99	1
109	1
119	1
129	1
139	1
149	1
159	1
169	1
179	1
189	1
199	1
select max(t2nr) from t3 where price=983543950;
max(t2nr)
41807
select t1.period from t3 t1 limit 1;
period
1001
select t1.period from t1 as t1 limit 1;
period
9410
select t1.period as "Nuvarande period" from t1 as t1 limit 1;
Nuvarande period
9410
select period as ok_period from t1 limit 1;
ok_period
9410
select period as ok_period from t1 group by ok_period limit 1;
ok_period
9410
select 1+1 as summa from t1 group by summa limit 1;
summa
2
select period as "Nuvarande period" from t1 group by "Nuvarande period" limit 1;
Nuvarande period
9410
show tables;
Tables_in_test
t1
t2
t3
t4
show tables from test like "s%";
Tables_in_test (s%)
show tables from test like "t?";
Tables_in_test (t?)
show full columns from t2;
Field	Type	Collation	Null	Key	Default	Extra	Privileges	Comment
auto	int(11)	NULL	NO	PRI	NULL	auto_increment	select,insert,update,references	
fld1	int(6) unsigned zerofill	NULL	NO	UNI	000000		select,insert,update,references	
companynr	tinyint(2) unsigned zerofill	NULL	NO		00		select,insert,update,references	
fld3	char(30)	utf8mb4_0900_ai_ci	NO	MUL			select,insert,update,references	
fld4	char(35)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
fld5	char(35)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
fld6	char(4)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
show full columns from t2 from test like 'f%';
Field	Type	Collation	Null	Key	Default	Extra	Privileges	Comment
fld1	int(6) unsigned zerofill	NULL	NO	UNI	000000		select,insert,update,references	
fld3	char(30)	utf8mb4_0900_ai_ci	NO	MUL			select,insert,update,references	
fld4	char(35)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
fld5	char(35)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
fld6	char(4)	utf8mb4_0900_ai_ci	NO				select,insert,update,references	
show full columns from t2 from test like 's%';
Field	Type	Collation	Null	Key	Default	Extra	Privileges	Comment
analyze table t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
show keys from t2;
Table	Non_unique	Key_name	Seq_in_index	Column_name	Collation	Cardinality	Sub_part	Packed	Null	Index_type	Comment	Index_comment	Visible	Expression
t2	0	PRIMARY	1	auto	A	1199	NULL	NULL		BTREE			YES	NULL
t2	0	fld1	1	fld1	A	1199	NULL	NULL		BTREE			YES	NULL
t2	1	fld3	1	fld3	A	1199	NULL	NULL		BTREE			YES	NULL
drop table t4, t3, t2, t1;
DO 1;
DO benchmark(100,1+1),1,1;
do default;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' at line 1
do foobar;
ERROR 42S22: Unknown column 'foobar' in 'field list'
CREATE TABLE t1 (
id mediumint(8) unsigned NOT NULL auto_increment,
pseudo varchar(35) NOT NULL default '',
PRIMARY KEY  (id),
UNIQUE KEY pseudo (pseudo)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 (pseudo) VALUES ('test');
INSERT INTO t1 (pseudo) VALUES ('test1');
SELECT 1 as rnd1 from t1 where rand() > 2;
rnd1
DROP TABLE t1;
CREATE TABLE t1 (gvid int(10) unsigned default NULL,  hmid int(10) unsigned default NULL,  volid int(10) unsigned default NULL,  mmid int(10) unsigned default NULL,  hdid int(10) unsigned default NULL,  fsid int(10) unsigned default NULL,  ctid int(10) unsigned default NULL,  dtid int(10) unsigned default NULL,  cost int(10) unsigned default NULL,  performance int(10) unsigned default NULL,  serialnumber bigint(20) unsigned default NULL,  monitored tinyint(3) unsigned default '1',  removed tinyint(3) unsigned default '0',  target tinyint(3) unsigned default '0',  dt_modified timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  name varchar(255) binary default NULL,  description varchar(255) default NULL,  UNIQUE KEY hmid (hmid,volid)) ENGINE=MyISAM;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1287	'BINARY as attribute of a type' is deprecated and will be removed in a future release. Please use a CHARACTER SET clause with _bin collation instead
INSERT INTO t1 VALUES (200001,2,1,1,100,1,1,1,0,0,0,1,0,1,20020425060057,'\\\\ARKIVIO-TESTPDC\\E$',''),(200002,2,2,1,101,1,1,1,0,0,0,1,0,1,20020425060057,'\\\\ARKIVIO-TESTPDC\\C$',''),(200003,1,3,2,NULL,NULL,NULL,NULL,NULL,NULL,NULL,1,0,1,20020425060427,'c:',NULL);
CREATE TABLE t2 (  hmid int(10) unsigned default NULL,  volid int(10) unsigned default NULL,  sampletid smallint(5) unsigned default NULL,  sampletime datetime default NULL,  samplevalue bigint(20) unsigned default NULL,  KEY idx1 (hmid,volid,sampletid,sampletime)) ENGINE=MyISAM;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (1,3,10,'2002-06-01 08:00:00',35),(1,3,1010,'2002-06-01 12:00:01',35);
SELECT a.gvid, (SUM(CASE b.sampletid WHEN 140 THEN b.samplevalue ELSE 0 END)) as the_success,(SUM(CASE b.sampletid WHEN 141 THEN b.samplevalue ELSE 0 END)) as the_fail,(SUM(CASE b.sampletid WHEN 142 THEN b.samplevalue ELSE 0 END)) as the_size,(SUM(CASE b.sampletid WHEN 143 THEN b.samplevalue ELSE 0 END)) as the_time FROM t1 a, t2 b WHERE a.hmid = b.hmid AND a.volid = b.volid AND b.sampletime >= 'wrong-date-value' AND b.sampletime < 'wrong-date-value' AND b.sampletid IN (140, 141, 142, 143) GROUP BY a.gvid;
ERROR HY000: Incorrect DATETIME value: 'wrong-date-value'
SELECT a.gvid, (SUM(CASE b.sampletid WHEN 140 THEN b.samplevalue ELSE 0 END)) as the_success,(SUM(CASE b.sampletid WHEN 141 THEN b.samplevalue ELSE 0 END)) as the_fail,(SUM(CASE b.sampletid WHEN 142 THEN b.samplevalue ELSE 0 END)) as the_size,(SUM(CASE b.sampletid WHEN 143 THEN b.samplevalue ELSE 0 END)) as the_time FROM t1 a, t2 b WHERE a.hmid = b.hmid AND a.volid = b.volid AND b.sampletime >= NULL AND b.sampletime < NULL AND b.sampletid IN (140, 141, 142, 143) GROUP BY a.gvid;
gvid	the_success	the_fail	the_size	the_time
DROP TABLE t1,t2;
create table  t1 (  A_Id bigint(20) NOT NULL default '0',  A_UpdateBy char(10) NOT NULL default '',  A_UpdateDate bigint(20) NOT NULL default '0',  A_UpdateSerial int(11) NOT NULL default '0',  other_types bigint(20) NOT NULL default '0',  wss_type bigint(20) NOT NULL default '0');
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (102935998719055004,'brade',1029359987,2,102935229116544068,102935229216544093);
select wss_type from t1 where wss_type ='102935229216544106';
wss_type
select wss_type from t1 where wss_type ='102935229216544105';
wss_type
select wss_type from t1 where wss_type ='102935229216544104';
wss_type
select wss_type from t1 where wss_type ='102935229216544093';
wss_type
102935229216544093
select wss_type from t1 where wss_type =102935229216544093;
wss_type
102935229216544093
drop table t1;
select 1+2,"aaaa",3.13*2.0 into @a,@b,@c;
select @a;
@a
3
select @b;
@b
aaaa
select @c;
@c
6.260
create table t1 (a int not null auto_increment primary key);
insert into t1 values ();
insert into t1 values ();
insert into t1 values ();
select * from (t1 as t2 left join t1 as t3 using (a)), t1;
a	a
1	1
1	2
1	3
2	1
2	2
2	3
3	1
3	2
3	3
select * from t1, (t1 as t2 left join t1 as t3 using (a));
a	a
1	1
1	2
1	3
2	1
2	2
2	3
3	1
3	2
3	3
select * from (t1 as t2 left join t1 as t3 using (a)) straight_join t1;
a	a
1	1
1	2
1	3
2	1
2	2
2	3
3	1
3	2
3	3
select * from t1 straight_join (t1 as t2 left join t1 as t3 using (a));
a	a
1	1
1	2
1	3
2	1
2	2
2	3
3	1
3	2
3	3
select * from (t1 as t2 left join t1 as t3 using (a)) inner join t1 on t1.a>1;
a	a
1	2
1	3
2	2
2	3
3	2
3	3
select * from t1 inner join (t1 as t2 left join t1 as t3 using (a)) on t1.a>1;
a	a
2	1
2	2
2	3
3	1
3	2
3	3
select * from (t1 as t2 left join t1 as t3 using (a)) inner join t1 using ( a );
a
1
2
3
select * from t1 inner join (t1 as t2 left join t1 as t3 using (a)) using ( a );
a
1
2
3
select * from (t1 as t2 left join t1 as t3 using (a)) left outer join t1 on t1.a>1;
a	a
1	2
1	3
2	2
2	3
3	2
3	3
select * from t1 left outer join (t1 as t2 left join t1 as t3 using (a)) on t1.a>1;
a	a
1	NULL
2	1
2	2
2	3
3	1
3	2
3	3
select * from (t1 as t2 left join t1 as t3 using (a)) left join t1 using ( a );
a
1
2
3
select * from t1 left join (t1 as t2 left join t1 as t3 using (a)) using ( a );
a
1
2
3
select * from (t1 as t2 left join t1 as t3 using (a)) natural left join t1;
a
1
2
3
select * from t1 natural left join (t1 as t2 left join t1 as t3 using (a));
a
1
2
3
select * from (t1 as t2 left join t1 as t3 using (a)) right join t1 on t1.a>1;
a	a
NULL	1
1	2
2	2
3	2
1	3
2	3
3	3
select * from t1 right join (t1 as t2 left join t1 as t3 using (a)) on t1.a>1;
a	a
2	1
2	2
2	3
3	1
3	2
3	3
select * from (t1 as t2 left join t1 as t3 using (a)) right outer join t1 using ( a );
a
1
2
3
select * from t1 right outer join (t1 as t2 left join t1 as t3 using (a)) using ( a );
a
1
2
3
select * from (t1 as t2 left join t1 as t3 using (a)) natural right join t1;
a
1
2
3
select * from t1 natural right join (t1 as t2 left join t1 as t3 using (a));
a
1
2
3
select * from t1 natural join (t1 as t2 left join t1 as t3 using (a));
a
1
2
3
select * from (t1 as t2 left join t1 as t3 using (a)) natural join t1;
a
1
2
3
drop table t1;
CREATE TABLE t1 (  aa char(2),  id int(11) NOT NULL auto_increment,  t2_id int(11) NOT NULL default '0',  PRIMARY KEY  (id),  KEY replace_id (t2_id)) ENGINE=MyISAM;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES ("1",8264,2506),("2",8299,2517),("3",8301,2518),("4",8302,2519),("5",8303,2520),("6",8304,2521),("7",8305,2522);
CREATE TABLE t2 ( id int(11) NOT NULL auto_increment,  PRIMARY KEY  (id)) ENGINE=MyISAM;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (2517), (2518), (2519), (2520), (2521), (2522);
select * from t1, t2 WHERE t1.t2_id = t2.id and t1.t2_id > 0   order by t1.id   LIMIT 0, 5;
aa	id	t2_id	id
2	8299	2517	2517
3	8301	2518	2518
4	8302	2519	2519
5	8303	2520	2520
6	8304	2521	2521
drop table t1,t2;
create table t1 (id1 int NOT NULL);
create table t2 (id2 int NOT NULL);
create table t3 (id3 int NOT NULL);
create table t4 (id4 int NOT NULL, id44 int NOT NULL, KEY (id4));
insert into t1 values (1);
insert into t1 values (2);
insert into t2 values (1);
insert into t4 values (1,1);
explain select * from t1 left join t2 on id1 = id2 left join t3 on id1 = id3
left join t4 on id3 = id4 where id2 = 1 or id4 = 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	NULL	system	NULL	NULL	NULL	NULL	0	0.00	const row not found
1	SIMPLE	t4	NULL	const	id4	NULL	NULL	NULL	1	100.00	Impossible ON condition
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`id1` AS `id1`,`test`.`t2`.`id2` AS `id2`,NULL AS `id3`,NULL AS `id4`,NULL AS `id44` from `test`.`t1` left join `test`.`t2` on((`test`.`t2`.`id2` = `test`.`t1`.`id1`)) left join `test`.`t4` on(multiple equal(NULL, NULL)) where ((`test`.`t2`.`id2` = 1) or (NULL = 1))
select * from t1 left join t2 on id1 = id2 left join t3 on id1 = id3
left join t4 on id3 = id4 where id2 = 1 or id4 = 1;
id1	id2	id3	id4	id44
1	1	NULL	NULL	NULL
drop table t1,t2,t3,t4;
create table t1(s varchar(10) not null);
create table t2(s varchar(10) not null primary key);
create table t3(s varchar(10) not null primary key);
insert into t1 values ('one\t'), ('two\t');
insert into t2 values ('one\r'), ('two\t');
insert into t3 values ('one\b'), ('two\t');
select * from t1 where s = 'one';
s
select * from t2 where s = 'one';
s
select * from t3 where s = 'one';
s
one
select * from t1,t2 where t1.s = t2.s;
s	s
two		two	
select * from t2,t3 where t2.s = t3.s;
s	s
two		two	
drop table t1, t2, t3;
create table t1 (a integer,  b integer, index(a), index(b));
create table t2 (c integer,  d integer, index(c), index(d));
insert into t1 values (1,2), (2,2), (3,2), (4,2);
insert into t2 values (1,3), (2,3), (3,4), (4,4);
explain select * from t1 left join t2 on a=c where d in (4);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	c,d	d	5	const	2	100.00	Using where
1	SIMPLE	t1	NULL	ref	a	a	5	test.t2.c	2	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`c` AS `c`,`test`.`t2`.`d` AS `d` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t2`.`c`) and (`test`.`t2`.`d` = 4))
select * from t1 left join t2 on a=c where d in (4);
a	b	c	d
3	2	3	4
4	2	4	4
explain select * from t1 left join t2 on a=c where d = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	c,d	d	5	const	2	100.00	Using where
1	SIMPLE	t1	NULL	ref	a	a	5	test.t2.c	2	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t2`.`c` AS `c`,`test`.`t2`.`d` AS `d` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = `test`.`t2`.`c`) and (`test`.`t2`.`d` = 4))
select * from t1 left join t2 on a=c where d = 4;
a	b	c	d
3	2	3	4
4	2	4	4
drop table t1, t2;
CREATE TABLE t1 (
i int(11) NOT NULL default '0',
c char(10) NOT NULL default '',
PRIMARY KEY  (i),
UNIQUE KEY c (c)
) ENGINE=MyISAM;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (1,'a');
INSERT INTO t1 VALUES (2,'b');
INSERT INTO t1 VALUES (3,'c');
EXPLAIN SELECT i FROM t1 WHERE i=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select '1' AS `i` from `test`.`t1` where true
DROP TABLE t1;
CREATE TABLE t1 ( a BLOB, INDEX (a(20)) );
CREATE TABLE t2 ( a BLOB, INDEX (a(20)) );
INSERT INTO t1 VALUES ('one'),('two'),('three'),('four'),('five');
INSERT INTO t2 VALUES ('one'),('two'),('three'),('four'),('five');
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 USE INDEX (a) ON t1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	t2	NULL	ref	a	a	23	test.t1.a	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a` from `test`.`t1` left join `test`.`t2` USE INDEX (`a`) on((`test`.`t2`.`a` = `test`.`t1`.`a`)) where true
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 FORCE INDEX (a) ON t1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	t2	NULL	ref	a	a	23	test.t1.a	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`a` AS `a` from `test`.`t1` left join `test`.`t2` FORCE INDEX (`a`) on((`test`.`t2`.`a` = `test`.`t1`.`a`)) where true
DROP TABLE t1, t2;
CREATE TABLE t1 ( city char(30) ) charset utf8mb4;
INSERT INTO t1 VALUES ('London');
INSERT INTO t1 VALUES ('Paris');
SELECT * FROM t1 WHERE city='London';
city
London
SELECT * FROM t1 WHERE city='london';
city
London
EXPLAIN SELECT * FROM t1 WHERE city='London' AND city='london';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`city` AS `city` from `test`.`t1` where (`test`.`t1`.`city` = 'London')
SELECT * FROM t1 WHERE city='London' AND city='london';
city
London
EXPLAIN SELECT * FROM t1 WHERE city LIKE '%london%' AND city='London';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`city` AS `city` from `test`.`t1` where ((`test`.`t1`.`city` = 'London') and (`test`.`t1`.`city` like '%london%'))
SELECT * FROM t1 WHERE city LIKE '%london%' AND city='London';
city
London
DROP TABLE t1;
create table t1 (a int(11) unsigned, b int(11) unsigned);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (1,0), (1,1), (18446744073709551615,0);
Warnings:
Warning	1264	Out of range value for column 'a' at row 3
select a-b  from t1 order by 1;
a-b
0
1
4294967295
select a-b , (a-b < 0)  from t1 order by 1;
a-b	(a-b < 0)
0	0
1	0
4294967295	0
select a-b as d, (a-b >= 0), b from t1 group by b having d >= 0;
d	(a-b >= 0)	b
1	1	0
0	1	1
select cast((a - b) as unsigned) from t1 order by 1;
cast((a - b) as unsigned)
0
1
4294967295
drop table t1;
create table t1 (a int(11));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
select all all * from t1;
a
select distinct distinct * from t1;
a
select all distinct * from t1;
ERROR HY000: Incorrect usage of ALL and DISTINCT
select distinct all * from t1;
ERROR HY000: Incorrect usage of ALL and DISTINCT
drop table t1;
CREATE TABLE t1 (
kunde_intern_id int(10) unsigned NOT NULL default '0',
kunde_id int(10) unsigned NOT NULL default '0',
FK_firma_id int(10) unsigned NOT NULL default '0',
aktuell enum('Ja','Nein') NOT NULL default 'Ja',
vorname varchar(128) NOT NULL default '',
nachname varchar(128) NOT NULL default '',
geloescht enum('Ja','Nein') NOT NULL default 'Nein',
firma varchar(128) NOT NULL default ''
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES 
(3964,3051,1,'Ja','Vorname1','1Nachname','Nein','Print Schau XXXX'),
(3965,3051111,1,'Ja','Vorname1111','1111Nachname','Nein','Print Schau XXXX');
SELECT kunde_id ,FK_firma_id ,aktuell, vorname, nachname, geloescht FROM t1
WHERE
(
(
( '' != '' AND firma LIKE CONCAT('%', '', '%'))
OR
(vorname LIKE CONCAT('%', 'Vorname1', '%') AND 
nachname LIKE CONCAT('%', '1Nachname', '%') AND 
'Vorname1' != '' AND 'xxxx' != '')
)
AND
(
aktuell = 'Ja' AND geloescht = 'Nein' AND FK_firma_id = 2
)
)
;
kunde_id	FK_firma_id	aktuell	vorname	nachname	geloescht
SELECT kunde_id ,FK_firma_id ,aktuell, vorname, nachname,
geloescht FROM t1
WHERE
(
(
aktuell = 'Ja' AND geloescht = 'Nein' AND FK_firma_id = 2
)
AND
(
( '' != '' AND firma LIKE CONCAT('%', '', '%')  )
OR
(  vorname LIKE CONCAT('%', 'Vorname1', '%') AND
nachname LIKE CONCAT('%', '1Nachname', '%') AND 'Vorname1' != '' AND
'xxxx' != '')
)
)
;
kunde_id	FK_firma_id	aktuell	vorname	nachname	geloescht
SELECT COUNT(*) FROM t1 WHERE 
( 0 OR (vorname LIKE '%Vorname1%' AND nachname LIKE '%1Nachname%' AND 1)) 
AND FK_firma_id = 2;
COUNT(*)
0
drop table t1;
CREATE TABLE t1 (b BIGINT(20) UNSIGNED NOT NULL, PRIMARY KEY (b));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (0x8000000000000000);
SELECT b FROM t1 WHERE b=0x8000000000000000;
b
9223372036854775808
DROP TABLE t1;
CREATE TABLE `t1` ( `gid` int(11) default NULL, `uid` int(11) default NULL);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE `t2` ( `ident` int(11) default NULL, `level` char(16) default NULL);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO `t2` VALUES (0,'READ');
CREATE TABLE `t3` ( `id` int(11) default NULL, `name` char(16) default NULL);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO `t3` VALUES (1,'fs');
select * from t3 left join t1 on t3.id = t1.uid, t2 where t2.ident in (0, t1.gid, t3.id, 0);
id	name	gid	uid	ident	level
1	fs	NULL	NULL	0	READ
drop table t1,t2,t3;
CREATE TABLE t1 (
acct_id int(11) NOT NULL default '0',
profile_id smallint(6) default NULL,
UNIQUE KEY t1$acct_id (acct_id),
KEY t1$profile_id (profile_id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (132,17),(133,18);
CREATE TABLE t2 (
profile_id smallint(6) default NULL,
queue_id int(11) default NULL,
seq int(11) default NULL,
KEY t2$queue_id (queue_id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t2 VALUES (17,31,4),(17,30,3),(17,36,2),(17,37,1);
CREATE TABLE t3 (
id int(11) NOT NULL default '0',
qtype int(11) default NULL,
seq int(11) default NULL,
warn_lvl int(11) default NULL,
crit_lvl int(11) default NULL,
rr1 tinyint(4) NOT NULL default '0',
rr2 int(11) default NULL,
default_queue tinyint(4) NOT NULL default '0',
KEY t3$qtype (qtype),
KEY t3$id (id)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t3 VALUES (30,1,29,NULL,NULL,0,NULL,0),(31,1,28,NULL,NULL,0,NULL,0),
(36,1,34,NULL,NULL,0,NULL,0),(37,1,35,NULL,NULL,0,121,0);
SELECT COUNT(*) FROM t1 a STRAIGHT_JOIN t2 pq STRAIGHT_JOIN t3 q 
WHERE 
(pq.profile_id = a.profile_id) AND (a.acct_id = 132) AND 
(pq.queue_id = q.id) AND (q.rr1 <> 1);
COUNT(*)
4
drop table t1,t2,t3;
create table t1 (f1 int);
insert into t1 values (1),(NULL);
create table t2 (f2 int, f3 int, f4 int);
create index idx1 on t2 (f4);
insert into t2 values (1,2,3),(2,4,6);
select A.f2 from t1 left join t2 A on A.f2 = f1 where A.f3=(select min(f3)
from  t2 C where A.f4 = C.f4) or A.f3 IS NULL;
f2
1
NULL
drop table t1,t2;
create table t2 (a tinyint unsigned);
create index t2i on t2(a);
insert into t2 values (0), (254), (255);
explain select * from t2 where a > -1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	t2i	t2i	2	NULL	3	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`a` AS `a` from `test`.`t2` where (`test`.`t2`.`a` is not null)
select * from t2 where a > -1;
a
0
254
255
drop table t2;
CREATE TABLE t1 (a int, b int, c int);
INSERT INTO t1
SELECT 50, 3, 3 FROM DUAL
WHERE NOT EXISTS
(SELECT * FROM t1 WHERE a = 50 AND b = 3);
SELECT * FROM t1;
a	b	c
50	3	3
INSERT INTO t1
SELECT 50, 3, 3 FROM DUAL
WHERE NOT EXISTS
(SELECT * FROM t1 WHERE a = 50 AND b = 3);
select found_rows();
found_rows()
0
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
SELECT * FROM t1;
a	b	c
50	3	3
select count(*) from t1;
count(*)
1
select found_rows();
found_rows()
1
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
select count(*) from t1 limit 2,3;
count(*)
select found_rows();
found_rows()
1
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
select SQL_CALC_FOUND_ROWS count(*) from t1 limit 2,3;
count(*)
Warnings:
Warning	1287	SQL_CALC_FOUND_ROWS is deprecated and will be removed in a future release. Consider using two separate queries instead.
select found_rows();
found_rows()
1
Warnings:
Warning	1287	FOUND_ROWS() is deprecated and will be removed in a future release. Consider using COUNT(*) instead.
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
(SELECT a, b AS c FROM t1) ORDER BY c+1;
a	c
(SELECT a, b AS c FROM t1) ORDER BY b+1;
a	c
SELECT a, b AS c FROM t1 ORDER BY c+1;
a	c
SELECT a, b AS c FROM t1 ORDER BY b+1;
a	c
drop table t1;
create table t1(f1 int, f2 int);
create table t2(f3 int);
select f1 from t1,t2 where f1=f2 and (f1,f2) = ((1,1));
f1
select f1 from t1,t2 where f1=f2 and (f1,NULL) = ((1,1));
f1
select f1 from t1,t2 where f1=f2 and (f1,f2) = ((1,NULL));
f1
insert into t1 values(1,1),(2,null);
insert into t2 values(2);
select * from t1,t2 where f1=f3 and (f1,f2) = (2,null);
f1	f2	f3
select * from t1,t2 where f1=f3 and (f1,f2) <=> (2,null);
f1	f2	f3
2	NULL	2
drop table t1,t2;
create table t1 (f1 int not null auto_increment primary key, f2 varchar(10));
create table t11 like t1;
insert into t1 values(1,""),(2,"");
analyze table t1, t11;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t11	analyze	status	Table is already up to date
show table status like 't1%';
Name	Engine	Version	Row_format	Rows	Avg_row_length	Data_length	Max_data_length	Index_length	Data_free	Auto_increment	Create_time	Update_time	Check_time	Collation	Checksum	Create_options	Comment
t1	MyISAM	10	Dynamic	2	20	X	X	X	X	X	X	X	X	X	NULL		
t11	MyISAM	10	Dynamic	0	0	X	X	X	X	X	X	X	X	X	NULL		
select 123 as a from t1 where f1 is null;
a
drop table t1,t11;
CREATE TABLE t1 ( a INT NOT NULL, b INT NOT NULL, UNIQUE idx (a,b) );
INSERT INTO t1 VALUES (1,1),(1,2),(1,3),(1,4);
CREATE TABLE t2 ( a INT NOT NULL, b INT NOT NULL, e INT );
INSERT INTO t2 VALUES ( 1,10,1), (1,10,2), (1,11,1), (1,11,2), (1,2,1), (1,2,2),(1,2,3);
SELECT t2.a, t2.b, IF(t1.b IS NULL,'',e) AS c, COUNT(*) AS d FROM t2 LEFT JOIN
t1 ON t2.a = t1.a AND t2.b = t1.b GROUP BY a, b, c;
a	b	c	d
1	10		2
1	11		2
1	2	1	1
1	2	2	1
1	2	3	1
SELECT t2.a, t2.b, IF(t1.b IS NULL,'',e) AS c, COUNT(*) AS d FROM t2 LEFT JOIN
t1 ON t2.a = t1.a AND t2.b = t1.b GROUP BY t1.a, t1.b, c;
a	b	c	d
1	10		4
1	2	1	1
1	2	2	1
1	2	3	1
SELECT t2.a, t2.b, IF(t1.b IS NULL,'',e) AS c, COUNT(*) AS d FROM t2 LEFT JOIN
t1 ON t2.a = t1.a AND t2.b = t1.b GROUP BY t2.a, t2.b, c;
a	b	c	d
1	10		2
1	11		2
1	2	1	1
1	2	2	1
1	2	3	1
SELECT t2.a, t2.b, IF(t1.b IS NULL,'',e) AS c, COUNT(*) AS d FROM t2,t1
WHERE t2.a = t1.a AND t2.b = t1.b GROUP BY a, b, c;
a	b	c	d
1	2	1	1
1	2	2	1
1	2	3	1
DROP TABLE IF EXISTS t1, t2;
create table t1 (f1 int primary key, f2 int);
create table t2 (f3 int, f4 int, primary key(f3,f4));
insert into t1 values (1,1);
insert into t2 values (1,1),(1,2);
select distinct count(f2) >0 from t1 left join t2 on f1=f3 group by f1;
count(f2) >0
1
drop table t1,t2;
create table t1 (f1 int,f2 int);
insert into t1 values(1,1);
create table t2 (f3 int, f4 int, primary key(f3,f4));
insert into t2 values(1,1);
select * from t1 where f1 in (select f3 from t2 where (f3,f4)= (select f3,f4 from t2));
f1	f2
1	1
drop table t1,t2;
CREATE TABLE t1(a int, b int, c int, KEY b(b), KEY c(c));
insert into t1 values (1,0,0),(2,0,0);
CREATE TABLE t2 (a int, b varchar(2), c varchar(2), PRIMARY KEY(a));
insert into t2 values (1,'',''), (2,'','');
CREATE TABLE t3 (a int, b int, PRIMARY KEY (a,b), KEY a (a), KEY b (b));
insert into t3 values (1,1),(1,2);
explain select straight_join DISTINCT t2.a,t2.b, t1.c from t1, t3, t2 
where (t1.c=t2.a or (t1.c=t3.a and t2.a=t3.b)) and t1.b=556476786 and 
t2.b like '%%' order by t2.b limit 0,1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	b,c	b	5	const	1	100.00	Using temporary; Using filesort
1	SIMPLE	t3	NULL	index	PRIMARY,a,b	PRIMARY	8	NULL	2	100.00	Using index
1	SIMPLE	t2	NULL	ALL	PRIMARY	NULL	NULL	NULL	2	50.00	Range checked for each record (index map: 0x1)
Warnings:
Note	1003	/* select#1 */ select straight_join distinct `test`.`t2`.`a` AS `a`,`test`.`t2`.`b` AS `b`,`test`.`t1`.`c` AS `c` from `test`.`t1` join `test`.`t3` join `test`.`t2` where ((`test`.`t1`.`b` = 556476786) and ((`test`.`t2`.`a` = `test`.`t1`.`c`) or ((`test`.`t2`.`a` = `test`.`t3`.`b`) and (`test`.`t3`.`a` = `test`.`t1`.`c`))) and (`test`.`t2`.`b` like '%%')) order by `test`.`t2`.`b` limit 0,1
DROP TABLE t1,t2,t3;
CREATE TABLE t1 (a int, INDEX idx(a));
INSERT INTO t1 VALUES (2), (3), (1);
EXPLAIN SELECT * FROM t1 IGNORE INDEX (idx);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` IGNORE INDEX (`idx`)
EXPLAIN SELECT * FROM t1 IGNORE INDEX (a);
ERROR 42000: Key 'a' doesn't exist in table 't1'
EXPLAIN SELECT * FROM t1 FORCE INDEX (a);
ERROR 42000: Key 'a' doesn't exist in table 't1'
DROP TABLE t1;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 VALUES (1,1), (2,1), (4,10);
CREATE TABLE t2 (a int PRIMARY KEY, b int, KEY b (b));
INSERT INTO t2 VALUES (1,NULL), (2,10);
ALTER TABLE t1 ENABLE KEYS;
EXPLAIN SELECT STRAIGHT_JOIN COUNT(*) FROM t2, t1 WHERE t1.b = t2.b OR t2.b IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	b	b	5	NULL	2	100.00	Using index
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select straight_join count(0) AS `COUNT(*)` from `test`.`t2` join `test`.`t1` where ((`test`.`t1`.`b` = `test`.`t2`.`b`) or (`test`.`t2`.`b` is null))
SELECT STRAIGHT_JOIN * FROM t2, t1 WHERE t1.b = t2.b OR t2.b IS NULL;
a	b	a	b
1	NULL	1	1
1	NULL	2	1
1	NULL	4	10
2	10	4	10
EXPLAIN SELECT STRAIGHT_JOIN COUNT(*) FROM t2, t1 WHERE t1.b = t2.b OR t2.b IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	index	b	b	5	NULL	2	100.00	Using index
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select straight_join count(0) AS `COUNT(*)` from `test`.`t2` join `test`.`t1` where ((`test`.`t1`.`b` = `test`.`t2`.`b`) or (`test`.`t2`.`b` is null))
SELECT STRAIGHT_JOIN * FROM t2, t1 WHERE t1.b = t2.b OR t2.b IS NULL;
a	b	a	b
1	NULL	1	1
1	NULL	2	1
1	NULL	4	10
2	10	4	10
DROP TABLE IF EXISTS t1,t2;
CREATE TABLE t1 (key1 double default NULL, UNIQUE KEY key1 (key1));
CREATE TABLE t2 (key2 double default NULL, UNIQUE KEY key2 (key2));
INSERT INTO t1 VALUES (0.3762),(0.3845),(0.6158),(0.7941);
INSERT INTO t2 VALUES (1.3762),(1.3845),(1.6158),(1.7941);
explain select max(key1) from t1 where key1 <= 0.6158;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`key1`) AS `max(key1)` from `test`.`t1` where (`test`.`t1`.`key1` <= 0.6158)
explain select max(key2) from t2 where key2 <= 1.6158;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t2`.`key2`) AS `max(key2)` from `test`.`t2` where (`test`.`t2`.`key2` <= 1.6158)
explain select min(key1) from t1 where key1 >= 0.3762;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`key1`) AS `min(key1)` from `test`.`t1` where (`test`.`t1`.`key1` >= 0.3762)
explain select min(key2) from t2 where key2 >= 1.3762;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t2`.`key2`) AS `min(key2)` from `test`.`t2` where (`test`.`t2`.`key2` >= 1.3762)
explain select max(key1), min(key2) from t1, t2
where key1 <= 0.6158 and key2 >= 1.3762;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Select tables optimized away
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`key1`) AS `max(key1)`,min(`test`.`t2`.`key2`) AS `min(key2)` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`key1` <= 0.6158) and (`test`.`t2`.`key2` >= 1.3762))
explain select max(key1) from t1 where key1 <= 0.6158 and rand() + 0.5 >= 0.5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	key1	key1	9	NULL	2	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select max(`test`.`t1`.`key1`) AS `max(key1)` from `test`.`t1` where ((`test`.`t1`.`key1` <= 0.6158) and ((rand() + 0.5) >= 0.5))
explain select min(key1) from t1 where key1 >= 0.3762 and rand() + 0.5 >= 0.5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	index	key1	key1	9	NULL	4	100.00	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select min(`test`.`t1`.`key1`) AS `min(key1)` from `test`.`t1` where ((`test`.`t1`.`key1` >= 0.3762) and ((rand() + 0.5) >= 0.5))
select max(key1) from t1 where key1 <= 0.6158;
max(key1)
0.6158
select max(key2) from t2 where key2 <= 1.6158;
max(key2)
1.6158
select min(key1) from t1 where key1 >= 0.3762;
min(key1)
0.3762
select min(key2) from t2 where key2 >= 1.3762;
min(key2)
1.3762
select max(key1), min(key2) from t1, t2
where key1 <= 0.6158 and key2 >= 1.3762;
max(key1)	min(key2)
0.6158	1.3762
select max(key1) from t1 where key1 <= 0.6158 and rand() + 0.5 >= 0.5;
max(key1)
0.6158
select min(key1) from t1 where key1 >= 0.3762 and rand() + 0.5 >= 0.5;
min(key1)
0.3762
DROP TABLE t1,t2;
CREATE TABLE t1 (i BIGINT UNSIGNED NOT NULL);
INSERT INTO t1 VALUES (10);
SELECT i='1e+01',i=1e+01, i in (1e+01,1e+01), i in ('1e+01','1e+01') FROM t1;
i='1e+01'	i=1e+01	i in (1e+01,1e+01)	i in ('1e+01','1e+01')
1	1	1	1
DROP TABLE t1;
create table t1(a bigint unsigned, b bigint);
insert ignore into t1 values (0xfffffffffffffffff, 0xfffffffffffffffff), 
(0x10000000000000000, 0x10000000000000000), 
(0x8fffffffffffffff, 0x8fffffffffffffff);
Warnings:
Warning	1264	Out of range value for column 'a' at row 1
Warning	1264	Out of range value for column 'b' at row 1
Warning	1264	Out of range value for column 'a' at row 2
Warning	1264	Out of range value for column 'b' at row 2
Warning	1264	Out of range value for column 'b' at row 3
select hex(a), hex(b) from t1;
hex(a)	hex(b)
FFFFFFFFFFFFFFFF	7FFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF	7FFFFFFFFFFFFFFF
8FFFFFFFFFFFFFFF	7FFFFFFFFFFFFFFF
drop table t1;
CREATE TABLE t1 (c0 int);
CREATE TABLE t2 (c0 int);
INSERT INTO t1 VALUES(@@connect_timeout);
INSERT INTO t2 VALUES(@@connect_timeout);
SELECT * FROM t1 JOIN t2 ON t1.c0 = t2.c0 WHERE (t1.c0 <=> @@connect_timeout);
c0	c0
X	X
DROP TABLE t1, t2;
End of 4.1 tests
CREATE TABLE t1 ( 
K2C4 varchar(4) character set latin1 collate latin1_bin NOT NULL default '', 
K4N4 varchar(4) character set latin1 collate latin1_bin NOT NULL default '0000', 
F2I4 int(11) NOT NULL default '0' 
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES 
('W%RT', '0100',  1), 
('W-RT', '0100', 1), 
('WART', '0100', 1), 
('WART', '0200', 1), 
('WERT', '0100', 2), 
('WORT','0200', 2), 
('WT', '0100', 2), 
('W_RT', '0100', 2), 
('WaRT', '0100', 3), 
('WART', '0300', 3), 
('WRT' , '0400', 3), 
('WURM', '0500', 3), 
('W%T', '0600', 4), 
('WA%T', '0700', 4), 
('WA_T', '0800', 4);
SELECT K2C4, K4N4, F2I4 FROM t1
WHERE  K2C4 = 'WART' AND 
(F2I4 = 2 AND K2C4 = 'WART' OR (F2I4 = 2 OR K4N4 = '0200'));
K2C4	K4N4	F2I4
WART	0200	1
SELECT K2C4, K4N4, F2I4 FROM t1
WHERE  K2C4 = 'WART' AND (K2C4 = 'WART' OR K4N4 = '0200');
K2C4	K4N4	F2I4
WART	0100	1
WART	0200	1
WART	0300	3
DROP TABLE t1;
create table t1 (a int, b int);
create table t2 like t1;
select t1.a from (t1 inner join t2 on t1.a=t2.a) where t2.a=1;
a
select t1.a from ((t1 inner join t2 on t1.a=t2.a)) where t2.a=1;
a
select x.a, y.a, z.a from ( (t1 x inner join t2 y on x.a=y.a) inner join t2 z on y.a=z.a) WHERE x.a=1;
a	a	a
drop table t1,t2;
create table t1 (s1 varchar(5));
insert into t1 values ('Wall');
select min(s1) from t1 group by s1 with rollup;
min(s1)
Wall
Wall
drop table t1;
create table t1 (s1 int) engine=myisam;
insert into t1 values (0);
select avg(distinct s1) from t1 group by s1 with rollup;
avg(distinct s1)
0.0000
0.0000
drop table t1;
create table t1 (s1 int);
insert into t1 values (null),(1);
select avg(s1) as x from t1 group by s1 with rollup;
x
NULL
1.0000
1.0000
select distinct avg(s1) as x from t1 group by s1 with rollup;
x
NULL
1.0000
drop table t1;
CREATE TABLE t1 (a int);
CREATE TABLE t2 (a int);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5);
INSERT INTO t2 VALUES (2), (4), (6);
SELECT t1.a FROM t1 STRAIGHT_JOIN t2 ON t1.a=t2.a;
a
2
4
EXPLAIN SELECT t1.a FROM t1 STRAIGHT_JOIN t2 ON t1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	33.33	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` straight_join `test`.`t2` where (`test`.`t2`.`a` = `test`.`t1`.`a`)
EXPLAIN SELECT t1.a FROM t1 INNER JOIN t2 ON t1.a=t2.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	20.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` join `test`.`t2` where (`test`.`t1`.`a` = `test`.`t2`.`a`)
DROP TABLE t1,t2;
select x'10' + 0, X'10' + 0, b'10' + 0, B'10' + 0;
x'10' + 0	X'10' + 0	b'10' + 0	B'10' + 0
16	16	2	2
create table t1 (f1 varchar(6) default NULL, f2 int(6) primary key not null);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t2 (f3 varchar(5) not null, f4 varchar(5) not null, UNIQUE KEY UKEY (f3,f4));
insert into t1 values (" 2", 2);
insert into t2 values (" 2", " one "),(" 2", " two ");
select * from t1 left join t2 on f1 = f3;
f1	f2	f3	f4
 2	2	 2	 one 
 2	2	 2	 two 
drop table t1,t2;
create table t1 (empnum smallint, grp int);
create table t2 (empnum int, name char(5));
insert into t1 values(1,1);
insert into t2 values(1,'bob');
create view v1 as select * from t2 inner join t1 using (empnum);
select * from v1;
empnum	name	grp
1	bob	1
drop table t1,t2;
drop view v1;
create table t1 (pk int primary key, b int);
create table t2 (pk int primary key, c int);
select pk from t1 inner join t2 using (pk);
pk
drop table t1,t2;
create table t1 (s1 int, s2 char(5), s3 decimal(10));
create view v1 as select s1, s2, 'x' as s3 from t1;
select * from t1 natural join v1;
s1	s2	s3
Warnings:
Warning	1292	Truncated incorrect DECIMAL value: 'x'
insert into t1 values (1,'x',5);
select * from t1 natural join v1;
s1	s2	s3
Warnings:
Warning	1292	Truncated incorrect DECIMAL value: 'x'
drop table t1;
drop view v1;
create table t1(a1 int);
create table t2(a2 int);
insert into t1 values(1),(2);
insert into t2 values(1),(2);
create view v2 (c) as select a1 from t1;
select * from t1 natural left join t2;
a1	a2
1	1
1	2
2	1
2	2
select * from t1 natural right join t2;
a2	a1
1	1
1	2
2	1
2	2
select * from v2 natural left join t2;
c	a2
1	1
1	2
2	1
2	2
select * from v2 natural right join t2;
a2	c
1	1
1	2
2	1
2	2
drop table t1, t2;
drop view v2;
create table t1 (a int(10), t1_val int(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t2 (b int(10), t2_val int(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t3 (a int(10), b int(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (1,1),(2,2);
insert into t2 values (1,1),(2,2),(3,3);
insert into t3 values (1,1),(2,1),(3,1),(4,1);
select * from t1 natural join t2 natural join t3;
a	b	t1_val	t2_val
1	1	1	1
2	1	2	1
select * from t1 natural join t3 natural join t2;
b	a	t1_val	t2_val
1	1	1	1
1	2	2	1
drop table t1, t2, t3;
DO IFNULL(NULL, NULL);
SELECT CAST(IFNULL(NULL, NULL) AS DECIMAL);
CAST(IFNULL(NULL, NULL) AS DECIMAL)
NULL
SELECT ABS(IFNULL(NULL, NULL));
ABS(IFNULL(NULL, NULL))
NULL
SELECT IFNULL(NULL, NULL);
IFNULL(NULL, NULL)
NULL
SET @OLD_SQL_MODE12595=@@SQL_MODE, @@SQL_MODE='';
SHOW LOCAL VARIABLES LIKE 'SQL_MODE';
Variable_name	Value
sql_mode	
CREATE TABLE BUG_12595(a varchar(100)) charset latin1;
INSERT INTO BUG_12595 VALUES ('hakan%'), ('hakank'), ("ha%an");
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan\%';
a
hakan%
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan*%' ESCAPE '*';
a
hakan%
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan**%' ESCAPE '**';
ERROR HY000: Incorrect arguments to ESCAPE
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan%' ESCAPE '';
a
hakan%
hakank
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan\%' ESCAPE '';
a
hakan%
SELECT * FROM BUG_12595 WHERE a LIKE 'ha\%an' ESCAPE 0x5c;
a
ha%an
SELECT * FROM BUG_12595 WHERE a LIKE 'ha%%an' ESCAPE '%';
a
ha%an
SELECT * FROM BUG_12595 WHERE a LIKE 'ha\%an' ESCAPE '\\';
a
ha%an
SELECT * FROM BUG_12595 WHERE a LIKE 'ha|%an' ESCAPE '|';
a
ha%an
SET @@SQL_MODE='NO_BACKSLASH_ESCAPES';
SHOW LOCAL VARIABLES LIKE 'SQL_MODE';
Variable_name	Value
sql_mode	NO_BACKSLASH_ESCAPES
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan\%';
a
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan*%' ESCAPE '*';
a
hakan%
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan**%' ESCAPE '**';
ERROR HY000: Incorrect arguments to ESCAPE
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan\%' ESCAPE '\\';
ERROR HY000: Incorrect arguments to ESCAPE
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan%' ESCAPE '';
ERROR HY000: Incorrect arguments to ESCAPE
SELECT * FROM BUG_12595 WHERE a LIKE 'ha\%an' ESCAPE 0x5c;
a
ha%an
SELECT * FROM BUG_12595 WHERE a LIKE 'ha|%an' ESCAPE '|';
a
ha%an
SELECT * FROM BUG_12595 WHERE a LIKE 'hakan\n%' ESCAPE '\n';
ERROR HY000: Incorrect arguments to ESCAPE
SET @@SQL_MODE=@OLD_SQL_MODE12595;
DROP TABLE BUG_12595;
create table t1 (a char(1));
create table t2 (a char(1));
insert into t1 values ('a'),('b'),('c');
insert into t2 values ('b'),('c'),('d');
select a from t1 natural join t2;
a
b
c
select * from t1 natural join t2 where a = 'b';
a
b
drop table t1, t2;
CREATE TABLE t1 (`id` TINYINT);
CREATE TABLE t2 (`id` TINYINT);
CREATE TABLE t3 (`id` TINYINT);
INSERT INTO t1 VALUES (1),(2),(3);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
SELECT t1.id,t3.id FROM t1 JOIN t2 ON (t2.id=t1.id) LEFT JOIN t3 USING (id);
ERROR 23000: Column 'id' in from clause is ambiguous
SELECT t1.id,t3.id FROM t1 JOIN t2 ON (t2.notacolumn=t1.id) LEFT JOIN t3 USING (id);
ERROR 23000: Column 'id' in from clause is ambiguous
SELECT id,t3.id FROM t1 JOIN t2 ON (t2.id=t1.id) LEFT JOIN t3 USING (id);
ERROR 23000: Column 'id' in from clause is ambiguous
SELECT id,t3.id FROM (t1 JOIN t2 ON (t2.id=t1.id)) LEFT JOIN t3 USING (id);
ERROR 23000: Column 'id' in from clause is ambiguous
drop table t1, t2, t3;
create table t1 (a int(10),b int(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
create table t2 (a int(10),b int(10));
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (1,10),(2,20),(3,30);
insert into t2 values (1,10);
select * from t1 inner join t2 using (A);
a	b	b
1	10	10
select * from t1 inner join t2 using (a);
a	b	b
1	10	10
drop table t1, t2;
create table t1 (a int, c int);
create table t2 (b int);
create table t3 (b int, a int);
create table t4 (c int);
insert into t1 values (1,1);
insert into t2 values (1);
insert into t3 values (1,1);
insert into t4 values (1);
select * from t1 join t2 join t3 on (t2.b = t3.b and t1.a = t3.a);
a	c	b	b	a
1	1	1	1	1
select * from t1, t2 join t3 on (t2.b = t3.b and t1.a = t3.a);
ERROR 42S22: Unknown column 't1.a' in 'on clause'
select * from t1 join t2 join t3 join t4 on (t1.a = t4.c and t2.b = t4.c);
a	c	b	b	a	c
1	1	1	1	1	1
select * from t1 join t2 join t4 using (c);
c	a	b
1	1	1
drop table t1, t2, t3, t4;
create table t1(x int, y int);
create table t2(x int, y int);
create table t3(x int, primary key(x));
insert into t1 values (1, 1), (2, 1), (3, 1), (4, 3), (5, 6), (6, 6);
insert into t2 values (1, 1), (2, 1), (3, 3), (4, 6), (5, 6);
insert into t3 values (1), (2), (3), (4), (5);
select t1.x, t3.x from t1, t2, t3  where t1.x = t2.x and t3.x >= t1.y and t3.x <= t2.y;
x	x
1	1
2	1
3	1
3	2
3	3
4	3
4	4
4	5
drop table t1,t2,t3;
create table t1 (id char(16) not null default '', primary key  (id));
insert into t1 values ('100'),('101'),('102');
create table t2 (id char(16) default null);
insert into t2 values (1);
create view v1 as select t1.id from t1;
create view v2 as select t2.id from t2;
create view v3 as select (t1.id+2) as id from t1 natural left join t2;
select t1.id from t1 left join v2 using (id);
id
100
101
102
select t1.id from v2 right join t1 using (id);
id
100
101
102
select t1.id from t1 left join v3 using (id);
id
100
101
102
select * from t1 left join v2 using (id);
id
100
101
102
select * from v2 right join t1 using (id);
id
100
101
102
select * from t1 left join v3 using (id);
id
100
101
102
select v1.id from v1 left join v2 using (id);
id
100
101
102
select v1.id from v2 right join v1 using (id);
id
100
101
102
select v1.id from v1 left join v3 using (id);
id
100
101
102
select * from v1 left join v2 using (id);
id
100
101
102
select * from v2 right join v1 using (id);
id
100
101
102
select * from v1 left join v3 using (id);
id
100
101
102
drop table t1, t2;
drop view v1, v2, v3;
create table t1 (id int(11) not null default '0');
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (123),(191),(192);
create table t2 (id char(16) character set utf8 not null);
Warnings:
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
insert into t2 values ('58013'),('58014'),('58015'),('58016');
create table t3 (a_id int(11) not null, b_id char(16) character set utf8);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	3719	'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
insert into t3 values (123,null),(123,null),(123,null),(123,null),(123,null),(123,'58013');
select count(*)
from t1 inner join (t3 left join t2 on t2.id = t3.b_id) on t1.id = t3.a_id;
count(*)
6
select count(*)
from t1 inner join (t2 right join t3 on t2.id = t3.b_id) on t1.id = t3.a_id;
count(*)
6
drop table t1,t2,t3;
create table t1 (a int);
create table t2 (b int);
create table t3 (c int);
select * from t1 join t2 join t3 on (t1.a=t3.c);
a	b	c
select * from t1 join t2 left join t3 on (t1.a=t3.c);
a	b	c
select * from t1 join t2 right join t3 on (t1.a=t3.c);
a	b	c
select * from t1 join t2 straight_join t3 on (t1.a=t3.c);
a	b	c
drop table t1, t2 ,t3;
create table t1(f1 int, f2 date);
insert into t1 values(1,'2005-01-01'),(2,'2005-09-01'),(3,'2005-09-30'),
(4,'2005-10-01'),(5,'2005-12-30');
select * from t1 where f2 >= 0            order by f2;
f1	f2
1	2005-01-01
2	2005-09-01
3	2005-09-30
4	2005-10-01
5	2005-12-30
select * from t1 where f2 >= '0000-00-00' order by f2;
ERROR HY000: Incorrect DATE value: '0000-00-00'
select * from t1 where f2 >= '2005-09-31' order by f2;
ERROR HY000: Incorrect DATE value: '2005-09-31'
select * from t1 where f2 >= '2005-09-3a' order by f2;
f1	f2
3	2005-09-30
4	2005-10-01
5	2005-12-30
Warnings:
Warning	1292	Incorrect date value: '2005-09-3a' for column 'f2' at row 1
select * from t1 where f2 <= '2005-09-31' order by f2;
ERROR HY000: Incorrect DATE value: '2005-09-31'
select * from t1 where f2 <= '2005-09-3a' order by f2;
f1	f2
1	2005-01-01
2	2005-09-01
Warnings:
Warning	1292	Incorrect date value: '2005-09-3a' for column 'f2' at row 1
drop table t1;
create table t1 (f1 int, f2 int);
insert into t1 values (1, 30), (2, 20), (3, 10);
create algorithm=merge view v1 as select f1, f2 from t1;
create algorithm=merge view v2 (f2, f1) as select f1, f2 from t1;
create algorithm=merge view v3 as select t1.f1 as f2, t1.f2 as f1 from t1;
select t1.f1 as x1, f1 from t1 order by t1.f1;
x1	f1
1	1
2	2
3	3
select v1.f1 as x1, f1 from v1 order by v1.f1;
x1	f1
1	1
2	2
3	3
select v2.f1 as x1, f1 from v2 order by v2.f1;
x1	f1
10	10
20	20
30	30
select v3.f1 as x1, f1 from v3 order by v3.f1;
x1	f1
10	10
20	20
30	30
select f1, f2, v1.f1 as x1 from v1 order by v1.f1;
f1	f2	x1
1	30	1
2	20	2
3	10	3
select f1, f2, v2.f1 as x1 from v2 order by v2.f1;
f1	f2	x1
10	3	10
20	2	20
30	1	30
select f1, f2, v3.f1 as x1 from v3 order by v3.f1;
f1	f2	x1
10	3	10
20	2	20
30	1	30
drop table t1;
drop view v1, v2, v3;
CREATE TABLE t1(key_a int4 NOT NULL, optimus varchar(32), PRIMARY KEY(key_a));
CREATE TABLE t2(key_a int4 NOT NULL, prime varchar(32), PRIMARY KEY(key_a));
CREATE table t3(key_a int4 NOT NULL, key_b int4 NOT NULL, foo varchar(32),
PRIMARY KEY(key_a,key_b));
INSERT INTO t1 VALUES (0,'');
INSERT INTO t1 VALUES (1,'i');
INSERT INTO t1 VALUES (2,'j');
INSERT INTO t1 VALUES (3,'k');
INSERT INTO t2 VALUES (1,'r');
INSERT INTO t2 VALUES (2,'s');
INSERT INTO t2 VALUES (3,'t');
INSERT INTO t3 VALUES (1,5,'x');
INSERT INTO t3 VALUES (1,6,'y');
INSERT INTO t3 VALUES (2,5,'xx');
INSERT INTO t3 VALUES (2,6,'yy');
INSERT INTO t3 VALUES (2,7,'zz');
INSERT INTO t3 VALUES (3,5,'xxx');
SELECT t2.key_a,foo 
FROM t1 INNER JOIN t2 ON t1.key_a = t2.key_a
INNER JOIN t3 ON t1.key_a = t3.key_a
WHERE t2.key_a=2 and key_b=5;
key_a	foo
2	xx
EXPLAIN SELECT t2.key_a,foo 
FROM t1 INNER JOIN t2 ON t1.key_a = t2.key_a
INNER JOIN t3 ON t1.key_a = t3.key_a
WHERE t2.key_a=2 and key_b=5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	Using index
1	SIMPLE	t2	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	Using index
1	SIMPLE	t3	NULL	const	PRIMARY	PRIMARY	8	const,const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2' AS `key_a`,'xx' AS `foo` from `test`.`t1` join `test`.`t2` join `test`.`t3` where true
SELECT t2.key_a,foo 
FROM t1 INNER JOIN t2 ON t2.key_a = t1.key_a
INNER JOIN t3 ON t1.key_a = t3.key_a
WHERE t2.key_a=2 and key_b=5;
key_a	foo
2	xx
EXPLAIN SELECT t2.key_a,foo 
FROM t1 INNER JOIN t2 ON t2.key_a = t1.key_a
INNER JOIN t3 ON t1.key_a = t3.key_a
WHERE t2.key_a=2 and key_b=5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	Using index
1	SIMPLE	t2	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	Using index
1	SIMPLE	t3	NULL	const	PRIMARY	PRIMARY	8	const,const	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2' AS `key_a`,'xx' AS `foo` from `test`.`t1` join `test`.`t2` join `test`.`t3` where true
DROP TABLE t1,t2,t3;
create  table t1 (f1 int);
insert into t1 values(1),(2);
create table t2 (f2 int, f3 int, key(f2));
insert into t2 values(1,1),(2,2);
create table t3 (f4 int not null);
insert into t3 values (2),(2),(2);
select f1,(select count(*) from t2,t3 where f2=f1 and f3=f4) as count from t1;
f1	count
1	0
2	3
drop table t1,t2,t3;
create table t1 (f1 int unique);
create table t2 (f2 int unique);
create table t3 (f3 int unique);
insert into t1 values(1),(2);
insert into t2 values(1),(2);
insert into t3 values(1),(NULL);
select * from t3 where f3 is null;
f3
NULL
select t2.f2 from t1 left join t2 on f1=f2 join t3 on f1=f3 where f1=1;
f2
1
drop table t1,t2,t3;
create table t1(f1 char, f2 char not null);
insert into t1 values(null,'a');
create table t2 (f2 char not null);
insert into t2 values('b');
select * from t1 left join t2 on f1=t2.f2 where t1.f2='a';
f1	f2	f2
NULL	a	NULL
drop table t1,t2;
select * from (select * left join t on f1=f2) tt;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'left join t on f1=f2) tt' at line 1
CREATE TABLE t1 (sku int PRIMARY KEY, pr int);
CREATE TABLE t2 (sku int PRIMARY KEY, sppr int, name varchar(255));
INSERT INTO t1 VALUES
(10, 10), (20, 10), (30, 20), (40, 30), (50, 10), (60, 10);
INSERT INTO t2 VALUES 
(10, 10, 'aaa'), (20, 10, 'bbb'), (30, 10, 'ccc'), (40, 20, 'ddd'),
(50, 10, 'eee'), (60, 20, 'fff'), (70, 20, 'ggg'), (80, 30, 'hhh');
SELECT t2.sku, t2.sppr, t2.name, t1.sku, t1.pr
FROM t2, t1 WHERE t2.sku=20 AND (t2.sku=t1.sku OR t2.sppr=t1.sku);
sku	sppr	name	sku	pr
20	10	bbb	10	10
20	10	bbb	20	10
EXPLAIN
SELECT t2.sku, t2.sppr, t2.name, t1.sku, t1.pr
FROM t2, t1 WHERE t2.sku=20 AND (t2.sku=t1.sku OR t2.sppr=t1.sku);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	2	100.00	Using index condition; Using MRR
Warnings:
Note	1003	/* select#1 */ select '20' AS `sku`,'10' AS `sppr`,'bbb' AS `name`,`test`.`t1`.`sku` AS `sku`,`test`.`t1`.`pr` AS `pr` from `test`.`t2` join `test`.`t1` where (((`test`.`t1`.`sku` = 20) or (`test`.`t1`.`sku` = '10')))
DROP TABLE t1,t2;
SET SQL_MODE='NO_UNSIGNED_SUBTRACTION';
CREATE TABLE t1 (i TINYINT UNSIGNED NOT NULL);
INSERT t1 SET i = 0;
UPDATE t1 SET i = -1;
Warnings:
Warning	1264	Out of range value for column 'i' at row 1
SELECT * FROM t1;
i
0
UPDATE t1 SET i = CAST(i - 1 AS SIGNED);
Warnings:
Warning	1264	Out of range value for column 'i' at row 1
SELECT * FROM t1;
i
0
UPDATE t1 SET i = i - 1;
Warnings:
Warning	1264	Out of range value for column 'i' at row 1
SELECT * FROM t1;
i
0
DROP TABLE t1;
SET SQL_MODE=default;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, b int, c int, e int, primary key(a,b,c));
# The "ANALYZE TABLE"-command that is executed further down will get
# different results depending on the order of rows in table t2. Since the
# INSERT INTO ... SELECT may be executed using different execution plans,
# we've added ORDER BY to ensure that we rows has the same order every
# time. If not, the estimated number of rows for t2 (alias 'a') in the
# EXPLAIN may change on different platforms. Note that both table t1 and
# t2 may be MyISAM, since many of the test files that includes this file
# forces MyISAM as the default storage engine.
insert into t2 select A.a, B.a, C.a, C.a from t1 A, t1 B, t1 C
ORDER BY A.a, B.a, C.a;
analyze table t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
select 'In next EXPLAIN, B.rows must be exactly 10:' Z;
Z
In next EXPLAIN, B.rows must be exactly 10:
explain select * from t2 a, t2 b where a.a=5 and a.b=5 and a.c<5
and b.a=5 and b.b=a.e and (b.b =1 or b.b = 3 or b.b=5);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	a	NULL	range	PRIMARY	PRIMARY	12	NULL	5	27.10	Using index condition; Using where; Using MRR
1	SIMPLE	b	NULL	ref	PRIMARY	PRIMARY	8	const,test.a.e	10	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`a`.`a` AS `a`,`test`.`a`.`b` AS `b`,`test`.`a`.`c` AS `c`,`test`.`a`.`e` AS `e`,`test`.`b`.`a` AS `a`,`test`.`b`.`b` AS `b`,`test`.`b`.`c` AS `c`,`test`.`b`.`e` AS `e` from `test`.`t2` `a` join `test`.`t2` `b` where ((`test`.`b`.`b` = `test`.`a`.`e`) and (`test`.`b`.`a` = 5) and (`test`.`a`.`b` = 5) and (`test`.`a`.`a` = 5) and (`test`.`a`.`c` < 5) and ((`test`.`a`.`e` = 1) or (`test`.`a`.`e` = 3) or (`test`.`a`.`e` = 5)))
drop table t1, t2;
CREATE TABLE t1 (a int PRIMARY KEY, b int, INDEX(b));
INSERT INTO t1 VALUES (1, 3), (9,4), (7,5), (4,5), (6,2),
(3,1), (5,1), (8,9), (2,2), (0,9);
CREATE TABLE t2 (c int, d int, f int, INDEX(c,f));
INSERT INTO t2 VALUES
(1,0,0), (1,0,1), (2,0,0), (2,0,1), (3,0,0), (4,0,1),
(5,0,0), (5,0,1), (6,0,0), (0,0,1), (7,0,0), (7,0,1),
(0,0,0), (0,0,1), (8,0,0), (8,0,1), (9,0,0), (9,0,1);
EXPLAIN
SELECT a, c, d, f FROM t1,t2 WHERE a=c AND b BETWEEN 4 AND 6;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY,b	b	5	NULL	3	100.00	Using index condition; Using MRR
1	SIMPLE	t2	NULL	ref	c	c	5	test.t1.a	2	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`c` AS `c`,`test`.`t2`.`d` AS `d`,`test`.`t2`.`f` AS `f` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`c` = `test`.`t1`.`a`) and (`test`.`t1`.`b` between 4 and 6))
EXPLAIN
SELECT a, c, d, f FROM t1,t2 WHERE a=c AND b BETWEEN 4 AND 6 AND a > 0;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY,b	b	5	NULL	3	90.00	Using index condition; Using where; Using MRR
1	SIMPLE	t2	NULL	ref	c	c	5	test.t1.a	2	100.00	Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t2`.`c` AS `c`,`test`.`t2`.`d` AS `d`,`test`.`t2`.`f` AS `f` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`c` = `test`.`t1`.`a`) and (`test`.`t1`.`b` between 4 and 6) and (`test`.`t1`.`a` > 0))
DROP TABLE t1, t2;
create table t1 (
a int unsigned    not null auto_increment primary key,
b bit             not null,
c bit             not null
);
create table t2 (
a int unsigned    not null auto_increment primary key,
b bit             not null,
c int unsigned    not null,
d varchar(50)
);
insert into t1 (b,c) values (0,1), (0,1);
insert into t2 (b,c) values (0,1);
select t1.a, t1.b + 0, t1.c + 0, t2.a, t2.b + 0, t2.c, t2.d
from t1 left outer join t2 on t1.a = t2.c and t2.b <> 1
where t1.b <> 1 order by t1.a;
a	t1.b + 0	t1.c + 0	a	t2.b + 0	c	d
1	0	1	1	0	1	NULL
2	0	1	NULL	NULL	NULL	NULL
drop table t1,t2;
SELECT 0.9888889889 * 1.011111411911;
0.9888889889 * 1.011111411911
0.9998769417899202067879
prepare stmt from 'select 1 as " a "';
Warnings:
Warning	1466	Leading spaces are removed from name ' a '
execute stmt;
a 
1
CREATE TABLE t1 (a int NOT NULL PRIMARY KEY, b int NOT NULL);
INSERT INTO t1 VALUES (1,1), (2,2), (3,3), (4,4);
CREATE TABLE t2 (c int NOT NULL, INDEX idx(c));
INSERT INTO t2 VALUES
(1), (1), (1), (1), (1), (1), (1), (1),
(2), (2), (2), (2),
(3), (3),
(4);
EXPLAIN SELECT b FROM t1, t2 WHERE b=c AND a=1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	ref	idx	idx	4	const	7	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select '1' AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`c` = '1'))
EXPLAIN SELECT b FROM t1, t2 WHERE b=c AND a=4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	ref	idx	idx	4	const	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select '4' AS `b` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`c` = '4'))
DROP TABLE t1, t2;
CREATE TABLE t1 (id int NOT NULL PRIMARY KEY, a int);
INSERT INTO t1 VALUES (1,2), (2,NULL), (3,2);
CREATE TABLE t2 (b int, c INT, INDEX idx1(b));
INSERT INTO t2 VALUES (2,1), (3,2);
CREATE TABLE t3 (d int,  e int, INDEX idx1(d));
INSERT INTO t3 VALUES (2,10), (2,20), (1,30), (2,40), (2,50);
EXPLAIN
SELECT * FROM t1 LEFT JOIN t2 ON t2.b=t1.a INNER JOIN t3 ON t3.d=t1.id
WHERE t1.id=2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	const	idx1	NULL	NULL	NULL	1	100.00	Impossible ON condition
1	SIMPLE	t3	NULL	ref	idx1	idx1	5	const	3	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2' AS `id`,NULL AS `a`,NULL AS `b`,NULL AS `c`,`test`.`t3`.`d` AS `d`,`test`.`t3`.`e` AS `e` from `test`.`t1` left join `test`.`t2` on(multiple equal(NULL, NULL)) join `test`.`t3` where (`test`.`t3`.`d` = 2)
SELECT * FROM t1 LEFT JOIN t2 ON t2.b=t1.a INNER JOIN t3 ON t3.d=t1.id
WHERE t1.id=2;
id	a	b	c	d	e
2	NULL	NULL	NULL	2	10
2	NULL	NULL	NULL	2	20
2	NULL	NULL	NULL	2	40
2	NULL	NULL	NULL	2	50
DROP TABLE t1,t2,t3;
create table t1 (c1 varchar(1), c2 int, c3 int, c4 int, c5 int, c6 int,
c7 int, c8 int, c9 int, fulltext key (`c1`));
select distinct match (`c1`) against ('z') , c2, c3, c4,c5, c6,c7, c8 
from t1 where c9=1 order by c2, c2;
match (`c1`) against ('z')	c2	c3	c4	c5	c6	c7	c8
drop table t1;
CREATE TABLE t1 (pk varchar(10) PRIMARY KEY, fk varchar(16)) charset utf8mb4;
CREATE TABLE t2 (pk varchar(16) PRIMARY KEY, fk varchar(10)) charset utf8mb4;
INSERT INTO t1 VALUES
('d','dddd'), ('i','iii'), ('a','aa'), ('b','bb'), ('g','gg'), 
('e','eee'), ('c','cccc'), ('h','hhh'), ('j','jjj'), ('f','fff');
INSERT INTO t2 VALUES
('jjj', 'j'), ('cc','c'), ('ccc','c'), ('aaa', 'a'), ('jjjj','j'),
('hhh','h'), ('gg','g'), ('fff','f'), ('ee','e'), ('ffff','f'),
('bbb','b'), ('ff','f'), ('cccc','c'), ('dddd','d'), ('jj','j'),
('aaaa','a'), ('bb','b'), ('eeee','e'), ('aa','a'), ('hh','h');
EXPLAIN SELECT t2.* 
FROM t1 JOIN t2 ON t2.fk=t1.pk
WHERE t2.fk < 'c' AND t2.pk=t1.fk;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	42	NULL	3	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t2	NULL	eq_ref	PRIMARY	PRIMARY	66	test.t1.fk	1	5.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`pk` AS `pk`,`test`.`t2`.`fk` AS `fk` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`fk` = `test`.`t1`.`pk`) and (`test`.`t2`.`pk` = `test`.`t1`.`fk`) and (`test`.`t1`.`pk` < 'c'))
EXPLAIN SELECT t2.* 
FROM t1 JOIN t2 ON t2.fk=t1.pk 
WHERE t2.fk BETWEEN 'a' AND 'b' AND t2.pk=t1.fk;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	42	NULL	2	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t2	NULL	eq_ref	PRIMARY	PRIMARY	66	test.t1.fk	1	5.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`pk` AS `pk`,`test`.`t2`.`fk` AS `fk` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`fk` = `test`.`t1`.`pk`) and (`test`.`t2`.`pk` = `test`.`t1`.`fk`) and (`test`.`t1`.`pk` between 'a' and 'b'))
EXPLAIN SELECT t2.* 
FROM t1 JOIN t2 ON t2.fk=t1.pk 
WHERE t2.fk IN ('a','b') AND t2.pk=t1.fk;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	42	NULL	2	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t2	NULL	eq_ref	PRIMARY	PRIMARY	66	test.t1.fk	1	5.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`pk` AS `pk`,`test`.`t2`.`fk` AS `fk` from `test`.`t1` join `test`.`t2` where ((`test`.`t2`.`fk` = `test`.`t1`.`pk`) and (`test`.`t2`.`pk` = `test`.`t1`.`fk`) and (`test`.`t1`.`pk` in ('a','b')))
DROP TABLE t1,t2;
CREATE TABLE t1 (a int, b varchar(20) NOT NULL, PRIMARY KEY(a)) charset utf8mb4;
CREATE TABLE t2 (a int, b varchar(20) NOT NULL,
PRIMARY KEY (a), UNIQUE KEY (b)) charset utf8mb4;
INSERT INTO t1 VALUES (1,'a'),(2,'b'),(3,'c');
INSERT INTO t2 VALUES (1,'a'),(2,'b'),(3,'c');
EXPLAIN SELECT t1.a FROM t1 LEFT JOIN t2 ON t2.b=t1.b WHERE t1.a=3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	const	b	b	82	const	1	100.00	Using index
Warnings:
Note	1003	/* select#1 */ select '3' AS `a` from `test`.`t1` left join `test`.`t2` on(multiple equal('c', 'c')) where true
DROP TABLE t1,t2;
CREATE TABLE t1(id int PRIMARY KEY, b int, e int);
CREATE TABLE t2(i int, a int, INDEX si(i), INDEX ai(a));
CREATE TABLE t3(a int PRIMARY KEY, c char(4), INDEX ci(c));
INSERT INTO t1 VALUES 
(1,10,19), (2,20,22), (4,41,42), (9,93,95), (7, 77,79),
(6,63,67), (5,55,58), (3,38,39), (8,81,89);
INSERT INTO t2 VALUES
(21,210), (41,410), (82,820), (83,830), (84,840),
(65,650), (51,510), (37,370), (94,940), (76,760),
(22,220), (33,330), (40,400), (95,950), (38,380),
(67,670), (88,880), (57,570), (96,960), (97,970);
INSERT INTO t3 VALUES
(210,'bb'), (950,'ii'), (400,'ab'), (500,'ee'), (220,'gg'),
(440,'gg'), (310,'eg'), (380,'ee'), (840,'bb'), (830,'ff'),
(230,'aa'), (960,'ii'), (410,'aa'), (510,'ee'), (290,'bb'),
(450,'gg'), (320,'dd'), (390,'hh'), (850,'jj'), (860,'ff');
EXPLAIN
SELECT t3.a FROM t1,t2 FORCE INDEX (si),t3
WHERE t1.id = 8 AND t2.i BETWEEN t1.b AND t1.e AND 
t3.a=t2.a AND t3.c IN ('bb','ee');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	range	si	si	5	NULL	4	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t3	NULL	eq_ref	PRIMARY,ci	PRIMARY	4	test.t2.a	1	25.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t2` FORCE INDEX (`si`) join `test`.`t3` where ((`test`.`t3`.`a` = `test`.`t2`.`a`) and (`test`.`t2`.`i` between '81' and '89') and (`test`.`t3`.`c` in ('bb','ee')))
EXPLAIN
SELECT t3.a FROM t1,t2,t3
WHERE t1.id = 8 AND t2.i BETWEEN t1.b AND t1.e AND
t3.a=t2.a AND t3.c IN ('bb','ee') ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	range	si,ai	si	5	NULL	4	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t3	NULL	eq_ref	PRIMARY,ci	PRIMARY	4	test.t2.a	1	25.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t2` join `test`.`t3` where ((`test`.`t3`.`a` = `test`.`t2`.`a`) and (`test`.`t2`.`i` between '81' and '89') and (`test`.`t3`.`c` in ('bb','ee')))
EXPLAIN 
SELECT t3.a FROM t1,t2 FORCE INDEX (si),t3
WHERE t1.id = 8 AND (t2.i=t1.b OR t2.i=t1.e) AND t3.a=t2.a AND
t3.c IN ('bb','ee');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	range	si	si	5	NULL	2	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t3	NULL	eq_ref	PRIMARY,ci	PRIMARY	4	test.t2.a	1	25.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t2` FORCE INDEX (`si`) join `test`.`t3` where ((`test`.`t3`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`i` = '81') or (`test`.`t2`.`i` = '89')) and (`test`.`t3`.`c` in ('bb','ee')))
EXPLAIN 
SELECT t3.a FROM t1,t2,t3
WHERE t1.id = 8 AND (t2.i=t1.b OR t2.i=t1.e) AND t3.a=t2.a AND
t3.c IN ('bb','ee');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t2	NULL	range	si,ai	si	5	NULL	2	100.00	Using index condition; Using where; Using MRR
1	SIMPLE	t3	NULL	eq_ref	PRIMARY,ci	PRIMARY	4	test.t2.a	1	25.00	Using where; Using join buffer (Batched Key Access)
Warnings:
Note	1003	/* select#1 */ select `test`.`t3`.`a` AS `a` from `test`.`t1` join `test`.`t2` join `test`.`t3` where ((`test`.`t3`.`a` = `test`.`t2`.`a`) and ((`test`.`t2`.`i` = '81') or (`test`.`t2`.`i` = '89')) and (`test`.`t3`.`c` in ('bb','ee')))
DROP TABLE t1,t2,t3;
CREATE TABLE t1 ( f1 int primary key, f2 int, f3 int, f4 int, f5 int, f6 int, checked_out int);
CREATE TABLE t2 ( f11 int PRIMARY KEY );
INSERT INTO t1 VALUES (1,1,1,0,0,0,0),(2,1,1,3,8,1,0),(3,1,1,4,12,1,0);
INSERT INTO t2 VALUES (62);
SELECT * FROM t1 LEFT JOIN t2 ON f11 = t1.checked_out GROUP BY f1 ORDER BY f2, f3, f4, f5 LIMIT 0, 1;
f1	f2	f3	f4	f5	f6	checked_out	f11
1	1	1	0	0	0	0	NULL
DROP TABLE t1, t2;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(a int);
INSERT into t1 values (1), (2), (3);
SELECT * FROM t1 LIMIT 2, -1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '-1' at line 1
DROP TABLE t1;
CREATE TABLE t1 (
ID_with_null int NULL,
ID_better int NOT NULL,
INDEX idx1 (ID_with_null),
INDEX idx2 (ID_better)
);
INSERT INTO t1 VALUES (1,1), (2,1), (null,3), (null,3), (null,3), (null,3);
INSERT INTO t1 SELECT * FROM t1 WHERE ID_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID_with_null IS NULL;
SELECT COUNT(*) FROM t1 WHERE ID_with_null IS NULL;
COUNT(*)
128
SELECT COUNT(*) FROM t1 WHERE ID_better=1;
COUNT(*)
2
EXPLAIN SELECT * FROM t1 WHERE ID_better=1 AND ID_with_null IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	97.69	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID_with_null` AS `ID_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID_with_null` is null))
DROP INDEX idx1 ON t1;
CREATE UNIQUE INDEX idx1 ON t1(ID_with_null);
EXPLAIN SELECT * FROM t1 WHERE ID_better=1 AND ID_with_null IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	97.69	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID_with_null` AS `ID_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID_with_null` is null))
DROP TABLE t1;
CREATE TABLE t1 (
ID1_with_null int NULL,
ID2_with_null int NULL,
ID_better int NOT NULL,
INDEX idx1 (ID1_with_null, ID2_with_null),
INDEX idx2 (ID_better)
);
INSERT INTO t1 VALUES (1,1,1), (2,2,1), (3,null,3), (null,3,3), (null,null,3),
(3,null,3), (null,3,3), (null,null,3), (3,null,3), (null,3,3), (null,null,3);
INSERT INTO t1 SELECT * FROM t1 WHERE ID1_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID2_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID1_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID2_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID1_with_null IS NULL;
INSERT INTO t1 SELECT * FROM t1 WHERE ID2_with_null IS NULL;
SELECT COUNT(*) FROM t1 WHERE ID1_with_null IS NULL AND ID2_with_null=3;
COUNT(*)
24
SELECT COUNT(*) FROM t1 WHERE ID1_with_null=3 AND ID2_with_null IS NULL;
COUNT(*)
24
SELECT COUNT(*) FROM t1 WHERE ID1_with_null IS NULL AND ID2_with_null IS NULL;
COUNT(*)
192
SELECT COUNT(*) FROM t1 WHERE ID_better=1;
COUNT(*)
2
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null IS NULL AND ID2_with_null=3 ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	5.79	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID2_with_null` = 3) and (`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID1_with_null` is null))
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null=3 AND ID2_with_null=3 IS NULL ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	27.27	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID1_with_null` = 3) and (`test`.`t1`.`ID_better` = 1) and ((`test`.`t1`.`ID2_with_null` = 3) is null))
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null IS NULL AND ID2_with_null IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	64.88	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID1_with_null` is null) and (`test`.`t1`.`ID2_with_null` is null))
DROP INDEX idx1 ON t1;
CREATE UNIQUE INDEX idx1 ON t1(ID1_with_null,ID2_with_null);
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null IS NULL AND ID2_with_null=3 ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	12.40	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID2_with_null` = 3) and (`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID1_with_null` is null))
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null=3 AND ID2_with_null IS NULL ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	12.40	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID1_with_null` = 3) and (`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID2_with_null` is null))
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null IS NULL AND ID2_with_null IS NULL;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	73.55	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID1_with_null` is null) and (`test`.`t1`.`ID2_with_null` is null))
EXPLAIN SELECT * FROM t1
WHERE ID_better=1 AND ID1_with_null IS NULL AND 
(ID2_with_null=1 OR ID2_with_null=2);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ref	idx1,idx2	idx2	4	const	1	5.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`ID1_with_null` AS `ID1_with_null`,`test`.`t1`.`ID2_with_null` AS `ID2_with_null`,`test`.`t1`.`ID_better` AS `ID_better` from `test`.`t1` where ((`test`.`t1`.`ID_better` = 1) and (`test`.`t1`.`ID1_with_null` is null) and ((`test`.`t1`.`ID2_with_null` = 1) or (`test`.`t1`.`ID2_with_null` = 2)))
DROP TABLE t1;
CREATE TABLE t1 (a INT, ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, KEY ts(ts));
INSERT INTO t1 VALUES (30,"2006-01-03 23:00:00"), (31,"2006-01-03 23:00:00");
ANALYZE TABLE t1;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
CREATE TABLE t2 (a INT, dt1 DATETIME, dt2 DATETIME, PRIMARY KEY (a));
INSERT INTO t2 VALUES (30, "2006-01-01 00:00:00", "2999-12-31 00:00:00");
INSERT INTO t2 SELECT a+1,dt1,dt2 FROM t2;
ANALYZE TABLE t2;
Table	Op	Msg_type	Msg_text
test.t2	analyze	status	OK
EXPLAIN
SELECT * FROM t1 LEFT JOIN t2 ON (t1.a=t2.a) WHERE t1.a=30
AND t1.ts BETWEEN t2.dt1 AND t2.dt2
AND t1.ts BETWEEN "2006-01-01" AND "2006-12-31";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	const	PRIMARY	PRIMARY	4	const	1	100.00	NULL
1	SIMPLE	t1	NULL	range	ts	ts	4	NULL	1	50.00	Using index condition; Using where; Using MRR
Warnings:
Warning	1292	Incorrect datetime value: '2999-12-31 00:00:00' for column 'ts' at row 1
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`ts` AS `ts`,'30' AS `a`,'2006-01-01 00:00:00' AS `dt1`,'2999-12-31 00:00:00' AS `dt2` from `test`.`t1` join `test`.`t2` where ((`test`.`t1`.`a` = 30) and (`test`.`t1`.`ts` between '2006-01-01 00:00:00' and '2999-12-31 00:00:00') and (`test`.`t1`.`ts` between '2006-01-01' and '2006-12-31'))
SELECT * FROM t1 LEFT JOIN t2 ON (t1.a=t2.a) WHERE t1.a=30
AND t1.ts BETWEEN t2.dt1 AND t2.dt2
AND t1.ts BETWEEN "2006-01-01" AND "2006-12-31";
a	ts	a	dt1	dt2
30	2006-01-03 23:00:00	30	2006-01-01 00:00:00	2999-12-31 00:00:00
Warnings:
Warning	1292	Incorrect datetime value: '2999-12-31 00:00:00' for column 'ts' at row 1
DROP TABLE t1,t2;
create table t1 (a bigint unsigned);
insert into t1 values
(if(1, 9223372036854775808, 1)),
(case when 1 then 9223372036854775808 else 1 end),
(coalesce(9223372036854775808, 1));
select * from t1;
a
9223372036854775808
9223372036854775808
9223372036854775808
drop table t1;
create table t1 charset utf8mb4 select
if(1, 9223372036854775808, 1) i,
case when 1 then 9223372036854775808 else 1 end c,
coalesce(9223372036854775808, 1) co;
show create table t1;
Table	Create Table
t1	CREATE TABLE `t1` (
  `i` decimal(19,0) NOT NULL DEFAULT '0',
  `c` decimal(19,0) NOT NULL DEFAULT '0',
  `co` decimal(19,0) NOT NULL DEFAULT '0'
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
drop table t1;
select 
if(1, cast(1111111111111111111 as unsigned), 1) i,
case when 1 then cast(1111111111111111111 as unsigned) else 1 end c,
coalesce(cast(1111111111111111111 as unsigned), 1) co;
i	c	co
1111111111111111111	1111111111111111111	1111111111111111111
CREATE TABLE t1 (name varchar(255)) charset latin1;
CREATE TABLE t2 (name varchar(255), n int, KEY (name(3))) charset latin1;
INSERT INTO t1 VALUES ('ccc'), ('bb'), ('cc '), ('aa  '), ('aa');
INSERT INTO t2 VALUES ('bb',1), ('aa',2), ('cc   ',3);
INSERT INTO t2 VALUES (concat('cc ', 0x06), 4);
INSERT INTO t2 VALUES ('cc',5), ('bb ',6), ('cc ',7);
SELECT * FROM t2;
name	n
bb	1
aa	2
cc   	3
cc 	4
cc	5
bb 	6
cc 	7
SELECT * FROM t2 ORDER BY name;
name	n
aa	2
bb	1
bb 	6
cc 	4
cc   	3
cc	5
cc 	7
SELECT name, LENGTH(name), n FROM t2 ORDER BY name;
name	LENGTH(name)	n
aa	2	2
bb	2	1
bb 	3	6
cc 	4	4
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT name, LENGTH(name), n FROM t2 WHERE name='cc ';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	name	name	6	const	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` = 'cc ')
SELECT name, LENGTH(name), n FROM t2 WHERE name='cc ';
name	LENGTH(name)	n
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	name	name	6	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` like 'cc%')
SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%';
name	LENGTH(name)	n
cc   	5	3
cc 	4	4
cc	2	5
cc 	3	7
EXPLAIN SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%' ORDER BY name;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	name	name	6	NULL	3	100.00	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` like 'cc%') order by `test`.`t2`.`name`
SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%' ORDER BY name;
name	LENGTH(name)	n
cc 	4	4
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.name=t2.name;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	t2	NULL	ref	name	name	6	test.t1.name	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`name` AS `name`,`test`.`t2`.`name` AS `name`,`test`.`t2`.`n` AS `n` from `test`.`t1` left join `test`.`t2` on((`test`.`t2`.`name` = `test`.`t1`.`name`)) where true
SELECT * FROM t1 LEFT JOIN t2 ON t1.name=t2.name;
name	name	n
aa	aa	2
aa  	aa	2
bb	bb	1
bb	bb 	6
cc 	cc	5
cc 	cc 	7
cc 	cc   	3
ccc	NULL	NULL
DROP TABLE t1,t2;
CREATE TABLE t1 (name text) charset latin1;
CREATE TABLE t2 (name text, n int, KEY (name(3))) charset latin1;
INSERT INTO t1 VALUES ('ccc'), ('bb'), ('cc '), ('aa  '), ('aa');
INSERT INTO t2 VALUES ('bb',1), ('aa',2), ('cc   ',3);
INSERT INTO t2 VALUES (concat('cc ', 0x06), 4);
INSERT INTO t2 VALUES ('cc',5), ('bb ',6), ('cc ',7);
SELECT * FROM t2;
name	n
bb	1
aa	2
cc   	3
cc 	4
cc	5
bb 	6
cc 	7
SELECT * FROM t2 ORDER BY name;
name	n
aa	2
bb	1
bb 	6
cc 	4
cc   	3
cc	5
cc 	7
SELECT name, LENGTH(name), n FROM t2 ORDER BY name;
name	LENGTH(name)	n
aa	2	2
bb	2	1
bb 	3	6
cc 	4	4
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT name, LENGTH(name), n FROM t2 WHERE name='cc ';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	ref	name	name	6	const	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` = 'cc ')
SELECT name, LENGTH(name), n FROM t2 WHERE name='cc ';
name	LENGTH(name)	n
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	name	name	6	NULL	3	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` like 'cc%')
SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%';
name	LENGTH(name)	n
cc   	5	3
cc 	4	4
cc	2	5
cc 	3	7
EXPLAIN SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%' ORDER BY name;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	range	name	name	6	NULL	3	100.00	Using where; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t2`.`name` AS `name`,length(`test`.`t2`.`name`) AS `LENGTH(name)`,`test`.`t2`.`n` AS `n` from `test`.`t2` where (`test`.`t2`.`name` like 'cc%') order by `test`.`t2`.`name`
SELECT name , LENGTH(name), n FROM t2 WHERE name LIKE 'cc%' ORDER BY name;
name	LENGTH(name)	n
cc 	4	4
cc   	5	3
cc	2	5
cc 	3	7
EXPLAIN SELECT * FROM t1 LEFT JOIN t2 ON t1.name=t2.name;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	t2	NULL	ref	name	name	6	test.t1.name	2	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`name` AS `name`,`test`.`t2`.`name` AS `name`,`test`.`t2`.`n` AS `n` from `test`.`t1` left join `test`.`t2` on((`test`.`t2`.`name` = `test`.`t1`.`name`)) where true
SELECT * FROM t1 LEFT JOIN t2 ON t1.name=t2.name;
name	name	n
aa	aa	2
aa  	aa	2
bb	bb	1
bb	bb 	6
cc 	cc	5
cc 	cc 	7
cc 	cc   	3
ccc	NULL	NULL
DROP TABLE t1,t2;
CREATE TABLE t1 (
access_id int NOT NULL default '0',
name varchar(20) default NULL,
`rank` int NOT NULL default '0',
KEY idx (access_id)
);
CREATE TABLE t2 (
faq_group_id int NOT NULL default '0',
faq_id int NOT NULL default '0',
access_id int default NULL,
UNIQUE KEY idx1 (faq_id),
KEY idx2 (faq_group_id,faq_id)
);
INSERT INTO t1 VALUES 
(1,'Everyone',2),(2,'Help',3),(3,'Technical Support',1),(4,'Chat User',4);
INSERT INTO t2 VALUES
(261,265,1),(490,494,1);
SELECT t2.faq_id 
FROM t1 INNER JOIN t2 IGNORE INDEX (idx1)
ON (t1.access_id = t2.access_id)
LEFT JOIN t2 t
ON (t.faq_group_id = t2.faq_group_id AND
find_in_set(t.access_id, '1,4') < find_in_set(t2.access_id, '1,4'))
WHERE
t2.access_id IN (1,4) AND t.access_id IS NULL AND t2.faq_id in (265);
faq_id
265
SELECT t2.faq_id 
FROM t1 INNER JOIN t2
ON (t1.access_id = t2.access_id)
LEFT JOIN t2 t
ON (t.faq_group_id = t2.faq_group_id AND
find_in_set(t.access_id, '1,4') < find_in_set(t2.access_id, '1,4'))
WHERE
t2.access_id IN (1,4) AND t.access_id IS NULL AND t2.faq_id in (265);
faq_id
265
DROP TABLE t1,t2;
CREATE TABLE t1 (a INT, b INT, KEY inx (b,a));
INSERT INTO t1 VALUES (1,1), (1,2), (1,3), (1,4), (1,5), (1, 6), (1,7);
EXPLAIN SELECT COUNT(*) FROM t1 f1 INNER JOIN t1 f2
ON ( f1.b=f2.b AND f1.a<f2.a ) 
WHERE 1 AND f1.b NOT IN (100,2232,3343,51111);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	f1	NULL	index	inx	inx	10	NULL	7	100.00	Using where; Using index
1	SIMPLE	f2	NULL	ref	inx	inx	5	test.f1.b	2	33.33	Using where; Using index
Warnings:
Note	1003	/* select#1 */ select count(0) AS `COUNT(*)` from `test`.`t1` `f1` join `test`.`t1` `f2` where ((`test`.`f2`.`b` = `test`.`f1`.`b`) and (`test`.`f1`.`b` not in (100,2232,3343,51111)) and (`test`.`f1`.`a` < `test`.`f2`.`a`))
DROP TABLE t1;
CREATE TABLE t1 (c1 INT, c2 INT);
INSERT INTO t1 VALUES (1,11), (2,22), (2,22);
EXPLAIN SELECT c1 FROM t1 WHERE (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT COUNT(c2)))))))))))))))))))))))))))))) > 0;
EXPLAIN SELECT c1 FROM t1 WHERE (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT (SELECT COUNT(c2))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) > 0;
ERROR HY000: Too high level of nesting for select
DROP TABLE t1;
CREATE TABLE t1 (
c1 int(11) NOT NULL AUTO_INCREMENT,
c2 varchar(1000) DEFAULT NULL,
c3 bigint(20) DEFAULT NULL,
c4 bigint(20) DEFAULT NULL,
PRIMARY KEY (c1)
) charset utf8mb4;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
EXPLAIN
SELECT  join_2.c1  
FROM 
t1 AS join_0, 
t1 AS join_1, 
t1 AS join_2, 
t1 AS join_3, 
t1 AS join_4, 
t1 AS join_5, 
t1 AS join_6, 
t1 AS join_7
WHERE 
join_0.c1=join_1.c1  AND 
join_1.c1=join_2.c1  AND 
join_2.c1=join_3.c1  AND 
join_3.c1=join_4.c1  AND 
join_4.c1=join_5.c1  AND 
join_5.c1=join_6.c1  AND 
join_6.c1=join_7.c1 
OR 
join_0.c2 < '?'  AND 
join_1.c2 < '?'  AND
join_2.c2 > '?'  AND
join_2.c2 < '!'  AND
join_3.c2 > '?'  AND 
join_4.c2 = '?'  AND 
join_5.c2 <> '?' AND
join_6.c2 <> '?' AND 
join_7.c2 >= '?' AND
join_0.c1=join_1.c1  AND 
join_1.c1=join_2.c1  AND 
join_2.c1=join_3.c1  AND
join_3.c1=join_4.c1  AND 
join_4.c1=join_5.c1  AND 
join_5.c1=join_6.c1  AND 
join_6.c1=join_7.c1
GROUP BY 
join_3.c1,
join_2.c1,
join_7.c1,
join_1.c1,
join_0.c1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select NULL AS `c1` from `test`.`t1` `join_0` join `test`.`t1` `join_1` join `test`.`t1` `join_2` join `test`.`t1` `join_3` join `test`.`t1` `join_4` join `test`.`t1` `join_5` join `test`.`t1` `join_6` join `test`.`t1` `join_7` where (multiple equal(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) or ((NULL < '?') and (NULL < '?') and (NULL > '?') and (NULL < '!') and (NULL > '?') and (NULL <> '?') and (NULL <> '?') and (NULL >= '?') and multiple equal('?', NULL) and multiple equal(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL))) group by NULL,NULL,NULL,NULL,NULL
SHOW WARNINGS;
Level	Code	Message
Note	1003	/* select#1 */ select NULL AS `c1` from `test`.`t1` `join_0` join `test`.`t1` `join_1` join `test`.`t1` `join_2` join `test`.`t1` `join_3` join `test`.`t1` `join_4` join `test`.`t1` `join_5` join `test`.`t1` `join_6` join `test`.`t1` `join_7` where (multiple equal(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) or ((NULL < '?') and (NULL < '?') and (NULL > '?') and (NULL < '!') and (NULL > '?') and (NULL <> '?') and (NULL <> '?') and (NULL >= '?') and multiple equal('?', NULL) and multiple equal(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL))) group by NULL,NULL,NULL,NULL,NULL
DROP TABLE t1;
SELECT 1 AS ` `;

1
Warnings:
Warning	1474	Name ' ' has become ''
SELECT 1 AS `  `;

1
Warnings:
Warning	1474	Name '  ' has become ''
SELECT 1 AS ` x`;
x
1
Warnings:
Warning	1466	Leading spaces are removed from name ' x'
CREATE VIEW v1 AS SELECT 1 AS ``;
ERROR 42000: Incorrect column name ''
CREATE VIEW v1 AS SELECT 1 AS ` `;
ERROR 42000: Incorrect column name ' '
CREATE VIEW v1 AS SELECT 1 AS `  `;
ERROR 42000: Incorrect column name '  '
CREATE VIEW v1 AS SELECT (SELECT 1 AS `  `);
ERROR 42000: Incorrect column name '  '
CREATE VIEW v1 AS SELECT 1 AS ` x`;
Warnings:
Warning	1466	Leading spaces are removed from name ' x'
SELECT `x` FROM v1;
x
1
ALTER VIEW v1 AS SELECT 1 AS ` `;
ERROR 42000: Incorrect column name ' '
DROP VIEW v1;
select str_to_date('2007-10-09','%Y-%m-%d') between '2007/10/01 00:00:00 GMT'
                                                and '2007/10/20 00:00:00 GMT';
str_to_date('2007-10-09','%Y-%m-%d') between '2007/10/01 00:00:00 GMT'
                                                and '2007/10/20 00:00:00 GMT'
1
Warnings:
Warning	1292	Truncated incorrect date value: '2007/10/01 00:00:00 GMT'
Warning	1292	Truncated incorrect date value: '2007/10/20 00:00:00 GMT'
select str_to_date('2007-10-09','%Y-%m-%d') > '2007/10/01 00:00:00 GMT-6';
str_to_date('2007-10-09','%Y-%m-%d') > '2007/10/01 00:00:00 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect date value: '2007/10/01 00:00:00 GMT-6'
select str_to_date('2007-10-09','%Y-%m-%d') <= '2007/10/2000:00:00 GMT-6';
ERROR HY000: Incorrect DATE value: '2007/10/2000:00:00 GMT-6'
select str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-1 00:00:00 GMT-6';
str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-1 00:00:00 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect date value: '2007-10-1 00:00:00 GMT-6'
select str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-01 x00:00:00 GMT-6';
str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-01 x00:00:00 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect date value: '2007-10-01 x00:00:00 GMT-6'
select str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 00:00:00 GMT-6';
str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 00:00:00 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 00:00:00 GMT-6'
select str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 00:x00:00 GMT-6';
str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 00:x00:00 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 00:x00:00 GMT-6'
select str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 x12:34:56 GMT-6';
str_to_date('2007-10-01','%Y-%m-%d %H:%i:%s') = '2007-10-01 x12:34:56 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 x12:34:56 GMT-6'
select str_to_date('2007-10-01 12:34:00','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34x:56 GMT-6';
str_to_date('2007-10-01 12:34:00','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34x:56 GMT-6'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 12:34x:56 GMT-6'
select str_to_date('2007-10-01 12:34:56','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34x:56 GMT-6';
str_to_date('2007-10-01 12:34:56','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34x:56 GMT-6'
0
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 12:34x:56 GMT-6'
select str_to_date('2007-10-01 12:34:56','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34:56';
str_to_date('2007-10-01 12:34:56','%Y-%m-%d %H:%i:%s') = '2007-10-01 12:34:56'
1
select str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-01 12:00:00';
str_to_date('2007-10-01','%Y-%m-%d') = '2007-10-01 12:00:00'
0
select str_to_date('2007-10-01 12','%Y-%m-%d %H') = '2007-10-01 12:00:00';
str_to_date('2007-10-01 12','%Y-%m-%d %H') = '2007-10-01 12:00:00'
1
select str_to_date('2007-10-01 12:34','%Y-%m-%d %H') = '2007-10-01 12:00:00';
str_to_date('2007-10-01 12:34','%Y-%m-%d %H') = '2007-10-01 12:00:00'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: '2007-10-01 12:34'
select str_to_date('2007-02-30 12:34','%Y-%m-%d %H:%i') = '2007-02-30 12:34:00';
ERROR HY000: Incorrect DATETIME value: '2007-02-30 12:34:00'
select str_to_date('2007-10-00 12:34','%Y-%m-%d %H:%i') = '2007-10-00 12:34';
ERROR HY000: Incorrect DATETIME value: '2007-10-00 12:34'
select str_to_date('2007-10-00','%Y-%m-%d') between '2007/09/01 00:00:00'
                                                and '2007/10/20 00:00:00';
str_to_date('2007-10-00','%Y-%m-%d') between '2007/09/01 00:00:00'
                                                and '2007/10/20 00:00:00'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-10-00' for function str_to_date
set SQL_MODE=TRADITIONAL;
select str_to_date('2007-10-00 12:34','%Y-%m-%d %H:%i') = '2007-10-00 12:34';
ERROR HY000: Incorrect DATETIME value: '2007-10-00 12:34'
select str_to_date('2007-10-01 12:34','%Y-%m-%d %H:%i') = '2007-10-00 12:34';
ERROR HY000: Incorrect DATETIME value: '2007-10-00 12:34'
select str_to_date('2007-10-00 12:34','%Y-%m-%d %H:%i') = '2007-10-01 12:34';
str_to_date('2007-10-00 12:34','%Y-%m-%d %H:%i') = '2007-10-01 12:34'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-10-00 12:34' for function str_to_date
select str_to_date('2007-10-00','%Y-%m-%d') between '2007/09/01'
                                                and '2007/10/20';
str_to_date('2007-10-00','%Y-%m-%d') between '2007/09/01'
                                                and '2007/10/20'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-10-00' for function str_to_date
set SQL_MODE=DEFAULT;
select str_to_date('2007-10-00','%Y-%m-%d') between '' and '2007/10/20';
str_to_date('2007-10-00','%Y-%m-%d') between '' and '2007/10/20'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-10-00' for function str_to_date
select str_to_date('','%Y-%m-%d') between '2007/10/01' and '2007/10/20';
str_to_date('','%Y-%m-%d') between '2007/10/01' and '2007/10/20'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '' for function str_to_date
select str_to_date('','%Y-%m-%d %H:%i') = '2007-10-01 12:34';
str_to_date('','%Y-%m-%d %H:%i') = '2007-10-01 12:34'
NULL
Warnings:
Warning	1411	Incorrect datetime value: '' for function str_to_date
select str_to_date(NULL,'%Y-%m-%d %H:%i') = '2007-10-01 12:34';
str_to_date(NULL,'%Y-%m-%d %H:%i') = '2007-10-01 12:34'
NULL
select str_to_date('2007-10-00 12:34','%Y-%m-%d %H:%i') = '';
ERROR HY000: Incorrect DATETIME value: ''
select str_to_date('1','%Y-%m-%d') = '1';
ERROR HY000: Incorrect DATE value: '1'
select str_to_date('1','%Y-%m-%d') = '1';
ERROR HY000: Incorrect DATE value: '1'
select str_to_date('','%Y-%m-%d') = '';
ERROR HY000: Incorrect DATE value: ''
select str_to_date('1000-01-01','%Y-%m-%d') between '0000-00-00' and NULL;
str_to_date('1000-01-01','%Y-%m-%d') between '0000-00-00' and NULL
0
Warnings:
Warning	1292	Truncated incorrect date value: '0000-00-00'
select str_to_date('1000-01-01','%Y-%m-%d') between NULL and '2000-00-00';
str_to_date('1000-01-01','%Y-%m-%d') between NULL and '2000-00-00'
NULL
Warnings:
Warning	1292	Truncated incorrect date value: '2000-00-00'
select str_to_date('1000-01-01','%Y-%m-%d') between NULL and NULL;
str_to_date('1000-01-01','%Y-%m-%d') between NULL and NULL
0
CREATE TABLE t1 (c11 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE t2 (c21 INT UNSIGNED NOT NULL, 
c22 INT DEFAULT NULL, 
KEY(c21, c22));
CREATE TABLE t3 (c31 INT UNSIGNED NOT NULL DEFAULT 0, 
c32 INT DEFAULT NULL, 
c33 INT NOT NULL, 
c34 INT UNSIGNED DEFAULT 0,
KEY (c33, c34, c32));
INSERT INTO t1 values (),(),(),(),();
INSERT INTO t2 SELECT a.c11, b.c11 FROM t1 a, t1 b;
INSERT INTO t3 VALUES (1, 1, 1, 0), 
(2, 2, 0, 0), 
(3, 3, 1, 0), 
(4, 4, 0, 0), 
(5, 5, 1, 0);
SELECT c32 FROM t1, t2, t3 WHERE t1.c11 IN (1, 3, 5) AND 
t3.c31 = t1.c11 AND t2.c21 = t1.c11 AND 
t3.c33 = 1 AND t2.c22 in (1, 3) 
ORDER BY c32;
c32
1
1
3
3
5
5
SELECT c32 FROM t1, t2, t3 WHERE t1.c11 IN (1, 3, 5) AND 
t3.c31 = t1.c11 AND t2.c21 = t1.c11 AND 
t3.c33 = 1 AND t2.c22 in (1, 3) 
ORDER BY c32 DESC;
c32
5
5
3
3
1
1
DROP TABLE t1, t2, t3;

#
# Bug#30736: Row Size Too Large Error Creating a Table and
# Inserting Data.
#
DROP TABLE IF EXISTS t1;
DROP TABLE IF EXISTS t2;

CREATE TABLE t1(
c1 DECIMAL(10, 2),
c2 FLOAT);

INSERT INTO t1 VALUES (0, 1), (2, 3), (4, 5);

CREATE TABLE t2(
c3 DECIMAL(10, 2))
SELECT
c1 * c2 AS c3
FROM t1;

SELECT * FROM t1;
c1	c2
0.00	1
2.00	3
4.00	5

SELECT * FROM t2;
c3
0.00
6.00
20.00

DROP TABLE t1;
DROP TABLE t2;

CREATE TABLE t1 (c1 BIGINT NOT NULL);
INSERT INTO t1 (c1) VALUES (1);
SELECT * FROM t1 WHERE c1 > NULL + 1;
c1
DROP TABLE t1;

CREATE TABLE t1 (a VARCHAR(10) NOT NULL PRIMARY KEY);
INSERT INTO t1 (a) VALUES ('foo0'), ('bar0'), ('baz0');
SELECT * FROM t1 WHERE a IN (CONCAT('foo', 0), 'bar');
a
foo0
DROP TABLE t1;
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, c INT, KEY(a));
INSERT INTO t1 VALUES (1, 1), (2, 2);
INSERT INTO t2 VALUES (1, 1), (1, 2), (1, 3), (1, 4), (1, 5),
(2, 1), (2, 2), (2, 3), (2, 4), (2, 5),
(3, 1), (3, 2), (3, 3), (3, 4), (3, 5),
(4, 1), (4, 2), (4, 3), (4, 4), (4, 5);
FLUSH STATUS;
SELECT DISTINCT b FROM t1 LEFT JOIN t2 USING(a) WHERE c <= 3;
b
1
2
SHOW STATUS LIKE 'Handler_read%';
Variable_name	Value
Handler_read_first	0
Handler_read_key	2
Handler_read_last	0
Handler_read_next	10
Handler_read_prev	0
Handler_read_rnd	10
Handler_read_rnd_next	6
DROP TABLE t1, t2;
CREATE TABLE t1 (f1 bigint(20) NOT NULL default '0',
f2 int(11) NOT NULL default '0',
f3 bigint(20) NOT NULL default '0',
f4 varchar(255) NOT NULL default '',
PRIMARY KEY (f1),
KEY key1 (f4),
KEY key2 (f2)) charset latin1;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t2 (f1 int(11) NOT NULL default '0',
f2 enum('A1','A2','A3') NOT NULL default 'A1',
f3 int(11) NOT NULL default '0',
PRIMARY KEY (f1),
KEY key1 (f3)) charset latin1;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
CREATE TABLE t3 (f1 bigint(20) NOT NULL default '0',
f2 datetime NOT NULL default '1980-01-01 00:00:00',
PRIMARY KEY (f1)) charset latin1;
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
insert into t1 values (1, 1, 1, 'abc');
insert into t1 values (2, 1, 2, 'def');
insert into t1 values (3, 1, 2, 'def');
insert into t2 values (1, 'A1', 1);
insert into t3 values (1, '1980-01-01');
SELECT a.f3, cr.f4, count(*) count
FROM t2 a
STRAIGHT_JOIN t1 cr ON cr.f2 = a.f1
LEFT JOIN
(t1 cr2
JOIN t3 ae2 ON cr2.f3 = ae2.f1
) ON a.f1 = cr2.f2 AND ae2.f2 < now() - INTERVAL 7 DAY AND
cr.f4 = cr2.f4
GROUP BY a.f3, cr.f4;
f3	f4	count
1	abc	1
1	def	2
drop table t1, t2, t3;
CREATE TABLE t1 (a INT KEY, b INT);
INSERT INTO t1 VALUES (1,1), (2,2), (3,3), (4,4);
EXPLAIN SELECT a, b FROM t1 WHERE a > 1 AND a = b LIMIT 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	3	25.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((`test`.`t1`.`b` = `test`.`t1`.`a`) and (`test`.`t1`.`a` > 1)) limit 2
EXPLAIN SELECT a, b FROM t1 WHERE a > 1 AND b = a LIMIT 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	range	PRIMARY	PRIMARY	4	NULL	3	25.00	Using index condition; Using where; Using MRR
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where ((`test`.`t1`.`a` = `test`.`t1`.`b`) and (`test`.`t1`.`a` > 1)) limit 2
DROP TABLE t1;
#
# Bug#47019: Assertion failed: 0, file .\rt_mbr.c, line 138 when 
# forcing a spatial index
#
CREATE TABLE t1(a LINESTRING NOT NULL SRID 0, SPATIAL KEY(a));
INSERT INTO t1 VALUES
(ST_GEOMFROMTEXT('LINESTRING(-1 -1, 1 -1, -1 -1, -1 1, 1 1)')),
(ST_GEOMFROMTEXT('LINESTRING(-1 -1, 1 -1, -1 -1, -1 1, 1 1)'));
EXPLAIN SELECT 1 FROM t1 NATURAL LEFT JOIN t1 AS t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	a	NULL	NULL	NULL	2	100.00	Range checked for each record (index map: 0x1)
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` left join `test`.`t1` `t2` on((`test`.`t2`.`a` = `test`.`t1`.`a`)) where true
SELECT 1 FROM t1 NATURAL LEFT JOIN t1 AS t2;
1
1
1
1
1
EXPLAIN SELECT 1 FROM t1 NATURAL LEFT JOIN t1 AS t2 FORCE INDEX(a);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	t2	NULL	ALL	a	NULL	NULL	NULL	2	100.00	Range checked for each record (index map: 0x1)
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` left join `test`.`t1` `t2` FORCE INDEX (`a`) on((`test`.`t2`.`a` = `test`.`t1`.`a`)) where true
SELECT 1 FROM t1 NATURAL LEFT JOIN t1 AS t2 FORCE INDEX(a);
1
1
1
1
1
DROP TABLE t1;
#
# Bug #48291 : crash with row() operator,select into @var, and 
#   subquery returning multiple rows
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES (2),(3);
# Should not crash
SELECT 1 FROM t1 WHERE a <> 1 AND NOT
ROW(1,a) <=> ROW(1,(SELECT 1 FROM t1))
INTO @var0;
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t1;
#
# Bug #48458: simple query tries to allocate enormous amount of
#   memory
#
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1(a INT NOT NULL, b YEAR);
INSERT INTO t1 VALUES ();
Warnings:
Warning	1364	Field 'a' doesn't have a default value
CREATE TABLE t2(c INT);
# Should not err out because of out-of-memory
SELECT 1 FROM t2 JOIN t1 ON 1=1
WHERE a != '1' AND NOT a >= b OR NOT ROW(b,a )<> ROW(a,a);
1
DROP TABLE t1,t2;
SET sql_mode = default;
#
# Bug #49199: Optimizer handles incorrectly: 
# field='const1' AND field='const2' in some cases

CREATE TABLE t1(a DATETIME NOT NULL);
INSERT INTO t1 VALUES('2001-01-01');
SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
a
2001-01-01 00:00:00
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a` from dual where true
DROP TABLE t1;
CREATE TABLE t1(a DATE NOT NULL);
INSERT INTO t1 VALUES('2001-01-01');
SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
a
2001-01-01
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01' AS `a` from dual where true
DROP TABLE t1;
CREATE TABLE t1(a TIMESTAMP NOT NULL NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES('2001-01-01');
SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
a
2001-01-01 00:00:00
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01' AND a='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a` from dual where true
DROP TABLE t1;
CREATE TABLE t1(a DATETIME NOT NULL, b DATE NOT NULL);
INSERT INTO t1 VALUES('2001-01-01', '2001-01-01');
SELECT * FROM t1 WHERE a='2001-01-01' AND a=b AND b='2001-01-01 00:00:00';
a	b
2001-01-01 00:00:00	2001-01-01
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01' AND a=b AND b='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a`,'2001-01-01' AS `b` from dual where true
DROP TABLE t1;
CREATE TABLE t1(a DATETIME NOT NULL, b VARCHAR(20) NOT NULL) charset utf8mb4;
INSERT INTO t1 VALUES('2001-01-01', '2001-01-01');
SELECT * FROM t1 WHERE a='2001-01-01' AND a=b AND b='2001-01-01 00:00:00';
a	b
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01' AND a=b AND b='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE noticed after reading const tables
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a`,'2001-01-01' AS `b` from dual where false
SELECT * FROM t1 WHERE a='2001-01-01 00:00:00' AND a=b AND b='2001-01-01';
a	b
2001-01-01 00:00:00	2001-01-01
EXPLAIN SELECT * FROM t1 WHERE a='2001-01-01 00:00:00' AND a=b AND b='2001-01-01';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a`,'2001-01-01' AS `b` from dual where true
DROP TABLE t1;
CREATE TABLE t1(a DATETIME NOT NULL, b DATE NOT NULL);
INSERT INTO t1 VALUES('2001-01-01', '2001-01-01');
SELECT x.a, y.a, z.a FROM t1 x 
JOIN t1 y ON x.a=y.a 
JOIN t1 z ON y.a=z.a 
WHERE x.a='2001-01-01' AND z.a='2001-01-01 00:00:00';
a	a	a
2001-01-01 00:00:00	2001-01-01 00:00:00	2001-01-01 00:00:00
EXPLAIN SELECT x.a, y.a, z.a FROM t1 x
JOIN t1 y ON x.a=y.a 
JOIN t1 z ON y.a=z.a 
WHERE x.a='2001-01-01' AND z.a='2001-01-01 00:00:00';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	x	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	y	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	z	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '2001-01-01 00:00:00' AS `a`,'2001-01-01 00:00:00' AS `a`,'2001-01-01 00:00:00' AS `a` from dual where true
DROP TABLE t1;
#
# Bug #49897: crash in ptr_compare when char(0) NOT NULL 
# column is used for ORDER BY
#
SET @old_sort_buffer_size= @@session.sort_buffer_size;
SET @@sort_buffer_size= 40000;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t1(a CHAR(0) NOT NULL);
INSERT INTO t1 VALUES (0), (0), (0);
INSERT INTO t1 SELECT t11.a FROM t1 t11, t1 t12;
INSERT INTO t1 SELECT t11.a FROM t1 t11, t1 t12;
INSERT INTO t1 SELECT t11.a FROM t1 t11, t1 t12;
EXPLAIN SELECT a FROM t1 ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	24492	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` order by `test`.`t1`.`a`
SELECT a FROM t1 ORDER BY a;
DROP TABLE t1;
CREATE TABLE t1(a CHAR(0) NOT NULL, b CHAR(0) NOT NULL, c int);
INSERT INTO t1 VALUES (0, 0, 0), (0, 0, 2), (0, 0, 1);
# Since ANALYZE TABLE only reads a subset of the data, the statistics for
# table t1 depends on the row order. And since the INSERT INTO ... SELECT
# may be executed using different execution plans, we've added ORDER BY
# to ensure that we rows has the same order every time. If not, the
# estimated number of rows in EXPLAIN may change on different platforms.
# Note that the tables may be MyISAM, since many of the test files that
# includes this file forces MyISAM as the default storage engine.
INSERT INTO t1 SELECT t11.a, t11.b, t11.c FROM t1 t11, t1 t12
ORDER BY t11.a, t11.b, t11.c;
INSERT INTO t1 SELECT t11.a, t11.b, t11.c FROM t1 t11, t1 t12
ORDER BY t11.a, t11.b, t11.c;
INSERT INTO t1 SELECT t11.a, t11.b, t11.c FROM t1 t11, t1 t12
ORDER BY t11.a, t11.b, t11.c;
EXPLAIN SELECT a FROM t1 ORDER BY a LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	24492	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` order by `test`.`t1`.`a` limit 5
SELECT a FROM t1 ORDER BY a LIMIT 5;
a





EXPLAIN SELECT * FROM t1 ORDER BY a, b LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	24492	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`c` AS `c` from `test`.`t1` order by `test`.`t1`.`a`,`test`.`t1`.`b` limit 5
SELECT * FROM t1 ORDER BY a, b LIMIT 5;
a	b	c
		0
		2
		1
		0
		0
EXPLAIN SELECT * FROM t1 ORDER BY a, b, c LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	24492	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`c` AS `c` from `test`.`t1` order by `test`.`t1`.`a`,`test`.`t1`.`b`,`test`.`t1`.`c` limit 5
SELECT * FROM t1 ORDER BY a, b, c LIMIT 5;
a	b	c
		0
		0
		0
		0
		0
EXPLAIN SELECT * FROM t1 ORDER BY c, a LIMIT 5;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	24492	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b`,`test`.`t1`.`c` AS `c` from `test`.`t1` order by `test`.`t1`.`c`,`test`.`t1`.`a` limit 5
SELECT * FROM t1 ORDER BY c, a LIMIT 5;
a	b	c
		0
		0
		0
		0
		0
SET @@sort_buffer_size= @old_sort_buffer_size;
DROP TABLE t1;
SET sql_mode = default;
End of 5.0 tests
create table t1(a INT, KEY (a));
INSERT INTO t1 VALUES (1),(2),(3),(4),(5);
SELECT a FROM t1 ORDER BY a LIMIT 2;
a
1
2
SELECT a FROM t1 ORDER BY a LIMIT 2,4294967296;
a
3
4
5
SELECT a FROM t1 ORDER BY a LIMIT 2,4294967297;
a
3
4
5
DROP TABLE t1;
CREATE TABLE A (date_key date);
CREATE TABLE C (
pk int,
int_nokey int,
int_key int,
date_key date NOT NULL,
date_nokey date,
varchar_key varchar(1)
);
INSERT IGNORE INTO C VALUES 
(1,1,1,'0000-00-00',NULL,NULL),
(1,1,1,'0000-00-00',NULL,NULL);
Warnings:
Warning	1264	Out of range value for column 'date_key' at row 1
Warning	1264	Out of range value for column 'date_key' at row 2
SELECT 1 FROM C WHERE pk > ANY (SELECT 1 FROM C);
1
SELECT COUNT(DISTINCT 1) FROM C 
WHERE date_key = (SELECT 1 FROM A WHERE C.date_key IS NULL) GROUP BY pk;
COUNT(DISTINCT 1)
SELECT date_nokey FROM C 
WHERE int_key IN (SELECT 1 FROM A) 
HAVING date_nokey = '10:41:7' 
ORDER BY date_key;
ERROR HY000: Incorrect DATE value: '10:41:7'
DROP TABLE A,C;
CREATE TABLE t1 (a INT NOT NULL, b INT);
INSERT INTO t1 VALUES (1, 1);
EXPLAIN SELECT * FROM t1 WHERE (a=a AND a=a) OR b > 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select '1' AS `a`,'1' AS `b` from dual where true
SELECT * FROM t1 WHERE (a=a AND a=a) OR b > 2;
a	b
1	1
DROP TABLE t1;
CREATE TABLE t1 (a INT NOT NULL, b INT NOT NULL, c INT NOT NULL);
EXPLAIN SELECT * FROM t1 WHERE (a=a AND b=b AND c=c) OR b > 20;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select NULL AS `a`,NULL AS `b`,NULL AS `c` from `test`.`t1` where true
EXPLAIN SELECT * FROM t1 WHERE (a=a AND a=a AND b=b) OR b > 20;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select NULL AS `a`,NULL AS `b`,NULL AS `c` from `test`.`t1` where true
EXPLAIN SELECT * FROM t1 WHERE (a=a AND b=b AND a=a) OR b > 20;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select NULL AS `a`,NULL AS `b`,NULL AS `c` from `test`.`t1` where true
DROP TABLE t1;
#
# Bug#45266: Uninitialized variable lead to an empty result.
#
drop table if exists A,AA,B,BB;
CREATE TABLE `A` (
`pk` int(11) NOT NULL AUTO_INCREMENT,
`date_key` date NOT NULL,
`date_nokey` date NOT NULL,
`datetime_key` datetime NOT NULL,
`int_nokey` int(11) NOT NULL,
`time_key` time NOT NULL,
`time_nokey` time NOT NULL,
PRIMARY KEY (`pk`),
KEY `date_key` (`date_key`),
KEY `time_key` (`time_key`),
KEY `datetime_key` (`datetime_key`)
);
CREATE TABLE `AA` (
`pk` int(11) NOT NULL AUTO_INCREMENT,
`int_nokey` int(11) NOT NULL,
`time_key` time NOT NULL,
KEY `time_key` (`time_key`),
PRIMARY KEY (`pk`)
);
CREATE TABLE `B` (
`date_nokey` date NOT NULL,
`date_key` date NOT NULL,
`time_key` time NOT NULL,
`datetime_nokey` datetime NOT NULL,
`varchar_key` varchar(1) NOT NULL,
KEY `date_key` (`date_key`),
KEY `time_key` (`time_key`),
KEY `varchar_key` (`varchar_key`)
);
INSERT IGNORE INTO `B` VALUES ('2003-07-28','2003-07-28','15:13:38','0000-00-00 00:00:00','f'),('0000-00-00','0000-00-00','00:05:48','2004-07-02 14:34:13','x');
CREATE TABLE `BB` (
`pk` int(11) NOT NULL AUTO_INCREMENT,
`int_nokey` int(11) NOT NULL,
`date_key` date NOT NULL,
`varchar_nokey` varchar(1) NOT NULL,
`date_nokey` date NOT NULL,
PRIMARY KEY (`pk`),
KEY `date_key` (`date_key`)
);
INSERT IGNORE INTO `BB` VALUES (10,8,'0000-00-00','i','0000-00-00'),(11,0,'2005-08-18','','2005-08-18');
SELECT table1 . `pk` AS field1 
FROM 
(BB AS table1 INNER JOIN 
(AA AS table2 STRAIGHT_JOIN A AS table3 
ON ( table3 . `date_key` = table2 . `pk` ))
ON ( table3 . `datetime_key` = table2 . `int_nokey` ))
WHERE  ( table3 . `date_key` <= 4 AND table2 . `pk` = table1 . `varchar_nokey`)
GROUP BY field1 ;
field1
SELECT table3 .`date_key` field1
FROM
B table1 LEFT JOIN B table3 JOIN
(BB table6 JOIN A table7 ON table6 .`varchar_nokey`)
ON table6 .`int_nokey` ON table6 .`date_key`
  WHERE  NOT ( table1 .`varchar_key`  AND table7 .`pk`) GROUP  BY field1;
field1
NULL
SELECT table4 . `time_nokey` AS field1 FROM 
(AA AS table1 CROSS JOIN 
(AA AS table2 STRAIGHT_JOIN 
(B AS table3 STRAIGHT_JOIN A AS table4 
ON ( table4 . `date_key` = table3 . `time_key` ))
ON ( table4 . `pk` = table3 . `date_nokey` ))
ON ( table4 . `time_key` = table3 . `datetime_nokey` ))
WHERE  ( table4 . `time_key` < table1 . `time_key` AND
table1 . `int_nokey` != 'f')
GROUP BY field1  ORDER BY field1 , field1;
field1
SELECT table1 .`time_key` field2  FROM B table1  LEFT JOIN  BB JOIN A table5 ON table5 .`date_nokey`  ON table5 .`int_nokey` GROUP  BY field2;
field2
00:05:48
15:13:38
drop table A,AA,B,BB;
#end of test for bug#45266
#
# Bug#33546: Slowdown on re-evaluation of constant expressions.
#
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
CREATE TABLE t2 (b INT);
INSERT INTO t2 VALUES (2);
SELECT * FROM t1 WHERE a = 1 + 1;
a
2
EXPLAIN SELECT * FROM t1 WHERE a = 1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` = <cache>((1 + 1)))
SELECT * FROM t1 HAVING a = 1 + 1;
a
2
EXPLAIN SELECT * FROM t1 HAVING a = 1 + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` having (`test`.`t1`.`a` = <cache>((1 + 1)))
SELECT * FROM t1, t2 WHERE a = b + (1 + 1);
a	b
4	2
EXPLAIN SELECT * FROM t1, t2 WHERE a = b + (1 + 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,'2' AS `b` from `test`.`t1` where (`test`.`t1`.`a` = <cache>(('2' + (1 + 1))))
SELECT * FROM t2 LEFT JOIN t1 ON a = b + 1;
b	a
2	3
EXPLAIN SELECT * FROM t2 LEFT JOIN t1 ON a = b + 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t2	NULL	system	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	100.00	Using where
Warnings:
Note	1003	/* select#1 */ select '2' AS `b`,`test`.`t1`.`a` AS `a` from <constant table> left join `test`.`t1` on((`test`.`t1`.`a` = <cache>(('2' + 1)))) where true
EXPLAIN SELECT * FROM t1 WHERE a > UNIX_TIMESTAMP('2009-03-10 00:00:00');
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	33.33	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` > <cache>(unix_timestamp('2009-03-10 00:00:00')))
CREATE FUNCTION f1() RETURNS INT DETERMINISTIC
BEGIN
SET @cnt := @cnt + 1;
RETURN 1;
END;|
SET @cnt := 0;
SELECT * FROM t1 WHERE a = f1();
a
1
SELECT @cnt;
@cnt
1
EXPLAIN SELECT * FROM t1 WHERE a = f1();
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	10	10.00	Using where
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a` from `test`.`t1` where (`test`.`t1`.`a` = <cache>(`f1`()))
DROP TABLE t1, t2;
DROP FUNCTION f1;
# End of bug#33546
# 
# BUG#48052: Valgrind warning - uninitialized value in init_read_record()
# 
# Disable Index condition pushdown
SELECT @old_optimizer_switch:=@@optimizer_switch;
@old_optimizer_switch:=@@optimizer_switch
#
Warnings:
#	1287	Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: 'SET variable=expression, ...', or 'SELECT expression(s) INTO variables(s)'.
CREATE TABLE t1 (
pk int(11) NOT NULL,
i int(11) DEFAULT NULL,
v varchar(1) DEFAULT NULL,
PRIMARY KEY (pk)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (2,7,'m');
INSERT INTO t1 VALUES (3,9,'m');
SELECT  v
FROM t1
WHERE NOT pk > 0  
HAVING v <= 't' 
ORDER BY pk;
v
# Restore old value for Index condition pushdown
SET SESSION optimizer_switch=@old_optimizer_switch;
DROP TABLE t1;
#
# Bug#49489 Uninitialized cache led to a wrong result.
#
CREATE TABLE t1(c1 DOUBLE(5,4));
Warnings:
Warning	1681	Specifying number of digits for floating point data types is deprecated and will be removed in a future release.
INSERT INTO t1 VALUES (9.1234);
SELECT * FROM t1 WHERE c1 < 9.12345;
c1
9.1234
DROP TABLE t1;
# End of test for bug#49489.
#
# Bug #49517: Inconsistent behavior while using 
# NULLable BIGINT and INT columns in comparison
#
CREATE TABLE t1(a BIGINT UNSIGNED NOT NULL, b BIGINT NULL, c INT NULL);
INSERT INTO t1 VALUES(105, NULL, NULL);
SELECT * FROM t1 WHERE b < 102;
a	b	c
SELECT * FROM t1 WHERE c < 102;
a	b	c
SELECT * FROM t1 WHERE 102 < b;
a	b	c
SELECT * FROM t1 WHERE 102 < c;
a	b	c
DROP TABLE t1;
#
# Bug #54459: Assertion failed: param.sort_length, 
# file .\filesort.cc, line 149 (part II)
#
CREATE TABLE t1(a ENUM('') NOT NULL) charset latin1;
INSERT INTO t1 VALUES (), (), ();
EXPLAIN SELECT 1 FROM t1 ORDER BY a COLLATE latin1_german2_ci;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t1	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select 1 AS `1` from `test`.`t1` order by (`test`.`t1`.`a` collate latin1_german2_ci)
SELECT 1 FROM t1 ORDER BY a COLLATE latin1_german2_ci;
1
1
1
1
DROP TABLE t1;
#
# Bug #58422: Incorrect result when OUTER JOIN'ing 
# with an empty table
#
CREATE TABLE t_empty(pk INT PRIMARY KEY, i INT) ENGINE = MYISAM;
CREATE TABLE t1(pk INT PRIMARY KEY, i INT) ENGINE = MYISAM;
INSERT INTO t1 VALUES (1,1), (2,2), (3,3);
CREATE TABLE t2(pk INT PRIMARY KEY, i INT) ENGINE = MYISAM;
INSERT INTO t2 VALUES (1,1), (2,2), (3,3);
EXPLAIN
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 INNER JOIN t_empty ON TRUE)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk`,`test`.`t1`.`i` AS `i`,`test`.`t2`.`pk` AS `pk`,`test`.`t2`.`i` AS `i`,NULL AS `pk`,NULL AS `i` from `test`.`t1` join `test`.`t2` join `test`.`t_empty` where ((`test`.`t2`.`pk` <> 2) and multiple equal(`test`.`t1`.`pk`, `test`.`t2`.`pk`))
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 INNER JOIN t_empty ON TRUE)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
pk	i	pk	i	pk	i
EXPLAIN
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 CROSS JOIN t_empty)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk`,`test`.`t1`.`i` AS `i`,`test`.`t2`.`pk` AS `pk`,`test`.`t2`.`i` AS `i`,NULL AS `pk`,NULL AS `i` from `test`.`t1` join `test`.`t2` join `test`.`t_empty` where ((`test`.`t2`.`pk` <> 2) and multiple equal(`test`.`t1`.`pk`, `test`.`t2`.`pk`))
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 CROSS JOIN t_empty)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
pk	i	pk	i	pk	i
EXPLAIN
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 INNER JOIN t_empty ON t_empty.i=t2.i)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`pk` AS `pk`,`test`.`t1`.`i` AS `i`,`test`.`t2`.`pk` AS `pk`,`test`.`t2`.`i` AS `i`,NULL AS `pk`,NULL AS `i` from `test`.`t1` join `test`.`t2` join `test`.`t_empty` where ((`test`.`t2`.`pk` <> 2) and multiple equal(`test`.`t1`.`pk`, `test`.`t2`.`pk`) and multiple equal(NULL, `test`.`t2`.`i`))
SELECT *
FROM 
t1
LEFT OUTER JOIN
(t2 INNER JOIN t_empty ON t_empty.i=t2.i)
ON t1.pk=t2.pk
WHERE t2.pk <> 2;
pk	i	pk	i	pk	i
DROP TABLE t1,t2,t_empty;
End of 5.1 tests
#
# Bug#45227: Lost HAVING clause led to a wrong result.
#
CREATE TABLE `cc` (
`int_nokey` int(11) NOT NULL,
`int_key` int(11) NOT NULL,
`varchar_key` varchar(1) NOT NULL,
`varchar_nokey` varchar(1) NOT NULL,
KEY `int_key` (`int_key`),
KEY `varchar_key` (`varchar_key`)
);
Warnings:
Warning	1681	Integer display width is deprecated and will be removed in a future release.
Warning	1681	Integer display width is deprecated and will be removed in a future release.
INSERT INTO `cc` VALUES
(0,8,'q','q'),(5,8,'m','m'),(7,3,'j','j'),(1,2,'z','z'),(8,2,'a','a'),(2,6,'',''),(1,8,'e'
,'e'),(8,9,'t','t'),(5,2,'q','q'),(4,6,'b','b'),(5,5,'w','w'),(3,2,'m','m'),(0,4,'x','x'),
(8,9,'',''),(0,6,'w','w'),(4,5,'x','x'),(0,0,'e','e'),(0,0,'e','e'),(2,8,'p','p'),(0,0,'x'
,'x');
EXPLAIN SELECT `varchar_nokey` g1  FROM cc  WHERE `int_nokey` AND `int_key`  <= 4
HAVING g1  ORDER  BY `varchar_key` LIMIT  6   ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	cc	NULL	range	int_key	int_key	4	NULL	10	90.00	Using index condition; Using where; Using MRR; Using filesort
Warnings:
Note	1003	/* select#1 */ select `test`.`cc`.`varchar_nokey` AS `g1` from `test`.`cc` where ((0 <> `test`.`cc`.`int_nokey`) and (`test`.`cc`.`int_key` <= 4)) having (0 <> `g1`) order by `test`.`cc`.`varchar_key` limit 6
SELECT `varchar_nokey` g1  FROM cc  WHERE `int_nokey` AND `int_key`  <= 4
HAVING g1  ORDER  BY `varchar_key` LIMIT  6   ;
g1
Warnings:
Warning	1292	Truncated incorrect DOUBLE value: 'j'
Warning	1292	Truncated incorrect DOUBLE value: 'z'
Warning	1292	Truncated incorrect DOUBLE value: 'a'
Warning	1292	Truncated incorrect DOUBLE value: 'q'
Warning	1292	Truncated incorrect DOUBLE value: 'm'
DROP TABLE cc;
# End of test#45227
#
# Bug#54515: Crash in opt_range.cc::get_best_group_min_max on 
#            SELECT from VIEW with GROUP BY
#
CREATE TABLE t1 (
col_int_key int DEFAULT NULL,
KEY int_key (col_int_key)
) ;
INSERT INTO t1 VALUES (1),(2);
CREATE VIEW view_t1 AS 
SELECT t1.col_int_key AS col_int_key
FROM t1;
SELECT col_int_key FROM view_t1 GROUP BY col_int_key;
col_int_key
1
2
DROP VIEW view_t1;
DROP TABLE t1;
# End of test BUG#54515
#
# Bug #57203 Assertion `field_length <= 255' failed.
#
SELECT coalesce((avg(distinct (ST_geomfromtext("point(25379 -22010)"))))) 
UNION ALL 
SELECT coalesce((avg(distinct (ST_geomfromtext("point(25379 -22010)")))))
AS foo
;
ERROR HY000: Incorrect arguments to avg
CREATE table t1(a text);
INSERT INTO t1 VALUES (''), ('');
SELECT avg(distinct(t1.a)) FROM t1, t1 t2
GROUP BY t2.a ORDER BY t1.a;
avg(distinct(t1.a))
0
DROP TABLE t1;
# End of test BUG#57203
#
# Bug#63020: Function "format"'s 'locale' argument is not considered
#	     when creating a "view'
#
CREATE TABLE t1 (f1 DECIMAL(10,2));
INSERT INTO t1 VALUES (11.67),(17865.3),(12345678.92);
CREATE VIEW view_t1 AS SELECT FORMAT(f1,1,'sk_SK') AS f1 FROM t1;
SHOW CREATE VIEW view_t1;
View	Create View	character_set_client	collation_connection
view_t1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `view_t1` AS select format(`t1`.`f1`,1,'sk_SK') AS `f1` from `t1`	utf8mb4	utf8mb4_0900_ai_ci
SELECT * FROM view_t1;
f1
11,7
17 865,3
12 345 678,9
DROP TABLE t1;
DROP VIEW view_t1;
# End of test  BUG#63020
#
# Bug #13571700 TINYBLOB NOT NULL, CRASH IN PROTOCOL::NET_STORE_DATA
#
CREATE TABLE t1 (a TINYBLOB NOT NULL);
SELECT a, COUNT(*) FROM t1 WHERE 0;
a	COUNT(*)
NULL	0
DROP TABLE t1;
# End of test BUG#13571700
#
# Bug #18766378: CRASH IN ITEM_SUM_BIT::RESET_FIELD
#
CREATE TABLE t1(b int);
CREATE TABLE t2(a int);
INSERT INTO t1 VALUES (),();
INSERT INTO t2 VALUES (),();
SELECT
( SELECT 1 FROM t1 GROUP BY a
HAVING avg(distinct 1) ORDER BY max(a)
)
FROM  t1, t2
GROUP BY a;
( SELECT 1 FROM t1 GROUP BY a
HAVING avg(distinct 1) ORDER BY max(a)
)
1
DROP TABLE t1,t2;
# End of test BUG#18766378
set optimizer_switch=default
set optimizer_switch=default;
