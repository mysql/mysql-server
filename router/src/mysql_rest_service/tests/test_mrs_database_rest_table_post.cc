/*
  Copyright (c) 2022, 2024, Oracle and/or its affiliates.

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2.0,
  as published by the Free Software Foundation.

  This program is also distributed with certain software (including
  but not limited to OpenSSL) that is licensed under separate terms,
  as designated in a particular file or component or in included license
  documentation.  The authors of MySQL hereby grant you an additional
  permission to link the program and your derivative works with the
  separately licensed software that they have included with MySQL.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <vector>

#include "helper/expect_throw_msg.h"
#include "mock/mock_session.h"
#include "mrs/database/query_rest_table_updater.h"
#include "test_mrs_database_rest_table.h"
#include "test_mrs_object_utils.h"

using namespace mrs::database;

using testing::_;
using testing::Return;
using testing::StrictMock;
using testing::Test;

// TODO - allow true/false for int (and convert to 1/0)
// TODO - allow omitting columns, which should insert as DEFAULT

inline std::string str_replace(std::string_view s, std::string_view from,
                               std::string_view to) {
  std::string str;
  int offs = from.length();
  str.reserve(s.length());

  if (from.empty()) {
    str.append(to);
    for (char c : s) {
      str.push_back(c);
      str.append(to);
    }
  } else {
    std::string::size_type start = 0, p = s.find(from);
    while (p != std::string::npos) {
      if (p > start) str.append(s, start, p - start);
      str.append(to);
      start = p + offs;
      p = s.find(from, start);
    }
    if (start < s.length()) str.append(s, start, s.length() - start);
  }
  return str;
}

inline std::string unescape(const std::string &s) {
  static std::vector<std::pair<std::string_view, std::string_view>> k_repl = {
      {"\\n", "\n"}, {"\\'", "'"},  {"\\\"", "\""}, {"\\Z", "Z"},
      {"\\r", "\r"}, {"\\b", "\b"}, {"\\\\", "\\"}};

  std::string out = s;
  for (const auto &r : k_repl) {
    out = str_replace(out, r.first, r.second);
  }
  return out;
}

#define EXPECT_UUID(value) EXPECT_EQ(16, unescape(value).size() - 2) << value

class DatabaseQueryPost : public DatabaseRestTableTest {
 public:
  PrimaryKeyColumnValues test_post(std::shared_ptr<entry::Object> root,
                                   const rapidjson::Document &doc,
                                   const ObjectRowOwnership &row_owner = {}) {
    mrs::database::TableUpdater rest(root, row_owner);

    return rest.handle_post(m_.get(), doc);
  }

  void test_post_ai(std::shared_ptr<entry::Object> root,
                    const rapidjson::Document &doc,
                    const ObjectRowOwnership &row_owner = {}) {
    auto id = next_auto_inc(root->get_base_table()->table);

    auto pk = test_post(root, doc, row_owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ(id, pk[root->get_base_table()->primary_key()[0]->name].str());
  }

  void test_post_uuid(std::shared_ptr<entry::Object> root,
                      const rapidjson::Document &doc,
                      const ObjectRowOwnership &row_owner = {}) {
    auto pk = test_post(root, doc, row_owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_UUID(pk[root->get_base_table()->primary_key()[0]->name].str());
  }
};

TEST_F(DatabaseQueryPost, no_root_fields) {
  // no fields in the root object
  auto root =
      ObjectBuilder("mrstestdb", "country")
          .column("country_id", FieldFlag::PRIMARY)
          .nest_list("cities",
                     ObjectBuilder("city", {{"country_id", "country_id"}})
                         .column("country_id")
                         .field("city")
                         .field("city_id", FieldFlag::PRIMARY))
          .root();

  {
    auto rest = std::make_unique<mrs::database::TableUpdater>(root);

    EXPECT_REST_ERROR(
        rest->handle_post(m_.get(), make_json(R"*({
    "cities": [
      {"city": "MyCity"},
      {"city": "New MyCity"},
      {"city": "West MyCity"}
    ]
  })*")),
        "Inserted document must contain a primary key, it may be auto "
        "generated by 'ownership' configuration or auto_increment.");
  }
}

TEST_F(DatabaseQueryPost, no_pk) {
  auto root = ObjectBuilder("mrstestdb", "country")
                  .field("country_id", FieldFlag::PRIMARY)
                  .field("country")
                  .root();

  {
    auto rest = std::make_unique<mrs::database::TableUpdater>(root);

    EXPECT_REST_ERROR(
        rest->handle_post(m_.get(), make_json(R"*({
    "country": "MyCountry"
  })*")),
        "Inserted document must contain a primary key, it may be auto "
        "generated by 'ownership' configuration or auto_increment.");
  }
}

TEST_F(DatabaseQueryPost, no_pk_multi) {
  auto root = ObjectBuilder("mrstestdb", "country")
                  .field("country_id", FieldFlag::PRIMARY)
                  .field("continent_id", FieldFlag::PRIMARY)
                  .field("country")
                  .root();

  auto rest = std::make_unique<mrs::database::TableUpdater>(root);
  EXPECT_REST_ERROR(
      rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 2,
    "country": "Testland"
  })*")),
      "Inserted document must contain a primary key, it may be auto "
      "generated by 'ownership' configuration or auto_increment.");

  EXPECT_REST_ERROR(
      rest->handle_post(m_.get(), make_json(R"*({
    "continent_id": 2,
    "country": "Testland"
  })*")),

      "Inserted document must contain a primary key, it may be auto "
      "generated by 'ownership' configuration or auto_increment.");
}

TEST_F(DatabaseQueryPost, unknown_fields) {
  auto root = ObjectBuilder("mrstestdb", "country")
                  .field("country_id", FieldFlag::PRIMARY)
                  .field("country");

  // no PK value given but it's autogenerated
  {
    auto rest = std::make_unique<mrs::database::TableUpdater>(root);

    EXPECT_REST_ERROR(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "country": "AAA",
    "population": 1234
  })*")),
                      "Unknown field 'population' in JSON document");
  }
}

TEST_F(DatabaseQueryPost, disabled_fields) {
  auto root =
      ObjectBuilder("mrstestdb", "actor")
          .field("actor_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("first_name")
          .field("last_name")
          .column("last_update")
          .nest_list(
              "film_actor",
              ObjectBuilder("film_actor", {{"actor_id", "actor_id"}})
                  .column("actor_id", FieldFlag::PRIMARY)
                  .column("film_id", FieldFlag::PRIMARY)
                  .nest("film", ObjectBuilder("film", {{"film_id", "film_id"}},
                                              Operation::valueRead)
                                    .field("film_id", FieldFlag::PRIMARY |
                                                          FieldFlag::AUTO_INC)
                                    .field("title")))
          .root();

  // don't require disabled fields
  {
    test_post_ai(root, make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": [
        {"film": {"film_id": 1, "title": "Frozen"}}
    ]
  })*"));
  }
  // error if disabled fields given
  {
    auto rest = std::make_unique<mrs::database::TableUpdater>(root);

    EXPECT_REST_ERROR(rest->handle_post(m_.get(), make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "last_update": "1999-01-01 11:11:00",
    "film_actor": [
        {"film": {"film_id": 1, "title": "Frozen"}}
    ]
  })*")),
                      "Unknown field 'last_update' in JSON document");
  }
}

TEST_F(DatabaseQueryPost, no_update_fields) {}

TEST_F(DatabaseQueryPost, type_check_nested) {
  {
    auto root =
        ObjectBuilder("mrstestdb", "country")
            .field("country_id", FieldFlag::PRIMARY)
            .nest("nest", ObjectBuilder("city", {{"country_id", "country_id"}})
                              .column("country_id")
                              .field("city"));
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "nest": "AAA"
  })*")),
                       std::runtime_error, "/nest expected to be an Object");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "nest": 1234
  })*")),
                       std::runtime_error, "/nest expected to be an Object");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "nest": []
  })*")),
                       std::runtime_error,
                       "/nest is an Array but wasn't expected to be");
    }
  }
  {
    auto root =
        ObjectBuilder("mrstestdb", "country")
            .field("country_id", FieldFlag::PRIMARY)
            .nest_list("nest",
                       ObjectBuilder("city", {{"country_id", "country_id"}})
                           .column("country_id")
                           .field("city", "city", "VARCHAR(40)"));
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
      "country_id": 123,
      "nest": "AAA"
    })*")),
                       std::runtime_error, "/nest expected to be an Array");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
      "country_id": 123,
      "nest": 1234
    })*")),
                       std::runtime_error, "/nest expected to be an Array");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
      "country_id": 123,
      "nest": {}
    })*")),
                       std::runtime_error, "/nest expected to be an Array");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
      "country_id": 123,
      "nest": null
    })*")),
                       std::runtime_error, "/nest expected to be an Array");
    }
    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "nest": [1234]
  })*")),
                       std::runtime_error, "/nest/0 expected to be an Object");
    }

    {
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(rest->handle_post(m_.get(), make_json(R"*({
    "country_id": 123,
    "nest": [{"city":1234}]
  })*")),
                       std::runtime_error,
                       "/nest/0/city has invalid value type");
    }
  }
}

TEST_F(DatabaseQueryPost, type_check) {
  std::vector<std::pair<const char *, entry::ColumnType>> known_types{
      {"BIT(1)", entry::ColumnType::BOOLEAN},
      {"BIT", entry::ColumnType::BINARY},
      {"TINYINT", entry::ColumnType::INTEGER},
      {"SMALLINT", entry::ColumnType::INTEGER},
      {"MEDIUMINT", entry::ColumnType::INTEGER},
      {"INT", entry::ColumnType::INTEGER},
      {"BIGINT", entry::ColumnType::INTEGER},
      {"FLOAT", entry::ColumnType::DOUBLE},
      {"REAL", entry::ColumnType::DOUBLE},
      {"DOUBLE", entry::ColumnType::DOUBLE},
      {"DECIMAL(10,2)", entry::ColumnType::DOUBLE},
      {"CHAR(42)", entry::ColumnType::STRING},
      {"NCHAR", entry::ColumnType::STRING},
      {"VARCHAR", entry::ColumnType::STRING},
      {"NVARCHAR", entry::ColumnType::STRING},
      {"BINARY", entry::ColumnType::BINARY},
      {"VARBINARY", entry::ColumnType::BINARY},
      {"TINYTEXT", entry::ColumnType::STRING},
      {"TEXT", entry::ColumnType::STRING},
      {"MEDIUMTEXT", entry::ColumnType::STRING},
      {"LONGTEXT", entry::ColumnType::STRING},
      {"TINYBLOB", entry::ColumnType::BINARY},
      {"BLOB", entry::ColumnType::BINARY},
      {"MEDIUMBLOB", entry::ColumnType::BINARY},
      {"LONGBLOB", entry::ColumnType::BINARY},
      {"JSON", entry::ColumnType::JSON},
      {"DATETIME", entry::ColumnType::STRING},
      {"DATE", entry::ColumnType::STRING},
      {"TIME(6)", entry::ColumnType::STRING},
      {"YEAR", entry::ColumnType::INTEGER},
      {"TIMESTAMP", entry::ColumnType::STRING},
      {"GEOMETRY", entry::ColumnType::GEOMETRY},
      {"POINT", entry::ColumnType::GEOMETRY},
      {"LINESTRING", entry::ColumnType::GEOMETRY},
      {"POLYGON", entry::ColumnType::GEOMETRY},
      {"GEOMCOLLECTION", entry::ColumnType::GEOMETRY},
      {"GEOMETRYCOLLECTION", entry::ColumnType::GEOMETRY},
      {"MULTIPOINT", entry::ColumnType::GEOMETRY},
      {"MULTILINESTRING", entry::ColumnType::GEOMETRY},
      {"MULTIPOLYGON", entry::ColumnType::GEOMETRY},
      {"BOOLEAN", entry::ColumnType::BOOLEAN},
      {"ENUM", entry::ColumnType::STRING},
      {"SET", entry::ColumnType::STRING}};

  std::map<entry::ColumnType, std::vector<const char *>> bad_values{
      {entry::ColumnType::INTEGER, {"32.20", "\"\"", "\"x\""}},
      {entry::ColumnType::DOUBLE, {"\"\"", "\"x\"", "true"}},
      {entry::ColumnType::BOOLEAN, {"32.34", "\"x\"", "\"\""}},
      {entry::ColumnType::STRING, {"42", "32.34", "true"}},
      {entry::ColumnType::BINARY, {"42", "32.34", "true"}},
      {entry::ColumnType::GEOMETRY, {"42", "32.34", "true", "\"foo\""}},
      {entry::ColumnType::JSON, {}}};

  for (const auto &type : known_types) {
    SCOPED_TRACE(type.first);

    auto root =
        ObjectBuilder("mrstestdb", "country")
            .field("country", "country", type.first, FieldFlag::PRIMARY);

    for (const auto &test : bad_values[type.second]) {
      SCOPED_TRACE(test);
      auto rest = std::make_unique<mrs::database::TableUpdater>(root);
      EXPECT_THROW_MSG(
          rest->handle_post(
              m_.get(), make_json(std::string("{\"country\": ") + test + "}")),
          std::runtime_error, "/country has invalid value type");
    }
  }
}

TEST_F(DatabaseQueryPost, special_types) {
  auto root = ObjectBuilder("mrstestdb", "typetest")
                  .field("id", FieldFlag::PRIMARY)
                  .field("Geom", "geom", "GEOMETRY")
                  .field("Bool", "bool", "BIT(1)")
                  .field("Binary", "bin", "BLOB")
                  .field("Json", "js", "JSON");

  test_post(root, make_json(R"*({
  "id": 42,
  "Bool": true,
  "Geom": {
      "type": "Point",
      "coordinates": [
          12.123,
          34.123
      ]
  },
  "Binary": "SGVsbG8gV29ybGQK",
  "Json": [1, {"a": true, "b": null}]
})*"));

  EXPECT_ROWS_ADDED("typetest", 1);

  auto row = m_->query_one(
      "SELECT id, hex(geom), hex(bool), hex(bin), js FROM mrstestdb.typetest "
      "WHERE id=42");
  EXPECT_STREQ("42", (*row)[0]);
  EXPECT_STREQ("E61000000101000000E5D022DBF93E284039B4C876BE0F4140", (*row)[1]);
  EXPECT_STREQ("1", (*row)[2]);
  EXPECT_STREQ("48656C6C6F20576F726C640A", (*row)[3]);
  EXPECT_STREQ("[1, {\"a\": true, \"b\": null}]", (*row)[4]);

  // test other json values
  test_post(root, make_json(R"*({
  "id": 43,
  "Json": 1
})*"));
  row = m_->query_one("SELECT js FROM mrstestdb.typetest WHERE id=43");
  EXPECT_STREQ("1", (*row)[0]);

  test_post(root, make_json(R"*({
  "id": 44,
  "Json": "hello"
})*"));
  row = m_->query_one("SELECT js FROM mrstestdb.typetest WHERE id=44");
  EXPECT_STREQ("\"hello\"", (*row)[0]);

  test_post(root, make_json(R"*({
  "id": 45,
  "Json": null
})*"));
  row = m_->query_one("SELECT js FROM mrstestdb.typetest WHERE id=45");
  EXPECT_STREQ("null", (*row)[0]);

  test_post(root, make_json(R"*({
  "id": 46,
  "Json": {}
})*"));
  row = m_->query_one("SELECT js FROM mrstestdb.typetest WHERE id=46");
  EXPECT_STREQ("{}", (*row)[0]);
}

TEST_F(DatabaseQueryPost, store_bool_in_int) {
  // sending bool values to be stored in any int column should be converted to 1
  // or 0
  auto root = ObjectBuilder("mrstestdb", "t2_base")
                  .column("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("data2", "data2", "INT");

  auto pk = test_post(root, make_json(R"*({"data2": true})*"));
  auto row = m_->query_one(
      ("SELECT data2 FROM mrstestdb.t2_base WHERE id=" + pk["id"].str()));
  EXPECT_STREQ("1", (*row)[0]);

  pk = test_post(root, make_json(R"*({"data2": false})*"));
  row = m_->query_one(
      ("SELECT data2 FROM mrstestdb.t2_base WHERE id=" + pk["id"].str()));
  EXPECT_STREQ("0", (*row)[0]);
}

TEST_F(DatabaseQueryPost, field_defaults) {
  // for POST, missing field values should be filled with the DEFAULT
  m_->execute(R"*(CREATE TABLE mrstestdb.defaults_test (a int primary key,
    b int not null,
    c int default null,
    d timestamp default current_timestamp,
    e varchar(4) default 'ABC',
    f json default ('{}')
  ))*");

  auto root = ObjectBuilder("mrstestdb", "defaults_test")
                  .field("a", "a", "int", FieldFlag::PRIMARY)
                  .field("b")
                  .field("c")
                  .field("d")
                  .field("e")
                  .field("f");

  // no value given for field with no default
  EXPECT_THROW_MSG(
      test_post(root, make_json(R"*({"a": 42})*")), std::runtime_error,
      R"*(Error executing MySQL query "INSERT INTO `mrstestdb`.`defaults_test` (`a`, `b`, `c`, `d`, `e`, `f`) VALUES (42, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT)": Field 'b' doesn't have a default value (1364))*");

  // no value given for fields with default
  test_post(root, make_json(R"*({"a": 42, "b": 123})*"));

  auto row = m_->query_one("select * from mrstestdb.defaults_test");
  EXPECT_STREQ("42", (*row)[0]);
  EXPECT_STREQ("123", (*row)[1]);
  EXPECT_EQ(nullptr, (*row)[2]);
  EXPECT_TRUE((strncmp((*row)[3], "20", 2) == 0));
  EXPECT_STREQ("ABC", (*row)[4]);
  EXPECT_STREQ("{}", (*row)[5]);
}

TEST_F(DatabaseQueryPost, plain_autoinc) {
  auto root = ObjectBuilder("mrstestdb", "actor")
                  .field("actorId", "actor_id", "int",
                         FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("firstName", "first_name", "text")
                  .field("lastName", "last_name", "text")
                  .root();

  test_post_ai(root, make_json(R"*({
    "firstName": "Arnold",
    "lastName": "Smith"
  })*"));
  // XXX override PK with known value
}

TEST_F(DatabaseQueryPost, plain_autoinc_row_owner) {
  auto root =
      ObjectBuilder("mrstestdb", "t2_base")
          .field("id", "id", "int", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("owner_id")
          .field("data1", "data1", "text")
          .field("data2", "data2", "int")
          .root();

  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "owner_id",
                                    mysqlrouter::sqlstring("111"));

    test_post_ai(root, make_json(R"*({
    "data1": "Hello World",
    "data2": 42
  })*"),
                 owner);
  }
  // try to Post as someone else's row
  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "owner_id",
                                    mysqlrouter::sqlstring("222"));

    test_post_ai(root, make_json(R"*({
    "owner_id": "ROOT",
    "data1": "Bla",
    "data2": 12
  })*"),
                 owner);
  }
  // allow Post own row
  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "owner_id",
                                    mysqlrouter::sqlstring("333"));

    test_post_ai(
        root,
        make_json(R"*({"owner_id": "USER3", "data1": "Joe", "data2": 1})*"),
        owner);
  }

  root = ObjectBuilder("mrstestdb", "t2_base")
             .field("Id", "id", "int", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
             .field("firstName", "data1", "text")
             .field("age", "data2", "int")
             .root();
  // owner_id = PK
  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "id",
                                    mysqlrouter::sqlstring("111"));

    auto pk = test_post(root, make_json(R"*({"firstName": "Joe", "age": 20})*"),
                        owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ("111", pk["id"].str());
  }
  // can't insert someone else's row
  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "id",
                                    mysqlrouter::sqlstring("222"));
    auto pk = test_post(
        root, make_json(R"*({"Id": 222, "firstName": "Joe", "age": 30})*"),
        owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ("222", pk["id"].str());
  }
  // allow inserting own row
  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "id",
                                    mysqlrouter::sqlstring("333"));
    auto pk = test_post(
        root, make_json(R"*({"Id": 333, "firstName": "Joe", "age": 40})*"),
        owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ("333", pk["id"].str());
  }
}

TEST_F(DatabaseQueryPost, plain_uuid) {
  auto root = ObjectBuilder("mrstestdb", "t1_base")
                  .field("id", "id", "binary(16)",
                         FieldFlag::PRIMARY | FieldFlag::REV_UUID)
                  .field("data", "data", "text")
                  .root();
  test_post_uuid(root, make_json(R"*({
    "data": "Hello World"
  })*"));
  EXPECT_ROWS_ADDED("t1_base", 1);

  auto pk = test_post(root, make_json(R"*({
    "id": "dXVpZDEK",
    "data": "Hello World"
  })*"));
  EXPECT_EQ(1, pk.size());
  EXPECT_EQ("FROM_BASE64('dXVpZDEK')", pk["id"].str());

  EXPECT_ROWS_ADDED("t1_base", 2);
}

TEST_F(DatabaseQueryPost, plain_noautogen) {
  auto root = ObjectBuilder("mrstestdb", "actor")
                  .field("actorId", "actor_id", "int", FieldFlag::PRIMARY)
                  .field("firstName", "first_name", "text")
                  .field("lastName", "last_name", "text");

  // should fail b/c PK not given
  {
    auto rest = std::make_unique<mrs::database::TableUpdater>(root);

    EXPECT_REST_ERROR(
        rest->handle_post(m_.get(), make_json(R"*({
    "firstName": "Arnold",
    "lastName": "Smith"
  })*")),
        "Inserted document must contain a primary key, it may be auto "
        "generated by 'ownership' configuration or auto_increment.");
  }

  // give PK in document

  // INSERT
  {
    auto pk = test_post(root, make_json(R"*({
    "actorId": 123,
    "firstName": "Arnold",
    "lastName": "Smith"
  })*"));
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ("123", pk["actor_id"].str());
  }
}

TEST_F(DatabaseQueryPost, plain_noautogen_rowowner) {
  // ensure ownership column can't be overriden in request
  // {
  //   mrs::database::JsonInsertBuilder ib(
  //       root, {"actor_id", mysqlrouter::sqlstring("125")});
  //   rest->handle_post(m_.get(), make_json(R"*({
  //   "firstName": "Arnold",
  //   "lastName": "Smith"
  // })*"));

  //   auto sql = ib.insert();
  //   EXPECT_EQ(
  //       "INSERT INTO `mrstestdb`.`actor` (`actor_id`, `first_name`, "
  //       "`last_name`) "
  //       "VALUES (125, 'Arnold', 'Smith')",
  //       sql.str());
  // }
}

TEST_F(DatabaseQueryPost, nested_1n_autoinc_autoinc) {
  auto root =
      ObjectBuilder("mrstestdb", "country")
          .field("country_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("country")
          .nest_list(
              "cities",
              ObjectBuilder("city", {{"country_id", "country_id"}})
                  .field("city_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("country_id")
                  .field("city"))
          .root();

  // nested list is empty
  {
    test_post_ai(root, make_json(R"*({
      "country": "MyCountry",
      "cities": []
  })*"));
  }

  // nested list has items
  {
    test_post_ai(root, make_json(R"*({
    "country": "MyCountry",
    "cities": [
      {"city": "MyCity"},
      {"city": "New MyCity"},
      {"city": "West MyCity"}
    ]
  })*"));
  }

  // bogus country_id in nested row
  {
    test_post_ai(root, make_json(R"*({
    "country": "MyCountry",
    "cities": [
      {"city": "MyCity", "country_id": 99999}
    ]
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_1n_autoinc_uuid) {
  auto root =
      ObjectBuilder("mrstestdb", "t3_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("data1")
          .field("data2")
          .nest_list("nested",
                     ObjectBuilder("t3_ref_1n", {{"base_id", "id"}})
                         .field("id", FieldFlag::PRIMARY | FieldFlag::REV_UUID)
                         .field("base_id")
                         .field("data"))
          .root();

  // nested list is empty
  {
    test_post_ai(root, make_json(R"*({
      "data1": "str",
      "data2": 4,
      "nested": []
  })*"));
  }

  // nested list has items
  {
    test_post_ai(root, make_json(R"*({
    "data1": "str",
    "data2": 4,
    "nested": [
      {"data": "MyCity"},
      {"data": "New MyCity"},
      {"data": "West MyCity"}
    ]
  })*"));
  }

  // bogus country_id in nested row
  {
    test_post_ai(root, make_json(R"*({
    "data1": "str",
    "data2": 5,
    "nested": [
      {"data": "MyCity", "base_id": 99999}
    ]
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_1n_uuid_autoinc) {
  auto root =
      ObjectBuilder("mrstestdb", "t4_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::REV_UUID)
          .field("data")
          .nest_list("refs",
                     ObjectBuilder("t4_ref_1n", {{"base_id", "id"}})
                         .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                         .field("base_id")
                         .field("data"))
          .root();

  // nested list is empty
  {
    test_post_uuid(root, make_json(R"*({
      "data": "MyCountry",
      "refs": []
  })*"));
  }

  // nested list has items
  {
    test_post_uuid(root, make_json(R"*({
    "data": "MyCountry",
    "refs": [
      {"data": "Mydata"},
      {"data": "New Mydata"},
      {"data": "West Mydata"}
    ]
  })*"));
  }

  // bogus country_id in nested row
  {
    test_post_uuid(root, make_json(R"*({
    "data": "MyCountry",
    "refs": [
      {"data": "Mydata", "base_id": 99999}
    ]
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_1n_uuid_uuid) {
  auto root =
      ObjectBuilder("mrstestdb", "t1_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::REV_UUID)
          .field("data")
          .nest_list("refs",
                     ObjectBuilder("t1_ref_1n", {{"base_id", "id"}})
                         .field("id", FieldFlag::PRIMARY | FieldFlag::REV_UUID)
                         .field("base_id")
                         .field("data"))
          .root();

  // nested list is empty
  {
    test_post_uuid(root, make_json(R"*({
      "data": "Mydata",
      "refs": []
  })*"));
  }

  // nested list has items
  {
    test_post_uuid(root, make_json(R"*({
    "data": "Mydata",
    "refs": [
      {"data": "Mydata"},
      {"data": "New Mydata"},
      {"data": "West Mydata"}
    ]
  })*"));
  }

  // bogus base_id in nested row
  {
    test_post_uuid(root, make_json(R"*({
    "data": "Mydata",
    "refs": [
      {"data": "Mydata", "base_id": "99999"}
    ]
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_n1_null) {
  auto root =
      ObjectBuilder("mrstestdb", "t2_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("data1")
          .field("data2")
          .column("ref_11_id")
          .nest("ref11",
                ObjectBuilder("t2_ref_11", {{"ref_11_id", "id"}})
                    .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                    .field("data"))
          .root();

  {
    test_post_ai(root, make_json(R"*({
    "data1": "aaa",
    "data2": 111,
    "ref11": null
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_11_owned_child_autoinc) {
  auto root = ObjectBuilder("mrstestdb", "city")
                  .field("city_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("city")
                  .column("country_id")
                  .nest("country",
                        ObjectBuilder("country", {{"country_id", "country_id"}})
                            .field("country_id",
                                   FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                            .field("country"))
                  .root();

  // create a new nested object (deleting the old one)
  {
    test_post_ai(root, make_json(R"*({
    "city": "Test City",
    "country": {
        "country": "Testland"
    }
  })*"));
  }

  // update existing nested object (requires id) - should fail because this is
  // POST
  {
    EXPECT_THROW_MSG(
        test_post_ai(root, make_json(R"*({
    "city": "Test City",
    "country": {
        "country_id": 5,
        "country": "Anguilla"
    }
  })*")),
        std::runtime_error,
        R"*(Error executing MySQL query "INSERT INTO `mrstestdb`.`country` (`country_id`, `country`) VALUES (5, 'Anguilla')": Duplicate entry '5' for key 'country.PRIMARY' (1062))*");
  }

  // assign to null (delete only)
  {
    EXPECT_THROW_MSG(
        test_post_ai(root, make_json(R"*({
    "city": "Test City",
    "country": null
  })*")),
        std::runtime_error,
        R"*(Error executing MySQL query "INSERT INTO `mrstestdb`.`city` (`city`, `country_id`) VALUES ('Test City', NULL)": Column 'country_id' cannot be null (1048))*");
  }
}

TEST_F(DatabaseQueryPost, nested_11_owned_child_uuid) {
  auto root = ObjectBuilder("mrstestdb", "t1_base")
                  .field("id", FieldFlag::PRIMARY | FieldFlag::REV_UUID)
                  .field("data")
                  .column("ref_11_id")
                  .nest("ref", ObjectBuilder("t1_ref_11", {{"ref_11_id", "id"}})
                                   .field("id", FieldFlag::PRIMARY |
                                                    FieldFlag::REV_UUID)
                                   .field("data"))
                  .root();

  // create a new nested object (deleting the old one)
  {
    test_post_uuid(root, make_json(R"*({
    "data": "Test",
    "ref": {
        "data": "Ref"
    }
  })*"));
  }

  // update existing nested object - should fail because this is a POST
  {
    EXPECT_THROW(test_post_uuid(root, make_json(R"*({
    "data": "Test2",
    "ref": {
        "id": "UUID1",
        "data": "Ref2"
    }
  })*")),
                 std::runtime_error);
  }

  // assign to null
  {
    test_post_uuid(root, make_json(R"*({
    "data": "Test3",
    "ref": null
  })*"));
  }
}

TEST_F(DatabaseQueryPost, unnested_11_owned_child_autoinc) {
  auto root =
      ObjectBuilder("mrstestdb", "city")
          .field("city_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("city")
          .column("country_id")
          .unnest(
              ObjectBuilder("country", {{"country_id", "country_id"}})
                  .field("country_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("country")
                  .field("last_update"))
          .root();

  // create a new nested object (deleting the old one)
  {
    test_post_ai(root, make_json(R"*({
    "city": "Test City",
    "country": "Testland",
    "last_update": "2000-01-01 1:00:00"
  })*"));
  }

  // assign to null (country_id is NOT NULL, so fail)
  {
    EXPECT_THROW_MSG(
        test_post_ai(root, make_json(R"*({
    "city": "Test City",
    "country": null,
    "last_update": null
  })*")),
        std::runtime_error,
        R"*(Error executing MySQL query "INSERT INTO `mrstestdb`.`city` (`city`, `country_id`) VALUES ('Test City', NULL)": Column 'country_id' cannot be null (1048))*");
  }
}

TEST_F(DatabaseQueryPost, nested_11_multi) {
  auto root =
      ObjectBuilder("mrstestdb", "tc2_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("sub_id", FieldFlag::PRIMARY)
          .field("data1")
          .field("data2")
          .column("ref_11_id")
          .column("ref_11_sub_id")
          .nest("ref",
                ObjectBuilder("tc2_ref_11", {{"ref_11_id", "id"},
                                             {"ref_11_sub_id", "sub_id"}})
                    .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                    .field("sub_id", FieldFlag::PRIMARY)
                    .field("data"))
          .root();

  {
    test_post(root, make_json(R"*({
      "id": 222,
      "sub_id": "AB",
      "data1": "AAA",
      "data2": 1,
      "ref": {
        "sub_id": 888,
        "data": "REF11"
      }
    })*"));

    EXPECT_ROWS_ADDED("tc2_base", 1);
    EXPECT_ROWS_ADDED("tc2_ref_11", 1);
  }

  {
    test_post(root, make_json(R"*({
      "sub_id": "AB",
      "data1": "CHANGED",
      "data2": 3,
      "ref": {
        "sub_id": 888,
        "data": "REF11"
      }
    })*"));

    EXPECT_ROWS_ADDED("tc2_base", 2);
    EXPECT_ROWS_ADDED("tc2_ref_11", 2);
  }
}

TEST_F(DatabaseQueryPost, nested_n1_ref_autoinc) {
  auto root = ObjectBuilder("mrstestdb", "city")
                  .field("city_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                  .field("city")
                  .column("country_id")
                  .nest("country",
                        ObjectBuilder("country", {{"country_id", "country_id"}},
                                      Operation::Values::valueRead)
                            .field("country_id",
                                   FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                            .field("country"))
                  .root();

  // {
  //   auto rest = std::make_unique<mrs::database::TableUpdater>(root);

  //   // insert a new city (direct fk)
  //   EXPECT_REST_ERROR(rest->handle_post(m_.get(), make_json(R"*({
  //   "city": "Somewhere",
  //   "country_id": 5
  // })*")),
  //                     "Document has missing fields");
  // }
  {
    // insert a new city to an existing country through a fk specified in the
    // nested object

    test_post_ai(root, make_json(R"*({
    "city": "Somewhere",
    "country": {
      "country_id": 5,
      "country": "Anguilla"
    }
  })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_nm_autoinc_ref) {
  auto root =
      ObjectBuilder("mrstestdb", "actor")
          .field("actor_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("first_name")
          .field("last_name")
          .nest_list(
              "film_actor",
              ObjectBuilder("film_actor", {{"actor_id", "actor_id"}})
                  .column("actor_id", FieldFlag::PRIMARY)
                  .column("film_id", FieldFlag::PRIMARY)
                  .nest("film", ObjectBuilder("film", {{"film_id", "film_id"}},
                                              Operation::valueRead)
                                    .field("film_id", FieldFlag::PRIMARY |
                                                          FieldFlag::AUTO_INC)
                                    .field("title")
                                    .field("language_id")
                                    .field("original_language_id")))
          .root();

  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": [
        {"film": {"film_id": 11, "title": "THE TEST I", "language_id":1, "original_language_id":1}},
        {"film": {"film_id": 12, "title": "THE TEST II", "language_id":1, "original_language_id":1}},
        {"film": {"film_id": 13, "title": "THE TEST III", "language_id":1, "original_language_id":1}}
    ]
  })*");
    test_post_ai(root, doc);
  }
  // empty list
  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": []
  })*");
    test_post_ai(root, doc);
  }
}

TEST_F(DatabaseQueryPost, nested_nm_autoinc) {
  auto root =
      ObjectBuilder("mrstestdb", "actor")
          .field("actor_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("first_name")
          .field("last_name")
          .nest_list(
              "film_actor",
              ObjectBuilder("film_actor", {{"actor_id", "actor_id"}})
                  .column("actor_id", FieldFlag::PRIMARY)
                  .column("film_id", FieldFlag::PRIMARY)
                  .nest("film", ObjectBuilder("film", {{"film_id", "film_id"}})
                                    .field("film_id", FieldFlag::PRIMARY |
                                                          FieldFlag::AUTO_INC)
                                    .field("title")
                                    .field("language_id")
                                    .field("original_language_id")))
          .root();

  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": [
        {"film": {"title": "Frozen", "language_id":1, "original_language_id":1}},
        {"film": {"title": "Melted", "language_id":1, "original_language_id":1}}
    ]
  })*");
    test_post_ai(root, doc);
  }
  // empty list
  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": []
  })*");
    test_post_ai(root, doc);
  }
}

TEST_F(DatabaseQueryPost, nested_nm_autoinc_ref_extras) {
  auto root =
      ObjectBuilder("mrstestdb", "actor")
          .field("actor_id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("first_name")
          .field("last_name")
          .nest_list(
              "film_actor",
              ObjectBuilder("film_actor", {{"actor_id", "actor_id"}})
                  .column("actor_id", FieldFlag::PRIMARY)
                  .column("film_id", FieldFlag::PRIMARY)
                  .field("last_update")
                  .nest("film", ObjectBuilder("film", {{"film_id", "film_id"}},
                                              Operation::valueRead)
                                    .field("film_id", FieldFlag::PRIMARY |
                                                          FieldFlag::AUTO_INC)
                                    .field("title")
                                    .field("language_id")
                                    .field("original_language_id")))
          .root();

  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": [
        {"last_update": "2000-01-01 1:10:10", 
          "film": {"film_id": 11, "title": "THE TEST I", "language_id":1, "original_language_id":1}},
        {"last_update": "2000-01-02 1:10:10",
          "film": {"film_id": 12, "title": "THE TEST II", "language_id":1, "original_language_id":1}},
        {"last_update": "2000-01-03 1:10:10",
          "film": {"film_id": 13, "title": "THE TEST III", "language_id":1, "original_language_id":1}}
    ]
  })*");
    test_post_ai(root, doc);
  }
  // empty list
  {
    auto doc = make_json(R"*({
    "first_name": "Angelina",
    "last_name": "Joline",
    "film_actor": []
  })*");
    test_post_ai(root, doc);
  }
}

TEST_F(DatabaseQueryPost, nested_nm_ref_multi) {
  // also tests differently named FK columns
  auto root =
      ObjectBuilder("mrstestdb", "tc2_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("sub_id", FieldFlag::PRIMARY)
          .field("data1")
          .field("data2")
          .nest_list(
              "refs",
              ObjectBuilder("tc2_ref_nm_join",
                            {{"base_id", "id"}, {"base_sub_id", "sub_id"}})
                  .column("base_id", FieldFlag::PRIMARY)
                  .column("base_sub_id", FieldFlag::PRIMARY)
                  .column("ref_id", FieldFlag::PRIMARY)
                  .column("ref_sub_id", FieldFlag::PRIMARY)
                  .nest("ref", ObjectBuilder(
                                   "tc2_ref_nm",
                                   {{"ref_id", "id"}, {"ref_sub_id", "sub_id"}},
                                   Operation::valueRead)
                                   .field("id", FieldFlag::PRIMARY)
                                   .field("sub_id", FieldFlag::PRIMARY)
                                   .field("data")))
          .root();

  {
    test_post(root, make_json(R"*({
      "sub_id": "AA",
      "data1": "ABC",
      "data2": 5,
      "refs": [
        {
          "ref": {
              "id": 111,
              "sub_id": 888,
              "data": "Data1"
          }
        },
        {
          "ref": {
              "id": 222,
              "sub_id": 999,
              "data": "Data2"
          }
        }
      ]
    })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_nm_owned_multi) {
  auto root =
      ObjectBuilder("mrstestdb", "tc2_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("sub_id", FieldFlag::PRIMARY)
          .field("data1")
          .field("data2")
          .nest_list(
              "refs",
              ObjectBuilder("tc2_ref_nm_join",
                            {{"base_id", "id"}, {"base_sub_id", "sub_id"}})
                  .column("base_id", FieldFlag::PRIMARY)
                  .column("base_sub_id", FieldFlag::PRIMARY)
                  .column("ref_id", FieldFlag::PRIMARY)
                  .column("ref_sub_id", FieldFlag::PRIMARY)
                  .nest(
                      "ref",
                      ObjectBuilder("tc2_ref_nm", {{"ref_id", "id"},
                                                   {"ref_sub_id", "sub_id"}})
                          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                          .field("sub_id", FieldFlag::PRIMARY)
                          .field("data")))
          .root();

  {
    test_post(root, make_json(R"*({
      "sub_id": "AA",
      "data1": "ABC",
      "data2": 5,
      "refs": [
        {
          "ref": {
              "sub_id": 888,
              "data": "Data1"
          }
        },
        {
          "ref": {
              "sub_id": 999,
              "data": "Data2"
          }
        }
      ]
    })*"));
  }
}

TEST_F(DatabaseQueryPost, nested_nm_row_owner) {
  auto root =
      ObjectBuilder("mrstestdb", "t2_base")
          .field("id", FieldFlag::PRIMARY)
          .field("data1")
          .field("data2")
          .nest_list(
              "refs",
              ObjectBuilder("t2_ref_nm_join", {{"base_id", "id"}})
                  .column("base_id", FieldFlag::PRIMARY)
                  .column("ref_id", FieldFlag::PRIMARY)
                  .nest("ref", ObjectBuilder("t2_ref_nm", {{"ref_id", "id"}})
                                   .field("id", FieldFlag::PRIMARY |
                                                    FieldFlag::AUTO_INC)
                                   .field("data")))
          .root();
  // PK = owner
  {
    auto doc = make_json(R"*({
    "data1": "AAA",
    "data2": 5,
    "refs": [
        {"ref": {"data": "DATA3"}},
        {"ref": {"data": "DATA4"}}
    ]
  })*");

    auto owner = ObjectRowOwnership(root->get_base_table(), "id",
                                    mysqlrouter::sqlstring("444"));
    auto pk = test_post(root, doc, owner);
    EXPECT_EQ(1, pk.size());
    EXPECT_EQ("444", pk["id"].str());
  }
}

TEST_F(DatabaseQueryPost, nested_nm_multi_row_owner) {
  auto root =
      ObjectBuilder("mrstestdb", "tc2_base")
          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
          .field("sub_id", FieldFlag::PRIMARY)
          .field("data1")
          .field("data2")
          .nest_list(
              "refs",
              ObjectBuilder("tc2_ref_nm_join",
                            {{"base_id", "id"}, {"base_sub_id", "sub_id"}})
                  .column("base_id", FieldFlag::PRIMARY)
                  .column("base_sub_id", FieldFlag::PRIMARY)
                  .column("ref_id", FieldFlag::PRIMARY)
                  .column("ref_sub_id", FieldFlag::PRIMARY)
                  .nest(
                      "ref",
                      ObjectBuilder("tc2_ref_nm", {{"ref_id", "id"},
                                                   {"ref_sub_id", "sub_id"}})
                          .field("id", FieldFlag::PRIMARY | FieldFlag::AUTO_INC)
                          .field("sub_id", FieldFlag::PRIMARY)
                          .field("data")))
          .root();

  {
    auto owner = ObjectRowOwnership(root->get_base_table(), "sub_id",
                                    mysqlrouter::sqlstring("'XX'"));

    auto id = next_auto_inc("tc2_base");

    auto pk = test_post(root, make_json(R"*({
      "data1": "ABC",
      "data2": 5,
      "refs": [
        {
          "ref": {
              "sub_id": 888,
              "data": "Data1"
          }
        },
        {
          "ref": {
              "sub_id": 999,
              "data": "Data2"
          }
        }
      ]
    })*"),
                        owner);
    EXPECT_EQ(2, pk.size());
    EXPECT_EQ(id, pk["id"].str());
    EXPECT_EQ("'XX'", pk["sub_id"].str());
  }
}

TEST_F(DatabaseQueryPost, ultimate) {
  auto root = ObjectBuilder("mrstestdb", "level1")
                  .field("id1", FieldFlag::PRIMARY)
                  .field("id2", FieldFlag::PRIMARY);
}

// TODO
// - composite keys
// - nested join
// - s/base/nested/
// - 1:1
// - 1:n
// - n:m
// - reduce with value
// - 2 subqueries
// - 2 joins
// - allowed crud operation check

// inserts
// - PK - auto-inc / single / composite

// deny_insert
