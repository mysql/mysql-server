################################################################################
# BUG#22336669 - TIMEOUT WHILE SHUTTING DOWN THE SERVER WITH PREPARED PROCEDURES
#                RUNNING
#
# Test to check if the server hangs while a STOP GROUP_REPLICATION command is
# executed and a stored procedure is running.
#
# Test:
# 0. The test requires two servers: M1 and M2.
# 1. With both the members ONLINE. On M1 create a table and stored procedure(SP)
#    to insert 199 rows in the table created.
# 2. Set DEBUG point to hang SP at the before commit hook. Call SP and
#    simultaneously stop GR on M1.
# 3. Signal to continue_commit. Check that BUG#22336669 fixes the hang. Wait
#    for the 199 rows in the table.
# 4. Assert check that SP was executed only on M1's binary log and was logged
#    with M1's UUID. It never reached the binary log of M2. On M2 there is
#    only 5 transactions logged with group UUID.
# 5. Clean up.
################################################################################

# Setup a two server Group.
--source include/have_debug.inc
--source ../inc/have_group_replication_plugin.inc
--let $rpl_gtid_utils= 1
--source ../inc/group_replication.inc

--let $rpl_connection_name= server1
--source include/rpl_connection.inc

# Create a stored procedure to insert rows in the table created.
CREATE TABLE test.t1 (a INT PRIMARY KEY);
USE test;
delimiter $$;
CREATE PROCEDURE insert_into_t1()
     BEGIN
     DECLARE x INT;
     SET x=1;
     WHILE x<200 DO
     INSERT INTO t1 VALUES (x);
     SET x=x+1;
     END WHILE;
     end$$
delimiter ;$$
--echo

# Call the procedure and simultaneously executed STOP GROUP_REPLICATION from a
# new connection.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
SET @debug_save= @@GLOBAL.DEBUG;
SET @@GLOBAL.DEBUG='d,group_replication_before_commit_hook_wait';

--send CALL insert_into_t1()

# Ensuring that the procedure actually hangs at the before commit hook.
--let $rpl_connection_name= server_1
--source include/rpl_connection.inc
--let $wait_condition=SELECT COUNT(*)=1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE State = 'debug sync point: now'
--source include/wait_condition.inc

--source include/stop_group_replication.inc

SET DEBUG_SYNC='now SIGNAL continue_commit';
SET @@GLOBAL.DEBUG= @debug_save;

# Prior to the fix of the BUG#21649247, the member used to hang here during
# the reap. Now it passes successfully.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
--reap

--let $wait_condition= SELECT COUNT(*) = 199 from test.t1;
--source include/wait_condition.inc

# Asserting that the stored procedure was executed only on server1 binary log
# and was logged with the the server1's UUID. It never reached the binary log
# of server2.

--let $master_uuid= `SELECT @@GLOBAL.SERVER_UUID`
--let $assert_text= Stored procedure is executed on server1 with server1 UUID.
--let $assert_cond= GTID_IS_EQUAL("[SELECT @@GLOBAL.GTID_EXECUTED]", "$master_uuid:1-199,$group_replication_group_name:1-4")
--source include/assert.inc

# On server 2 only 5 transaction are logged with group gtid.
--let $rpl_connection_name= server2
--source include/rpl_connection.inc
--let $assert_text= Stored procedure is not replicated here. It has only group transactions.
--let $assert_cond= GTID_IS_EQUAL("[SELECT @@GLOBAL.GTID_EXECUTED]", "$group_replication_group_name:1-4")
--source include/assert.inc

# Cleanup
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
DROP PROCEDURE insert_into_t1;
DROP TABLE t1;

--let $rpl_connection_name= server2
--source include/rpl_connection.inc
DROP PROCEDURE insert_into_t1;
DROP TABLE t1;
--source include/stop_group_replication.inc

--source ../inc/group_replication_end.inc
