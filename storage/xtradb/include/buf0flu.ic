/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************
The database buffer pool flush algorithm

Created 11/5/1995 Heikki Tuuri
*******************************************************/

#include "buf0buf.h"
#include "mtr0mtr.h"

/************************************************************************
Inserts a modified block into the flush list. */
UNIV_INTERN
void
buf_flush_insert_into_flush_list(
/*=============================*/
	buf_block_t*	block);	/* in/out: block which is modified */
/************************************************************************
Inserts a modified block into the flush list in the right sorted position.
This function is used by recovery, because there the modifications do not
necessarily come in the order of lsn's. */
UNIV_INTERN
void
buf_flush_insert_sorted_into_flush_list(
/*====================================*/
	buf_block_t*	block);	/* in/out: block which is modified */

/************************************************************************
This function should be called at a mini-transaction commit, if a page was
modified in it. Puts the block to the list of modified blocks, if it is not
already in it. */
UNIV_INLINE
void
buf_flush_note_modification(
/*========================*/
	buf_block_t*	block,	/* in: block which is modified */
	mtr_t*		mtr)	/* in: mtr */
{
	ibool	use_LRU_mutex = FALSE;

	if (UT_LIST_GET_LEN(buf_pool->unzip_LRU))
		use_LRU_mutex = TRUE;

	if (use_LRU_mutex)
		mutex_enter(&LRU_list_mutex);

	mutex_enter(&block->mutex);

	ut_ad(block);
	ut_ad(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);
	ut_ad(block->page.buf_fix_count > 0);
#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */
	//ut_ad(buf_pool_mutex_own());

	ut_ad(mtr->start_lsn != 0);
	ut_ad(mtr->modifications);
	ut_ad(block->page.newest_modification <= mtr->end_lsn);

	block->page.newest_modification = mtr->end_lsn;

	if (!block->page.oldest_modification) {
		mutex_enter(&flush_list_mutex);

		block->page.oldest_modification = mtr->start_lsn;
		ut_ad(block->page.oldest_modification != 0);

		buf_flush_insert_into_flush_list(block);
		mutex_exit(&flush_list_mutex);
	} else {
		ut_ad(block->page.oldest_modification <= mtr->start_lsn);
	}

	mutex_exit(&block->mutex);

	++srv_buf_pool_write_requests;

	if (use_LRU_mutex)
		mutex_exit(&LRU_list_mutex);
}

/************************************************************************
This function should be called when recovery has modified a buffer page. */
UNIV_INLINE
void
buf_flush_recv_note_modification(
/*=============================*/
	buf_block_t*	block,		/* in: block which is modified */
	ib_uint64_t	start_lsn,	/* in: start lsn of the first mtr in a
					set of mtr's */
	ib_uint64_t	end_lsn)	/* in: end lsn of the last mtr in the
					set of mtr's */
{
	ibool	use_LRU_mutex = FALSE;

	if(UT_LIST_GET_LEN(buf_pool->unzip_LRU))
		use_LRU_mutex = TRUE;

	if (use_LRU_mutex)
		mutex_enter(&LRU_list_mutex);

	mutex_enter(&(block->mutex));

	ut_ad(block);
	ut_ad(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);
	ut_ad(block->page.buf_fix_count > 0);
#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */

	//buf_pool_mutex_enter();

	ut_ad(block->page.newest_modification <= end_lsn);

	block->page.newest_modification = end_lsn;

	if (!block->page.oldest_modification) {
		mutex_enter(&flush_list_mutex);

		block->page.oldest_modification = start_lsn;

		ut_ad(block->page.oldest_modification != 0);

		buf_flush_insert_sorted_into_flush_list(block);
		mutex_exit(&flush_list_mutex);
	} else {
		ut_ad(block->page.oldest_modification <= start_lsn);
	}

	//buf_pool_mutex_exit();
	if (use_LRU_mutex)
		mutex_exit(&LRU_list_mutex);
	mutex_exit(&(block->mutex));
}
