/*****************************************************************************

Copyright (c) 2011, 2016, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/******************************************************************//**
@file include/fts0priv.ic
Full text search internal header file

Created 2011/11/12 Sunny Bains
***********************************************************************/

/******************************************************************//**
Write the table id to the given buffer (including final NUL). Buffer must be
at least FTS_AUX_MIN_TABLE_ID_LENGTH bytes long.
@return number of bytes written */
UNIV_INLINE
int
fts_write_object_id(
/*================*/
	ib_id_t		id,		/* in: a table/index id */
	char*		str,		/* in: buffer to write the id to */
	bool		hex_format MY_ATTRIBUTE((unused)))
					/* in: true for fixed hex format,
					false for old ambiguous format */
{

#ifdef _WIN32

	DBUG_EXECUTE_IF("innodb_test_wrong_non_windows_fts_aux_table_name",
			return(sprintf(str, UINT64PFx, id)););

	/* Use this to construct old(5.6.14 and 5.7.3) windows
	ambiguous aux table names */
	DBUG_EXECUTE_IF("innodb_test_wrong_fts_aux_table_name",
			return(sprintf(str, "%016llu", id)););

#else /* _WIN32 */

	/* Use this to construct old(5.6.14 and 5.7.3) windows
	ambiguous aux table names */
	DBUG_EXECUTE_IF("innodb_test_wrong_windows_fts_aux_table_name",
			return(sprintf(str, "%016" PRIu64, id)););

	DBUG_EXECUTE_IF("innodb_test_wrong_fts_aux_table_name",
			return(sprintf(str, UINT64PFx, id)););

#endif /* _WIN32 */

	/* As above, but this is only for those tables failing to rename. */
	if (!hex_format) {
#ifdef _WIN32
		// FIXME: Use ut_snprintf(), so does following one.
		return(sprintf(str, "%016llu", id));
#else /* _WIN32 */
		return(sprintf(str, "%016" PRIu64, id));
#endif /* _WIN32 */
	}

	return(sprintf(str, UINT64PFx, id));
}

/******************************************************************//**
Read the table id from the string generated by fts_write_object_id().
@return TRUE if parse successful */
UNIV_INLINE
ibool
fts_read_object_id(
/*===============*/
	ib_id_t*	id,		/* out: an id */
	const char*	str)		/* in: buffer to read from */
{
	/* NOTE: this func doesn't care about whether current table
	is set with HEX_NAME, the user of the id read here will check
	if the id is HEX or DEC and do the right thing with it. */
	return(sscanf(str, UINT64PFx, id) == 1);
}

/******************************************************************//**
Compare two fts_trx_table_t instances.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
UNIV_INLINE
int
fts_trx_table_cmp(
/*==============*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const dict_table_t*	table1
		= (*static_cast<const fts_trx_table_t* const*>(p1))->table;

	const dict_table_t*	table2
		= (*static_cast<const fts_trx_table_t* const*>(p2))->table;

	return((table1->id > table2->id)
	       ? 1
	       : (table1->id == table2->id)
		  ? 0
		  : -1);
}

/******************************************************************//**
Compare a table id with a fts_trx_table_t table id.
@return < 0 if n1 < n2, 0 if n1 == n2,> 0 if n1 > n2 */
UNIV_INLINE
int
fts_trx_table_id_cmp(
/*=================*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const uintmax_t*	table_id = static_cast<const uintmax_t*>(p1);
	const dict_table_t*	table2
		= (*static_cast<const fts_trx_table_t* const*>(p2))->table;

	return((*table_id > table2->id)
	       ? 1
	       : (*table_id == table2->id)
		  ? 0
		  : -1);
}
