/*****************************************************************************

Copyright (c) 2011, 2013, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/******************************************************************//**
@file include/fts0priv.ic
Full text search internal header file

Created 2011/11/12 Sunny Bains
***********************************************************************/

/******************************************************************//**
Write the table id to the given buffer (including final NUL). Buffer must be
at least FTS_AUX_MIN_TABLE_ID_LENGTH bytes long.
@return	number of bytes written */
UNIV_INLINE
int
fts_write_object_id(
/*================*/
	ib_id_t		id,		/* in: a table/index id */
	char*		str,		/* in: buffer to write the id to */
	bool		hex_format __attribute__((unused)))
					/* in: true for fixed hex format,
					false for old ambiguous format */
{
#ifdef _WIN32
	/* Use this to construct old(5.6.14 and 5.7.3) ambiguous
	aux table names */
	DBUG_EXECUTE_IF("innodb_test_wrong_fts_aux_table_name",
			return(sprintf(str, "%016llu", id)););

	/* As above, but this is only for those tables failing to rename. */
	if (!hex_format) {
		// FIXME: Use ut_snprintf(), so does following one.
		return(sprintf(str, "%016llu", id));
	}
#endif /* _WIN32 */

	return(sprintf(str, UINT64PFx, id));
}

/******************************************************************//**
Read the table id from the string generated by fts_write_object_id().
@return	TRUE if parse successful */
UNIV_INLINE
ibool
fts_read_object_id(
/*===============*/
	ib_id_t*	id,		/* out: an id */
	const char*	str)		/* in: buffer to read from */
{
	/* NOTE: this func doesn't care about whether current table
	is set with HEX_NAME, the user of the id read here will check
	if the id is HEX or DEC and do the right thing with it. */
	return(sscanf(str, UINT64PFx, id) == 1);
}

/******************************************************************//**
Compare two fts_trx_table_t instances.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2  */
UNIV_INLINE
int
fts_trx_table_cmp(
/*==============*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const dict_table_t* table1 = (*(const fts_trx_table_t**) p1)->table;
	const dict_table_t* table2 = (*(const fts_trx_table_t**) p2)->table;

	return((table1->id > table2->id)
	       ? 1
	       : (table1->id == table2->id)
		  ? 0
		  : -1);
}

/******************************************************************//**
Compare a table id with a fts_trx_table_t table id.
@return < 0 if n1 < n2, 0 if n1 == n2,> 0 if n1 > n2 */
UNIV_INLINE
int
fts_trx_table_id_cmp(
/*=================*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const ullint* table_id = (const ullint*) p1;
	const dict_table_t* table2 = (*(const fts_trx_table_t**) p2)->table;

	return((*table_id > table2->id)
	       ? 1
	       : (*table_id == table2->id)
		  ? 0
		  : -1);
}
