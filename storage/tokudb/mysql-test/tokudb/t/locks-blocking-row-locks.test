source include/have_tokudb.inc;
# Tokutek
# Blocking row lock tests;
# Generated by locks-blocking-row-locks-testgen.py on 2013-10-14;

# prepare with some common parameters
connect(conn1, localhost, root);
set session transaction isolation level serializable;
connect(conn2, localhost, root);
set session transaction isolation level serializable;
connection conn1;

# drop old table, generate new one. 4 rows
--disable_warnings
drop table if exists t;
--enable_warnings
create table t (a int primary key, b int) engine=tokudb;
insert ignore t values(1, 1);
insert ignore t values(2, 4);
insert ignore t values(3, 9);
insert ignore t values(4, 16);
insert ignore t values(5, 25);
insert ignore t values(6, 36);

# testing with timeout 0
connection conn1;
set session tokudb_lock_timeout=0;
connection conn2;
set session tokudb_lock_timeout=0;

# testing each point query vs each point query
# testing conflict "select for update" vs. "select for update"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "select for update" vs. "update"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "select for update" vs. "insert"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing conflict "select for update" vs. "replace"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs "select for update"
connection conn1;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs "select for update"
connection conn1;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "update" vs. "select for update"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "update" vs. "update"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "update" vs. "insert"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing conflict "update" vs. "replace"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs "update"
connection conn1;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs "update"
connection conn1;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "insert" vs. "select for update"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "insert" vs. "update"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "insert" vs. "insert"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing conflict "insert" vs. "replace"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs "insert"
connection conn1;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs "insert"
connection conn1;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "replace" vs. "select for update"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "replace" vs. "update"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# testing conflict "replace" vs. "insert"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing conflict "replace" vs. "replace"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs "replace"
connection conn1;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs "replace"
connection conn1;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs range query "select for update"
connection conn1;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "select for update" vs range query "update"
connection conn1;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs range query "select for update"
connection conn1;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
begin;
select * from t;
commit;
connection conn1;

# testing range query "update" vs range query "update"
connection conn1;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
begin;
select * from t;
commit;
connection conn1;

# testing with timeout 500
connection conn1;
set session tokudb_lock_timeout=500;
connection conn2;
set session tokudb_lock_timeout=500;

# testing each point query vs each point query
# testing conflict "select for update" vs. "select for update"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  select * from t where a=1 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "update"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  update t set b=b where a=1;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "insert"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  insert ignore t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "select for update" vs. "replace"
connection conn1;
begin;
# about to do qa..
select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  replace t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "select for update"
connection conn1;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  select * from t where a<=2 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs "select for update"
connection conn1;
begin;

select * from t where a=1 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a=1 for update;
connection conn2;
send  update t set b=b where a<=2;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "select for update"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  select * from t where a=1 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "update"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  update t set b=b where a=1;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "insert"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  insert ignore t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "update" vs. "replace"
connection conn1;
begin;
# about to do qa..
update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  replace t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "update"
connection conn1;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  select * from t where a<=2 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs "update"
connection conn1;
begin;

update t set b=b where a=1;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a=1;
connection conn2;
send  update t set b=b where a<=2;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "select for update"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  select * from t where a=1 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "update"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  update t set b=b where a=1;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "insert"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  insert ignore t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "insert" vs. "replace"
connection conn1;
begin;
# about to do qa..
insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  replace t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "insert"
connection conn1;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  select * from t where a<=2 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs "insert"
connection conn1;
begin;

insert ignore t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
insert ignore t values(1, 150);
connection conn2;
send  update t set b=b where a<=2;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "select for update"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1 for update;
select * from t where a=2 for update;
select * from t where a=3 for update;
select * from t where a=4 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a=1 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  select * from t where a=1 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "update"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a=1;
update t set b=b where a=2;
update t set b=b where a=3;
update t set b=b where a=4;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a=1;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  update t set b=b where a=1;
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "insert"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
insert ignore t values(1, 100);
insert ignore t values(2, 100);
insert ignore t values(3, 100);
insert ignore t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
insert ignore t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  insert ignore t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing conflict "replace" vs. "replace"
connection conn1;
begin;
# about to do qa..
replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
replace t values(1, 100);
replace t values(2, 100);
replace t values(3, 100);
replace t values(4, 100);
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
replace t values(1, 100);
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  replace t values(1, 175);
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs "replace"
connection conn1;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 for update;
select * from t where a>2 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a<=2 for update;
select * from t where a>=0 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  select * from t where a<=2 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs "replace"
connection conn1;
begin;

replace t values(1, 100);
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0;
update t set b=b where a>2;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=1;
select * from t where a>=2;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a<=2;
update t set b=b where a>=0;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
replace t values(1, 150);
connection conn2;
send  update t set b=b where a<=2;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs range query "select for update"
connection conn1;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a>=2 and a<=4 for update;
connection conn2;
send  select * from t where a>=0 and a<=3 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "select for update" vs range query "update"
connection conn1;
begin;

select * from t where a>=2 and a<=4 for update;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
select * from t where a>=2 and a<=4 for update;
connection conn2;
send  update t set b=b where a>=0 and a<=3;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs range query "select for update"
connection conn1;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=0 and a<=3 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=6 for update;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a<=2 for update;
select * from t where a>=5 for update;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
select * from t where a>=0 and a<=3 for update;
select * from t where a>=3 and a<=6 for update;
select * from t where a<=2 for update;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a>=2 and a<=4;
connection conn2;
send  select * from t where a>=0 and a<=3 for update;
connection conn1;
commit;
connection conn2;
reap;
# testing range query "update" vs range query "update"
connection conn1;
begin;

update t set b=b where a>=2 and a<=4;
connection conn2;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=0 and a<=3;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a>=3 and a<=6;
--error ER_LOCK_WAIT_TIMEOUT
update t set b=b where a<=2;
update t set b=b where a>=5;
# make sure we can't read that row, but can read others.
begin;
--error ER_LOCK_WAIT_TIMEOUT
select * from t;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a=2;
--error ER_LOCK_WAIT_TIMEOUT
select * from t where a>=3 and a<=5;
select * from t where a>=5;
commit;
connection conn1;
commit;
connection conn2;
update t set b=b where a>=0 and a<=3;
update t set b=b where a>=3 and a<=6;
update t set b=b where a<=2;
begin;
select * from t;
commit;
connection conn1;

# check that an early commit allows a blocked
# transaction to complete
connection conn1;
begin;
update t set b=b where a>=2 and a<=4;
connection conn2;
send  update t set b=b where a>=0 and a<=3;
connection conn1;
commit;
connection conn2;
reap;
# clean it all up
drop table t;

